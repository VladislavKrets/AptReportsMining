["using Pipelines.Sockets.Unofficial;\n\nusing System.IO.Pipelines;\n\nusing System.Net;\n\nusing System.Threading.Tasks;\n\n\n\nnamespace Shadowsocks.Protocol\n\n{\n\n    public class TcpPipeClient : IStreamClient\n\n    {\n\n        public async Task Connect(EndPoint destination, IDuplexPipe client, IDuplexPipe server)\n\n        {\n\n            var sc = await SocketConnection.ConnectAsync(destination);\n\n            await DuplexPipe.CopyDuplexPipe(client, sc);\n\n        }\n\n    }\n\n}\n", "using System;\n\nusing System.Globalization;\n\nusing System.Runtime.InteropServices;\n\nusing System.Text;\n\n\n\nnamespace Shadowsocks.Protocol\n\n{\n\n    internal static class Util\n\n    {\n\n        private static readonly IdnMapping _idnMapping = new IdnMapping();\n\n\n\n        public static string RestoreHostName(string punycode) => Encoding.UTF8.GetByteCount(punycode) != punycode.Length\n\n                ? punycode.ToLowerInvariant()\n\n                : _idnMapping.GetUnicode(punycode).ToLowerInvariant();\n\n\n\n        public static string EncodeHostName(string unicode) => Encoding.UTF8.GetByteCount(unicode) != unicode.Length\n\n                ? _idnMapping.GetAscii(unicode).ToLowerInvariant()\n\n                : unicode.ToLowerInvariant();\n\n\n\n        public static ArraySegment<byte> GetArray(ReadOnlyMemory<byte> m)\n\n        {\n\n            if (!MemoryMarshal.TryGetArray(m, out var arr))\n\n            {\n\n                throw new InvalidOperationException(\"Can't get base array\");\n\n            }\n\n            return arr;\n\n        }\n\n\n\n        public static ArgumentException BufferTooSmall(int expected, int actual, string name) => new ArgumentException($\"Require {expected} byte buffer, received {actual} byte\", name);\n\n\n\n        public static bool SequenceEqual(this Memory<byte> m1, ReadOnlyMemory<byte> m2) => m1.Span.SequenceEqual(m2.Span);\n\n\n\n        public static void SodiumIncrement(this Span<byte> salt)\n\n        {\n\n            for (var i = 0; i < salt.Length; ++i)\n\n            {\n\n                if (++salt[i] != 0)\n\n                {\n\n                    break;\n\n                }\n\n            }\n\n        }\n\n    }\n\n}\n", "using System;\n\nusing System.Buffers;\n\nusing System.Diagnostics;\n\nusing System.IO.Pipelines;\n\nusing System.Threading;\n\nusing System.Threading.Tasks;\n\n\n\nnamespace Shadowsocks.Protocol\n\n{\n\n    public class ProtocolMessagePipe\n\n    {\n\n        private readonly PipeReader _reader;\n\n        private readonly PipeWriter _writer;\n\n\n\n        public ProtocolMessagePipe(IDuplexPipe pipe)\n\n        {\n\n            _reader = pipe.Input;\n\n            _writer = pipe.Output;\n\n        }\n\n\n\n        public async Task<T> ReadAsync<T>(int millisecond) where T : IProtocolMessage, new()\n\n        {\n\n            var delay = new CancellationTokenSource();\n\n            delay.CancelAfter(millisecond);\n\n\n\n            return await ReadAsync<T>(delay.Token);\n\n        }\n\n\n\n        public async Task<T> ReadAsync<T>(T ret, int millisecond) where T : IProtocolMessage\n\n        {\n\n            var delay = new CancellationTokenSource();\n\n            delay.CancelAfter(millisecond);\n\n\n\n            return await ReadAsync(ret, delay.Token);\n\n        }\n\n\n\n        public async Task<T> ReadAsync<T>(CancellationToken token = default) where T : IProtocolMessage, new() => await ReadAsync(new T(), token);\n\n\n\n        public async Task<T> ReadAsync<T>(T ret, CancellationToken token = default) where T : IProtocolMessage\n\n        {\n\n            Debug.WriteLine($\"Reading protocol message {typeof(T).Name}\");\n\n            //var ret = new T();\n\n            var required = 0;\n\n            do\n\n            {\n\n                var seq = ReadOnlySequence<byte>.Empty;\n\n                var eof = false;\n\n                var ctr = 0;\n\n                do\n\n                {\n\n                    if (eof)\n\n                        throw new FormatException(\n\n                            $\"Message {typeof(T)} parse error, required {required} byte, {seq.Length} byte remain\");\n\n                    var result = await _reader.ReadAsync(token);\n\n                    seq = result.Buffer;\n\n                    eof = result.IsCompleted;\n\n                    if (seq.Length == 0)\n\n                    {\n\n                        if (++ctr > 1000)\n\n                            throw new FormatException($\"Message {typeof(T)} parse error, maybe EOF\");\n\n                    }\n\n                } while (seq.Length < required);\n\n\n\n                var frame = MakeFrame(seq);\n\n                (var ok, var len) = ret.TryLoad(frame);\n\n                if (ok)\n\n                {\n\n                    var ptr = seq.GetPosition(len, seq.Start);\n\n                    _reader.AdvanceTo(ptr);\n\n                    break;\n\n                }\n\n\n\n                if (len == 0)\n\n                {\n\n                    var arr = Util.GetArray(frame).Array;\n\n                    if (arr == null) throw new FormatException($\"Message {typeof(T)} parse error\");\n\n                    throw new FormatException(\n\n                        $\"Message {typeof(T)} parse error, {Environment.NewLine}{BitConverter.ToString(arr)}\");\n\n                }\n\n\n\n                required = len;\n\n            } while (true);\n\n\n\n            return ret;\n\n        }\n\n\n\n        public async Task WriteAsync(IProtocolMessage msg, CancellationToken token = default)\n\n        {\n\n            Debug.WriteLine($\"Writing protocol message {msg}\");\n\n\n\n            Memory<byte> buf;\n\n            var estSize = 4096;\n\n            int size;\n\n            do\n\n            {\n\n                buf = _writer.GetMemory(estSize);\n\n                try\n\n                {\n\n                    size = msg.Serialize(buf);\n\n                }\n\n                catch (ArgumentException)\n\n                {\n\n                    estSize *= 2;\n\n                    continue;\n\n                }\n\n                if (estSize > 65536) throw new ArgumentException(\"Protocol message is too large\");\n\n                _writer.Advance(size);\n\n                await _writer.FlushAsync(token);\n\n\n\n                return;\n\n            } while (true);\n\n        }\n\n\n\n        private SequencePosition _lastFrameStart;\n\n        private SequencePosition _lastFrameEnd;\n\n        private ReadOnlyMemory<byte> _lastFrame;\n\n\n\n        public ReadOnlyMemory<byte> MakeFrame(ReadOnlySequence<byte> seq)\n\n        {\n\n            // cached frame\n\n            if (_lastFrameStart.Equals(seq.Start) && _lastFrameEnd.Equals(seq.End))\n\n            {\n\n                Debug.WriteLine(\"Hit cached frame\");\n\n                return _lastFrame;\n\n            }\n\n\n\n            _lastFrameStart = seq.Start;\n\n            _lastFrameEnd = seq.End;\n\n\n\n            if (seq.IsSingleSegment)\n\n            {\n\n                Debug.WriteLine(\"Frame is single segement\");\n\n                _lastFrame = seq.First;\n\n                return seq.First;\n\n            }\n\n\n\n            Debug.WriteLine(\"Copy frame data into single Memory\");\n\n            Memory<byte> ret = new byte[seq.Length];\n\n            var ptr = 0;\n\n            foreach (var mem in seq)\n\n            {\n\n                mem.CopyTo(ret.Slice(ptr));\n\n                ptr += mem.Length;\n\n            }\n\n\n\n            _lastFrame = ret;\n\n            return ret;\n\n        }\n\n    }\n\n}", "using Pipelines.Sockets.Unofficial;\n\nusing Shadowsocks.Protocol.Shadowsocks;\n\nusing Shadowsocks.Protocol.Socks5;\n\nusing System;\n\nusing System.Collections.Generic;\n\nusing System.Net;\n\nusing System.Net.Sockets;\n\nusing System.Threading.Tasks;\n\n\n\nnamespace Shadowsocks.Protocol\n\n{\n\n    public class TcpPipeListener\n\n    {\n\n        private readonly TcpListener _listener;\n\n        private readonly IEnumerable<IStreamService> _services;\n\n\n\n        public TcpPipeListener(IPEndPoint localEP)\n\n        {\n\n            _listener = new TcpListener(localEP);\n\n            _services = new[] { new Socks5Service(), };\n\n        }\n\n\n\n        public TcpPipeListener(IPEndPoint endPoint, IEnumerable<IStreamService> services)\n\n        {\n\n            _listener = new TcpListener(endPoint);\n\n            _services = services;\n\n        }\n\n\n\n        public async Task Start(IPEndPoint localEP, DnsEndPoint remoteEP, string method, string? password, byte[]? key)\n\n        {\n\n            _listener.Start();\n\n\n\n            while (true)\n\n            {\n\n                var socket = await _listener.AcceptSocketAsync();\n\n                var conn = SocketConnection.Create(socket);\n\n\n\n                foreach (var svc in _services)\n\n                {\n\n                    if (await svc.IsMyClient(conn))\n\n                    {\n\n                        // todo: save to list, so we can optionally close them\n\n                        _ = RunService(svc, conn, localEP, remoteEP, method, password, key);\n\n                    }\n\n                }\n\n            }\n\n        }\n\n\n\n        private async Task RunService(IStreamService svc, SocketConnection conn, IPEndPoint localEP, DnsEndPoint remoteEP, string method, string? password, byte[]? key)\n\n        {\n\n            var s5tcp = new PipePair();\n\n\n\n            var raw = await svc.Handle(conn);\n\n            ShadowsocksClient s5c;\n\n            if (!string.IsNullOrEmpty(password))\n\n                s5c = new ShadowsocksClient(method, password);\n\n            else if (key != null)\n\n                s5c = new ShadowsocksClient(method, key);\n\n            else\n\n                throw new ArgumentException(\"Either a password or a key must be provided.\");\n\n            var tpc = new TcpPipeClient();\n\n            var t2 = tpc.Connect(remoteEP, s5tcp.DownSide, null);\n\n            var t1 = s5c.Connect(localEP, raw, s5tcp.UpSide);\n\n            await Task.WhenAll(t1, t2);\n\n        }\n\n\n\n        public void Stop() => _listener.Stop();\n\n    }\n\n}\n", "using System.IO.Pipelines;\n\nusing System.Threading.Tasks;\n\n\n\nnamespace Shadowsocks.Protocol\n\n{\n\n    class DuplexPipe : IDuplexPipe\n\n    {\n\n        public PipeReader Input { get; set; }\n\n        public PipeWriter Output { get; set; }\n\n\n\n        public static Task CopyDuplexPipe(IDuplexPipe p1, IDuplexPipe p2)\n\n        {\n\n            var t1 = p1.Input.CopyToAsync(p2.Output);\n\n            var t2 = p2.Input.CopyToAsync(p1.Output);\n\n\n\n            return Task.WhenAll(t1, t2);\n\n        }\n\n    }\n\n}\n", "using System.IO.Pipelines;\n\nusing System.Net;\n\nusing System.Threading.Tasks;\n\n\n\nnamespace Shadowsocks.Protocol\n\n{\n\n    interface IStreamClient\n\n    {\n\n        Task Connect(EndPoint destination, IDuplexPipe client, IDuplexPipe server);\n\n    }\n\n}", "using System;\n\n\n\nnamespace Shadowsocks.Protocol\n\n{\n\n    public interface IProtocolMessage : IEquatable<IProtocolMessage>\n\n    {\n\n        public int Serialize(Memory<byte> buffer);\n\n        /// <summary>\n\n        /// \n\n        /// </summary>\n\n        /// <param name=\"buffer\"></param>\n\n        /// <returns>Tuple represent load state,\n\n        /// when success, length is how many byte has been taken\n\n        /// when fail, length is how many byte required, 0 is parse error\n\n        /// </returns>\n\n        public (bool success, int length) TryLoad(ReadOnlyMemory<byte> buffer);\n\n    }\n\n}", "using System.IO.Pipelines;\n\n\n\nnamespace Shadowsocks.Protocol\n\n{\n\n    internal class PipePair\n\n    {\n\n\n\n        /*\n\n         *  \n\n         *  --> c ---w[  uplink  ]r--> s\n\n         *  <-- c <--r[ downlink ]w--- s\n\n         *  down   up              down\n\n         */\n\n\n\n        private readonly Pipe uplink = new Pipe();\n\n        private readonly Pipe downlink = new Pipe();\n\n        public DuplexPipe UpSide { get; private set; }\n\n        public DuplexPipe DownSide { get; private set; }\n\n        public PipePair()\n\n        {\n\n            UpSide = new DuplexPipe\n\n            {\n\n                Input = downlink.Reader,\n\n                Output = uplink.Writer,\n\n            };\n\n            DownSide = new DuplexPipe\n\n            {\n\n                Input = uplink.Reader,\n\n                Output = downlink.Writer,\n\n            };\n\n        }\n\n    }\n\n}\n", "using System.IO.Pipelines;\n\nusing System.Threading.Tasks;\n\n\n\nnamespace Shadowsocks.Protocol\n\n{\n\n    public interface IStreamService\n\n    {\n\n        Task<bool> IsMyClient(IDuplexPipe pipe);\n\n        Task<IDuplexPipe> Handle(IDuplexPipe pipe);\n\n    }\n\n}\n", "using System;\n\n\n\nnamespace Shadowsocks.Protocol.Socks5\n\n{\n\n    public class Socks5UserPasswordResponseMessage : Socks5Message\n\n    {\n\n        // 1 success\n\n\n\n        public bool Success;\n\n\n\n        public override int Serialize(Memory<byte> buffer)\n\n        {\n\n            if (buffer.Length < 2) throw Util.BufferTooSmall(2, buffer.Length, nameof(buffer));\n\n\n\n            buffer.Span[0] = 1;\n\n            buffer.Span[1] = (byte) (Success ? 0 : 1);\n\n            return 2;\n\n        }\n\n\n\n        public override (bool success, int length) TryLoad(ReadOnlyMemory<byte> buffer)\n\n        {\n\n            if (buffer.Length < 2) return (false, 2);\n\n            if (buffer.Span[0] != 1) return (false, 0);\n\n\n\n            Success = buffer.Span[1] == 0;\n\n            return (true, 2);\n\n        }\n\n\n\n        public override bool Equals(IProtocolMessage other)\n\n        {\n\n            if (other is null) return false;\n\n            if (ReferenceEquals(this, other)) return true;\n\n            if (other.GetType() != GetType()) return false;\n\n            return Success == ((Socks5UserPasswordResponseMessage)other).Success;\n\n        }\n\n    }\n\n}", "using System;\n\nusing System.Diagnostics;\n\nusing System.Net;\n\n\n\nnamespace Shadowsocks.Protocol.Socks5\n\n{\n\n    public class Socks5UdpMessage : Socks5Message\n\n    {\n\n        public byte Fragment;\n\n        public EndPoint EndPoint = new IPEndPoint(IPAddress.Any, 0);\n\n\n\n        public override int Serialize(Memory<byte> buffer)\n\n        {\n\n            var addrLen = NeededBytes(EndPoint);\n\n            if (buffer.Length < addrLen + 3) throw Util.BufferTooSmall(addrLen + 3, buffer.Length, nameof(buffer));\n\n            buffer.Span[0] = 0;\n\n            buffer.Span[1] = 0;\n\n            buffer.Span[2] = Fragment;\n\n\n\n            return SerializeAddress(buffer[3..], EndPoint) + 3;\n\n        }\n\n\n\n        public override (bool success, int length) TryLoad(ReadOnlyMemory<byte> buffer)\n\n        {\n\n            if (buffer.Length < 4) return (false, 4);\n\n            if (buffer.Span[0] != 0 || buffer.Span[1] != 0) return (false, 0);\n\n            if (buffer.Span[3] == 3 && buffer.Length < 5) return (false, 5);\n\n            var req = buffer.Span[3] switch\n\n            {\n\n                AddressIPv4 => 10,\n\n                AddressDomain => buffer.Span[4] + 7,\n\n                AddressIPv6 => 22,\n\n                _ => 0,\n\n            };\n\n            if (req == 0) return (false, 0);\n\n            if (buffer.Length < req) return (false, req);\n\n\n\n            (var state, var len) = TryParseAddress(buffer[3..], out var ep);\n\n            Debug.Assert(state);\n\n            Debug.Assert(len == req - 3);\n\n\n\n            Fragment = buffer.Span[2];\n\n            EndPoint = ep;\n\n            return (true, req);\n\n        }\n\n\n\n        public override bool Equals(IProtocolMessage other)\n\n        {\n\n            if (other is null) return false;\n\n            if (ReferenceEquals(this, other)) return true;\n\n            if (other.GetType() != GetType()) return false;\n\n            var msg = (Socks5UdpMessage) other;\n\n            return Fragment == msg.Fragment && Equals(EndPoint, msg.EndPoint);\n\n        }\n\n    }\n\n}", "using System;\n\n\n\nnamespace Shadowsocks.Protocol.Socks5\n\n{\n\n    public class Socks5UserPasswordRequestMessage : Socks5Message\n\n    {\n\n        // 1 lUser [User] lPassword [Password]\n\n\n\n        public Memory<byte> User;\n\n        public Memory<byte> Password;\n\n\n\n        public override int Serialize(Memory<byte> buffer)\n\n        {\n\n            var required = User.Length + Password.Length + 3;\n\n            if (buffer.Length < required) throw Util.BufferTooSmall(required, buffer.Length, nameof(buffer));\n\n            buffer.Span[0] = 1;\n\n            buffer.Span[1] = (byte) User.Length;\n\n            User.CopyTo(buffer.Slice(2));\n\n            buffer.Span[User.Length + 2] = (byte) Password.Length;\n\n            Password.CopyTo(buffer.Slice(User.Length + 3));\n\n            return required;\n\n        }\n\n\n\n        public override (bool success, int length) TryLoad(ReadOnlyMemory<byte> buffer)\n\n        {\n\n            if (buffer.Length < 2) return (false, 2);\n\n            if (buffer.Span[0] != 1) return (false, 0);\n\n            int userLength = buffer.Span[1];\n\n            if (buffer.Length < userLength + 3) return (false, userLength + 3);\n\n            int passLength = buffer.Span[userLength + 2];\n\n            if (buffer.Length < userLength + passLength + 3) return (false, userLength + passLength + 3);\n\n\n\n            User = Util.GetArray(buffer[2..(2 + userLength)]);\n\n            Password = Util.GetArray(buffer[(3 + userLength)..(3 + userLength + passLength)]);\n\n            return (true, userLength + passLength + 3);\n\n        }\n\n\n\n        public override bool Equals(IProtocolMessage other)\n\n        {\n\n            if (other is null) return false;\n\n            if (ReferenceEquals(this, other)) return true;\n\n            if (other.GetType() != GetType()) return false;\n\n            var msg = (Socks5UserPasswordRequestMessage) other;\n\n            return User.SequenceEqual(msg.User) && Password.SequenceEqual(msg.Password);\n\n        }\n\n    }\n\n}", "using System;\n\n\n\nnamespace Shadowsocks.Protocol.Socks5\n\n{\n\n    public class Socks5MethodSelectionMessage : Socks5Message\n\n    {\n\n        // 5 auth\n\n        public byte SelectedAuth;\n\n\n\n        public override int Serialize(Memory<byte> buffer)\n\n        {\n\n            if (buffer.Length < 2) throw Util.BufferTooSmall(2, buffer.Length, nameof(buffer));\n\n\n\n            buffer.Span[0] = 5;\n\n            buffer.Span[1] = SelectedAuth;\n\n            return 2;\n\n        }\n\n\n\n        public override (bool success, int length) TryLoad(ReadOnlyMemory<byte> buffer)\n\n        {\n\n            // need 3 byte\n\n            if (buffer.Length < 2) return (false, 2);\n\n            if (buffer.Span[0] != 5) return (false, 0);\n\n\n\n            SelectedAuth = buffer.Span[1];\n\n            return (true, 2);\n\n        }\n\n\n\n        public override bool Equals(IProtocolMessage other)\n\n        {\n\n            if (other is null) return false;\n\n            if (ReferenceEquals(this, other)) return true;\n\n            if (other.GetType() != GetType()) return false;\n\n            return SelectedAuth == ((Socks5MethodSelectionMessage) other).SelectedAuth;\n\n        }\n\n    }\n\n}", "using System;\n\n\n\nnamespace Shadowsocks.Protocol.Socks5\n\n{\n\n    public class Socks5VersionIdentifierMessage : Socks5Message\n\n    {\n\n        // 5 lAuth [Auth]\n\n\n\n        public Memory<byte> Auth;\n\n\n\n        public override int Serialize(Memory<byte> buffer)\n\n        {\n\n            var required = Auth.Length + 2;\n\n            if (buffer.Length < required) throw Util.BufferTooSmall(required, buffer.Length, nameof(buffer));\n\n\n\n            buffer.Span[0] = 5;\n\n            buffer.Span[1] = (byte) Auth.Length;\n\n            Auth.CopyTo(buffer.Slice(2));\n\n            return Auth.Length + 2;\n\n        }\n\n\n\n        public override (bool success, int length) TryLoad(ReadOnlyMemory<byte> buffer)\n\n        {\n\n            // need 3 byte\n\n            if (buffer.Length < 3) return (false, 3);\n\n            if (buffer.Span[0] != 5) return (false, 0);\n\n            if (buffer.Span[1] == 0) return (false, 0);\n\n            if (buffer.Length < buffer.Span[1] + 2) return (false, buffer.Span[1] + 2);\n\n\n\n            Auth = Util.GetArray(buffer[2..(2 + buffer.Span[1])]);\n\n            return (true, buffer.Span[1] + 2);\n\n        }\n\n\n\n        public override bool Equals(IProtocolMessage other)\n\n        {\n\n            if (other is null) return false;\n\n            if (ReferenceEquals(this, other)) return true;\n\n            if (other.GetType() != GetType()) return false;\n\n            return Auth.SequenceEqual(((Socks5VersionIdentifierMessage) other).Auth);\n\n        }\n\n    }\n\n}", "using System;\n\nusing System.Diagnostics;\n\nusing System.Net;\n\nusing System.Net.Sockets;\n\nusing System.Text;\n\n\n\nnamespace Shadowsocks.Protocol.Socks5\n\n{\n\n    public abstract class Socks5Message : IProtocolMessage\n\n    {\n\n        public abstract int Serialize(Memory<byte> buffer);\n\n        public abstract (bool success, int length) TryLoad(ReadOnlyMemory<byte> buffer);\n\n\n\n        public abstract bool Equals(IProtocolMessage other);\n\n\n\n        #region Socks5 constants\n\n\n\n        public const byte AuthNone = 0;\n\n        public const byte AuthGssApi = 1;\n\n        public const byte AuthUserPass = 2;\n\n        public const byte AuthChallengeHandshake = 3;\n\n        public const byte AuthChallengeResponse = 5;\n\n        public const byte AuthSsl = 6;\n\n        public const byte AuthNds = 7;\n\n        public const byte AuthMultiAuthenticationFramework = 8;\n\n        public const byte AuthJsonParameterBlock = 9;\n\n        public const byte AuthNoAcceptable = 0xff;\n\n\n\n        public const byte AddressIPv4 = 1;\n\n        public const byte AddressDomain = 3;\n\n        public const byte AddressIPv6 = 4;\n\n\n\n        public const byte CmdConnect = 1;\n\n        public const byte CmdBind = 2;\n\n        public const byte CmdUdpAssociation = 3;\n\n\n\n        public const byte ReplySucceed = 0;\n\n        public const byte ReplyFailure = 1;\n\n        public const byte ReplyNotAllowed = 2;\n\n        public const byte ReplyNetworkUnreachable = 3;\n\n        public const byte ReplyHostUnreachable = 4;\n\n        public const byte ReplyConnectionRefused = 5;\n\n        public const byte ReplyTtlExpired = 6;\n\n        public const byte ReplyCommandNotSupport = 7;\n\n        public const byte ReplyAddressNotSupport = 8;\n\n\n\n        #endregion\n\n\n\n        private static readonly NotSupportedException _addressNotSupport =\n\n            new NotSupportedException(\"Socks5 only support IPv4, IPv6, Domain name address\");\n\n\n\n        #region Address convert\n\n\n\n        private static (byte high, byte low) ExpandPort(int port)\n\n        {\n\n            Debug.Assert(port >= 0 && port <= 65535);\n\n            return ((byte) (port / 256), (byte) (port % 256));\n\n        }\n\n\n\n        private static int TransformPort(byte high, byte low) => high * 256 + low;\n\n\n\n        protected static int NeededBytes(EndPoint endPoint)\n\n        {\n\n            switch (endPoint)\n\n            {\n\n                case IPEndPoint ipEndPoint when ipEndPoint.AddressFamily == AddressFamily.InterNetwork:\n\n                    return 7;\n\n\n\n                case IPEndPoint ipEndPoint when ipEndPoint.AddressFamily == AddressFamily.InterNetworkV6:\n\n                    return 19;\n\n\n\n                case DnsEndPoint dnsEndPoint:\n\n                    var host = Util.EncodeHostName(dnsEndPoint.Host);\n\n                    return host.Length + 4;\n\n\n\n                default:\n\n                    throw _addressNotSupport;\n\n            }\n\n        }\n\n\n\n        public static int SerializeAddress(Memory<byte> buffer, EndPoint endPoint)\n\n        {\n\n            switch (endPoint)\n\n            {\n\n                case IPEndPoint ipEndPoint when ipEndPoint.AddressFamily == AddressFamily.InterNetwork:\n\n                {\n\n                    if (buffer.Length < 7) throw Util.BufferTooSmall(7, buffer.Length, nameof(buffer));\n\n                    buffer.Span[0] = AddressIPv4;\n\n                    Debug.Assert(ipEndPoint.Address.TryWriteBytes(buffer.Span[1..], out var l));\n\n                    Debug.Assert(l == 4);\n\n\n\n                    (var high, var low) = ExpandPort(ipEndPoint.Port);\n\n                    buffer.Span[5] = high;\n\n                    buffer.Span[6] = low;\n\n                    return 7;\n\n                }\n\n\n\n                case IPEndPoint ipEndPoint when ipEndPoint.AddressFamily == AddressFamily.InterNetworkV6:\n\n                {\n\n                    if (buffer.Length < 19) throw Util.BufferTooSmall(19, buffer.Length, nameof(buffer));\n\n                    buffer.Span[0] = AddressIPv6;\n\n                    Debug.Assert(ipEndPoint.Address.TryWriteBytes(buffer.Span[1..], out var l));\n\n                    Debug.Assert(l == 16);\n\n\n\n                    (var high, var low) = ExpandPort(ipEndPoint.Port);\n\n                    buffer.Span[18] = low;\n\n                    buffer.Span[17] = high;\n\n                    return 19;\n\n                }\n\n\n\n                case DnsEndPoint dnsEndPoint:\n\n                {\n\n                    // 3 lHost [Host] port port\n\n\n\n                    var host = Util.EncodeHostName(dnsEndPoint.Host);\n\n                    if (host.Length > 255) throw new NotSupportedException(\"Host name too long\");\n\n                    if (buffer.Length < host.Length + 4)\n\n                        throw Util.BufferTooSmall(host.Length + 4, buffer.Length, nameof(buffer));\n\n\n\n                    buffer.Span[0] = AddressDomain;\n\n                    buffer.Span[1] = (byte) host.Length;\n\n                    Encoding.ASCII.GetBytes(host, buffer.Span[2..]);\n\n\n\n                    (var high, var low) = ExpandPort(dnsEndPoint.Port);\n\n                    buffer.Span[host.Length + 2] = high;\n\n                    buffer.Span[host.Length + 3] = low;\n\n\n\n                    return host.Length + 4;\n\n                }\n\n\n\n                default:\n\n                    throw _addressNotSupport;\n\n            }\n\n        }\n\n\n\n        public static (bool success, int length) TryParseAddress(ReadOnlyMemory<byte> buffer,\n\n            out EndPoint result)\n\n        {\n\n            result = default;\n\n            if (buffer.Length < 1) return (false, 1);\n\n            var addrType = buffer.Span[0];\n\n            int len;\n\n            switch (addrType)\n\n            {\n\n                case AddressIPv4:\n\n                    if (buffer.Length < 7) return (false, 7);\n\n                    var s = buffer[1..5];\n\n                    result = new IPEndPoint(\n\n                        new IPAddress(Util.GetArray(s)),\n\n                        TransformPort(buffer.Span[5], buffer.Span[6])\n\n                    );\n\n                    len = 7;\n\n                    break;\n\n\n\n                case AddressDomain:\n\n                    if (buffer.Length < 2) return (false, 2);\n\n                    var nameLength = buffer.Span[1];\n\n                    if (buffer.Length < nameLength + 4) return (false, nameLength + 4);\n\n\n\n                    result = new DnsEndPoint(\n\n                        Encoding.ASCII.GetString(buffer.Span[2..(nameLength + 2)]),\n\n                        TransformPort(buffer.Span[nameLength + 2], buffer.Span[nameLength + 3])\n\n                    );\n\n                    len = nameLength + 4;\n\n\n\n                    break;\n\n\n\n                case AddressIPv6:\n\n                    if (buffer.Length < 19) return (false, 19);\n\n                    result = new IPEndPoint(new IPAddress(Util.GetArray(buffer[1..17])),\n\n                        TransformPort(buffer.Span[17], buffer.Span[18]));\n\n                    len = 19;\n\n\n\n                    break;\n\n\n\n                default:\n\n                    return (false, 0);\n\n            }\n\n\n\n            return (true, len);\n\n        }\n\n\n\n        #endregion\n\n    }\n\n}", "using System;\n\nusing System.Diagnostics;\n\nusing System.Net;\n\n\n\nnamespace Shadowsocks.Protocol.Socks5\n\n{\n\n    public class Socks5RequestReplyMessageBase : Socks5Message\n\n    {\n\n        // 5 cmdOrReply 0 aType [addr] port\n\n        \n\n        protected byte CmdByte;\n\n        public EndPoint EndPoint =new IPEndPoint(IPAddress.Any, 0);\n\n\n\n        public override int Serialize(Memory<byte> buffer)\n\n        {\n\n            var addrLen = NeededBytes(EndPoint);\n\n            if (buffer.Length < addrLen + 3) throw Util.BufferTooSmall(addrLen + 3, buffer.Length, nameof(buffer));\n\n            buffer.Span[0] = 5;\n\n            buffer.Span[1] = CmdByte;\n\n            buffer.Span[2] = 0;\n\n\n\n            return SerializeAddress(buffer[3..], EndPoint) + 3;\n\n        }\n\n\n\n        public override (bool success, int length) TryLoad(ReadOnlyMemory<byte> buffer)\n\n        {\n\n            if (buffer.Length < 4) return (false, 4);\n\n            if (buffer.Span[0] != 5 || buffer.Span[2] != 0) return (false, 0);\n\n            if (buffer.Span[3] == 3 && buffer.Length < 5) return (false, 5);\n\n            var req = buffer.Span[3] switch\n\n            {\n\n                AddressIPv4 => 10,\n\n                AddressDomain => buffer.Span[4] + 7,\n\n                AddressIPv6 => 22,\n\n                _ => 0,\n\n            };\n\n            if (req == 0) return (false, 0);\n\n            if (buffer.Length < req) return (false, req);\n\n\n\n            (var state, var len) = TryParseAddress(buffer[3..], out var ep);\n\n            Debug.Assert(state);\n\n            Debug.Assert(len == req - 3);\n\n\n\n            CmdByte = buffer.Span[1];\n\n            EndPoint = ep;\n\n            return (true, req);\n\n        }\n\n        \n\n        public override bool Equals(IProtocolMessage other)\n\n        {\n\n            if (other is null) return false;\n\n            if (ReferenceEquals(this, other)) return true;\n\n            if (other.GetType() != GetType()) return false; \n\n            var msg = (Socks5RequestReplyMessageBase) other;\n\n            return CmdByte == msg.CmdByte && EndPoint.Equals(msg.EndPoint);\n\n        }\n\n    }\n\n    \n\n    public class Socks5ReplyMessage : Socks5RequestReplyMessageBase\n\n    {\n\n        public byte Reply\n\n        {\n\n            get => CmdByte;\n\n            set => CmdByte = value;\n\n        }\n\n    }\n\n    \n\n    public class Socks5RequestMessage : Socks5RequestReplyMessageBase\n\n    {\n\n        public byte Command\n\n        {\n\n            get => CmdByte;\n\n            set => CmdByte = value;\n\n        }\n\n    }\n\n}", "using System;\n\nusing System.Collections.Generic;\n\nusing System.IO.Pipelines;\n\nusing System.Linq;\n\nusing System.Text;\n\nusing System.Threading.Tasks;\n\n\n\nnamespace Shadowsocks.Protocol.Socks5\n\n{\n\n    public class Socks5Service : IStreamService\n\n    {\n\n        public Socks5Service()\n\n        {\n\n\n\n        }\n\n\n\n        public Socks5Service(Dictionary<string, string> passwords)\n\n        {\n\n            enablePassword = true;\n\n            this.passwords = passwords;\n\n        }\n\n\n\n        private readonly bool enablePassword;\n\n        private readonly Dictionary<string, string> passwords = new Dictionary<string, string>();\n\n        public static int ReadTimeout = 120000;\n\n\n\n        public async Task<bool> IsMyClient(IDuplexPipe pipe)\n\n        {\n\n            var result = await pipe.Input.ReadAsync();\n\n            pipe.Input.AdvanceTo(result.Buffer.Start);\n\n            var buffer = result.Buffer;\n\n            if (buffer.Length < 3) return false;\n\n            if (buffer.First.Span[0] != 5) return false;\n\n            if (buffer.First.Span[1] == 0) return false;\n\n            // ver 5, has auth method\n\n            return true;\n\n        }\n\n\n\n        public async Task<IDuplexPipe> Handle(IDuplexPipe pipe)\n\n        {\n\n            var pmp = new ProtocolMessagePipe(pipe);\n\n            var hs = await pmp.ReadAsync<Socks5VersionIdentifierMessage>();\n\n\n\n            var selected = Socks5Message.AuthNoAcceptable;\n\n            if (enablePassword)\n\n            {\n\n                foreach (var a in Util.GetArray(hs.Auth))\n\n                {\n\n                    if (a == Socks5Message.AuthUserPass)\n\n                    {\n\n                        selected = Socks5Message.AuthUserPass;\n\n                        break;\n\n                    }\n\n\n\n                    if (a == Socks5Message.AuthNone)\n\n                    {\n\n                        selected = Socks5Message.AuthNone;\n\n                    }\n\n                }\n\n            }\n\n            else\n\n            {\n\n                if (Util.GetArray(hs.Auth).Any(a => a == Socks5Message.AuthNone))\n\n                {\n\n                    selected = Socks5Message.AuthNone;\n\n                }\n\n            }\n\n\n\n            await pmp.WriteAsync(new Socks5MethodSelectionMessage()\n\n            {\n\n                SelectedAuth = selected,\n\n            });\n\n            switch (selected)\n\n            {\n\n                case Socks5Message.AuthNoAcceptable:\n\n                default:\n\n                    await pipe.Output.CompleteAsync();\n\n                    return null;\n\n\n\n                case Socks5Message.AuthNone:\n\n                    break;\n\n\n\n                case Socks5Message.AuthUserPass:\n\n                    var token = await pmp.ReadAsync<Socks5UserPasswordRequestMessage>();\n\n                    var user = Encoding.UTF8.GetString(token.User.Span);\n\n                    var password = Encoding.UTF8.GetString(token.Password.Span);\n\n                    var ar = new Socks5UserPasswordResponseMessage();\n\n                    var success =\n\n                        passwords.TryGetValue(user, out var expectPassword)\n\n                        && expectPassword == password;\n\n                    ar.Success = success;\n\n                    await pmp.WriteAsync(ar);\n\n                    if (!success)\n\n                    {\n\n                        await pipe.Output.CompleteAsync();\n\n                        return null;\n\n                    }\n\n\n\n                    break;\n\n            }\n\n\n\n            var req = await pmp.ReadAsync<Socks5RequestMessage>();\n\n            var resp = new Socks5ReplyMessage();\n\n            switch (req.Command)\n\n            {\n\n                case Socks5Message.CmdBind:\n\n                case Socks5Message.CmdUdpAssociation: // not support yet\n\n                    resp.Reply = Socks5Message.ReplyCommandNotSupport;\n\n                    break;\n\n\n\n                case Socks5Message.CmdConnect:\n\n                    Console.WriteLine(req.EndPoint);\n\n                    // TODO: route and dial outbound\n\n\n\n\n\n                    resp.Reply = Socks5Message.ReplySucceed;\n\n                    break;\n\n            }\n\n            // TODO: write response, hand out connection\n\n            await pmp.WriteAsync(resp);\n\n            if (req.Command != Socks5Message.CmdConnect) return null;\n\n\n\n            return pipe;\n\n        }\n\n    }\n\n}\n", "using System;\n\nusing System.Diagnostics;\n\nusing System.IO.Pipelines;\n\nusing System.Net;\n\nusing System.Text;\n\nusing System.Threading.Tasks;\n\n\n\nnamespace Shadowsocks.Protocol.Socks5\n\n{\n\n    class Socks5Client : IStreamClient\n\n    {\n\n        NetworkCredential _credential;\n\n\n\n        public Socks5Client(NetworkCredential credential = null)\n\n        {\n\n            _credential = credential;\n\n        }\n\n\n\n        public async Task Connect(EndPoint destination, IDuplexPipe client, IDuplexPipe server)\n\n        {\n\n            var pmp = new ProtocolMessagePipe(server);\n\n\n\n            await pmp.WriteAsync(new Socks5VersionIdentifierMessage\n\n            {\n\n                Auth = _credential == null ? new [] { Socks5Message.AuthNone } : new [] { Socks5Message.AuthNone, Socks5Message.AuthUserPass }\n\n            });\n\n\n\n            var msm = await pmp.ReadAsync<Socks5MethodSelectionMessage>();\n\n            switch (msm.SelectedAuth)\n\n            {\n\n                case Socks5Message.AuthNone:\n\n                    break;\n\n                case Socks5Message.AuthUserPass:\n\n                    Debug.Assert(_credential != null);\n\n                    var name = _credential.UserName;\n\n                    var password = _credential.Password;\n\n\n\n                    await pmp.WriteAsync(new Socks5UserPasswordRequestMessage\n\n                    {\n\n                        User = Encoding.UTF8.GetBytes(name),\n\n                        Password = Encoding.UTF8.GetBytes(password),\n\n                    });\n\n\n\n                    var upResp = await pmp.ReadAsync<Socks5UserPasswordResponseMessage>();\n\n                    if (!upResp.Success) throw new UnauthorizedAccessException(\"Wrong username / password\");\n\n\n\n                    break;\n\n                default:\n\n                    throw new NotSupportedException(\"Server not support our authencation method\");\n\n            }\n\n            await pmp.WriteAsync(new Socks5RequestMessage\n\n            {\n\n                Command = Socks5Message.CmdConnect,\n\n                EndPoint = destination,\n\n            });\n\n\n\n            var reply = await pmp.ReadAsync<Socks5ReplyMessage>();\n\n\n\n            if (reply.Reply != Socks5Message.ReplySucceed) throw new Exception();\n\n\n\n            await DuplexPipe.CopyDuplexPipe(client, server);\n\n        }\n\n    }\n\n}\n", "using System.IO.Pipelines;\n\nusing System.Threading.Tasks;\n\n\n\nnamespace Shadowsocks.Protocol.Direct\n\n{\n\n    public class PortForwardService : IStreamService\n\n    {\n\n        public async Task<IDuplexPipe> Handle(IDuplexPipe pipe) => await Task.FromResult<IDuplexPipe>(null);\n\n\n\n        public Task<bool> IsMyClient(IDuplexPipe pipe) => Task.FromResult(true);\n\n    }\n\n}\n", "using Shadowsocks.Protocol.Shadowsocks.Crypto;\n\nusing System;\n\nusing System.IO.Pipelines;\n\nusing System.Net;\n\nusing System.Threading.Tasks;\n\n\n\nnamespace Shadowsocks.Protocol.Shadowsocks\n\n{\n\n    // 'original' shadowsocks encryption layer\n\n    internal class UnsafeClient : IStreamClient\n\n    {\n\n        CryptoParameter parameter;\n\n        string password;\n\n\n\n        public UnsafeClient(CryptoParameter parameter, string password)\n\n        {\n\n            this.password = password;\n\n            this.parameter = parameter;\n\n        }\n\n\n\n        public Task Connect(EndPoint destination, IDuplexPipe client, IDuplexPipe server) =>\n\n            // destination is ignored, this is just a converter\n\n            Task.WhenAll(ConvertUplink(client, server), ConvertDownlink(client, server));\n\n\n\n        public async Task ConvertUplink(IDuplexPipe client, IDuplexPipe server)\n\n        {\n\n            using var up = parameter.GetCrypto();\n\n            var pmp = new ProtocolMessagePipe(server);\n\n            var key = CryptoUtils.SSKDF(password, parameter.KeySize);\n\n\n\n            var salt = new SaltMessage(parameter.NonceSize, true);\n\n            await pmp.WriteAsync(salt);\n\n\n\n            up.Init(key, salt.Salt.ToArray());\n\n            Memory<byte> nonce = new byte[parameter.NonceSize];\n\n            nonce.Span.Fill(0);\n\n            // TODO write salt with data\n\n            while (true)\n\n            {\n\n                var result = await client.Input.ReadAsync();\n\n                if (result.IsCanceled || result.IsCompleted) return;\n\n\n\n                // TODO compress into one chunk when possible\n\n\n\n                foreach (var item in result.Buffer)\n\n                {\n\n                    var mem = server.Output.GetMemory(item.Length);\n\n                    var len = up.Encrypt(null, item.Span, mem.Span);\n\n                    server.Output.Advance(len);\n\n                }\n\n                client.Input.AdvanceTo(result.Buffer.End);\n\n            }\n\n        }\n\n\n\n        public async Task ConvertDownlink(IDuplexPipe client, IDuplexPipe server)\n\n        {\n\n            using var down = parameter.GetCrypto();\n\n\n\n            var pmp = new ProtocolMessagePipe(server);\n\n            var salt = await pmp.ReadAsync(new SaltMessage(parameter.NonceSize));\n\n\n\n            var key = CryptoUtils.SSKDF(password, parameter.KeySize);\n\n            down.Init(key, salt.Salt.ToArray());\n\n\n\n            while (true)\n\n            {\n\n                while (true)\n\n                {\n\n                    var result = await server.Input.ReadAsync();\n\n                    if (result.IsCanceled || result.IsCompleted) return;\n\n\n\n                    // TODO compress into one chunk when possible\n\n\n\n                    foreach (var item in result.Buffer)\n\n                    {\n\n                        var mem = client.Output.GetMemory(item.Length);\n\n                        var len = down.Decrypt(null, mem.Span, item.Span);\n\n                        client.Output.Advance(len);\n\n                    }\n\n                    server.Input.AdvanceTo(result.Buffer.End);\n\n                }\n\n            }\n\n        }\n\n\n\n    }\n\n}\n", "using Shadowsocks.Protocol.Shadowsocks.Crypto;\n\nusing System;\n\nusing System.Diagnostics.CodeAnalysis;\n\n\n\nnamespace Shadowsocks.Protocol.Shadowsocks\n\n{\n\n    class AeadBlockMessage : IProtocolMessage\n\n    {\n\n        public Memory<byte> Data;\n\n        private readonly int tagLength;\n\n        private readonly ICrypto aead;\n\n        private Memory<byte> nonce;\n\n\n\n        private int expectedDataLength;\n\n\n\n        public AeadBlockMessage(ICrypto aead, Memory<byte> nonce, CryptoParameter parameter)\n\n        {\n\n            this.aead = aead;\n\n            this.nonce = nonce;\n\n            tagLength = parameter.TagSize;\n\n        }\n\n\n\n        public bool Equals([AllowNull] IProtocolMessage other) => throw new NotImplementedException();\n\n\n\n        public int Serialize(Memory<byte> buffer)\n\n        {\n\n            var len = Data.Length + 2 * tagLength + 2;\n\n            if (buffer.Length < len)\n\n                throw Util.BufferTooSmall(len, buffer.Length, nameof(buffer));\n\n            Memory<byte> m = new byte[2];\n\n            m.Span[0] = (byte)(Data.Length / 256);\n\n            m.Span[1] = (byte)(Data.Length % 256);\n\n            var len1 = aead.Encrypt(nonce.Span, m.Span, buffer.Span);\n\n            nonce.Span.SodiumIncrement();\n\n            buffer = buffer.Slice(len1);\n\n            aead.Encrypt(nonce.Span, Data.Span, buffer.Span);\n\n            nonce.Span.SodiumIncrement();\n\n            return len;\n\n        }\n\n\n\n        public (bool success, int length) TryLoad(ReadOnlyMemory<byte> buffer)\n\n        {\n\n            int len;\n\n            if (expectedDataLength == 0)\n\n            {\n\n                if (buffer.Length < tagLength + 2) return (false, tagLength + 2);\n\n\n\n                // decrypt length\n\n                Memory<byte> m = new byte[2];\n\n                len = aead.Decrypt(nonce.Span, m.Span, buffer.Span);\n\n                nonce.Span.SodiumIncrement();\n\n                if (len != 2) return (false, 0);\n\n\n\n                expectedDataLength = m.Span[0] * 256 + m.Span[1];\n\n                if (expectedDataLength > 0x3fff) return (false, 0);\n\n            }\n\n            var totalLength = expectedDataLength + 2 * tagLength + 2;\n\n            if (buffer.Length < totalLength) return (false, totalLength);\n\n\n\n            // decrypt data\n\n            var dataBuffer = buffer.Slice(tagLength + 2);\n\n            Data = new byte[expectedDataLength];\n\n            len = aead.Decrypt(nonce.Span, Data.Span, dataBuffer.Span);\n\n            nonce.Span.SodiumIncrement();\n\n            if (len != expectedDataLength) return (false, 0);\n\n            return (true, totalLength);\n\n        }\n\n    }\n\n}\n", "using Shadowsocks.Protocol.Shadowsocks.Crypto;\n\nusing System;\n\nusing System.Diagnostics.CodeAnalysis;\n\nusing System.Security.Cryptography;\n\n\n\nnamespace Shadowsocks.Protocol.Shadowsocks\n\n{\n\n    public class SaltMessage : IProtocolMessage\n\n    {\n\n        private readonly int length;\n\n        public Memory<byte> Salt { get; private set; }\n\n\n\n        public SaltMessage(int length, bool roll = false)\n\n        {\n\n            this.length = length;\n\n            if (roll)\n\n            {\n\n                Salt = new byte[length];\n\n                RandomNumberGenerator.Fill(Salt.Span);\n\n            }\n\n        }\n\n\n\n        public bool Equals([AllowNull] IProtocolMessage other) => throw new NotImplementedException();\n\n\n\n        public int Serialize(Memory<byte> buffer)\n\n        {\n\n            Salt.CopyTo(buffer);\n\n            return length;\n\n        }\n\n\n\n        public (bool success, int length) TryLoad(ReadOnlyMemory<byte> buffer)\n\n        {\n\n            if (buffer.Length < length) return (false, length);\n\n            buffer.Slice(0, length).CopyTo(Salt);\n\n            return (true, length);\n\n        }\n\n    }\n\n}\n", "using System;\n\n\n\nnamespace Shadowsocks.Protocol.Shadowsocks\n\n{\n\n    // stream cipher simply ignore nonce\n\n    public interface ICrypto : IDisposable\n\n    {\n\n        void Init(byte[] key, byte[] iv);\n\n        int Encrypt(ReadOnlySpan<byte> nonce, ReadOnlySpan<byte> plain, Span<byte> cipher);\n\n        int Decrypt(ReadOnlySpan<byte> nonce, Span<byte> plain, ReadOnlySpan<byte> cipher);\n\n    }\n\n}\n", "using Shadowsocks.Protocol.Shadowsocks.Crypto;\n\nusing System;\n\nusing System.Collections.Generic;\n\nusing System.IO.Pipelines;\n\nusing System.Net;\n\nusing System.Runtime.InteropServices;\n\nusing System.Security.Cryptography;\n\nusing System.Threading.Tasks;\n\n\n\nnamespace Shadowsocks.Protocol.Shadowsocks\n\n{\n\n    public class AeadClient : IStreamClient\n\n    {\n\n        private CryptoParameter cryptoParameter;\n\n        private readonly byte[] mainKey;\n\n\n\n        /// <summary>\n\n        /// ss-subkey\n\n        /// </summary>\n\n        private static ReadOnlySpan<byte> _ssSubKeyInfo => new byte[]\n\n        {\n\n            0x73, 0x73, 0x2d, 0x73, 0x75, 0x62, 0x6b, 0x65, 0x79\n\n        };\n\n\n\n        public AeadClient(CryptoParameter parameter, string password)\n\n        {\n\n            cryptoParameter = parameter;\n\n            mainKey = CryptoUtils.SSKDF(password, parameter.KeySize);\n\n            if (!parameter.IsAead)\n\n                throw new NotSupportedException($\"Unsupported method.\");\n\n        }\n\n\n\n        public AeadClient(CryptoParameter parameter, byte[] key)\n\n        {\n\n            cryptoParameter = parameter;\n\n            mainKey = key;\n\n        }\n\n\n\n        public Task Connect(EndPoint destination, IDuplexPipe client, IDuplexPipe server) =>\n\n            // destination is ignored, this is just a converter\n\n            Task.WhenAll(ConvertUplink(client, server), ConvertDownlink(client, server));\n\n\n\n        public async Task ConvertUplink(IDuplexPipe client, IDuplexPipe server)\n\n        {\n\n            using var up = cryptoParameter.GetCrypto();\n\n            var pmp = new ProtocolMessagePipe(server);\n\n            var salt = new SaltMessage(16, true);\n\n            await pmp.WriteAsync(salt);\n\n\n\n            var key = new byte[cryptoParameter.KeySize];\n\n            HKDF.DeriveKey(HashAlgorithmName.SHA1, mainKey, key, salt.Salt.Span, _ssSubKeyInfo);\n\n            up.Init(key, null);\n\n            Memory<byte> nonce = new byte[cryptoParameter.NonceSize];\n\n            nonce.Span.Fill(0);\n\n            // TODO write salt with data\n\n            while (true)\n\n            {\n\n                var result = await client.Input.ReadAsync();\n\n                if (result.IsCanceled || result.IsCompleted) return;\n\n\n\n                // TODO compress into one chunk when possible\n\n\n\n                foreach (var item in result.Buffer)\n\n                {\n\n                    foreach (var i in SplitBigChunk(item))\n\n                    {\n\n                        await pmp.WriteAsync(new AeadBlockMessage(up, nonce, cryptoParameter)\n\n                        {\n\n                            // in send routine, Data is readonly\n\n                            Data = MemoryMarshal.AsMemory(i),\n\n                        });\n\n                    }\n\n                }\n\n                client.Input.AdvanceTo(result.Buffer.End);\n\n            }\n\n        }\n\n\n\n        public async Task ConvertDownlink(IDuplexPipe client, IDuplexPipe server)\n\n        {\n\n            using var down = cryptoParameter.GetCrypto();\n\n\n\n            var pmp = new ProtocolMessagePipe(server);\n\n            var salt = await pmp.ReadAsync(new SaltMessage(cryptoParameter.KeySize));\n\n\n\n            var key = new byte[cryptoParameter.KeySize];\n\n            HKDF.DeriveKey(HashAlgorithmName.SHA1, mainKey, key, salt.Salt.Span, _ssSubKeyInfo);\n\n            down.Init(key, null);\n\n            Memory<byte> nonce = new byte[cryptoParameter.NonceSize];\n\n            nonce.Span.Fill(0);\n\n\n\n            while (true)\n\n            {\n\n                try\n\n                {\n\n                    var block = await pmp.ReadAsync(new AeadBlockMessage(down, nonce, cryptoParameter));\n\n                    await client.Output.WriteAsync(block.Data);\n\n                    client.Output.Advance(block.Data.Length);\n\n                }\n\n                catch (FormatException)\n\n                {\n\n                    return;\n\n                }\n\n            }\n\n        }\n\n\n\n        public List<ReadOnlyMemory<byte>> SplitBigChunk(ReadOnlyMemory<byte> mem)\n\n        {\n\n            var l = new List<ReadOnlyMemory<byte>>(mem.Length / 0x3fff + 1);\n\n            while (mem.Length > 0x3fff)\n\n            {\n\n\n\n                l.Add(mem.Slice(0, 0x3fff));\n\n                mem = mem.Slice(0x4000);\n\n            }\n\n            l.Add(mem);\n\n            return l;\n\n        }\n\n    }\n\n}\n", "using Shadowsocks.Protocol.Shadowsocks.Crypto;\n\nusing System.IO.Pipelines;\n\nusing System.Net;\n\nusing System.Threading.Tasks;\n\n\n\nnamespace Shadowsocks.Protocol.Shadowsocks\n\n{\n\n    internal class ShadowsocksClient : IStreamClient\n\n    {\n\n        private readonly IStreamClient shadow;\n\n        private readonly PayloadProtocolClient socks = new PayloadProtocolClient();\n\n        private readonly PipePair p = new PipePair();\n\n\n\n        public ShadowsocksClient(string method, string password)\n\n        {\n\n            var param = CryptoProvider.GetCrypto(method);\n\n            if (param.IsAead)\n\n            {\n\n                shadow = new AeadClient(param, password);\n\n            }\n\n            else\n\n            {\n\n                shadow = new UnsafeClient(param, password);\n\n            }\n\n        }\n\n\n\n        public ShadowsocksClient(string method, byte[] key)\n\n        {\n\n            var param = CryptoProvider.GetCrypto(method);\n\n            shadow = new AeadClient(param, key);\n\n        }\n\n\n\n        public Task Connect(EndPoint destination, IDuplexPipe client, IDuplexPipe server)\n\n        {\n\n            var tShadow = shadow.Connect(null, p.UpSide, server);\n\n            var tSocks = socks.Connect(destination, client, p.UpSide);\n\n\n\n            return Task.WhenAll(tShadow, tSocks);\n\n        }\n\n    }\n\n}\n", "using Shadowsocks.Protocol.Socks5;\n\nusing System.IO.Pipelines;\n\nusing System.Net;\n\nusing System.Threading.Tasks;\n\n\n\nnamespace Shadowsocks.Protocol.Shadowsocks\n\n{\n\n    // shadowsocks payload protocol client\n\n    class PayloadProtocolClient : IStreamClient\n\n    {\n\n        public async Task Connect(EndPoint destination, IDuplexPipe client, IDuplexPipe server)\n\n        {\n\n            var addrMem = server.Output.GetMemory(512);\n\n\n\n            var addrLen = Socks5Message.SerializeAddress(addrMem, destination);\n\n            server.Output.Advance(addrLen);\n\n\n\n            await DuplexPipe.CopyDuplexPipe(client, server);\n\n        }\n\n    }\n\n}\n", "using CryptoBase;\n\n\n\nnamespace Shadowsocks.Protocol.Shadowsocks.Crypto\n\n{\n\n    public class AeadXChaCha20Poly1305Crypto : AeadCrypto\n\n    {\n\n        public AeadXChaCha20Poly1305Crypto(CryptoParameter parameter) : base(parameter)\n\n        {\n\n        }\n\n\n\n        public override void Init(byte[] key, byte[] iv) => crypto = AEADCryptoCreate.XChaCha20Poly1305(key);\n\n    }\n\n}\n", "using CryptoBase;\n\n\n\nnamespace Shadowsocks.Protocol.Shadowsocks.Crypto\n\n{\n\n    public class AeadAesGcmCrypto : AeadCrypto\n\n    {\n\n        public AeadAesGcmCrypto(CryptoParameter parameter) : base(parameter)\n\n        {\n\n        }\n\n\n\n        public override void Init(byte[] key, byte[] iv) => crypto = AEADCryptoCreate.AesGcm(key);\n\n    }\n\n}\n", "using CryptoBase.Digests.MD5;\n\nusing System;\n\nusing System.Buffers;\n\nusing System.Text;\n\n\n\nnamespace Shadowsocks.Protocol.Shadowsocks.Crypto\n\n{\n\n    public static class CryptoUtils\n\n    {\n\n        public static byte[] SSKDF(string password, int keylen)\n\n        {\n\n            const int md5Length = 16;\n\n            var pwMaxSize = Encoding.UTF8.GetMaxByteCount(password.Length);\n\n            var key = new byte[keylen];\n\n\n\n            var pwBuffer = ArrayPool<byte>.Shared.Rent(pwMaxSize);\n\n            var resultBuffer = ArrayPool<byte>.Shared.Rent(pwMaxSize + md5Length);\n\n            try\n\n            {\n\n                var pwLength = Encoding.UTF8.GetBytes(password, pwBuffer);\n\n                var pw = pwBuffer.AsSpan(0, pwLength);\n\n                Span<byte> md5Sum = stackalloc byte[md5Length];\n\n                var result = resultBuffer.AsSpan(0, pwLength + md5Length);\n\n                var i = 0;\n\n                while (i < keylen)\n\n                {\n\n                    if (i == 0)\n\n                    {\n\n                        MD5Utils.Default(pw, md5Sum);\n\n                    }\n\n                    else\n\n                    {\n\n                        md5Sum.CopyTo(result);\n\n                        pw.CopyTo(result.Slice(md5Length));\n\n                        MD5Utils.Default(result, md5Sum);\n\n                    }\n\n\n\n                    var length = Math.Min(16, keylen - i);\n\n                    md5Sum.Slice(0, length).CopyTo(key.AsSpan(i, length));\n\n\n\n                    i += md5Length;\n\n                }\n\n                return key;\n\n            }\n\n            finally\n\n            {\n\n                ArrayPool<byte>.Shared.Return(pwBuffer);\n\n                ArrayPool<byte>.Shared.Return(resultBuffer);\n\n            }\n\n        }\n\n    }\n\n}\n", "using System;\n\n\n\nnamespace Shadowsocks.Protocol.Shadowsocks.Crypto\n\n{\n\n    public struct CryptoParameter\n\n    {\n\n        public Type Crypto;\n\n        public int KeySize; // key size = salt size\n\n        public int NonceSize; // reused as iv size\n\n        public int TagSize;\n\n\n\n        public ICrypto GetCrypto()\n\n        {\n\n            var ctor = Crypto.GetConstructor(new[] { typeof(CryptoParameter) }) ??\n\n                  throw new TypeLoadException(\"can't load constructor\");\n\n            return (ICrypto)ctor.Invoke(new object[] { this });\n\n        }\n\n\n\n        public bool IsAead => TagSize > 0;\n\n    }\n\n}\n", "using System;\n\nusing System.Collections.Generic;\n\n\n\nnamespace Shadowsocks.Protocol.Shadowsocks.Crypto\n\n{\n\n    static class CryptoProvider\n\n    {\n\n        static Dictionary<string, CryptoParameter> parameters = new Dictionary<string, CryptoParameter>\n\n        {\n\n            [\"xchacha20-ietf-poly1305\"] = new CryptoParameter { KeySize = 32, NonceSize = 24, TagSize = 16, Crypto = typeof(AeadXChaCha20Poly1305Crypto) },\n\n            [\"chacha20-ietf-poly1305\"] = new CryptoParameter { KeySize = 32, NonceSize = 12, TagSize = 16, Crypto = typeof(AeadChaCha20Poly1305Crypto) },\n\n            [\"aes-256-gcm\"] = new CryptoParameter { KeySize = 32, NonceSize = 12, TagSize = 16, Crypto = typeof(AeadAesGcmCrypto) },\n\n            [\"aes-192-gcm\"] = new CryptoParameter { KeySize = 24, NonceSize = 12, TagSize = 16, Crypto = typeof(AeadAesGcmCrypto) },\n\n            [\"aes-128-gcm\"] = new CryptoParameter { KeySize = 16, NonceSize = 12, TagSize = 16, Crypto = typeof(AeadAesGcmCrypto) },\n\n            [\"none\"] = new CryptoParameter { KeySize = 0, NonceSize = 0, TagSize = 0, Crypto = typeof(UnsafeNoneCrypto) }\n\n        };\n\n\n\n        public static CryptoParameter GetCrypto(string method)\n\n        {\n\n            if (string.IsNullOrEmpty(method))\n\n            {\n\n                // todo\n\n                //method = IoCManager.Container.Resolve<IDefaultCrypto>().GetDefaultMethod();\n\n            }\n\n\n\n            method = method.ToLowerInvariant();\n\n            var ok = parameters.TryGetValue(method, out var t);\n\n            if (!ok)\n\n            {\n\n                //t = parameters[DefaultCipher];\n\n                throw new NotImplementedException();\n\n            }\n\n            return t;\n\n        }\n\n    }\n\n}\n", "using System;\n\n\n\nnamespace Shadowsocks.Protocol.Shadowsocks.Crypto\n\n{\n\n    class UnsafeNoneCrypto : ICrypto\n\n    {\n\n        public UnsafeNoneCrypto(CryptoParameter parameter)\n\n        {\n\n        }\n\n\n\n        public int Decrypt(ReadOnlySpan<byte> nonce, Span<byte> plain, ReadOnlySpan<byte> cipher)\n\n        {\n\n            cipher.CopyTo(plain);\n\n            return plain.Length;\n\n        }\n\n\n\n        public int Encrypt(ReadOnlySpan<byte> nonce, ReadOnlySpan<byte> plain, Span<byte> cipher)\n\n        {\n\n            plain.CopyTo(cipher);\n\n            return plain.Length;\n\n        }\n\n\n\n        public void Init(byte[] key, byte[] iv)\n\n        {\n\n        }\n\n\n\n        public void Dispose()\n\n        {\n\n        }\n\n    }\n\n}\n", "using CryptoBase.Abstractions.SymmetricCryptos;\n\nusing System;\n\n\n\nnamespace Shadowsocks.Protocol.Shadowsocks.Crypto\n\n{\n\n    public abstract class AeadCrypto : ICrypto\n\n    {\n\n        protected IAEADCrypto? crypto;\n\n\n\n        private readonly CryptoParameter _parameter;\n\n\n\n        protected AeadCrypto(CryptoParameter parameter)\n\n        {\n\n            _parameter = parameter;\n\n        }\n\n\n\n        public abstract void Init(byte[] key, byte[] iv);\n\n\n\n        public int Decrypt(ReadOnlySpan<byte> nonce, Span<byte> plain, ReadOnlySpan<byte> cipher)\n\n        {\n\n            crypto!.Decrypt(\n\n                nonce,\n\n                cipher[..^_parameter.TagSize],\n\n                cipher[^_parameter.TagSize..],\n\n                plain[..(cipher.Length - _parameter.TagSize)]);\n\n            return cipher.Length - _parameter.TagSize;\n\n        }\n\n\n\n        public int Encrypt(ReadOnlySpan<byte> nonce, ReadOnlySpan<byte> plain, Span<byte> cipher)\n\n        {\n\n            crypto!.Encrypt(\n\n                nonce,\n\n                plain,\n\n                cipher.Slice(0, plain.Length),\n\n                cipher.Slice(plain.Length, _parameter.TagSize));\n\n            return plain.Length + _parameter.TagSize;\n\n        }\n\n\n\n        public void Dispose() => crypto?.Dispose();\n\n    }\n\n}\n", "using CryptoBase;\n\n\n\nnamespace Shadowsocks.Protocol.Shadowsocks.Crypto\n\n{\n\n    public class AeadChaCha20Poly1305Crypto : AeadCrypto\n\n    {\n\n        public AeadChaCha20Poly1305Crypto(CryptoParameter parameter) : base(parameter)\n\n        {\n\n        }\n\n\n\n        public override void Init(byte[] key, byte[] iv) => crypto = AEADCryptoCreate.ChaCha20Poly1305(key);\n\n    }\n\n}\n", "// <auto-generated>\n\n//     Generated by the protocol buffer compiler.  DO NOT EDIT!\n\n//     source: geosite.proto\n\n// </auto-generated>\n\n#pragma warning disable 1591, 0612, 3021\n\n#region Designer generated code\n\n\n\nusing pb = global::Google.Protobuf;\n\nusing pbc = global::Google.Protobuf.Collections;\n\nusing pbr = global::Google.Protobuf.Reflection;\n\nusing scg = global::System.Collections.Generic;\n\n/// <summary>Holder for reflection information generated from geosite.proto</summary>\n\npublic static partial class GeositeReflection {\n\n\n\n  #region Descriptor\n\n  /// <summary>File descriptor for geosite.proto</summary>\n\n  public static pbr::FileDescriptor Descriptor {\n\n    get { return descriptor; }\n\n  }\n\n  private static pbr::FileDescriptor descriptor;\n\n\n\n  static GeositeReflection() {\n\n    byte[] descriptorData = global::System.Convert.FromBase64String(\n\n        string.Concat(\n\n          \"Cg1nZW9zaXRlLnByb3RvIvMBCgxEb21haW5PYmplY3QSIAoEdHlwZRgBIAEo\",\n\n          \"DjISLkRvbWFpbk9iamVjdC5UeXBlEg0KBXZhbHVlGAIgASgJEioKCWF0dHJp\",\n\n          \"YnV0ZRgDIAMoCzIXLkRvbWFpbk9iamVjdC5BdHRyaWJ1dGUaUgoJQXR0cmli\",\n\n          \"dXRlEgsKA2tleRgBIAEoCRIUCgpib29sX3ZhbHVlGAIgASgISAASEwoJaW50\",\n\n          \"X3ZhbHVlGAMgASgDSABCDQoLdHlwZWRfdmFsdWUiMgoEVHlwZRIJCgVQbGFp\",\n\n          \"bhAAEgkKBVJlZ2V4EAESCgoGRG9tYWluEAISCAoERnVsbBADIj0KB0dlb3Np\",\n\n          \"dGUSEgoKZ3JvdXBfbmFtZRgBIAEoCRIeCgdkb21haW5zGAIgAygLMg0uRG9t\",\n\n          \"YWluT2JqZWN0IigKC0dlb3NpdGVMaXN0EhkKB2VudHJpZXMYASADKAsyCC5H\",\n\n          \"ZW9zaXRlYgZwcm90bzM=\"));\n\n    descriptor = pbr::FileDescriptor.FromGeneratedCode(descriptorData,\n\n        new pbr::FileDescriptor[] { },\n\n        new pbr::GeneratedClrTypeInfo(null, null, new pbr::GeneratedClrTypeInfo[] {\n\n          new pbr::GeneratedClrTypeInfo(typeof(global::DomainObject), global::DomainObject.Parser, new[]{ \"Type\", \"Value\", \"Attribute\" }, null, new[]{ typeof(global::DomainObject.Types.Type) }, null, new pbr::GeneratedClrTypeInfo[] { new pbr::GeneratedClrTypeInfo(typeof(global::DomainObject.Types.Attribute), global::DomainObject.Types.Attribute.Parser, new[]{ \"Key\", \"BoolValue\", \"IntValue\" }, new[]{ \"TypedValue\" }, null, null, null)}),\n\n          new pbr::GeneratedClrTypeInfo(typeof(global::Geosite), global::Geosite.Parser, new[]{ \"GroupName\", \"Domains\" }, null, null, null, null),\n\n          new pbr::GeneratedClrTypeInfo(typeof(global::GeositeList), global::GeositeList.Parser, new[]{ \"Entries\" }, null, null, null, null)\n\n        }));\n\n  }\n\n  #endregion\n\n\n\n}\n\n#region Messages\n\n/// <summary>\n\n/// DomainObject for routing decision.\n\n/// </summary>\n\npublic sealed partial class DomainObject : pb::IMessage<DomainObject> {\n\n  private static readonly pb::MessageParser<DomainObject> _parser = new pb::MessageParser<DomainObject>(() => new DomainObject());\n\n  private pb::UnknownFieldSet _unknownFields;\n\n  [global::System.Diagnostics.DebuggerNonUserCodeAttribute]\n\n  public static pb::MessageParser<DomainObject> Parser { get { return _parser; } }\n\n\n\n  [global::System.Diagnostics.DebuggerNonUserCodeAttribute]\n\n  public static pbr::MessageDescriptor Descriptor {\n\n    get { return global::GeositeReflection.Descriptor.MessageTypes[0]; }\n\n  }\n\n\n\n  [global::System.Diagnostics.DebuggerNonUserCodeAttribute]\n\n  pbr::MessageDescriptor pb::IMessage.Descriptor {\n\n    get { return Descriptor; }\n\n  }\n\n\n\n  [global::System.Diagnostics.DebuggerNonUserCodeAttribute]\n\n  public DomainObject() {\n\n    OnConstruction();\n\n  }\n\n\n\n  partial void OnConstruction();\n\n\n\n  [global::System.Diagnostics.DebuggerNonUserCodeAttribute]\n\n  public DomainObject(DomainObject other) : this() {\n\n    type_ = other.type_;\n\n    value_ = other.value_;\n\n    attribute_ = other.attribute_.Clone();\n\n    _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);\n\n  }\n\n\n\n  [global::System.Diagnostics.DebuggerNonUserCodeAttribute]\n\n  public DomainObject Clone() {\n\n    return new DomainObject(this);\n\n  }\n\n\n\n  /// <summary>Field number for the \"type\" field.</summary>\n\n  public const int TypeFieldNumber = 1;\n\n  private global::DomainObject.Types.Type type_ = global::DomainObject.Types.Type.Plain;\n\n  /// <summary>\n\n  /// DomainObject matching type.\n\n  /// </summary>\n\n  [global::System.Diagnostics.DebuggerNonUserCodeAttribute]\n\n  public global::DomainObject.Types.Type Type {\n\n    get { return type_; }\n\n    set {\n\n      type_ = value;\n\n    }\n\n  }\n\n\n\n  /// <summary>Field number for the \"value\" field.</summary>\n\n  public const int ValueFieldNumber = 2;\n\n  private string value_ = \"\";\n\n  /// <summary>\n\n  /// DomainObject value.\n\n  /// </summary>\n\n  [global::System.Diagnostics.DebuggerNonUserCodeAttribute]\n\n  public string Value {\n\n    get { return value_; }\n\n    set {\n\n      value_ = pb::ProtoPreconditions.CheckNotNull(value, \"value\");\n\n    }\n\n  }\n\n\n\n  /// <summary>Field number for the \"attribute\" field.</summary>\n\n  public const int AttributeFieldNumber = 3;\n\n  private static readonly pb::FieldCodec<global::DomainObject.Types.Attribute> _repeated_attribute_codec\n\n      = pb::FieldCodec.ForMessage(26, global::DomainObject.Types.Attribute.Parser);\n\n  private readonly pbc::RepeatedField<global::DomainObject.Types.Attribute> attribute_ = new pbc::RepeatedField<global::DomainObject.Types.Attribute>();\n\n  /// <summary>\n\n  /// Attributes of this domain. May be used for filtering.\n\n  /// </summary>\n\n  [global::System.Diagnostics.DebuggerNonUserCodeAttribute]\n\n  public pbc::RepeatedField<global::DomainObject.Types.Attribute> Attribute {\n\n    get { return attribute_; }\n\n  }\n\n\n\n  [global::System.Diagnostics.DebuggerNonUserCodeAttribute]\n\n  public override bool Equals(object other) {\n\n    return Equals(other as DomainObject);\n\n  }\n\n\n\n  [global::System.Diagnostics.DebuggerNonUserCodeAttribute]\n\n  public bool Equals(DomainObject other) {\n\n    if (ReferenceEquals(other, null)) {\n\n      return false;\n\n    }\n\n    if (ReferenceEquals(other, this)) {\n\n      return true;\n\n    }\n\n    if (Type != other.Type) return false;\n\n    if (Value != other.Value) return false;\n\n    if(!attribute_.Equals(other.attribute_)) return false;\n\n    return Equals(_unknownFields, other._unknownFields);\n\n  }\n\n\n\n  [global::System.Diagnostics.DebuggerNonUserCodeAttribute]\n\n  public override int GetHashCode() {\n\n    int hash = 1;\n\n    if (Type != global::DomainObject.Types.Type.Plain) hash ^= Type.GetHashCode();\n\n    if (Value.Length != 0) hash ^= Value.GetHashCode();\n\n    hash ^= attribute_.GetHashCode();\n\n    if (_unknownFields != null) {\n\n      hash ^= _unknownFields.GetHashCode();\n\n    }\n\n    return hash;\n\n  }\n\n\n\n  [global::System.Diagnostics.DebuggerNonUserCodeAttribute]\n\n  public override string ToString() {\n\n    return pb::JsonFormatter.ToDiagnosticString(this);\n\n  }\n\n\n\n  [global::System.Diagnostics.DebuggerNonUserCodeAttribute]\n\n  public void WriteTo(pb::CodedOutputStream output) {\n\n    if (Type != global::DomainObject.Types.Type.Plain) {\n\n      output.WriteRawTag(8);\n\n      output.WriteEnum((int) Type);\n\n    }\n\n    if (Value.Length != 0) {\n\n      output.WriteRawTag(18);\n\n      output.WriteString(Value);\n\n    }\n\n    attribute_.WriteTo(output, _repeated_attribute_codec);\n\n    if (_unknownFields != null) {\n\n      _unknownFields.WriteTo(output);\n\n    }\n\n  }\n\n\n\n  [global::System.Diagnostics.DebuggerNonUserCodeAttribute]\n\n  public int CalculateSize() {\n\n    int size = 0;\n\n    if (Type != global::DomainObject.Types.Type.Plain) {\n\n      size += 1 + pb::CodedOutputStream.ComputeEnumSize((int) Type);\n\n    }\n\n    if (Value.Length != 0) {\n\n      size += 1 + pb::CodedOutputStream.ComputeStringSize(Value);\n\n    }\n\n    size += attribute_.CalculateSize(_repeated_attribute_codec);\n\n    if (_unknownFields != null) {\n\n      size += _unknownFields.CalculateSize();\n\n    }\n\n    return size;\n\n  }\n\n\n\n  [global::System.Diagnostics.DebuggerNonUserCodeAttribute]\n\n  public void MergeFrom(DomainObject other) {\n\n    if (other == null) {\n\n      return;\n\n    }\n\n    if (other.Type != global::DomainObject.Types.Type.Plain) {\n\n      Type = other.Type;\n\n    }\n\n    if (other.Value.Length != 0) {\n\n      Value = other.Value;\n\n    }\n\n    attribute_.Add(other.attribute_);\n\n    _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);\n\n  }\n\n\n\n  [global::System.Diagnostics.DebuggerNonUserCodeAttribute]\n\n  public void MergeFrom(pb::CodedInputStream input) {\n\n    uint tag;\n\n    while ((tag = input.ReadTag()) != 0) {\n\n      switch(tag) {\n\n        default:\n\n          _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);\n\n          break;\n\n        case 8: {\n\n          Type = (global::DomainObject.Types.Type) input.ReadEnum();\n\n          break;\n\n        }\n\n        case 18: {\n\n          Value = input.ReadString();\n\n          break;\n\n        }\n\n        case 26: {\n\n          attribute_.AddEntriesFrom(input, _repeated_attribute_codec);\n\n          break;\n\n        }\n\n      }\n\n    }\n\n  }\n\n\n\n  #region Nested types\n\n  /// <summary>Container for nested types declared in the DomainObject message type.</summary>\n\n  [global::System.Diagnostics.DebuggerNonUserCodeAttribute]\n\n  public static partial class Types {\n\n    /// <summary>\n\n    /// Type of domain value.\n\n    /// </summary>\n\n    public enum Type {\n\n      /// <summary>\n\n      /// The value is used as is.\n\n      /// </summary>\n\n      [pbr::OriginalName(\"Plain\")] Plain = 0,\n\n      /// <summary>\n\n      /// The value is used as a regular expression.\n\n      /// </summary>\n\n      [pbr::OriginalName(\"Regex\")] Regex = 1,\n\n      /// <summary>\n\n      /// The value is a root domain.\n\n      /// </summary>\n\n      [pbr::OriginalName(\"Domain\")] Domain = 2,\n\n      /// <summary>\n\n      /// The value is a domain.\n\n      /// </summary>\n\n      [pbr::OriginalName(\"Full\")] Full = 3,\n\n    }\n\n\n\n    public sealed partial class Attribute : pb::IMessage<Attribute> {\n\n      private static readonly pb::MessageParser<Attribute> _parser = new pb::MessageParser<Attribute>(() => new Attribute());\n\n      private pb::UnknownFieldSet _unknownFields;\n\n      [global::System.Diagnostics.DebuggerNonUserCodeAttribute]\n\n      public static pb::MessageParser<Attribute> Parser { get { return _parser; } }\n\n\n\n      [global::System.Diagnostics.DebuggerNonUserCodeAttribute]\n\n      public static pbr::MessageDescriptor Descriptor {\n\n        get { return global::DomainObject.Descriptor.NestedTypes[0]; }\n\n      }\n\n\n\n      [global::System.Diagnostics.DebuggerNonUserCodeAttribute]\n\n      pbr::MessageDescriptor pb::IMessage.Descriptor {\n\n        get { return Descriptor; }\n\n      }\n\n\n\n      [global::System.Diagnostics.DebuggerNonUserCodeAttribute]\n\n      public Attribute() {\n\n        OnConstruction();\n\n      }\n\n\n\n      partial void OnConstruction();\n\n\n\n      [global::System.Diagnostics.DebuggerNonUserCodeAttribute]\n\n      public Attribute(Attribute other) : this() {\n\n        key_ = other.key_;\n\n        switch (other.TypedValueCase) {\n\n          case TypedValueOneofCase.BoolValue:\n\n            BoolValue = other.BoolValue;\n\n            break;\n\n          case TypedValueOneofCase.IntValue:\n\n            IntValue = other.IntValue;\n\n            break;\n\n        }\n\n\n\n        _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);\n\n      }\n\n\n\n      [global::System.Diagnostics.DebuggerNonUserCodeAttribute]\n\n      public Attribute Clone() {\n\n        return new Attribute(this);\n\n      }\n\n\n\n      /// <summary>Field number for the \"key\" field.</summary>\n\n      public const int KeyFieldNumber = 1;\n\n      private string key_ = \"\";\n\n      [global::System.Diagnostics.DebuggerNonUserCodeAttribute]\n\n      public string Key {\n\n        get { return key_; }\n\n        set {\n\n          key_ = pb::ProtoPreconditions.CheckNotNull(value, \"value\");\n\n        }\n\n      }\n\n\n\n      /// <summary>Field number for the \"bool_value\" field.</summary>\n\n      public const int BoolValueFieldNumber = 2;\n\n      [global::System.Diagnostics.DebuggerNonUserCodeAttribute]\n\n      public bool BoolValue {\n\n        get { return typedValueCase_ == TypedValueOneofCase.BoolValue ? (bool) typedValue_ : false; }\n\n        set {\n\n          typedValue_ = value;\n\n          typedValueCase_ = TypedValueOneofCase.BoolValue;\n\n        }\n\n      }\n\n\n\n      /// <summary>Field number for the \"int_value\" field.</summary>\n\n      public const int IntValueFieldNumber = 3;\n\n      [global::System.Diagnostics.DebuggerNonUserCodeAttribute]\n\n      public long IntValue {\n\n        get { return typedValueCase_ == TypedValueOneofCase.IntValue ? (long) typedValue_ : 0L; }\n\n        set {\n\n          typedValue_ = value;\n\n          typedValueCase_ = TypedValueOneofCase.IntValue;\n\n        }\n\n      }\n\n\n\n      private object typedValue_;\n\n      /// <summary>Enum of possible cases for the \"typed_value\" oneof.</summary>\n\n      public enum TypedValueOneofCase {\n\n        None = 0,\n\n        BoolValue = 2,\n\n        IntValue = 3,\n\n      }\n\n      private TypedValueOneofCase typedValueCase_ = TypedValueOneofCase.None;\n\n      [global::System.Diagnostics.DebuggerNonUserCodeAttribute]\n\n      public TypedValueOneofCase TypedValueCase {\n\n        get { return typedValueCase_; }\n\n      }\n\n\n\n      [global::System.Diagnostics.DebuggerNonUserCodeAttribute]\n\n      public void ClearTypedValue() {\n\n        typedValueCase_ = TypedValueOneofCase.None;\n\n        typedValue_ = null;\n\n      }\n\n\n\n      [global::System.Diagnostics.DebuggerNonUserCodeAttribute]\n\n      public override bool Equals(object other) {\n\n        return Equals(other as Attribute);\n\n      }\n\n\n\n      [global::System.Diagnostics.DebuggerNonUserCodeAttribute]\n\n      public bool Equals(Attribute other) {\n\n        if (ReferenceEquals(other, null)) {\n\n          return false;\n\n        }\n\n        if (ReferenceEquals(other, this)) {\n\n          return true;\n\n        }\n\n        if (Key != other.Key) return false;\n\n        if (BoolValue != other.BoolValue) return false;\n\n        if (IntValue != other.IntValue) return false;\n\n        if (TypedValueCase != other.TypedValueCase) return false;\n\n        return Equals(_unknownFields, other._unknownFields);\n\n      }\n\n\n\n      [global::System.Diagnostics.DebuggerNonUserCodeAttribute]\n\n      public override int GetHashCode() {\n\n        int hash = 1;\n\n        if (Key.Length != 0) hash ^= Key.GetHashCode();\n\n        if (typedValueCase_ == TypedValueOneofCase.BoolValue) hash ^= BoolValue.GetHashCode();\n\n        if (typedValueCase_ == TypedValueOneofCase.IntValue) hash ^= IntValue.GetHashCode();\n\n        hash ^= (int) typedValueCase_;\n\n        if (_unknownFields != null) {\n\n          hash ^= _unknownFields.GetHashCode();\n\n        }\n\n        return hash;\n\n      }\n\n\n\n      [global::System.Diagnostics.DebuggerNonUserCodeAttribute]\n\n      public override string ToString() {\n\n        return pb::JsonFormatter.ToDiagnosticString(this);\n\n      }\n\n\n\n      [global::System.Diagnostics.DebuggerNonUserCodeAttribute]\n\n      public void WriteTo(pb::CodedOutputStream output) {\n\n        if (Key.Length != 0) {\n\n          output.WriteRawTag(10);\n\n          output.WriteString(Key);\n\n        }\n\n        if (typedValueCase_ == TypedValueOneofCase.BoolValue) {\n\n          output.WriteRawTag(16);\n\n          output.WriteBool(BoolValue);\n\n        }\n\n        if (typedValueCase_ == TypedValueOneofCase.IntValue) {\n\n          output.WriteRawTag(24);\n\n          output.WriteInt64(IntValue);\n\n        }\n\n        if (_unknownFields != null) {\n\n          _unknownFields.WriteTo(output);\n\n        }\n\n      }\n\n\n\n      [global::System.Diagnostics.DebuggerNonUserCodeAttribute]\n\n      public int CalculateSize() {\n\n        int size = 0;\n\n        if (Key.Length != 0) {\n\n          size += 1 + pb::CodedOutputStream.ComputeStringSize(Key);\n\n        }\n\n        if (typedValueCase_ == TypedValueOneofCase.BoolValue) {\n\n          size += 1 + 1;\n\n        }\n\n        if (typedValueCase_ == TypedValueOneofCase.IntValue) {\n\n          size += 1 + pb::CodedOutputStream.ComputeInt64Size(IntValue);\n\n        }\n\n        if (_unknownFields != null) {\n\n          size += _unknownFields.CalculateSize();\n\n        }\n\n        return size;\n\n      }\n\n\n\n      [global::System.Diagnostics.DebuggerNonUserCodeAttribute]\n\n      public void MergeFrom(Attribute other) {\n\n        if (other == null) {\n\n          return;\n\n        }\n\n        if (other.Key.Length != 0) {\n\n          Key = other.Key;\n\n        }\n\n        switch (other.TypedValueCase) {\n\n          case TypedValueOneofCase.BoolValue:\n\n            BoolValue = other.BoolValue;\n\n            break;\n\n          case TypedValueOneofCase.IntValue:\n\n            IntValue = other.IntValue;\n\n            break;\n\n        }\n\n\n\n        _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);\n\n      }\n\n\n\n      [global::System.Diagnostics.DebuggerNonUserCodeAttribute]\n\n      public void MergeFrom(pb::CodedInputStream input) {\n\n        uint tag;\n\n        while ((tag = input.ReadTag()) != 0) {\n\n          switch(tag) {\n\n            default:\n\n              _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);\n\n              break;\n\n            case 10: {\n\n              Key = input.ReadString();\n\n              break;\n\n            }\n\n            case 16: {\n\n              BoolValue = input.ReadBool();\n\n              break;\n\n            }\n\n            case 24: {\n\n              IntValue = input.ReadInt64();\n\n              break;\n\n            }\n\n          }\n\n        }\n\n      }\n\n\n\n    }\n\n\n\n  }\n\n  #endregion\n\n\n\n}\n\n\n\npublic sealed partial class Geosite : pb::IMessage<Geosite> {\n\n  private static readonly pb::MessageParser<Geosite> _parser = new pb::MessageParser<Geosite>(() => new Geosite());\n\n  private pb::UnknownFieldSet _unknownFields;\n\n  [global::System.Diagnostics.DebuggerNonUserCodeAttribute]\n\n  public static pb::MessageParser<Geosite> Parser { get { return _parser; } }\n\n\n\n  [global::System.Diagnostics.DebuggerNonUserCodeAttribute]\n\n  public static pbr::MessageDescriptor Descriptor {\n\n    get { return global::GeositeReflection.Descriptor.MessageTypes[1]; }\n\n  }\n\n\n\n  [global::System.Diagnostics.DebuggerNonUserCodeAttribute]\n\n  pbr::MessageDescriptor pb::IMessage.Descriptor {\n\n    get { return Descriptor; }\n\n  }\n\n\n\n  [global::System.Diagnostics.DebuggerNonUserCodeAttribute]\n\n  public Geosite() {\n\n    OnConstruction();\n\n  }\n\n\n\n  partial void OnConstruction();\n\n\n\n  [global::System.Diagnostics.DebuggerNonUserCodeAttribute]\n\n  public Geosite(Geosite other) : this() {\n\n    groupName_ = other.groupName_;\n\n    domains_ = other.domains_.Clone();\n\n    _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);\n\n  }\n\n\n\n  [global::System.Diagnostics.DebuggerNonUserCodeAttribute]\n\n  public Geosite Clone() {\n\n    return new Geosite(this);\n\n  }\n\n\n\n  /// <summary>Field number for the \"group_name\" field.</summary>\n\n  public const int GroupNameFieldNumber = 1;\n\n  private string groupName_ = \"\";\n\n  [global::System.Diagnostics.DebuggerNonUserCodeAttribute]\n\n  public string GroupName {\n\n    get { return groupName_; }\n\n    set {\n\n      groupName_ = pb::ProtoPreconditions.CheckNotNull(value, \"value\");\n\n    }\n\n  }\n\n\n\n  /// <summary>Field number for the \"domains\" field.</summary>\n\n  public const int DomainsFieldNumber = 2;\n\n  private static readonly pb::FieldCodec<global::DomainObject> _repeated_domains_codec\n\n      = pb::FieldCodec.ForMessage(18, global::DomainObject.Parser);\n\n  private readonly pbc::RepeatedField<global::DomainObject> domains_ = new pbc::RepeatedField<global::DomainObject>();\n\n  [global::System.Diagnostics.DebuggerNonUserCodeAttribute]\n\n  public pbc::RepeatedField<global::DomainObject> Domains {\n\n    get { return domains_; }\n\n  }\n\n\n\n  [global::System.Diagnostics.DebuggerNonUserCodeAttribute]\n\n  public override bool Equals(object other) {\n\n    return Equals(other as Geosite);\n\n  }\n\n\n\n  [global::System.Diagnostics.DebuggerNonUserCodeAttribute]\n\n  public bool Equals(Geosite other) {\n\n    if (ReferenceEquals(other, null)) {\n\n      return false;\n\n    }\n\n    if (ReferenceEquals(other, this)) {\n\n      return true;\n\n    }\n\n    if (GroupName != other.GroupName) return false;\n\n    if(!domains_.Equals(other.domains_)) return false;\n\n    return Equals(_unknownFields, other._unknownFields);\n\n  }\n\n\n\n  [global::System.Diagnostics.DebuggerNonUserCodeAttribute]\n\n  public override int GetHashCode() {\n\n    int hash = 1;\n\n    if (GroupName.Length != 0) hash ^= GroupName.GetHashCode();\n\n    hash ^= domains_.GetHashCode();\n\n    if (_unknownFields != null) {\n\n      hash ^= _unknownFields.GetHashCode();\n\n    }\n\n    return hash;\n\n  }\n\n\n\n  [global::System.Diagnostics.DebuggerNonUserCodeAttribute]\n\n  public override string ToString() {\n\n    return pb::JsonFormatter.ToDiagnosticString(this);\n\n  }\n\n\n\n  [global::System.Diagnostics.DebuggerNonUserCodeAttribute]\n\n  public void WriteTo(pb::CodedOutputStream output) {\n\n    if (GroupName.Length != 0) {\n\n      output.WriteRawTag(10);\n\n      output.WriteString(GroupName);\n\n    }\n\n    domains_.WriteTo(output, _repeated_domains_codec);\n\n    if (_unknownFields != null) {\n\n      _unknownFields.WriteTo(output);\n\n    }\n\n  }\n\n\n\n  [global::System.Diagnostics.DebuggerNonUserCodeAttribute]\n\n  public int CalculateSize() {\n\n    int size = 0;\n\n    if (GroupName.Length != 0) {\n\n      size += 1 + pb::CodedOutputStream.ComputeStringSize(GroupName);\n\n    }\n\n    size += domains_.CalculateSize(_repeated_domains_codec);\n\n    if (_unknownFields != null) {\n\n      size += _unknownFields.CalculateSize();\n\n    }\n\n    return size;\n\n  }\n\n\n\n  [global::System.Diagnostics.DebuggerNonUserCodeAttribute]\n\n  public void MergeFrom(Geosite other) {\n\n    if (other == null) {\n\n      return;\n\n    }\n\n    if (other.GroupName.Length != 0) {\n\n      GroupName = other.GroupName;\n\n    }\n\n    domains_.Add(other.domains_);\n\n    _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);\n\n  }\n\n\n\n  [global::System.Diagnostics.DebuggerNonUserCodeAttribute]\n\n  public void MergeFrom(pb::CodedInputStream input) {\n\n    uint tag;\n\n    while ((tag = input.ReadTag()) != 0) {\n\n      switch(tag) {\n\n        default:\n\n          _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);\n\n          break;\n\n        case 10: {\n\n          GroupName = input.ReadString();\n\n          break;\n\n        }\n\n        case 18: {\n\n          domains_.AddEntriesFrom(input, _repeated_domains_codec);\n\n          break;\n\n        }\n\n      }\n\n    }\n\n  }\n\n\n\n}\n\n\n\npublic sealed partial class GeositeList : pb::IMessage<GeositeList> {\n\n  private static readonly pb::MessageParser<GeositeList> _parser = new pb::MessageParser<GeositeList>(() => new GeositeList());\n\n  private pb::UnknownFieldSet _unknownFields;\n\n  [global::System.Diagnostics.DebuggerNonUserCodeAttribute]\n\n  public static pb::MessageParser<GeositeList> Parser { get { return _parser; } }\n\n\n\n  [global::System.Diagnostics.DebuggerNonUserCodeAttribute]\n\n  public static pbr::MessageDescriptor Descriptor {\n\n    get { return global::GeositeReflection.Descriptor.MessageTypes[2]; }\n\n  }\n\n\n\n  [global::System.Diagnostics.DebuggerNonUserCodeAttribute]\n\n  pbr::MessageDescriptor pb::IMessage.Descriptor {\n\n    get { return Descriptor; }\n\n  }\n\n\n\n  [global::System.Diagnostics.DebuggerNonUserCodeAttribute]\n\n  public GeositeList() {\n\n    OnConstruction();\n\n  }\n\n\n\n  partial void OnConstruction();\n\n\n\n  [global::System.Diagnostics.DebuggerNonUserCodeAttribute]\n\n  public GeositeList(GeositeList other) : this() {\n\n    entries_ = other.entries_.Clone();\n\n    _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);\n\n  }\n\n\n\n  [global::System.Diagnostics.DebuggerNonUserCodeAttribute]\n\n  public GeositeList Clone() {\n\n    return new GeositeList(this);\n\n  }\n\n\n\n  /// <summary>Field number for the \"entries\" field.</summary>\n\n  public const int EntriesFieldNumber = 1;\n\n  private static readonly pb::FieldCodec<global::Geosite> _repeated_entries_codec\n\n      = pb::FieldCodec.ForMessage(10, global::Geosite.Parser);\n\n  private readonly pbc::RepeatedField<global::Geosite> entries_ = new pbc::RepeatedField<global::Geosite>();\n\n  [global::System.Diagnostics.DebuggerNonUserCodeAttribute]\n\n  public pbc::RepeatedField<global::Geosite> Entries {\n\n    get { return entries_; }\n\n  }\n\n\n\n  [global::System.Diagnostics.DebuggerNonUserCodeAttribute]\n\n  public override bool Equals(object other) {\n\n    return Equals(other as GeositeList);\n\n  }\n\n\n\n  [global::System.Diagnostics.DebuggerNonUserCodeAttribute]\n\n  public bool Equals(GeositeList other) {\n\n    if (ReferenceEquals(other, null)) {\n\n      return false;\n\n    }\n\n    if (ReferenceEquals(other, this)) {\n\n      return true;\n\n    }\n\n    if(!entries_.Equals(other.entries_)) return false;\n\n    return Equals(_unknownFields, other._unknownFields);\n\n  }\n\n\n\n  [global::System.Diagnostics.DebuggerNonUserCodeAttribute]\n\n  public override int GetHashCode() {\n\n    int hash = 1;\n\n    hash ^= entries_.GetHashCode();\n\n    if (_unknownFields != null) {\n\n      hash ^= _unknownFields.GetHashCode();\n\n    }\n\n    return hash;\n\n  }\n\n\n\n  [global::System.Diagnostics.DebuggerNonUserCodeAttribute]\n\n  public override string ToString() {\n\n    return pb::JsonFormatter.ToDiagnosticString(this);\n\n  }\n\n\n\n  [global::System.Diagnostics.DebuggerNonUserCodeAttribute]\n\n  public void WriteTo(pb::CodedOutputStream output) {\n\n    entries_.WriteTo(output, _repeated_entries_codec);\n\n    if (_unknownFields != null) {\n\n      _unknownFields.WriteTo(output);\n\n    }\n\n  }\n\n\n\n  [global::System.Diagnostics.DebuggerNonUserCodeAttribute]\n\n  public int CalculateSize() {\n\n    int size = 0;\n\n    size += entries_.CalculateSize(_repeated_entries_codec);\n\n    if (_unknownFields != null) {\n\n      size += _unknownFields.CalculateSize();\n\n    }\n\n    return size;\n\n  }\n\n\n\n  [global::System.Diagnostics.DebuggerNonUserCodeAttribute]\n\n  public void MergeFrom(GeositeList other) {\n\n    if (other == null) {\n\n      return;\n\n    }\n\n    entries_.Add(other.entries_);\n\n    _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);\n\n  }\n\n\n\n  [global::System.Diagnostics.DebuggerNonUserCodeAttribute]\n\n  public void MergeFrom(pb::CodedInputStream input) {\n\n    uint tag;\n\n    while ((tag = input.ReadTag()) != 0) {\n\n      switch(tag) {\n\n        default:\n\n          _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);\n\n          break;\n\n        case 10: {\n\n          entries_.AddEntriesFrom(input, _repeated_entries_codec);\n\n          break;\n\n        }\n\n      }\n\n    }\n\n  }\n\n\n\n}\n\n\n\n#endregion\n\n\n\n\n\n#endregion Designer generated code\n", "using Splat;\n\nusing System;\n\nusing System.Collections.Generic;\n\nusing System.Linq;\n\nusing System.Net;\n\nusing System.Net.NetworkInformation;\n\nusing System.Net.Sockets;\n\nusing System.Threading;\n\nusing System.Threading.Tasks;\n\n\n\nnamespace Shadowsocks.Net\n\n{\n\n    public interface IDatagramService\n\n    {\n\n        public abstract Task< bool> Handle(Memory<byte> packet, Socket socket, EndPoint client);\n\n\n\n        void Stop();\n\n    }\n\n\n\n    public abstract class DatagramService : IDatagramService\n\n    {\n\n        public abstract Task<bool> Handle(Memory<byte> packet, Socket socket, EndPoint client);\n\n\n\n        public virtual void Stop() { }\n\n    }\n\n\n\n    public class UDPListener : IEnableLogger\n\n    {\n\n        public class UDPState\n\n        {\n\n            public UDPState(Socket s)\n\n            {\n\n                socket = s;\n\n                remoteEndPoint = new IPEndPoint(s.AddressFamily == AddressFamily.InterNetworkV6 ? IPAddress.IPv6Any : IPAddress.Any, 0);\n\n            }\n\n            public Socket socket;\n\n            public byte[] buffer = new byte[4096];\n\n            public EndPoint remoteEndPoint;\n\n        }\n\n\n\n        IPEndPoint _localEndPoint;\n\n        Socket _udpSocket;\n\n        IEnumerable<IDatagramService> _services;\n\n        CancellationTokenSource tokenSource = new CancellationTokenSource();\n\n\n\n        public UDPListener(IPEndPoint localEndPoint, IEnumerable<IDatagramService> services)\n\n        {\n\n            _localEndPoint = localEndPoint;\n\n            _services = services;\n\n        }\n\n\n\n        private bool CheckIfPortInUse(int port)\n\n        {\n\n            IPGlobalProperties ipProperties = IPGlobalProperties.GetIPGlobalProperties();\n\n            return ipProperties.GetActiveUdpListeners().Any(endPoint => endPoint.Port == port);\n\n        }\n\n\n\n        public void Start()\n\n        {\n\n            if (CheckIfPortInUse(_localEndPoint.Port))\n\n                throw new Exception($\"Port {_localEndPoint.Port} already in use\");\n\n\n\n            // Create a TCP/IP socket.\n\n            _udpSocket = new Socket(_localEndPoint.AddressFamily, SocketType.Dgram, ProtocolType.Udp);\n\n            _udpSocket.SetSocketOption(SocketOptionLevel.Socket, SocketOptionName.ReuseAddress, true);\n\n            _udpSocket.SetSocketOption(SocketOptionLevel.IPv6, SocketOptionName.IPv6Only, false);\n\n\n\n            // Bind the socket to the local endpoint and listen for incoming connections.\n\n            _udpSocket.Bind(_localEndPoint);\n\n\n\n            // Start an asynchronous socket to listen for connections.\n\n            this.Log().Info($\"Shadowsocks started UDP\");\n\n            this.Log().Debug(Crypto.CryptoFactory.DumpRegisteredEncryptor());\n\n            UDPState udpState = new UDPState(_udpSocket);\n\n            // _udpSocket.BeginReceiveFrom(udpState.buffer, 0, udpState.buffer.Length, 0, ref udpState.remoteEndPoint, new AsyncCallback(RecvFromCallback), udpState);\n\n            Task.Run(() => WorkLoop(tokenSource.Token));\n\n        }\n\n\n\n        private async Task WorkLoop(CancellationToken token)\n\n        {\n\n            byte[] buffer = new byte[4096];\n\n            EndPoint remote = new IPEndPoint(_udpSocket.AddressFamily == AddressFamily.InterNetworkV6 ? IPAddress.IPv6Any : IPAddress.Any, 0);\n\n            while (!token.IsCancellationRequested)\n\n            {\n\n                var result = await _udpSocket.ReceiveFromAsync(buffer, SocketFlags.None, remote);\n\n                var len = result.ReceivedBytes;\n\n                foreach (IDatagramService service in _services)\n\n                {\n\n                    if (await service.Handle(new Memory<byte>(buffer)[..len], _udpSocket, result.RemoteEndPoint))\n\n                    {\n\n                        break;\n\n                    }\n\n                }\n\n            }\n\n        }\n\n\n\n        public void Stop()\n\n        {\n\n            tokenSource.Cancel();\n\n            _udpSocket?.Close();\n\n            foreach (var s in _services)\n\n            {\n\n                s.Stop();\n\n            }\n\n        }\n\n    }\n\n}\n", "using System;\n\nusing System.Collections.Generic;\n\nusing System.IO;\n\nusing System.Net.Sockets;\n\nusing System.Runtime.CompilerServices;\n\nusing System.Text;\n\nusing System.Threading;\n\nusing System.Threading.Tasks;\n\n\n\nnamespace Shadowsocks.Net\n\n{\n\n    // cache first packet for duty-chain pattern listener\n\n    public class CachedNetworkStream : Stream\n\n    {\n\n        // 256 byte first packet buffer should enough for 99.999...% situation\n\n        // socks5: 0x05 0x....\n\n        // http-pac: GET /pac HTTP/1.1\n\n        // http-proxy: /[a-z]+ .+ HTTP\\/1\\.[01]/i\n\n\n\n        public const int MaxCache = 256;\n\n\n\n        public Socket Socket { get; private set; }\n\n\n\n        private readonly Stream s;\n\n\n\n        private byte[] cache = new byte[MaxCache];\n\n        private long cachePtr = 0;\n\n\n\n        private long readPtr = 0;\n\n\n\n        public CachedNetworkStream(Socket socket)\n\n        {\n\n            s = new NetworkStream(socket);\n\n            Socket = socket;\n\n        }\n\n\n\n        /// <summary>\n\n        /// Only for test purpose\n\n        /// </summary>\n\n        /// <param name=\"stream\"></param>\n\n        public CachedNetworkStream(Stream stream)\n\n        {\n\n            s = stream;\n\n        }\n\n\n\n        public override bool CanRead => s.CanRead;\n\n\n\n        // we haven't run out of cache\n\n        public override bool CanSeek => cachePtr == readPtr;\n\n\n\n        public override bool CanWrite => s.CanWrite;\n\n\n\n        public override long Length => s.Length;\n\n\n\n        public override long Position { get => readPtr; set => Seek(value, SeekOrigin.Begin); }\n\n\n\n        public override void Flush()\n\n        {\n\n            s.Flush();\n\n        }\n\n\n\n        //public override async ValueTask<int> ReadAsync(Memory<byte> buffer, CancellationToken cancellationToken = default)\n\n        //{\n\n        //    var endPtr = buffer.Length + readPtr;               // expected ptr after operation\n\n        //    var uncachedLen = Math.Max(endPtr - cachePtr, 0);   // how many data from socket\n\n        //    var cachedLen = buffer.Length - uncachedLen;        // how many data from cache\n\n        //    var emptyCacheLen = MaxCache - cachePtr;            // how many cache remain\n\n\n\n        //    int readLen = 0;\n\n        //    var cachedMem = buffer[..(int)cachedLen];\n\n        //    var uncachedMem = buffer[(int)cachedLen..];\n\n        //    if (cachedLen > 0)\n\n        //    {\n\n        //        cache[(int)readPtr..(int)(readPtr + cachedLen)].CopyTo(cachedMem);\n\n\n\n        //        readPtr += cachedLen;\n\n        //        readLen += (int)cachedLen;\n\n        //    }\n\n        //    if (uncachedLen > 0)\n\n        //    {\n\n        //        int readStreamLen = await s.ReadAsync(cachedMem, cancellationToken);\n\n\n\n        //        int lengthToCache = (int)Math.Min(emptyCacheLen, readStreamLen); // how many data need to cache\n\n        //        if (lengthToCache > 0)\n\n        //        {\n\n        //            uncachedMem[0..lengthToCache].CopyTo(cache[(int)cachePtr..]);\n\n        //            cachePtr += lengthToCache;\n\n        //        }\n\n\n\n        //        readPtr += readStreamLen;\n\n        //        readLen += readStreamLen;\n\n        //    }\n\n        //    return readLen;\n\n        //}\n\n\n\n        [MethodImpl(MethodImplOptions.AggressiveInlining)]\n\n        public override int Read(byte[] buffer, int offset, int count)\n\n        {\n\n            Span<byte> span = buffer.AsSpan(offset, count);\n\n            return Read(span);\n\n        }\n\n\n\n        [MethodImpl(MethodImplOptions.AggressiveOptimization)]\n\n        public override int Read(Span<byte> buffer)\n\n        {\n\n            // how many data from socket\n\n\n\n            // r: readPtr, c: cachePtr, e: endPtr\n\n            // ptr    0   r   c   e \n\n            // cached ####+++++\n\n            // read            ++++\n\n\n\n            // ptr    0   c   r   e \n\n            // cached #####\n\n            // read           +++++\n\n\n\n            var endPtr = buffer.Length + readPtr;               // expected ptr after operation\n\n            var uncachedLen = Math.Max(endPtr - Math.Max(cachePtr, readPtr), 0);\n\n            var cachedLen = buffer.Length - uncachedLen;        // how many data from cache\n\n            var emptyCacheLen = MaxCache - cachePtr;            // how many cache remain\n\n\n\n            int readLen = 0;\n\n\n\n            Span<byte> cachedSpan = buffer[..(int)cachedLen];\n\n            Span<byte> uncachedSpan = buffer[(int)cachedLen..];\n\n            if (cachedLen > 0)\n\n            {\n\n                cache[(int)readPtr..(int)(readPtr + cachedLen)].CopyTo(cachedSpan);\n\n\n\n                readPtr += cachedLen;\n\n                readLen += (int)cachedLen;\n\n            }\n\n            if (uncachedLen > 0)\n\n            {\n\n                int readStreamLen = s.Read(uncachedSpan);\n\n\n\n                // how many data need to cache\n\n                int lengthToCache = (int)Math.Min(emptyCacheLen, readStreamLen);\n\n                if (lengthToCache > 0)\n\n                {\n\n                    uncachedSpan[0..lengthToCache].ToArray().CopyTo(cache, cachePtr);\n\n                    cachePtr += lengthToCache;\n\n                }\n\n\n\n                readPtr += readStreamLen;\n\n                readLen += readStreamLen;\n\n            }\n\n            return readLen;\n\n        }\n\n\n\n        /// <summary>\n\n        /// Read first block, will never read into non-cache range\n\n        /// </summary>\n\n        /// <param name=\"buffer\"></param>\n\n        /// <returns></returns>\n\n        public int ReadFirstBlock(Span<byte> buffer)\n\n        {\n\n            Seek(0, SeekOrigin.Begin);\n\n            int len = Math.Min(MaxCache, buffer.Length);\n\n            return Read(buffer[0..len]);\n\n        }\n\n\n\n        /// <summary>\n\n        /// Seek position, only support seek to cached range when we haven't read into non-cache range\n\n        /// </summary>\n\n        /// <param name=\"offset\"></param>\n\n        /// <param name=\"origin\">Set it to System.IO.SeekOrigin.Begin, otherwise it will throw System.NotSupportedException</param>\n\n        /// <exception cref=\"IOException\"></exception>\n\n        /// <exception cref=\"NotSupportedException\"></exception>\n\n        /// <exception cref=\"ObjectDisposedException\"></exception>\n\n        /// <returns></returns>\n\n        public override long Seek(long offset, SeekOrigin origin)\n\n        {\n\n            if (!CanSeek) throw new NotSupportedException(\"Non cache data has been read\");\n\n            if (origin != SeekOrigin.Begin) throw new NotSupportedException(\"We don't know network stream's length\");\n\n            if (offset < 0 || offset > cachePtr) throw new NotSupportedException(\"Can't seek to uncached position\");\n\n\n\n            readPtr = offset;\n\n            return Position;\n\n        }\n\n\n\n        /// <summary>\n\n        /// Useless\n\n        /// </summary>\n\n        /// <param name=\"value\"></param>\n\n        /// <exception cref=\"NotSupportedException\"></exception>\n\n        public override void SetLength(long value)\n\n        {\n\n            s.SetLength(value);\n\n        }\n\n\n\n        /// <summary>\n\n        /// Write to underly stream\n\n        /// </summary>\n\n        /// <param name=\"buffer\"></param>\n\n        /// <param name=\"offset\"></param>\n\n        /// <param name=\"count\"></param>\n\n        /// <param name=\"cancellationToken\"></param>\n\n        /// <returns></returns>\n\n        public override Task WriteAsync(byte[] buffer, int offset, int count, CancellationToken cancellationToken)\n\n        {\n\n            return s.WriteAsync(buffer, offset, count, cancellationToken);\n\n        }\n\n\n\n        /// <summary>\n\n        /// Write to underly stream\n\n        /// </summary>\n\n        /// <param name=\"buffer\"></param>\n\n        /// <param name=\"offset\"></param>\n\n        /// <param name=\"count\"></param>\n\n        public override void Write(byte[] buffer, int offset, int count)\n\n        {\n\n            s.Write(buffer, offset, count);\n\n        }\n\n\n\n        protected override void Dispose(bool disposing)\n\n        {\n\n            s.Dispose();\n\n            base.Dispose(disposing);\n\n        }\n\n    }\n\n}\n", "using Splat;\n\nusing Shadowsocks.Net.Crypto;\n\nusing Shadowsocks.Net.Crypto.AEAD;\n\nusing Shadowsocks.Net.Proxy;\n\nusing System;\n\nusing System.Buffers;\n\nusing System.Collections.Generic;\n\nusing System.Net;\n\nusing System.Net.Sockets;\n\nusing System.Text;\n\nusing System.Threading;\n\nusing System.Threading.Tasks;\n\n\n\nusing static Shadowsocks.Net.Crypto.CryptoBase;\n\nusing Shadowsocks.Models;\n\n\n\nnamespace Shadowsocks.Net\n\n{\n\n    public class TCPRelay : StreamService, IEnableLogger\n\n    {\n\n        public event EventHandler<SSTCPConnectedEventArgs> OnConnected;\n\n        public event EventHandler<SSTransmitEventArgs> OnInbound;\n\n        public event EventHandler<SSTransmitEventArgs> OnOutbound;\n\n        public event EventHandler<SSRelayEventArgs> OnFailed;\n\n\n\n        private Server _server;\n\n        private DateTime _lastSweepTime;\n\n\n\n        public ISet<TCPHandler> Handlers { get; set; }\n\n\n\n        public TCPRelay(Server server)\n\n        {\n\n            _server = server;\n\n            Handlers = new HashSet<TCPHandler>();\n\n            _lastSweepTime = DateTime.Now;\n\n        }\n\n\n\n        public override bool Handle(CachedNetworkStream stream, object state)\n\n        {\n\n\n\n            byte[] fp = new byte[256];\n\n            int len = stream.ReadFirstBlock(fp);\n\n\n\n            var socket = stream.Socket;\n\n            if (socket.ProtocolType != ProtocolType.Tcp\n\n                || (len < 2 || fp[0] != 5))\n\n                return false;\n\n\n\n\n\n            socket.SetSocketOption(SocketOptionLevel.Tcp, SocketOptionName.NoDelay, true);\n\n\n\n            TCPHandler handler = new TCPHandler(_server, socket);\n\n\n\n            IList<TCPHandler> handlersToClose = new List<TCPHandler>();\n\n            lock (Handlers)\n\n            {\n\n                Handlers.Add(handler);\n\n                DateTime now = DateTime.Now;\n\n                if (now - _lastSweepTime > TimeSpan.FromSeconds(1))\n\n                {\n\n                    _lastSweepTime = now;\n\n                    foreach (TCPHandler handler1 in Handlers)\n\n                        if (now - handler1.lastActivity > TimeSpan.FromSeconds(900))\n\n                            handlersToClose.Add(handler1);\n\n                }\n\n            }\n\n            foreach (TCPHandler handler1 in handlersToClose)\n\n            {\n\n                this.Log().Debug(\"Closing timed out TCP connection.\");\n\n                handler1.Close();\n\n            }\n\n\n\n            /*\n\n             * Start after we put it into Handlers set. Otherwise if it failed in handler.Start()\n\n             * then it will call handler.Close() before we add it into the set.\n\n             * Then the handler will never release until the next Handle call. Sometimes it will\n\n             * cause odd problems (especially during memory profiling).\n\n             */\n\n            // handler.Start(fp, len);\n\n            _ = handler.StartAsync(fp, len);\n\n\n\n            return true;\n\n            // return Handle(fp, len, stream.Socket, state);\n\n        }\n\n\n\n        [Obsolete]\n\n        public override bool Handle(byte[] firstPacket, int length, Socket socket, object state)\n\n        {\n\n            if (socket.ProtocolType != ProtocolType.Tcp\n\n                || (length < 2 || firstPacket[0] != 5))\n\n            {\n\n                return false;\n\n            }\n\n\n\n            socket.SetSocketOption(SocketOptionLevel.Tcp, SocketOptionName.NoDelay, true);\n\n            TCPHandler handler = new TCPHandler(_server, socket);\n\n\n\n            handler.OnConnected += OnConnected;\n\n            handler.OnInbound += OnInbound;\n\n            handler.OnOutbound += OnOutbound;\n\n            handler.OnFailed += OnFailed;\n\n            handler.OnClosed += (h, arg) =>\n\n            {\n\n                lock (Handlers)\n\n                {\n\n                    Handlers.Remove(handler);\n\n                }\n\n            };\n\n\n\n            IList<TCPHandler> handlersToClose = new List<TCPHandler>();\n\n            lock (Handlers)\n\n            {\n\n                Handlers.Add(handler);\n\n                DateTime now = DateTime.Now;\n\n                if (now - _lastSweepTime > TimeSpan.FromSeconds(1))\n\n                {\n\n                    _lastSweepTime = now;\n\n                    foreach (TCPHandler handler1 in Handlers)\n\n                    {\n\n                        if (now - handler1.lastActivity > TimeSpan.FromSeconds(900))\n\n                        {\n\n                            handlersToClose.Add(handler1);\n\n                        }\n\n                    }\n\n                }\n\n            }\n\n            foreach (TCPHandler handler1 in handlersToClose)\n\n            {\n\n                this.Log().Debug(\"Closing timed out TCP connection.\");\n\n                handler1.Close();\n\n            }\n\n\n\n            /*\n\n             * Start after we put it into Handlers set. Otherwise if it failed in handler.Start()\n\n             * then it will call handler.Close() before we add it into the set.\n\n             * Then the handler will never release until the next Handle call. Sometimes it will\n\n             * cause odd problems (especially during memory profiling).\n\n             */\n\n            // handler.Start(firstPacket, length);\n\n            _ = handler.StartAsync(firstPacket, length);\n\n\n\n            return true;\n\n        }\n\n\n\n        public override void Stop()\n\n        {\n\n            List<TCPHandler> handlersToClose = new List<TCPHandler>();\n\n            lock (Handlers)\n\n            {\n\n                handlersToClose.AddRange(Handlers);\n\n            }\n\n            handlersToClose.ForEach(h => h.Close());\n\n        }\n\n    }\n\n\n\n    public class SSRelayEventArgs : EventArgs\n\n    {\n\n        public readonly Server server;\n\n\n\n        public SSRelayEventArgs(Server server)\n\n        {\n\n            this.server = server;\n\n        }\n\n    }\n\n\n\n    public class SSTransmitEventArgs : SSRelayEventArgs\n\n    {\n\n        public readonly long length;\n\n        public SSTransmitEventArgs(Server server, long length) : base(server)\n\n        {\n\n            this.length = length;\n\n        }\n\n    }\n\n\n\n    public class SSTCPConnectedEventArgs : SSRelayEventArgs\n\n    {\n\n        public readonly TimeSpan latency;\n\n\n\n        public SSTCPConnectedEventArgs(Server server, TimeSpan latency) : base(server)\n\n        {\n\n            this.latency = latency;\n\n        }\n\n    }\n\n\n\n    public class TCPHandler : IEnableLogger\n\n    {\n\n        public event EventHandler<SSTCPConnectedEventArgs> OnConnected;\n\n        public event EventHandler<SSTransmitEventArgs> OnInbound;\n\n        public event EventHandler<SSTransmitEventArgs> OnOutbound;\n\n        public event EventHandler<SSRelayEventArgs> OnClosed;\n\n        public event EventHandler<SSRelayEventArgs> OnFailed;\n\n\n\n        private readonly int _serverTimeout;\n\n        private readonly int _proxyTimeout;\n\n\n\n        private readonly MemoryPool<byte> pool = MemoryPool<byte>.Shared;\n\n        // each recv size.\n\n        public const int RecvSize = 16384;\n\n\n\n        // overhead of one chunk, reserved for AEAD ciphers\n\n        public const int ChunkOverheadSize = 100;//16 * 2 /* two tags */ + AEADEncryptor.ChunkLengthBytes;\n\n\n\n        // In general, the ciphertext length, we should take overhead into account\n\n        public const int SendSize = 32768;\n\n\n\n        public DateTime lastActivity;\n\n\n\n        // TODO: forward proxy\n\n        //private readonly ForwardProxyConfig _config;\n\n        private readonly Server _server;\n\n        private readonly Socket _connection;\n\n        private IProxy _remote;\n\n        private ICrypto encryptor;\n\n        // workaround\n\n        private ICrypto decryptor;\n\n\n\n        private byte[] _firstPacket;\n\n        private int _firstPacketLength;\n\n\n\n        private const int CMD_CONNECT = 0x01;\n\n        private const int CMD_BIND = 0x02;\n\n        private const int CMD_UDP_ASSOC = 0x03;\n\n\n\n        private bool _closed = false;\n\n\n\n        // instance-based lock without static\n\n        private readonly object _encryptionLock = new object();\n\n        private readonly object _decryptionLock = new object();\n\n        private readonly object _closeConnLock = new object();\n\n\n\n        // TODO: decouple controller\n\n        public TCPHandler(Server server, Socket socket)\n\n        {\n\n            _server = server;\n\n            _connection = socket;\n\n            _proxyTimeout = 5000;\n\n            _serverTimeout = 5000;\n\n\n\n            lastActivity = DateTime.Now;\n\n        }\n\n\n\n        public void CreateRemote(EndPoint destination)\n\n        {\n\n            if (_server == null || _server.Host == \"\")\n\n            {\n\n                throw new ArgumentException(\"No server configured\");\n\n            }\n\n\n\n            encryptor = CryptoFactory.GetEncryptor(_server.Method, _server.Password);\n\n            decryptor = CryptoFactory.GetEncryptor(_server.Method, _server.Password);\n\n        }\n\n\n\n        public async Task StartAsync(byte[] firstPacket, int length)\n\n        {\n\n            _firstPacket = firstPacket;\n\n            _firstPacketLength = length;\n\n            (int cmd, EndPoint dst) = await Socks5Handshake();\n\n            if (cmd == CMD_CONNECT)\n\n            {\n\n                await ConnectRemote(dst);\n\n                await SendAddress(dst);\n\n                await Forward();\n\n            }\n\n            else if (cmd == CMD_UDP_ASSOC)\n\n            {\n\n                await DrainConnection();\n\n            }\n\n        }\n\n\n\n        private void ErrorClose(Exception e)\n\n        {\n\n            this.Log().Error(e, \"\");\n\n            Close();\n\n        }\n\n\n\n        public void Close()\n\n        {\n\n            lock (_closeConnLock)\n\n            {\n\n                if (_closed)\n\n                {\n\n                    return;\n\n                }\n\n\n\n                _closed = true;\n\n            }\n\n\n\n            OnClosed?.Invoke(this, new SSRelayEventArgs(_server));\n\n\n\n            try\n\n            {\n\n                _connection.Shutdown(SocketShutdown.Both);\n\n                _connection.Close();\n\n\n\n                encryptor?.Dispose();\n\n                decryptor?.Dispose();\n\n            }\n\n            catch (Exception e)\n\n            {\n\n                this.Log().Error(e, \"\");\n\n            }\n\n        }\n\n\n\n        async Task<(int cmd, EndPoint destination)> Socks5Handshake()\n\n        {\n\n            // not so strict here\n\n            // 5 2 1 2 should return 5 255\n\n            // 5 1 0 5 / 1 0 1 127 0 0 1 0 80 will cause handshake fail\n\n\n\n            int bytesRead = _firstPacketLength;\n\n            if (bytesRead <= 1)\n\n            {\n\n                Close();\n\n                return (0, default);\n\n            }\n\n\n\n            byte[] response = { 5, 0 };\n\n            if (_firstPacket[0] != 5)\n\n            {\n\n                // reject socks 4\n\n                response = new byte[] { 0, 91 };\n\n                this.Log().Error(\"socks5 protocol error\");\n\n            }\n\n            await _connection.SendAsync(response, SocketFlags.None);\n\n\n\n            using var bufOwner = pool.Rent(512);\n\n            var buf = bufOwner.Memory;\n\n\n\n            if (await _connection.ReceiveAsync(buf.Slice(0, 5), SocketFlags.None) != 5)\n\n            {\n\n                Close();\n\n                return (0, default);\n\n            }\n\n\n\n            var cmd = buf.Span[1];\n\n            EndPoint dst = default;\n\n            switch (cmd)\n\n            {\n\n                case CMD_CONNECT:\n\n                    await _connection.SendAsync(new byte[] { 5, 0, 0, 1, 0, 0, 0, 0, 0, 0 }, SocketFlags.None);\n\n                    dst = await ReadAddress(buf);\n\n                    // start forward\n\n                    break;\n\n                case CMD_UDP_ASSOC:\n\n                    dst = await ReadAddress(buf);\n\n                    await SendUdpAssociate();\n\n                    // drain\n\n                    break;\n\n                default:\n\n                    Close();\n\n                    break;\n\n            }\n\n            return (cmd, dst);\n\n        }\n\n\n\n        async Task DrainConnection()\n\n        {\n\n            if (_closed)\n\n            {\n\n                return;\n\n            }\n\n            using var b = pool.Rent(512);\n\n            try\n\n            {\n\n                int l;\n\n                do\n\n                {\n\n                    l = await _connection.ReceiveAsync(b.Memory, SocketFlags.None);\n\n                }\n\n                while (l > 0);\n\n\n\n                Close();\n\n            }\n\n            catch (Exception e)\n\n            {\n\n                ErrorClose(e);\n\n            }\n\n        }\n\n\n\n        private async Task<EndPoint> ReadAddress(Memory<byte> buf)\n\n        {\n\n            var atyp = buf.Span[3];\n\n            var maybeDomainLength = buf.Span[4];\n\n            buf.Span[0] = atyp;\n\n            buf.Span[1] = maybeDomainLength;\n\n\n\n            int toRead = atyp switch\n\n            {\n\n                ATYP_IPv4 => 4,\n\n                ATYP_IPv6 => 16,\n\n                ATYP_DOMAIN => maybeDomainLength + 1,\n\n                _ => throw new NotSupportedException(),\n\n            } + 2 - 1;\n\n            await _connection.ReceiveAsync(buf.Slice(2, toRead), SocketFlags.None);\n\n\n\n            return GetSocks5EndPoint(buf.ToArray());\n\n        }\n\n\n\n        private int ReadPort(byte[] arr, long offset)\n\n        {\n\n            return (arr[offset] << 8) + arr[offset + 1];\n\n        }\n\n\n\n        private EndPoint GetSocks5EndPoint(byte[] buf)\n\n        {\n\n            int maybeDomainLength = buf[1] + 2;\n\n\n\n            return (buf[0]) switch\n\n            {\n\n                ATYP_IPv4 => new IPEndPoint(new IPAddress(buf[1..5]), ReadPort(buf, 5)),\n\n                ATYP_IPv6 => new IPEndPoint(new IPAddress(buf[1..17]), ReadPort(buf, 17)),\n\n                ATYP_DOMAIN => new DnsEndPoint(Encoding.ASCII.GetString(buf[2..maybeDomainLength]), ReadPort(buf, maybeDomainLength)),\n\n                _ => throw new NotSupportedException(),\n\n            };\n\n        }\n\n\n\n        private async Task SendUdpAssociate()\n\n        {\n\n            IPEndPoint endPoint = (IPEndPoint)_connection.LocalEndPoint;\n\n            byte[] address = endPoint.Address.GetAddressBytes();\n\n            int port = endPoint.Port;\n\n            byte[] response = new byte[4 + address.Length + ADDR_PORT_LEN];\n\n            response[0] = 5;\n\n            switch (endPoint.AddressFamily)\n\n            {\n\n                case AddressFamily.InterNetwork:\n\n                    response[3] = ATYP_IPv4;\n\n                    break;\n\n                case AddressFamily.InterNetworkV6:\n\n                    response[3] = ATYP_IPv6;\n\n                    break;\n\n            }\n\n            address.CopyTo(response, 4);\n\n            response[^1] = (byte)(port & 0xFF);\n\n            response[^2] = (byte)((port >> 8) & 0xFF);\n\n            await _connection.SendAsync(response, SocketFlags.None);\n\n        }\n\n\n\n        private async Task ConnectRemote(EndPoint destination)\n\n        {\n\n            CreateRemote(destination);\n\n            IProxy remote;\n\n            EndPoint proxyEP = null;\n\n            EndPoint serverEP = new DnsEndPoint(_server.Host, _server.Port);\n\n            EndPoint pluginEP = null; // TODO: plugin local end point\n\n\n\n            remote = new DirectConnect(); // TODO: forward proxy\n\n            NetworkCredential auth = null;\n\n            /*if (_config.useAuth)\n\n            {\n\n                auth = new NetworkCredential(_config.authUser, _config.authPwd);\n\n            }\n\n            if (pluginEP != null)\n\n            {\n\n                serverEP = pluginEP;\n\n                remote = new DirectConnect();\n\n            }\n\n            else if (_config.useProxy)\n\n            {\n\n                remote = _config.proxyType switch\n\n                {\n\n                    ForwardProxyConfig.PROXY_SOCKS5 => new Socks5Proxy(),\n\n                    ForwardProxyConfig.PROXY_HTTP => new HttpProxy(),\n\n                    _ => throw new NotSupportedException(\"Unknown forward proxy.\"),\n\n                };\n\n                proxyEP = new DnsEndPoint(_config.proxyServer, _config.proxyPort);\n\n            }\n\n            else\n\n            {\n\n                remote = new DirectConnect();\n\n            }*/\n\n\n\n            CancellationTokenSource cancelProxy = new CancellationTokenSource(_proxyTimeout * 1000);\n\n\n\n            await remote.ConnectProxyAsync(proxyEP, auth, cancelProxy.Token);\n\n            _remote = remote;\n\n\n\n            if (!(remote is DirectConnect))\n\n            {\n\n                this.Log().Debug($\"Socket connected to proxy {remote.ProxyEndPoint}\");\n\n            }\n\n\n\n            var _startConnectTime = DateTime.Now;\n\n            CancellationTokenSource cancelServer = new CancellationTokenSource(_serverTimeout * 1000);\n\n            await remote.ConnectRemoteAsync(serverEP, cancelServer.Token);\n\n            this.Log().Debug($\"Socket connected to ss server: {_server}\");\n\n            TimeSpan latency = DateTime.Now - _startConnectTime;\n\n            OnConnected?.Invoke(this, new SSTCPConnectedEventArgs(_server, latency));\n\n\n\n        }\n\n\n\n        private async Task SendAddress(EndPoint dest)\n\n        {\n\n            byte[] dstByte = GetSocks5EndPointByte(dest);\n\n            using var t = pool.Rent(512);\n\n            try\n\n            {\n\n                int addrlen = encryptor.Encrypt(dstByte, t.Memory.Span);\n\n                await _remote.SendAsync(t.Memory.Slice(0, addrlen));\n\n            }\n\n            catch (Exception e)\n\n            {\n\n                ErrorClose(e);\n\n            }\n\n        }\n\n\n\n        private byte[] GetSocks5EndPointByte(EndPoint dest)\n\n        {\n\n            if (dest is DnsEndPoint d)\n\n            {\n\n                byte[] r = new byte[d.Host.Length + 4];\n\n                r[0] = 3;\n\n                r[1] = (byte)d.Host.Length;\n\n                Encoding.ASCII.GetBytes(d.Host, r.AsSpan(2));\n\n                r[^2] = (byte)(d.Port / 256);\n\n                r[^1] = (byte)(d.Port % 256);\n\n                return r;\n\n            }\n\n            else if (dest is IPEndPoint i)\n\n            {\n\n                if (i.AddressFamily == AddressFamily.InterNetwork)\n\n                {\n\n                    byte[] r = new byte[7];\n\n                    r[0] = 1;\n\n                    i.Address.GetAddressBytes().CopyTo(r, 1);\n\n                    r[^2] = (byte)(i.Port / 256);\n\n                    r[^1] = (byte)(i.Port % 256);\n\n                    return r;\n\n                }\n\n                else if (i.AddressFamily == AddressFamily.InterNetworkV6)\n\n                {\n\n                    byte[] r = new byte[19];\n\n                    r[0] = 1;\n\n                    i.Address.GetAddressBytes().CopyTo(r, 1);\n\n                    r[^2] = (byte)(i.Port / 256);\n\n                    r[^1] = (byte)(i.Port % 256);\n\n                    return r;\n\n                }\n\n            }\n\n            throw new NotImplementedException();\n\n        }\n\n\n\n        private async Task Forward()\n\n        {\n\n            try\n\n            {\n\n                await Task.WhenAll(ForwardInbound(), ForwardOutbound());\n\n                Close();\n\n            }\n\n            catch (Exception e)\n\n            {\n\n                ErrorClose(e);\n\n            }\n\n        }\n\n\n\n        private async Task ForwardInbound()\n\n        {\n\n            using var cipherOwner = pool.Rent(RecvSize);\n\n            using var plainOwner = pool.Rent(SendSize);\n\n            var plain = plainOwner.Memory;\n\n            var cipher = cipherOwner.Memory;\n\n            try\n\n            {\n\n\n\n                while (true)\n\n                {\n\n                    int len = await _remote.ReceiveAsync(cipher);\n\n                    if (len == 0) break;\n\n                    int plen = decryptor.Decrypt(plain.Span, cipher.Span.Slice(0, len));\n\n                    if (plen == 0) continue;\n\n                    int len2 = await _connection.SendAsync(plain.Slice(0, plen), SocketFlags.None);\n\n                    if (len2 == 0) break;\n\n                    OnInbound?.Invoke(this, new SSTransmitEventArgs(_server, plen));\n\n                }\n\n            }\n\n            catch (Exception e)\n\n            {\n\n                ErrorClose(e);\n\n            }\n\n        }\n\n\n\n        private async Task ForwardOutbound()\n\n        {\n\n            using var plainOwner = pool.Rent(RecvSize);\n\n            using var cipherOwner = pool.Rent(SendSize);\n\n            var plain = plainOwner.Memory;\n\n            var cipher = cipherOwner.Memory;\n\n            while (true)\n\n            {\n\n                int len = await _connection.ReceiveAsync(plain, SocketFlags.None);\n\n\n\n                if (len == 0) break;\n\n                int clen = encryptor.Encrypt(plain.Span.Slice(0, len), cipher.Span);\n\n                int len2 = await _remote.SendAsync(cipher.Slice(0, clen));\n\n                if (len2 == 0) break;\n\n                OnOutbound?.Invoke(this, new SSTransmitEventArgs(_server, len));\n\n            }\n\n            _remote.Shutdown(SocketShutdown.Send);\n\n        }\n\n    }\n\n}", "using Shadowsocks.Models;\n\nusing Shadowsocks.Net.Crypto;\n\nusing Splat;\n\nusing System;\n\nusing System.Buffers;\n\nusing System.Collections.Generic;\n\nusing System.Net;\n\nusing System.Net.Sockets;\n\nusing System.Runtime.CompilerServices;\n\nusing System.Runtime.InteropServices;\n\nusing System.Threading.Tasks;\n\n\n\nnamespace Shadowsocks.Net\n\n{\n\n    public class UDPRelay : DatagramService\n\n    {\n\n        Server _server;\n\n        // TODO: choose a smart number\n\n        private LRUCache<IPEndPoint, UDPHandler> _cache = new LRUCache<IPEndPoint, UDPHandler>(512);\n\n\n\n        public long outbound = 0;\n\n        public long inbound = 0;\n\n\n\n        public UDPRelay(Server server)\n\n        {\n\n            _server = server;\n\n        }\n\n\n\n        public override async Task<bool> Handle(Memory<byte> packet, Socket socket, EndPoint client)\n\n        {\n\n            if (socket.ProtocolType != ProtocolType.Udp)\n\n            {\n\n                return false;\n\n            }\n\n            if (packet.Length < 4)\n\n            {\n\n                return false;\n\n            }\n\n            IPEndPoint remoteEndPoint = (IPEndPoint)client;\n\n            UDPHandler handler = _cache.get(remoteEndPoint);\n\n            if (handler == null)\n\n            {\n\n                handler = new UDPHandler(socket, _server, remoteEndPoint);\n\n                handler.Receive();\n\n                _cache.add(remoteEndPoint, handler);\n\n            }\n\n            await handler.SendAsync(packet);\n\n            return true;\n\n        }\n\n\n\n        public class UDPHandler : IEnableLogger\n\n        {\n\n            private static MemoryPool<byte> pool = MemoryPool<byte>.Shared;\n\n            private Socket _local;\n\n            private Socket _remote;\n\n\n\n            private Server _server;\n\n            private byte[] _buffer = new byte[65536];\n\n\n\n            private IPEndPoint _localEndPoint;\n\n            private IPEndPoint _remoteEndPoint;\n\n\n\n            private IPAddress ListenAddress\n\n            {\n\n                get\n\n                {\n\n                    return _remote.AddressFamily switch\n\n                    {\n\n                        AddressFamily.InterNetwork => IPAddress.Any,\n\n                        AddressFamily.InterNetworkV6 => IPAddress.IPv6Any,\n\n                        _ => throw new NotSupportedException(),\n\n                    };\n\n                }\n\n            }\n\n\n\n            public UDPHandler(Socket local, Server server, IPEndPoint localEndPoint)\n\n            {\n\n                _local = local;\n\n                _server = server;\n\n                _localEndPoint = localEndPoint;\n\n\n\n                // TODO async resolving\n\n                bool parsed = IPAddress.TryParse(server.Host, out IPAddress ipAddress);\n\n                if (!parsed)\n\n                {\n\n                    IPHostEntry ipHostInfo = Dns.GetHostEntry(server.Host);\n\n                    ipAddress = ipHostInfo.AddressList[0];\n\n                }\n\n                _remoteEndPoint = new IPEndPoint(ipAddress, server.Port);\n\n                _remote = new Socket(_remoteEndPoint.AddressFamily, SocketType.Dgram, ProtocolType.Udp);\n\n                _remote.Bind(new IPEndPoint(ListenAddress, 0));\n\n            }\n\n\n\n            public async Task SendAsync(ReadOnlyMemory<byte> data)\n\n            {\n\n                using ICrypto encryptor = CryptoFactory.GetEncryptor(_server.Method, _server.Password);\n\n                using IMemoryOwner<byte> mem = pool.Rent(data.Length + 1000);\n\n\n\n                // byte[] dataOut = new byte[slicedData.Length + 1000];\n\n                int outlen = encryptor.EncryptUDP(data.Span[3..], mem.Memory.Span);\n\n                this.Log().Debug($\"{_localEndPoint} {_remoteEndPoint} {outlen} UDP Relay up\");\n\n                if (!MemoryMarshal.TryGetArray(mem.Memory[..outlen], out ArraySegment<byte> outData))\n\n                {\n\n                    throw new InvalidOperationException(\"Can't extract underly array segment\");\n\n                };\n\n                await _remote?.SendToAsync(outData, SocketFlags.None, _remoteEndPoint);\n\n            }\n\n\n\n            public async Task ReceiveAsync()\n\n            {\n\n                EndPoint remoteEndPoint = new IPEndPoint(ListenAddress, 0);\n\n                this.Log().Debug($\"++++++Receive Server Port, size:\" + _buffer.Length);\n\n                try\n\n                {\n\n                    while (true)\n\n                    {\n\n                        var result = await _remote.ReceiveFromAsync(_buffer, SocketFlags.None, remoteEndPoint);\n\n                        int bytesRead = result.ReceivedBytes;\n\n\n\n                        using IMemoryOwner<byte> owner = pool.Rent(bytesRead + 3);\n\n                        Memory<byte> o = owner.Memory;\n\n\n\n                        using ICrypto encryptor = CryptoFactory.GetEncryptor(_server.Method, _server.Password);\n\n                        int outlen = encryptor.DecryptUDP(o.Span[3..], _buffer.AsSpan(0, bytesRead));\n\n                        this.Log().Debug($\"{_remoteEndPoint} {_localEndPoint} {outlen} UDP Relay down\");\n\n                        if (!MemoryMarshal.TryGetArray(o[..(outlen + 3)], out ArraySegment<byte> data))\n\n                        {\n\n                            throw new InvalidOperationException(\"Can't extract underly array segment\");\n\n                        };\n\n                        await _local?.SendToAsync(data, SocketFlags.None, _localEndPoint);\n\n\n\n                    }\n\n                }\n\n                catch (Exception e)\n\n                {\n\n                    this.Log().Warn(e, \"\");\n\n                }\n\n            }\n\n\n\n            public void Receive()\n\n            {\n\n                _ = ReceiveAsync();\n\n            }\n\n\n\n            public void Close()\n\n            {\n\n                try\n\n                {\n\n                    _remote?.Close();\n\n                }\n\n                catch (ObjectDisposedException)\n\n                {\n\n                    // TODO: handle the ObjectDisposedException\n\n                }\n\n                catch (Exception)\n\n                {\n\n                    // TODO: need more think about handle other Exceptions, or should remove this catch().\n\n                }\n\n            }\n\n        }\n\n    }\n\n\n\n    #region LRU cache\n\n\n\n    // cc by-sa 3.0 http://stackoverflow.com/a/3719378/1124054\n\n    class LRUCache<K, V> where V : UDPRelay.UDPHandler\n\n    {\n\n        private int capacity;\n\n        private Dictionary<K, LinkedListNode<LRUCacheItem<K, V>>> cacheMap = new Dictionary<K, LinkedListNode<LRUCacheItem<K, V>>>();\n\n        private LinkedList<LRUCacheItem<K, V>> lruList = new LinkedList<LRUCacheItem<K, V>>();\n\n\n\n        public LRUCache(int capacity)\n\n        {\n\n            this.capacity = capacity;\n\n        }\n\n\n\n        [MethodImpl(MethodImplOptions.Synchronized)]\n\n        public V get(K key)\n\n        {\n\n            LinkedListNode<LRUCacheItem<K, V>> node;\n\n            if (cacheMap.TryGetValue(key, out node))\n\n            {\n\n                V value = node.Value.value;\n\n                lruList.Remove(node);\n\n                lruList.AddLast(node);\n\n                return value;\n\n            }\n\n            return default(V);\n\n        }\n\n\n\n        [MethodImpl(MethodImplOptions.Synchronized)]\n\n        public void add(K key, V val)\n\n        {\n\n            if (cacheMap.Count >= capacity)\n\n            {\n\n                RemoveFirst();\n\n            }\n\n\n\n            LRUCacheItem<K, V> cacheItem = new LRUCacheItem<K, V>(key, val);\n\n            LinkedListNode<LRUCacheItem<K, V>> node = new LinkedListNode<LRUCacheItem<K, V>>(cacheItem);\n\n            lruList.AddLast(node);\n\n            cacheMap.Add(key, node);\n\n        }\n\n\n\n        private void RemoveFirst()\n\n        {\n\n            // Remove from LRUPriority\n\n            LinkedListNode<LRUCacheItem<K, V>> node = lruList.First;\n\n            lruList.RemoveFirst();\n\n\n\n            // Remove from cache\n\n            cacheMap.Remove(node.Value.key);\n\n            node.Value.value.Close();\n\n        }\n\n    }\n\n\n\n    class LRUCacheItem<K, V>\n\n    {\n\n        public LRUCacheItem(K k, V v)\n\n        {\n\n            key = k;\n\n            value = v;\n\n        }\n\n        public K key;\n\n        public V value;\n\n    }\n\n\n\n    #endregion\n\n}\n", "using Splat;\n\nusing System;\n\nusing System.Collections.Generic;\n\nusing System.Linq;\n\nusing System.Net;\n\nusing System.Net.NetworkInformation;\n\nusing System.Net.Sockets;\n\n\n\nnamespace Shadowsocks.Net\n\n{\n\n    public interface IStreamService\n\n    {\n\n        [Obsolete]\n\n        bool Handle(byte[] firstPacket, int length, Socket socket, object state);\n\n\n\n        public abstract bool Handle(CachedNetworkStream stream, object state);\n\n\n\n        void Stop();\n\n    }\n\n\n\n    public abstract class StreamService : IStreamService\n\n    {\n\n        [Obsolete]\n\n        public abstract bool Handle(byte[] firstPacket, int length, Socket socket, object state);\n\n\n\n        public abstract bool Handle(CachedNetworkStream stream, object state);\n\n\n\n        public virtual void Stop() { }\n\n    }\n\n\n\n    public class TCPListener : IEnableLogger\n\n    {\n\n        public class UDPState\n\n        {\n\n            public UDPState(Socket s)\n\n            {\n\n                socket = s;\n\n                remoteEndPoint = new IPEndPoint(s.AddressFamily == AddressFamily.InterNetworkV6 ? IPAddress.IPv6Any : IPAddress.Any, 0);\n\n            }\n\n            public Socket socket;\n\n            public byte[] buffer = new byte[4096];\n\n            public EndPoint remoteEndPoint;\n\n        }\n\n\n\n        IPEndPoint _localEndPoint;\n\n        Socket _tcpSocket;\n\n        IEnumerable<IStreamService> _services;\n\n\n\n        public TCPListener(IPEndPoint localEndPoint, IEnumerable<IStreamService> services)\n\n        {\n\n            _localEndPoint = localEndPoint;\n\n            _services = services;\n\n        }\n\n\n\n        private bool CheckIfPortInUse(int port)\n\n        {\n\n            IPGlobalProperties ipProperties = IPGlobalProperties.GetIPGlobalProperties();\n\n            return ipProperties.GetActiveTcpListeners().Any(endPoint => endPoint.Port == port);\n\n        }\n\n\n\n        public void Start()\n\n        {\n\n            if (CheckIfPortInUse(_localEndPoint.Port))\n\n                throw new Exception($\"Port {_localEndPoint.Port} already in use\");\n\n\n\n            try\n\n            {\n\n                // Create a TCP/IP socket.\n\n                _tcpSocket = new Socket(_localEndPoint.AddressFamily, SocketType.Stream, ProtocolType.Tcp);\n\n                _tcpSocket.SetSocketOption(SocketOptionLevel.Socket, SocketOptionName.ReuseAddress, true);\n\n                _tcpSocket.SetSocketOption(SocketOptionLevel.IPv6, SocketOptionName.IPv6Only, false);\n\n\n\n                // Bind the socket to the local endpoint and listen for incoming connections.\n\n                _tcpSocket.Bind(_localEndPoint);\n\n                _tcpSocket.Listen(1024);\n\n\n\n                // Start an asynchronous socket to listen for connections.\n\n                this.Log().Info($\"Shadowsocks started TCP\");\n\n                this.Log().Debug(Crypto.CryptoFactory.DumpRegisteredEncryptor());\n\n                _tcpSocket.BeginAccept(new AsyncCallback(AcceptCallback), _tcpSocket);\n\n            }\n\n            catch (SocketException)\n\n            {\n\n                _tcpSocket.Close();\n\n                throw;\n\n            }\n\n        }\n\n\n\n        public void Stop()\n\n        {\n\n            _tcpSocket?.Close();\n\n\n\n            foreach (IStreamService s in _services)\n\n            {\n\n                s.Stop();\n\n            }\n\n        }\n\n\n\n        public void AcceptCallback(IAsyncResult ar)\n\n        {\n\n            Socket listener = (Socket)ar.AsyncState;\n\n            try\n\n            {\n\n                Socket conn = listener.EndAccept(ar);\n\n\n\n                byte[] buf = new byte[4096];\n\n                object[] state = new object[] {\n\n                    conn,\n\n                    buf\n\n                };\n\n\n\n                conn.BeginReceive(buf, 0, buf.Length, 0,\n\n                    new AsyncCallback(ReceiveCallback), state);\n\n            }\n\n            catch (ObjectDisposedException)\n\n            {\n\n            }\n\n            catch (Exception e)\n\n            {\n\n                this.Log().Error(e, \"\");\n\n            }\n\n            finally\n\n            {\n\n                try\n\n                {\n\n                    listener.BeginAccept(\n\n                        new AsyncCallback(AcceptCallback),\n\n                        listener);\n\n                }\n\n                catch (ObjectDisposedException)\n\n                {\n\n                    // do nothing\n\n                }\n\n                catch (Exception e)\n\n                {\n\n                    this.Log().Error(e, \"\");\n\n                }\n\n            }\n\n        }\n\n\n\n        private void ReceiveCallback(IAsyncResult ar)\n\n        {\n\n            object[] state = (object[])ar.AsyncState;\n\n\n\n            Socket conn = (Socket)state[0];\n\n            byte[] buf = (byte[])state[1];\n\n            try\n\n            {\n\n                int bytesRead = conn.EndReceive(ar);\n\n                if (bytesRead <= 0)\n\n                {\n\n                    goto Shutdown;\n\n                }\n\n\n\n                foreach (IStreamService service in _services)\n\n                {\n\n                    if (service.Handle(buf, bytesRead, conn, null))\n\n                    {\n\n                        return;\n\n                    }\n\n                }\n\n            Shutdown:\n\n                // no service found for this\n\n                if (conn.ProtocolType == ProtocolType.Tcp)\n\n                {\n\n                    conn.Close();\n\n                }\n\n            }\n\n            catch (Exception e)\n\n            {\n\n                this.Log().Error(e, \"\");\n\n                conn.Close();\n\n            }\n\n        }\n\n    }\n\n}\n", "using System;\n\nusing System.Collections.Generic;\n\nusing System.Linq;\n\nusing System.Text;\n\nusing System.Threading.Tasks;\n\n\n\nnamespace Shadowsocks.Net.Settings\n\n{\n\n    public class ForwardProxySettings\n\n    {\n\n        public bool NoProxy { get; set; }\n\n        public bool UseSocks5Proxy { get; set; }\n\n        public bool UseHttpProxy { get; set; }\n\n        public string Address { get; set; }\n\n        public int Port { get; set; }\n\n        public string Username { get; set; }\n\n        public string Password { get; set; }\n\n\n\n        public ForwardProxySettings()\n\n        {\n\n            NoProxy = true;\n\n            UseSocks5Proxy = false;\n\n            UseHttpProxy = false;\n\n            Address = \"\";\n\n            Port = 1088;\n\n            Username = \"\";\n\n            Password = \"\";\n\n        }\n\n    }\n\n}\n", "using System;\n\nusing System.Collections.Generic;\n\nusing System.Text;\n\n\n\nnamespace Shadowsocks.Net.Settings\n\n{\n\n    public class NetSettings\n\n    {\n\n        public bool EnableSocks5 { get; set; }\n\n        public bool EnableHttp { get; set; }\n\n        public string Socks5ListeningAddress { get; set; }\n\n        public string HttpListeningAddress { get; set; }\n\n        public int Socks5ListeningPort { get; set; }\n\n        public int HttpListeningPort { get; set; }\n\n\n\n        public ForwardProxySettings ForwardProxy { get; set; }\n\n        \n\n        public NetSettings()\n\n        {\n\n            EnableSocks5 = true;\n\n            EnableHttp = true;\n\n            Socks5ListeningAddress = \"::1\";\n\n            HttpListeningAddress = \"::1\";\n\n            Socks5ListeningPort = 1080;\n\n            HttpListeningPort = 1080;\n\n\n\n            ForwardProxy = new ForwardProxySettings();\n\n        }\n\n    }\n\n}\n", "using CryptoBase.Digests.MD5;\n\n\n\nnamespace Shadowsocks.Net.Crypto\n\n{\n\n    public static class CryptoUtils\n\n    {\n\n        public static byte[] MD5(byte[] b)\n\n        {\n\n            var hash = new byte[CryptoBase.MD5Length];\n\n            MD5Utils.Default(b, hash);\n\n            return hash;\n\n        }\n\n    }\n\n}\n", "using System;\n\nusing System.Collections.Generic;\n\nusing System.Reflection;\n\nusing System.Text;\n\n\n\nusing Shadowsocks.Net.Crypto.AEAD;\n\nusing Shadowsocks.Net.Crypto.Stream;\n\n\n\nnamespace Shadowsocks.Net.Crypto\n\n{\n\n    public static class CryptoFactory\n\n    {\n\n        public static string DefaultCipher = \"chacha20-ietf-poly1305\";\n\n\n\n        private static readonly Dictionary<string, Type> _registeredEncryptors = new Dictionary<string, Type>();\n\n        private static readonly Dictionary<string, CipherInfo> ciphers = new Dictionary<string, CipherInfo>();\n\n        private static readonly Type[] ConstructorTypes = { typeof(string), typeof(string) };\n\n\n\n        static CryptoFactory()\n\n        {\n\n            foreach (var method in StreamPlainNativeCrypto.SupportedCiphers())\n\n            {\n\n                if (!_registeredEncryptors.ContainsKey(method.Key))\n\n                {\n\n                    ciphers.Add(method.Key, method.Value);\n\n                    _registeredEncryptors.Add(method.Key, typeof(StreamPlainNativeCrypto));\n\n                }\n\n            }\n\n\n\n            foreach (var method in StreamCryptoBaseCrypto.SupportedCiphers())\n\n            {\n\n                if (!_registeredEncryptors.ContainsKey(method.Key))\n\n                {\n\n                    ciphers.Add(method.Key, method.Value);\n\n                    _registeredEncryptors.Add(method.Key, typeof(StreamCryptoBaseCrypto));\n\n                }\n\n            }\n\n\n\n            foreach (var method in AEADCryptoBaseCrypto.SupportedCiphers())\n\n            {\n\n                if (!_registeredEncryptors.ContainsKey(method.Key))\n\n                {\n\n                    ciphers.Add(method.Key, method.Value);\n\n                    _registeredEncryptors.Add(method.Key, typeof(AEADCryptoBaseCrypto));\n\n                }\n\n            }\n\n        }\n\n\n\n        public static ICrypto GetEncryptor(string method, string password)\n\n        {\n\n            if (string.IsNullOrEmpty(method))\n\n            {\n\n                // todo\n\n                //method = IoCManager.Container.Resolve<IDefaultCrypto>().GetDefaultMethod();\n\n            }\n\n\n\n            method = method.ToLowerInvariant();\n\n            bool ok = _registeredEncryptors.TryGetValue(method, out Type t);\n\n            if (!ok)\n\n            {\n\n                t = _registeredEncryptors[DefaultCipher];\n\n            }\n\n\n\n            ConstructorInfo c = t?.GetConstructor(ConstructorTypes) ??\n\n                throw new TypeLoadException(\"can't load constructor\");\n\n            if (c == null) throw new System.Exception(\"Invalid ctor\");\n\n            ICrypto result = (ICrypto)c.Invoke(new object[] { method, password });\n\n            return result;\n\n        }\n\n\n\n        public static string DumpRegisteredEncryptor()\n\n        {\n\n            var sb = new StringBuilder();\n\n            sb.Append(Environment.NewLine);\n\n            sb.AppendLine(\"-------------------------\");\n\n            sb.AppendLine(\"Registered Encryptor Info\");\n\n            foreach (var encryptor in _registeredEncryptors)\n\n            {\n\n                sb.AppendLine($\"{ciphers[encryptor.Key].ToString(true)} => {encryptor.Value.Name}\");\n\n            }\n\n            // use ----- instead of =======, so when user paste it to Github, it won't became title\n\n            sb.AppendLine(\"-------------------------\");\n\n            return sb.ToString();\n\n        }\n\n\n\n        public static CipherInfo GetCipherInfo(string name)\n\n        {\n\n            // TODO: Replace cipher when required not exist\n\n            return ciphers[name];\n\n        }\n\n\n\n        public static IEnumerable<CipherInfo> ListAvaliableCiphers()\n\n        {\n\n            return ciphers.Values;\n\n        }\n\n    }\n\n}\n", "using System;\n\n\n\nnamespace Shadowsocks.Net.Crypto\n\n{\n\n    public interface ICrypto : IDisposable\n\n    {\n\n        int Encrypt(ReadOnlySpan<byte> plain, Span<byte> cipher);\n\n        int Decrypt(Span<byte> plain, ReadOnlySpan<byte> cipher);\n\n        int EncryptUDP(ReadOnlySpan<byte> plain, Span<byte> cipher);\n\n        int DecryptUDP(Span<byte> plain, ReadOnlySpan<byte> cipher);\n\n    }\n\n}\n", "namespace Shadowsocks.Net.Crypto\n\n{\n\n    public enum CipherFamily\n\n    {\n\n        Plain,\n\n        Table,\n\n\n\n        AesGcm,\n\n\n\n        AesCfb,\n\n        AesCtr,\n\n\n\n        Chacha20,\n\n        Chacha20Poly1305,\n\n        XChacha20Poly1305,\n\n\n\n        Rc4,\n\n        Rc4Md5,\n\n    }\n\n\n\n    public enum CipherStandardState\n\n    {\n\n        InUse,\n\n        Deprecated, // popup warning when updated\n\n        Hidden,     // enabled by hidden flag in config file\n\n\n\n        Unstable,   // not in standard list or wip, only gui info\n\n    }\n\n\n\n    public class CipherParameter\n\n    {\n\n        public int KeySize;\n\n    }\n\n    public class StreamCipherParameter : CipherParameter\n\n    {\n\n        public int IvSize;\n\n        public override string ToString()\n\n        {\n\n            return $\"stream (key:{KeySize * 8}, iv:{IvSize * 8})\";\n\n        }\n\n    }\n\n\n\n    public class AEADCipherParameter : CipherParameter\n\n    {\n\n        public int SaltSize;\n\n        public int TagSize;\n\n        public int NonceSize;\n\n        public override string ToString()\n\n        {\n\n            return $\"aead (key:{KeySize * 8}, salt:{SaltSize * 8}, tag:{TagSize * 8}, nonce:{NonceSize * 8})\";\n\n        }\n\n    }\n\n\n\n    public class CipherInfo\n\n    {\n\n        public string Name;\n\n        public CipherFamily Type;\n\n        public CipherParameter CipherParameter;\n\n\n\n        public CipherStandardState StandardState = CipherStandardState.InUse;\n\n\n\n        #region Stream ciphers\n\n        public CipherInfo(string name, int keySize, int ivSize, CipherFamily type, CipherStandardState state = CipherStandardState.Hidden)\n\n        {\n\n            Type = type;\n\n            Name = name;\n\n            StandardState = state;\n\n\n\n            CipherParameter = new StreamCipherParameter\n\n            {\n\n                KeySize = keySize,\n\n                IvSize = ivSize,\n\n            };\n\n        }\n\n\n\n        #endregion\n\n\n\n        #region AEAD ciphers\n\n        public CipherInfo(string name, int keySize, int saltSize, int nonceSize, int tagSize, CipherFamily type, CipherStandardState state = CipherStandardState.InUse)\n\n        {\n\n            Type = type;\n\n            Name = name;\n\n            StandardState = state;\n\n\n\n            CipherParameter = new AEADCipherParameter\n\n            {\n\n                KeySize = keySize,\n\n                SaltSize = saltSize,\n\n                NonceSize = nonceSize,\n\n                TagSize = tagSize,\n\n            };\n\n        }\n\n        #endregion\n\n\n\n        public override string ToString()\n\n        {\n\n            // TODO: \n\n            // return StandardState == CipherStandardState.InUse ? Name : $\"{Name} ({I18N.GetString(StandardState.ToString().ToLower())})\";\n\n            return \"\";\n\n        }\n\n        public string ToString(bool verbose)\n\n        {\n\n            if (!verbose)\n\n            {\n\n                return ToString();\n\n            }\n\n\n\n            return $\"{Name} {StandardState} {CipherParameter}\";\n\n        }\n\n    }\n\n}\n", "using System;\n\n\n\nnamespace Shadowsocks.Net.Crypto\n\n{\n\n    public abstract class CryptoBase : ICrypto\n\n    {\n\n        private static int _currentId = 0;\n\n\n\n        public const int MaxInputSize = 32768;\n\n\n\n        public const int MAX_DOMAIN_LEN = 255;\n\n        public const int ADDR_PORT_LEN = 2;\n\n        public const int ADDR_ATYP_LEN = 1;\n\n\n\n        public const int ATYP_IPv4 = 0x01;\n\n        public const int ATYP_DOMAIN = 0x03;\n\n        public const int ATYP_IPv6 = 0x04;\n\n\n\n        public const int MD5Length = 16;\n\n\n\n        // for debugging only, give it a number to trace data stream\n\n        public readonly int instanceId;\n\n\n\n        protected CryptoBase(string method, string password)\n\n        {\n\n            instanceId = _currentId;\n\n            _currentId++;\n\n\n\n            Method = method;\n\n            Password = password;\n\n        }\n\n\n\n        protected string Method;\n\n        protected string Password;\n\n\n\n        public override string ToString()\n\n        {\n\n            return $\"{instanceId}({Method},{Password})\";\n\n        }\n\n\n\n        public abstract int Encrypt(ReadOnlySpan<byte> plain, Span<byte> cipher);\n\n        public abstract int Decrypt(Span<byte> plain, ReadOnlySpan<byte> cipher);\n\n        public abstract int EncryptUDP(ReadOnlySpan<byte> plain, Span<byte> cipher);\n\n        public abstract int DecryptUDP(Span<byte> plain, ReadOnlySpan<byte> cipher);\n\n\n\n        public int AddressBufferLength { get; set; } = -1;\n\n\n\n        public abstract void Dispose();\n\n    }\n\n}\n", "using System;\n\nusing System.Security.Cryptography;\n\n\n\nnamespace Shadowsocks.Net.Crypto\n\n{\n\n    public static class RNG\n\n    {\n\n        private static RNGCryptoServiceProvider _rng = new RNGCryptoServiceProvider();\n\n\n\n        public static void Reload()\n\n        {\n\n            _rng.Dispose();\n\n            _rng = new RNGCryptoServiceProvider();\n\n        }\n\n\n\n        public static void GetSpan(Span<byte> span)\n\n        {\n\n            _rng.GetBytes(span);\n\n        }\n\n\n\n        public static Span<byte> GetSpan(int length)\n\n        {\n\n            Span<byte> span = new byte[length];\n\n            _rng.GetBytes(span);\n\n            return span;\n\n        }\n\n\n\n        public static byte[] GetBytes(int length)\n\n        {\n\n            byte[] buf = new byte[length];\n\n            _rng.GetBytes(buf);\n\n            return buf;\n\n        }\n\n\n\n        public static void GetBytes(byte[] buf, int len)\n\n        {\n\n            try\n\n            {\n\n                _rng.GetBytes(buf, 0, len);\n\n            }\n\n            catch\n\n            {\n\n                // the backup way\n\n                byte[] tmp = new byte[len];\n\n                _rng.GetBytes(tmp);\n\n                Buffer.BlockCopy(tmp, 0, buf, 0, len);\n\n            }\n\n        }\n\n    }\n\n}\n", "using Shadowsocks.Net.Crypto.AEAD;\n\n\n\nnamespace Shadowsocks.Net.Crypto\n\n{\n\n    public static class TCPParameter\n\n    {\n\n        // each recv size.\n\n        public const int RecvSize = 2048;\n\n\n\n        // overhead of one chunk, reserved for AEAD ciphers\n\n        //                                /* two tags */\n\n        public const int ChunkOverheadSize = 16 * 2  + AEADCrypto.ChunkLengthBytes;\n\n\n\n        // max chunk size\n\n        public const uint MaxChunkSize = AEADCrypto.ChunkLengthMask + AEADCrypto.ChunkLengthBytes + 16 * 2;\n\n\n\n        // In general, the ciphertext length, we should take overhead into account\n\n        public const int BufferSize = RecvSize + (int)MaxChunkSize + 32 /* max salt len */;\n\n    }\n\n}\n", "using System;\n\nusing System.Collections.Generic;\n\n\n\nnamespace Shadowsocks.Net.Crypto.Stream\n\n{\n\n    public class StreamPlainNativeCrypto : StreamCrypto\n\n    {\n\n\n\n        public StreamPlainNativeCrypto(string method, string password) : base(method, password)\n\n        {\n\n        }\n\n\n\n        protected override int CipherDecrypt(Span<byte> plain, ReadOnlySpan<byte> cipher)\n\n        {\n\n            cipher.CopyTo(plain);\n\n            return cipher.Length;\n\n        }\n\n\n\n        protected override int CipherEncrypt(ReadOnlySpan<byte> plain, Span<byte> cipher)\n\n        {\n\n            plain.CopyTo(cipher);\n\n            return plain.Length;\n\n        }\n\n\n\n        #region Cipher Info\n\n        private static readonly Dictionary<string, CipherInfo> _ciphers = new Dictionary<string, CipherInfo>\n\n        {\n\n            {\"plain\", new CipherInfo(\"plain\", 0, 0, CipherFamily.Plain) },\n\n            {\"none\", new CipherInfo(\"none\", 0, 0, CipherFamily.Plain) },\n\n        };\n\n\n\n        public static Dictionary<string, CipherInfo> SupportedCiphers()\n\n        {\n\n            return _ciphers;\n\n        }\n\n\n\n        protected override Dictionary<string, CipherInfo> GetCiphers()\n\n        {\n\n            return _ciphers;\n\n        }\n\n        #endregion\n\n\n\n        public override void Dispose() { }\n\n    }\n\n}\n", "using Splat;\n\nusing System;\n\nusing System.Collections.Generic;\n\nusing System.Runtime.CompilerServices;\n\nusing System.Text;\n\n\n\nnamespace Shadowsocks.Net.Crypto.Stream\n\n{\n\n    public abstract class StreamCrypto : CryptoBase, IEnableLogger\n\n    {\n\n        // shared by TCP decrypt UDP encrypt and decrypt\n\n        protected static byte[] sharedBuffer = new byte[65536];\n\n\n\n        // Is first packet\n\n        protected bool ivReady;\n\n\n\n        protected CipherFamily cipherFamily;\n\n        protected CipherInfo CipherInfo;\n\n        // long-time master key\n\n        protected static byte[] key = Array.Empty<byte>();\n\n        protected byte[] iv = Array.Empty<byte>();\n\n        protected int keyLen;\n\n        protected int ivLen;\n\n\n\n        public StreamCrypto(string method, string password)\n\n            : base(method, password)\n\n        {\n\n            CipherInfo = GetCiphers()[method.ToLower()];\n\n            cipherFamily = CipherInfo.Type;\n\n            StreamCipherParameter parameter = (StreamCipherParameter)CipherInfo.CipherParameter;\n\n            keyLen = parameter.KeySize;\n\n            ivLen = parameter.IvSize;\n\n\n\n            InitKey(password);\n\n\n\n            this.Log().Debug($\"key {instanceId} {key} {keyLen}\");\n\n        }\n\n\n\n        protected abstract Dictionary<string, CipherInfo> GetCiphers();\n\n\n\n        private void InitKey(string password)\n\n        {\n\n            byte[] passbuf = Encoding.UTF8.GetBytes(password);\n\n            key ??= new byte[keyLen];\n\n            if (key.Length != keyLen)\n\n            {\n\n                Array.Resize(ref key, keyLen);\n\n            }\n\n\n\n            LegacyDeriveKey(passbuf, key, keyLen);\n\n        }\n\n\n\n        [MethodImpl(MethodImplOptions.AggressiveInlining)]\n\n        public static void LegacyDeriveKey(byte[] password, byte[] key, int keylen)\n\n        {\n\n            byte[] result = new byte[password.Length + MD5Length];\n\n            int i = 0;\n\n            byte[] md5sum = Array.Empty<byte>();\n\n            while (i < keylen)\n\n            {\n\n                if (i == 0)\n\n                {\n\n                    md5sum = CryptoUtils.MD5(password);\n\n                }\n\n                else\n\n                {\n\n                    Array.Copy(md5sum, 0, result, 0, MD5Length);\n\n                    Array.Copy(password, 0, result, MD5Length, password.Length);\n\n                    md5sum = CryptoUtils.MD5(result);\n\n                }\n\n                Array.Copy(md5sum, 0, key, i, Math.Min(MD5Length, keylen - i));\n\n                i += MD5Length;\n\n            }\n\n        }\n\n\n\n        protected virtual void InitCipher(byte[] iv, bool isEncrypt)\n\n        {\n\n            if (ivLen == 0)\n\n            {\n\n                return;\n\n            }\n\n\n\n            this.iv = new byte[ivLen];\n\n            Array.Copy(iv, this.iv, ivLen);\n\n        }\n\n\n\n        protected abstract int CipherEncrypt(ReadOnlySpan<byte> plain, Span<byte> cipher);\n\n        protected abstract int CipherDecrypt(Span<byte> plain, ReadOnlySpan<byte> cipher);\n\n\n\n        #region TCP\n\n        [MethodImpl(MethodImplOptions.Synchronized)]\n\n        public override int Encrypt(ReadOnlySpan<byte> plain, Span<byte> cipher)\n\n        {\n\n            int cipherOffset = 0;\n\n            this.Log().Debug($\"{instanceId} encrypt TCP, generate iv: {!ivReady}\");\n\n            if (!ivReady)\n\n            {\n\n                // Generate IV\n\n                byte[] ivBytes = RNG.GetBytes(ivLen);\n\n                InitCipher(ivBytes, true);\n\n                ivBytes.CopyTo(cipher);\n\n                cipherOffset = ivLen;\n\n                cipher = cipher.Slice(cipherOffset);\n\n                ivReady = true;\n\n            }\n\n            int clen = CipherEncrypt(plain, cipher);\n\n\n\n            this.Log().Debug($\"plain {instanceId} {Convert.ToBase64String(plain)}\");\n\n            this.Log().Debug($\"cipher {instanceId} {Convert.ToBase64String(cipher.Slice(0, clen))}\");\n\n            this.Log().Debug($\"iv {instanceId} {iv} {ivLen}\");\n\n            return clen + cipherOffset;\n\n        }\n\n\n\n        private int recieveCtr = 0;\n\n        [MethodImpl(MethodImplOptions.Synchronized)]\n\n        public override int Decrypt(Span<byte> plain, ReadOnlySpan<byte> cipher)\n\n        {\n\n            this.Log().Debug($\"{instanceId} decrypt TCP, read iv: {!ivReady}\");\n\n\n\n            int cipherOffset = 0;\n\n            // is first packet, need read iv\n\n            if (!ivReady)\n\n            {\n\n                // push to buffer in case of not enough data\n\n                cipher.CopyTo(sharedBuffer.AsSpan(recieveCtr));\n\n                recieveCtr += cipher.Length;\n\n\n\n                // not enough data for read iv, return 0 byte data\n\n                if (recieveCtr <= ivLen)\n\n                {\n\n                    return 0;\n\n                }\n\n                // start decryption\n\n                ivReady = true;\n\n                if (ivLen > 0)\n\n                {\n\n                    // read iv\n\n                    byte[] iv = sharedBuffer.AsSpan(0, ivLen).ToArray();\n\n                    InitCipher(iv, false);\n\n                }\n\n                else\n\n                {\n\n                    InitCipher(Array.Empty<byte>(), false);\n\n                }\n\n                cipherOffset += ivLen;\n\n            }\n\n\n\n            // read all data from buffer\n\n            int len = CipherDecrypt(plain, cipher.Slice(cipherOffset));\n\n\n\n            this.Log().Debug($\"cipher {instanceId} {Convert.ToBase64String(cipher.Slice(cipherOffset))}\");\n\n            this.Log().Debug($\"plain {instanceId} {Convert.ToBase64String(plain.Slice(0, len))}\");\n\n            this.Log().Debug($\"iv {instanceId} {iv} {ivLen}\");\n\n            return len;\n\n        }\n\n\n\n        #endregion\n\n\n\n        #region UDP\n\n        [MethodImpl(MethodImplOptions.Synchronized)]\n\n        public override int EncryptUDP(ReadOnlySpan<byte> plain, Span<byte> cipher)\n\n        {\n\n            byte[] iv = RNG.GetBytes(ivLen);\n\n            iv.CopyTo(cipher);\n\n            InitCipher(iv, true);\n\n            return ivLen + CipherEncrypt(plain, cipher.Slice(ivLen));\n\n        }\n\n\n\n        [MethodImpl(MethodImplOptions.Synchronized)]\n\n        public override int DecryptUDP(Span<byte> plain, ReadOnlySpan<byte> cipher)\n\n        {\n\n            InitCipher(cipher.Slice(0, ivLen).ToArray(), false);\n\n            return CipherDecrypt(plain, cipher.Slice(ivLen));\n\n        }\n\n\n\n        #endregion\n\n    }\n\n}\n", "#nullable enable\n\nusing CryptoBase;\n\nusing CryptoBase.Abstractions.SymmetricCryptos;\n\nusing CryptoBase.Digests.MD5;\n\nusing System;\n\nusing System.Collections.Generic;\n\nusing System.Runtime.CompilerServices;\n\n\n\nnamespace Shadowsocks.Net.Crypto.Stream\n\n{\n\n    public class StreamCryptoBaseCrypto : StreamCrypto\n\n    {\n\n        private IStreamCrypto? _crypto;\n\n\n\n        public StreamCryptoBaseCrypto(string method, string password) : base(method, password)\n\n        {\n\n        }\n\n\n\n        protected override void InitCipher(byte[] iv, bool isEncrypt)\n\n        {\n\n            base.InitCipher(iv, isEncrypt);\n\n            _crypto?.Dispose();\n\n\n\n            if (cipherFamily == CipherFamily.Rc4Md5)\n\n            {\n\n                Span<byte> temp = stackalloc byte[keyLen + ivLen];\n\n                var realKey = new byte[MD5Length];\n\n                key.CopyTo(temp);\n\n                iv.CopyTo(temp.Slice(keyLen));\n\n                MD5Utils.Fast440(temp, realKey);\n\n\n\n                _crypto = StreamCryptoCreate.Rc4(realKey);\n\n                return;\n\n            }\n\n\n\n            _crypto = cipherFamily switch\n\n            {\n\n                CipherFamily.AesCfb => StreamCryptoCreate.AesCfb(isEncrypt, key, iv),\n\n                CipherFamily.Chacha20 => StreamCryptoCreate.ChaCha20(key, iv),\n\n                CipherFamily.Rc4 => StreamCryptoCreate.Rc4(key),\n\n                _ => throw new NotSupportedException()\n\n            };\n\n        }\n\n\n\n        protected override int CipherEncrypt(ReadOnlySpan<byte> plain, Span<byte> cipher)\n\n        {\n\n            return CipherUpdate(plain, cipher);\n\n        }\n\n\n\n        protected override int CipherDecrypt(Span<byte> plain, ReadOnlySpan<byte> cipher)\n\n        {\n\n            return CipherUpdate(cipher, plain);\n\n        }\n\n\n\n        [MethodImpl(MethodImplOptions.AggressiveInlining)]\n\n        private int CipherUpdate(ReadOnlySpan<byte> input, Span<byte> output)\n\n        {\n\n            _crypto!.Update(input, output);\n\n            return input.Length;\n\n        }\n\n\n\n        #region Cipher Info\n\n        private static readonly Dictionary<string, CipherInfo> _ciphers = new()\n\n        {\n\n            { \"aes-128-cfb\", new CipherInfo(\"aes-128-cfb\", 16, 16, CipherFamily.AesCfb, CipherStandardState.Unstable) },\n\n            { \"aes-192-cfb\", new CipherInfo(\"aes-192-cfb\", 24, 16, CipherFamily.AesCfb, CipherStandardState.Unstable) },\n\n            { \"aes-256-cfb\", new CipherInfo(\"aes-256-cfb\", 32, 16, CipherFamily.AesCfb, CipherStandardState.Unstable) },\n\n            { \"chacha20-ietf\", new CipherInfo(\"chacha20-ietf\", 32, 12, CipherFamily.Chacha20) },\n\n            { \"rc4\", new CipherInfo(\"rc4\", 16, 0, CipherFamily.Rc4) },\n\n            { \"rc4-md5\", new CipherInfo(\"rc4-md5\", 16, 16, CipherFamily.Rc4Md5) },\n\n        };\n\n\n\n        public static Dictionary<string, CipherInfo> SupportedCiphers()\n\n        {\n\n            return _ciphers;\n\n        }\n\n\n\n        protected override Dictionary<string, CipherInfo> GetCiphers()\n\n        {\n\n            return _ciphers;\n\n        }\n\n        #endregion\n\n\n\n        public override void Dispose()\n\n        {\n\n            _crypto?.Dispose();\n\n        }\n\n    }\n\n}\n", "using CryptoBase;\n\nusing Shadowsocks.Net.Crypto.Exception;\n\nusing Shadowsocks.Net.Crypto.Stream;\n\nusing Splat;\n\nusing System;\n\nusing System.Collections.Generic;\n\nusing System.Net;\n\nusing System.Runtime.CompilerServices;\n\nusing System.Security.Cryptography;\n\nusing System.Text;\n\n\n\nnamespace Shadowsocks.Net.Crypto.AEAD\n\n{\n\n    public abstract class AEADCrypto : CryptoBase, IEnableLogger\n\n    {\n\n        // We are using the same saltLen and keyLen\n\n        private const string Info = \"ss-subkey\";\n\n        private static readonly byte[] InfoBytes = Encoding.ASCII.GetBytes(Info);\n\n\n\n        // every connection should create its own buffer\n\n        private readonly byte[] buffer = new byte[65536];\n\n        private int bufPtr = 0;\n\n\n\n        public const int ChunkLengthBytes = 2;\n\n        public const uint ChunkLengthMask = 0x3FFFu;\n\n\n\n        protected CipherFamily cipherFamily;\n\n        protected CipherInfo CipherInfo;\n\n        protected static byte[] masterKey = Array.Empty<byte>();\n\n        protected byte[] sessionKey = Array.Empty<byte>();\n\n        protected int keyLen;\n\n        protected int saltLen;\n\n        protected int tagLen;\n\n        protected int nonceLen;\n\n\n\n        protected byte[] salt;\n\n        protected byte[] nonce;\n\n\n\n        // Is first packet\n\n        protected bool saltReady;\n\n\n\n        // Is first chunk(tcp request)\n\n        protected bool tcpRequestSent;\n\n\n\n        // [len(2)][lentag][data][datatag]\n\n        private int ChunkOverhead => tagLen * 2 + 2;\n\n\n\n        public AEADCrypto(string method, string password)\n\n            : base(method, password)\n\n        {\n\n            CipherInfo = GetCiphers()[method.ToLower()];\n\n            cipherFamily = CipherInfo.Type;\n\n            AEADCipherParameter parameter = (AEADCipherParameter)CipherInfo.CipherParameter;\n\n            keyLen = parameter.KeySize;\n\n            saltLen = parameter.SaltSize;\n\n            tagLen = parameter.TagSize;\n\n            nonceLen = parameter.NonceSize;\n\n\n\n            InitKey(password);\n\n\n\n            salt = new byte[saltLen];\n\n            // Initialize all-zero nonce for each connection\n\n            nonce = new byte[nonceLen];\n\n\n\n            this.Log().Debug($\"masterkey {instanceId} {masterKey} {keyLen}\");\n\n            this.Log().Debug($\"nonce {instanceId} {nonce} {keyLen}\");\n\n        }\n\n\n\n        protected abstract Dictionary<string, CipherInfo> GetCiphers();\n\n\n\n        protected void InitKey(string password)\n\n        {\n\n            byte[] passbuf = Encoding.UTF8.GetBytes(password);\n\n            // init master key\n\n            if (masterKey == null)\n\n            {\n\n                masterKey = new byte[keyLen];\n\n            }\n\n\n\n            if (masterKey.Length != keyLen)\n\n            {\n\n                Array.Resize(ref masterKey, keyLen);\n\n            }\n\n\n\n            StreamCrypto.LegacyDeriveKey(passbuf, masterKey, keyLen);\n\n            // init session key\n\n            sessionKey = new byte[keyLen];\n\n        }\n\n\n\n        public virtual void InitCipher(byte[] salt, bool isEncrypt)\n\n        {\n\n            this.salt = new byte[saltLen];\n\n            Array.Copy(salt, this.salt, saltLen);\n\n\n\n            HKDF.DeriveKey(HashAlgorithmName.SHA1, masterKey, sessionKey, salt, InfoBytes);\n\n\n\n            this.Log().Debug($\"salt {instanceId}\", salt, saltLen);\n\n            this.Log().Debug($\"sessionkey {instanceId}\", sessionKey, keyLen);\n\n        }\n\n\n\n        public abstract int CipherEncrypt(ReadOnlySpan<byte> plain, Span<byte> cipher);\n\n        public abstract int CipherDecrypt(Span<byte> plain, ReadOnlySpan<byte> cipher);\n\n\n\n        #region TCP\n\n\n\n        [MethodImpl(MethodImplOptions.Synchronized)]\n\n        public override int Encrypt(ReadOnlySpan<byte> plain, Span<byte> cipher)\n\n        {\n\n            // push data\n\n            Span<byte> tmp = buffer.AsSpan(0, plain.Length + bufPtr);\n\n            plain.CopyTo(tmp.Slice(bufPtr));\n\n\n\n            int outlength = 0;\n\n            if (!saltReady)\n\n            {\n\n                saltReady = true;\n\n                // Generate salt\n\n                byte[] saltBytes = RNG.GetBytes(saltLen);\n\n                InitCipher(saltBytes, true);\n\n                saltBytes.CopyTo(cipher);\n\n                outlength = saltLen;\n\n            }\n\n\n\n            while (true)\n\n            {\n\n                // calculate next chunk size\n\n                int bufSize = tmp.Length;\n\n                if (bufSize <= 0)\n\n                {\n\n                    return outlength;\n\n                }\n\n\n\n                int chunklength = (int)Math.Min(bufSize, ChunkLengthMask);\n\n                // read next chunk\n\n                int encChunkLength = ChunkEncrypt(tmp.Slice(0, chunklength), cipher.Slice(outlength));\n\n                tmp = tmp.Slice(chunklength);\n\n                outlength += encChunkLength;\n\n\n\n                // check if we have enough space for outbuf\n\n                // if not, keep buf for next run, at this condition, buffer is not empty\n\n                if (outlength + ChunkOverhead > cipher.Length)\n\n                {\n\n                    this.Log().Debug(\"enc outbuf almost full, giving up\");\n\n\n\n                    // write rest data to head of shared buffer\n\n                    tmp.CopyTo(buffer);\n\n                    bufPtr = tmp.Length;\n\n\n\n                    return outlength;\n\n                }\n\n                // check if buffer empty\n\n                bufSize = tmp.Length;\n\n                if (bufSize <= 0)\n\n                {\n\n                    this.Log().Debug(\"No more data to encrypt, leaving\");\n\n                    return outlength;\n\n                }\n\n            }\n\n        }\n\n\n\n        [MethodImpl(MethodImplOptions.Synchronized)]\n\n        public override int Decrypt(Span<byte> plain, ReadOnlySpan<byte> cipher)\n\n        {\n\n            int outlength = 0;\n\n            // drop all into buffer\n\n            Span<byte> tmp = buffer.AsSpan(0, cipher.Length + bufPtr);\n\n            cipher.CopyTo(tmp.Slice(bufPtr));\n\n            int bufSize = tmp.Length;\n\n\n\n            this.Log().Debug($\"{instanceId} decrypt tcp, read salt: {!saltReady}\");\n\n            if (!saltReady)\n\n            {\n\n                // check if we get the leading salt\n\n                if (bufSize <= saltLen)\n\n                {\n\n                    // need more, write back cache\n\n                    tmp.CopyTo(buffer);\n\n                    bufPtr = tmp.Length;\n\n                    return outlength;\n\n                }\n\n                saltReady = true;\n\n\n\n                byte[] salt = tmp.Slice(0, saltLen).ToArray();\n\n                tmp = tmp.Slice(saltLen);\n\n\n\n                InitCipher(salt, false);\n\n            }\n\n\n\n            // handle chunks\n\n            while (true)\n\n            {\n\n                bufSize = tmp.Length;\n\n                // check if we have any data\n\n                if (bufSize <= 0)\n\n                {\n\n                    this.Log().Debug(\"No data in buffer\");\n\n                    return outlength;\n\n                }\n\n\n\n                // first get chunk length\n\n                if (bufSize <= ChunkLengthBytes + tagLen)\n\n                {\n\n                    // so we only have chunk length and its tag?\n\n                    // wait more\n\n                    this.Log().Debug($\"{instanceId} not enough data to decrypt chunk. write {tmp.Length} byte back to buffer.\");\n\n                    tmp.CopyTo(buffer);\n\n                    bufPtr = tmp.Length;\n\n                    return outlength;\n\n                }\n\n                this.Log().Debug($\"{instanceId} try decrypt to offset {outlength}\");\n\n                int len = ChunkDecrypt(plain.Slice(outlength), tmp);\n\n                if (len <= 0)\n\n                {\n\n                    this.Log().Debug($\"{instanceId} no chunk decrypted, write {tmp.Length} byte back to buffer.\");\n\n\n\n                    // no chunk decrypted\n\n                    tmp.CopyTo(buffer);\n\n                    bufPtr = tmp.Length;\n\n                    return outlength;\n\n                }\n\n                this.Log().Debug($\"{instanceId} decrypted {len} to offset {outlength}\");\n\n\n\n                // drop decrypted data\n\n                tmp = tmp.Slice(ChunkLengthBytes + tagLen + len + tagLen);\n\n                outlength += len;\n\n\n\n                // logger.Debug(\"aead dec outlength \" + outlength);\n\n                if (outlength + ChunkOverhead > cipher.Length)\n\n                {\n\n                    this.Log().Debug($\"{instanceId} output almost full, write {tmp.Length} byte back to buffer.\");\n\n                    tmp.CopyTo(buffer);\n\n                    bufPtr = tmp.Length;\n\n                    return outlength;\n\n                }\n\n                bufSize = tmp.Length;\n\n                // check if we already done all of them\n\n                if (bufSize <= 0)\n\n                {\n\n                    bufPtr = 0;\n\n                    this.Log().Debug($\"{instanceId} no data in buffer, already all done\");\n\n                    return outlength;\n\n                }\n\n            }\n\n        }\n\n\n\n        #endregion\n\n\n\n        #region UDP\n\n        [MethodImpl(MethodImplOptions.Synchronized)]\n\n        public override int EncryptUDP(ReadOnlySpan<byte> plain, Span<byte> cipher)\n\n        {\n\n            RNG.GetSpan(cipher.Slice(0, saltLen));\n\n            InitCipher(cipher.Slice(0, saltLen).ToArray(), true);\n\n            return saltLen + CipherEncrypt(plain, cipher.Slice(saltLen));\n\n        }\n\n\n\n        [MethodImpl(MethodImplOptions.Synchronized)]\n\n        public override int DecryptUDP(Span<byte> plain, ReadOnlySpan<byte> cipher)\n\n        {\n\n            InitCipher(cipher.Slice(0, saltLen).ToArray(), false);\n\n            return CipherDecrypt(plain, cipher.Slice(saltLen));\n\n        }\n\n\n\n        #endregion\n\n\n\n        [MethodImpl(MethodImplOptions.Synchronized)]\n\n        private int ChunkEncrypt(ReadOnlySpan<byte> plain, Span<byte> cipher)\n\n        {\n\n            if (plain.Length > ChunkLengthMask)\n\n            {\n\n                this.Log().Error(\"enc chunk too big\");\n\n                throw new CryptoErrorException();\n\n            }\n\n\n\n            byte[] lenbuf = BitConverter.GetBytes((ushort)IPAddress.HostToNetworkOrder((short)plain.Length));\n\n            int cipherLenSize = CipherEncrypt(lenbuf, cipher);\n\n            nonce.Increment();\n\n            int cipherDataSize = CipherEncrypt(plain, cipher.Slice(cipherLenSize));\n\n            nonce.Increment();\n\n\n\n            return cipherLenSize + cipherDataSize;\n\n        }\n\n\n\n        [MethodImpl(MethodImplOptions.Synchronized)]\n\n        private int ChunkDecrypt(Span<byte> plain, ReadOnlySpan<byte> cipher)\n\n        {\n\n            // try to dec chunk len\n\n            byte[] chunkLengthByte = new byte[ChunkLengthBytes];\n\n            CipherDecrypt(chunkLengthByte, cipher.Slice(0, ChunkLengthBytes + tagLen));\n\n            ushort chunkLength = (ushort)IPAddress.NetworkToHostOrder((short)BitConverter.ToUInt16(chunkLengthByte, 0));\n\n            if (chunkLength > ChunkLengthMask)\n\n            {\n\n                // we get invalid chunk\n\n                this.Log().Error($\"{instanceId} Invalid chunk length: {chunkLength}\");\n\n                throw new CryptoErrorException();\n\n            }\n\n            // logger.Debug(\"Get the real chunk len:\" + chunkLength);\n\n            int bufSize = cipher.Length;\n\n            if (bufSize < ChunkLengthBytes + tagLen /* we haven't remove them */+ chunkLength + tagLen)\n\n            {\n\n                this.Log().Debug($\"{instanceId} need {ChunkLengthBytes + tagLen + chunkLength + tagLen}, but have {cipher.Length}\");\n\n                return 0;\n\n            }\n\n            nonce.Increment();\n\n            // we have enough data to decrypt one chunk\n\n            // drop chunk len and its tag from buffer\n\n            int len = CipherDecrypt(plain, cipher.Slice(ChunkLengthBytes + tagLen, chunkLength + tagLen));\n\n            nonce.Increment();\n\n            this.Log().Debug($\"{instanceId} decrypted {len} byte chunk used {ChunkLengthBytes + tagLen + chunkLength + tagLen} from {cipher.Length}\");\n\n            return len;\n\n        }\n\n    }\n\n}\n", "#nullable enable\n\nusing CryptoBase;\n\nusing CryptoBase.Abstractions.SymmetricCryptos;\n\nusing System;\n\nusing System.Collections.Generic;\n\n\n\nnamespace Shadowsocks.Net.Crypto.AEAD\n\n{\n\n    public class AEADCryptoBaseCrypto : AEADCrypto\n\n    {\n\n        private IAEADCrypto? _crypto;\n\n\n\n        public AEADCryptoBaseCrypto(string method, string password) : base(method, password)\n\n        {\n\n        }\n\n\n\n        #region Cipher Info\n\n        private static readonly Dictionary<string, CipherInfo> _ciphers = new()\n\n        {\n\n            { \"aes-128-gcm\", new CipherInfo(\"aes-128-gcm\", 16, 16, 12, 16, CipherFamily.AesGcm) },\n\n            { \"aes-192-gcm\", new CipherInfo(\"aes-192-gcm\", 24, 24, 12, 16, CipherFamily.AesGcm) },\n\n            { \"aes-256-gcm\", new CipherInfo(\"aes-256-gcm\", 32, 32, 12, 16, CipherFamily.AesGcm) },\n\n            { \"chacha20-ietf-poly1305\", new CipherInfo(\"chacha20-ietf-poly1305\", 32, 32, 12, 16, CipherFamily.Chacha20Poly1305) },\n\n            { \"xchacha20-ietf-poly1305\", new CipherInfo(\"xchacha20-ietf-poly1305\", 32, 32, 24, 16, CipherFamily.XChacha20Poly1305) },\n\n        };\n\n\n\n        protected override Dictionary<string, CipherInfo> GetCiphers()\n\n        {\n\n            return _ciphers;\n\n        }\n\n\n\n        public static Dictionary<string, CipherInfo> SupportedCiphers()\n\n        {\n\n            return _ciphers;\n\n        }\n\n        #endregion\n\n\n\n        public override void InitCipher(byte[] salt, bool isEncrypt)\n\n        {\n\n            base.InitCipher(salt, isEncrypt);\n\n            _crypto?.Dispose();\n\n\n\n            _crypto = cipherFamily switch\n\n            {\n\n                CipherFamily.AesGcm => AEADCryptoCreate.AesGcm(sessionKey),\n\n                CipherFamily.Chacha20Poly1305 => AEADCryptoCreate.ChaCha20Poly1305(sessionKey),\n\n                CipherFamily.XChacha20Poly1305 => AEADCryptoCreate.XChaCha20Poly1305(sessionKey),\n\n                _ => throw new NotSupportedException()\n\n            };\n\n        }\n\n\n\n        public override int CipherEncrypt(ReadOnlySpan<byte> plain, Span<byte> cipher)\n\n        {\n\n            _crypto!.Encrypt(nonce, plain, cipher.Slice(0, plain.Length), cipher.Slice(plain.Length, tagLen));\n\n            return plain.Length + tagLen;\n\n        }\n\n\n\n        public override int CipherDecrypt(Span<byte> plain, ReadOnlySpan<byte> cipher)\n\n        {\n\n            var clen = cipher.Length - tagLen;\n\n            var ciphertxt = cipher.Slice(0, clen);\n\n            var tag = cipher.Slice(clen);\n\n            _crypto!.Decrypt(nonce, ciphertxt, tag, plain.Slice(0, clen));\n\n            return clen;\n\n        }\n\n\n\n        public override void Dispose()\n\n        {\n\n            _crypto?.Dispose();\n\n        }\n\n    }\n\n}\n", "namespace Shadowsocks.Net.Crypto.Exception\n\n{\n\n    public class CryptoErrorException : System.Exception\n\n    {\n\n        public CryptoErrorException()\n\n        {\n\n        }\n\n\n\n        public CryptoErrorException(string msg) : base(msg)\n\n        {\n\n        }\n\n\n\n        public CryptoErrorException(string message, System.Exception innerException) : base(message, innerException)\n\n        {\n\n        }\n\n    }\n\n}\n", "using System;\n\nusing System.Net;\n\nusing System.Net.Sockets;\n\nusing System.Threading;\n\nusing System.Threading.Tasks;\n\n\n\nnamespace Shadowsocks.Net.Proxy\n\n{\n\n    public interface IProxy\n\n    {\n\n        EndPoint LocalEndPoint { get; }\n\n\n\n        EndPoint ProxyEndPoint { get; }\n\n\n\n        EndPoint DestEndPoint { get; }\n\n\n\n        Task ConnectProxyAsync(EndPoint remoteEP, NetworkCredential auth = null, CancellationToken token = default);\n\n\n\n        Task ConnectRemoteAsync(EndPoint destEndPoint, CancellationToken token = default);\n\n\n\n        Task<int> SendAsync(ReadOnlyMemory<byte> buffer, CancellationToken token = default);\n\n\n\n        Task<int> ReceiveAsync(Memory<byte> buffer, CancellationToken token = default);\n\n\n\n        void Shutdown(SocketShutdown how);\n\n\n\n        void Close();\n\n    }\n\n}\n", "using System;\n\nusing System.Net;\n\nusing System.Net.Sockets;\n\nusing System.Threading;\n\nusing System.Threading.Tasks;\n\n\n\nnamespace Shadowsocks.Net.Proxy\n\n{\n\n    public class DirectConnect : IProxy\n\n    {\n\n        private class FakeAsyncResult : IAsyncResult\n\n        {\n\n            public FakeAsyncResult(object state)\n\n            {\n\n                AsyncState = state;\n\n            }\n\n\n\n            public bool IsCompleted { get; } = true;\n\n            public WaitHandle AsyncWaitHandle { get; } = null;\n\n            public object AsyncState { get; }\n\n            public bool CompletedSynchronously { get; } = true;\n\n        }\n\n\n\n        private class FakeEndPoint : EndPoint\n\n        {\n\n            public override AddressFamily AddressFamily { get; } = AddressFamily.Unspecified;\n\n\n\n            public override string ToString()\n\n            {\n\n                return \"null proxy\";\n\n            }\n\n        }\n\n\n\n        private readonly Socket _remote = new Socket(SocketType.Stream, ProtocolType.Tcp);\n\n\n\n        public EndPoint LocalEndPoint => _remote.LocalEndPoint;\n\n\n\n        public EndPoint ProxyEndPoint { get; } = new FakeEndPoint();\n\n        public EndPoint DestEndPoint { get; private set; }\n\n\n\n        public void Shutdown(SocketShutdown how)\n\n        {\n\n            _remote.Shutdown(how);\n\n        }\n\n\n\n        public void Close()\n\n        {\n\n            _remote.Dispose();\n\n        }\n\n\n\n        public Task ConnectProxyAsync(EndPoint remoteEP, NetworkCredential auth = null, CancellationToken token = default)\n\n        {\n\n            return Task.CompletedTask;\n\n        }\n\n\n\n        public async Task ConnectRemoteAsync(EndPoint destEndPoint, CancellationToken token = default)\n\n        {\n\n            DestEndPoint = destEndPoint;\n\n            await _remote.ConnectAsync(destEndPoint);\n\n        }\n\n\n\n        public async Task<int> SendAsync(ReadOnlyMemory<byte> buffer, CancellationToken token = default)\n\n        {\n\n            return await _remote.SendAsync(buffer, SocketFlags.None, token);\n\n        }\n\n\n\n        public async Task<int> ReceiveAsync(Memory<byte> buffer, CancellationToken token = default)\n\n        {\n\n            return await _remote.ReceiveAsync(buffer, SocketFlags.None, token);\n\n        }\n\n    }\n\n}\n", "using Splat;\n\nusing System;\n\nusing System.Net;\n\nusing System.Net.Sockets;\n\nusing System.Text;\n\nusing System.Text.RegularExpressions;\n\nusing System.Threading;\n\nusing System.Threading.Tasks;\n\n\n\nnamespace Shadowsocks.Net.Proxy\n\n{\n\n    public class HttpProxy : IProxy, IEnableLogger\n\n    {\n\n        public EndPoint LocalEndPoint => _remote.LocalEndPoint;\n\n        public EndPoint ProxyEndPoint { get; private set; }\n\n        public EndPoint DestEndPoint { get; private set; }\n\n\n\n        private readonly Socket _remote = new Socket(SocketType.Stream, ProtocolType.Tcp);\n\n\n\n        private const string HTTP_CRLF = \"\\r\\n\";\n\n        private const string HTTP_CONNECT_TEMPLATE =\n\n            \"CONNECT {0} HTTP/1.1\" + HTTP_CRLF +\n\n            \"Host: {0}\" + HTTP_CRLF +\n\n            \"Proxy-Connection: keep-alive\" + HTTP_CRLF +\n\n            \"User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/85.0.4183.83 Safari/537.36\" + HTTP_CRLF +\n\n            \"{1}\" +         // Proxy-Authorization if any\n\n            \"\" + HTTP_CRLF; // End with an empty line\n\n        private const string PROXY_AUTH_TEMPLATE = \"Proxy-Authorization: Basic {0}\" + HTTP_CRLF;\n\n\n\n        public void Shutdown(SocketShutdown how)\n\n        {\n\n            _remote.Shutdown(how);\n\n        }\n\n\n\n        public void Close()\n\n        {\n\n            _remote.Dispose();\n\n        }\n\n\n\n        private static readonly Regex HttpRespondHeaderRegex = new Regex(@\"^(HTTP/1\\.\\d) (\\d{3}) (.+)$\", RegexOptions.Compiled);\n\n        private int _respondLineCount = 0;\n\n        private bool _established = false;\n\n\n\n        private bool OnLineRead(string line, object state)\n\n        {\n\n            this.Log().Debug(line);\n\n\n\n            if (_respondLineCount == 0)\n\n            {\n\n                var m = HttpRespondHeaderRegex.Match(line);\n\n                if (m.Success)\n\n                {\n\n                    var resultCode = m.Groups[2].Value;\n\n                    if (\"200\" != resultCode)\n\n                    {\n\n                        return true;\n\n                    }\n\n                    _established = true;\n\n                }\n\n            }\n\n            else\n\n            {\n\n                if (string.IsNullOrEmpty(line))\n\n                {\n\n                    return true;\n\n                }\n\n            }\n\n            _respondLineCount++;\n\n\n\n            return false;\n\n        }\n\n\n\n        private NetworkCredential auth;\n\n\n\n        public async Task ConnectProxyAsync(EndPoint remoteEP, NetworkCredential auth = null, CancellationToken token = default)\n\n        {\n\n            ProxyEndPoint = remoteEP;\n\n            this.auth = auth;\n\n            await _remote.ConnectAsync(remoteEP);\n\n            _remote.SetSocketOption(SocketOptionLevel.Tcp, SocketOptionName.NoDelay, true);\n\n        }\n\n\n\n        public async Task ConnectRemoteAsync(EndPoint destEndPoint, CancellationToken token = default)\n\n        {\n\n            DestEndPoint = destEndPoint;\n\n            String authInfo = \"\";\n\n            if (auth != null)\n\n            {\n\n                string authKey = Convert.ToBase64String(Encoding.UTF8.GetBytes(auth.UserName + \":\" + auth.Password));\n\n                authInfo = string.Format(PROXY_AUTH_TEMPLATE, authKey);\n\n            }\n\n            string request = string.Format(HTTP_CONNECT_TEMPLATE, destEndPoint, authInfo);\n\n\n\n            var b = Encoding.UTF8.GetBytes(request);\n\n\n\n            await _remote.SendAsync(Encoding.UTF8.GetBytes(request), SocketFlags.None, token);\n\n\n\n            // start line read\n\n            LineReader reader = new LineReader(_remote, OnLineRead, (e, _) => throw e, (_1, _2, _3, _4) => { }, Encoding.UTF8, HTTP_CRLF, 1024, null);\n\n            await reader.Finished;\n\n        }\n\n\n\n        public async Task<int> SendAsync(ReadOnlyMemory<byte> buffer, CancellationToken token = default)\n\n        {\n\n            return await _remote.SendAsync(buffer, SocketFlags.None, token);\n\n        }\n\n\n\n        public async Task<int> ReceiveAsync(Memory<byte> buffer, CancellationToken token = default)\n\n        {\n\n            return await _remote.ReceiveAsync(buffer, SocketFlags.None, token);\n\n        }\n\n    }\n\n}\n", "using System;\n\nusing System.Net.Sockets;\n\nusing System.Text;\n\nusing System.Threading.Tasks;\n\n\n\nnamespace Shadowsocks.Net.Proxy\n\n{\n\n    public class LineReader\n\n    {\n\n        private readonly Socket _socket;\n\n        private readonly Func<string, object, bool> _onLineRead;\n\n        private readonly Action<Exception, object> _onException;\n\n        private readonly Action<byte[], int, int, object> _onFinish;\n\n        private readonly Encoding _encoding;\n\n        // private readonly string _delimiter;\n\n        private readonly byte[] _delimiterBytes;\n\n        private readonly int[] _delimiterSearchCharTable;\n\n        private readonly int[] _delimiterSearchOffsetTable;\n\n        private readonly object _state;\n\n\n\n        private readonly byte[] _lineBuffer;\n\n\n\n        private int _bufferIndex;\n\n\n\n        private readonly TaskCompletionSource<int> finishPromise = new TaskCompletionSource<int>();\n\n        public Task Finished => finishPromise.Task;\n\n\n\n        public LineReader(Socket socket, Func<string, object, bool> onLineRead, Action<Exception, object> onException,\n\n            Action<byte[], int, int, object> onFinish, Encoding encoding, string delimiter, int maxLineBytes, object state)\n\n        {\n\n            if (socket == null)\n\n            {\n\n                throw new ArgumentNullException(nameof(socket));\n\n            }\n\n            if (onLineRead == null)\n\n            {\n\n                throw new ArgumentNullException(nameof(onLineRead));\n\n            }\n\n            if (encoding == null)\n\n            {\n\n                throw new ArgumentNullException(nameof(encoding));\n\n            }\n\n            if (delimiter == null)\n\n            {\n\n                throw new ArgumentNullException(nameof(delimiter));\n\n            }\n\n\n\n            _socket = socket;\n\n            _onLineRead = onLineRead;\n\n            _onException = onException;\n\n            _onFinish = onFinish;\n\n            _encoding = encoding;\n\n            // _delimiter = delimiter;\n\n            _state = state;\n\n\n\n            // decode delimiter\n\n            _delimiterBytes = encoding.GetBytes(delimiter);\n\n\n\n            if (_delimiterBytes.Length == 0)\n\n            {\n\n                throw new ArgumentException(\"Too short!\", nameof(delimiter));\n\n            }\n\n\n\n            if (maxLineBytes < _delimiterBytes.Length)\n\n            {\n\n                throw new ArgumentException(\"Too small!\", nameof(maxLineBytes));\n\n            }\n\n\n\n            _delimiterSearchCharTable = MakeCharTable(_delimiterBytes);\n\n            _delimiterSearchOffsetTable = MakeOffsetTable(_delimiterBytes);\n\n\n\n            _lineBuffer = new byte[maxLineBytes];\n\n\n\n            // start reading\n\n            socket.BeginReceive(_lineBuffer, 0, maxLineBytes, 0, ReceiveCallback, 0);\n\n        }\n\n\n\n        private void ReceiveCallback(IAsyncResult ar)\n\n        {\n\n            int length = (int)ar.AsyncState;\n\n            try\n\n            {\n\n                var bytesRead = _socket.EndReceive(ar);\n\n\n\n                if (bytesRead == 0)\n\n                {\n\n                    OnFinish(length);\n\n                    finishPromise.TrySetResult(0);\n\n                    return;\n\n                }\n\n\n\n                length += bytesRead;\n\n\n\n                int i;\n\n                while ((i = IndexOf(_lineBuffer, _bufferIndex, length, _delimiterBytes, _delimiterSearchOffsetTable,\n\n                           _delimiterSearchCharTable)) != -1)\n\n                {\n\n                    var decodeLen = i - _bufferIndex;\n\n                    string line = _encoding.GetString(_lineBuffer, _bufferIndex, decodeLen);\n\n\n\n                    _bufferIndex = i + _delimiterBytes.Length;\n\n                    length -= decodeLen;\n\n                    length -= _delimiterBytes.Length;\n\n\n\n                    var stop = _onLineRead(line, _state);\n\n                    if (stop)\n\n                    {\n\n                        OnFinish(length);\n\n                        return;\n\n                    }\n\n                }\n\n                if (length == _lineBuffer.Length)\n\n                {\n\n                    OnException(new IndexOutOfRangeException(\"LineBuffer full! Try increace maxLineBytes!\"));\n\n                    OnFinish(length);\n\n\n\n                    return;\n\n                }\n\n\n\n                if (_bufferIndex > 0)\n\n                {\n\n                    Buffer.BlockCopy(_lineBuffer, _bufferIndex, _lineBuffer, 0, length);\n\n                    _bufferIndex = 0;\n\n                }\n\n\n\n                _socket.BeginReceive(_lineBuffer, length, _lineBuffer.Length - length, 0, ReceiveCallback, length);\n\n            }\n\n            catch (Exception ex)\n\n            {\n\n                OnException(ex);\n\n                OnFinish(length);\n\n            }\n\n        }\n\n\n\n        private void OnException(Exception ex)\n\n        {\n\n            finishPromise.TrySetException(ex);\n\n            _onException?.Invoke(ex, _state);\n\n        }\n\n\n\n        private void OnFinish(int length)\n\n        {\n\n            _onFinish?.Invoke(_lineBuffer, _bufferIndex, length, _state);\n\n        }\n\n\n\n        #region Boyer-Moore string search\n\n\n\n        public static int IndexOf(byte[] haystack, int index, int length, byte[] needle, int[] offsetTable, int[] charTable)\n\n        {\n\n            var end = index + length;\n\n            for (int i = needle.Length - 1 + index, j; i < end;)\n\n            {\n\n                for (j = needle.Length - 1; needle[j] == haystack[i]; --i, --j)\n\n                {\n\n                    if (j == 0)\n\n                    {\n\n                        return i;\n\n                    }\n\n                }\n\n                // i += needle.length - j; // For naive method\n\n                i += Math.Max(offsetTable[needle.Length - 1 - j], charTable[haystack[i]]);\n\n            }\n\n            return -1;\n\n        }\n\n\n\n        /**\n\n         * Makes the jump table based on the mismatched character information.\n\n         */\n\n        private static int[] MakeCharTable(byte[] needle)\n\n        {\n\n            const int ALPHABET_SIZE = 256;\n\n            int[] table = new int[ALPHABET_SIZE];\n\n            for (int i = 0; i < table.Length; ++i)\n\n            {\n\n                table[i] = needle.Length;\n\n            }\n\n            for (int i = 0; i < needle.Length - 1; ++i)\n\n            {\n\n                table[needle[i]] = needle.Length - 1 - i;\n\n            }\n\n            return table;\n\n        }\n\n\n\n        /**\n\n         * Makes the jump table based on the scan offset which mismatch occurs.\n\n         */\n\n        private static int[] MakeOffsetTable(byte[] needle)\n\n        {\n\n            int[] table = new int[needle.Length];\n\n            int lastPrefixPosition = needle.Length;\n\n            for (int i = needle.Length - 1; i >= 0; --i)\n\n            {\n\n                if (IsPrefix(needle, i + 1))\n\n                {\n\n                    lastPrefixPosition = i + 1;\n\n                }\n\n                table[needle.Length - 1 - i] = lastPrefixPosition - i + needle.Length - 1;\n\n            }\n\n            for (int i = 0; i < needle.Length - 1; ++i)\n\n            {\n\n                int slen = SuffixLength(needle, i);\n\n                table[slen] = needle.Length - 1 - i + slen;\n\n            }\n\n            return table;\n\n        }\n\n\n\n        /**\n\n         * Is needle[p:end] a prefix of needle?\n\n         */\n\n        private static bool IsPrefix(byte[] needle, int p)\n\n        {\n\n            for (int i = p, j = 0; i < needle.Length; ++i, ++j)\n\n            {\n\n                if (needle[i] != needle[j])\n\n                {\n\n                    return false;\n\n                }\n\n            }\n\n            return true;\n\n        }\n\n\n\n        /**\n\n         * Returns the maximum length of the substring ends at p and is a suffix.\n\n         */\n\n        private static int SuffixLength(byte[] needle, int p)\n\n        {\n\n            int len = 0;\n\n            for (int i = p, j = needle.Length - 1;\n\n                     i >= 0 && needle[i] == needle[j]; --i, --j)\n\n            {\n\n                len += 1;\n\n            }\n\n            return len;\n\n        }\n\n\n\n        #endregion\n\n    }\n\n}\n", "using System;\n\nusing System.Net;\n\nusing System.Net.Sockets;\n\nusing System.Text;\n\nusing System.Threading;\n\nusing System.Threading.Tasks;\n\n\n\nnamespace Shadowsocks.Net.Proxy\n\n{\n\n    public class Socks5Proxy : IProxy\n\n    {\n\n        private readonly Socket _remote = new Socket(SocketType.Stream, ProtocolType.Tcp);\n\n\n\n        private const int Socks5PktMaxSize = 4 + 16 + 2;\n\n        private readonly byte[] _receiveBuffer = new byte[Socks5PktMaxSize];\n\n\n\n        public EndPoint LocalEndPoint => _remote.LocalEndPoint;\n\n        public EndPoint ProxyEndPoint { get; private set; }\n\n        public EndPoint DestEndPoint { get; private set; }\n\n\n\n        public void Shutdown(SocketShutdown how)\n\n        {\n\n            _remote.Shutdown(how);\n\n        }\n\n\n\n        public void Close()\n\n        {\n\n            _remote.Dispose();\n\n        }\n\n\n\n        public async Task ConnectProxyAsync(EndPoint remoteEP, NetworkCredential auth = null, CancellationToken token = default)\n\n        {\n\n            ProxyEndPoint = remoteEP;\n\n            await _remote.ConnectAsync(remoteEP);\n\n            await _remote.SendAsync(new byte[] { 5, 1, 0 }, SocketFlags.None);\n\n            if (await _remote.ReceiveAsync(_receiveBuffer.AsMemory(0, 2), SocketFlags.None) != 2)\n\n            {\n\n                throw new Exception(\"Proxy handshake failed\");\n\n            }\n\n            if (_receiveBuffer[0] != 5 || _receiveBuffer[1] != 0)\n\n            {\n\n                throw new Exception(\"Proxy handshake failed\");\n\n            }\n\n        }\n\n\n\n        public async Task ConnectRemoteAsync(EndPoint destEndPoint, CancellationToken token = default)\n\n        {\n\n            // TODO: support SOCKS5 auth\n\n            DestEndPoint = destEndPoint;\n\n\n\n            byte[] request;\n\n            byte atyp;\n\n            int port;\n\n            if (destEndPoint is DnsEndPoint dep)\n\n            {\n\n                // is a domain name, we will leave it to server\n\n\n\n                atyp = 3; // DOMAINNAME\n\n                var enc = Encoding.UTF8;\n\n                var hostByteCount = enc.GetByteCount(dep.Host);\n\n\n\n                request = new byte[4 + 1/*length byte*/ + hostByteCount + 2];\n\n                request[4] = (byte)hostByteCount;\n\n                enc.GetBytes(dep.Host, 0, dep.Host.Length, request, 5);\n\n\n\n                port = dep.Port;\n\n            }\n\n            else\n\n            {\n\n                switch (DestEndPoint.AddressFamily)\n\n                {\n\n                    case AddressFamily.InterNetwork:\n\n                        request = new byte[4 + 4 + 2];\n\n                        atyp = 1; // IP V4 address\n\n                        break;\n\n                    case AddressFamily.InterNetworkV6:\n\n                        request = new byte[4 + 16 + 2];\n\n                        atyp = 4; // IP V6 address\n\n                        break;\n\n                    default:\n\n                        throw new Exception(\"Proxy request failed\");\n\n                }\n\n                port = ((IPEndPoint)DestEndPoint).Port;\n\n                var addr = ((IPEndPoint)DestEndPoint).Address.GetAddressBytes();\n\n                Array.Copy(addr, 0, request, 4, request.Length - 4 - 2);\n\n            }\n\n\n\n            request[0] = 5;\n\n            request[1] = 1;\n\n            request[2] = 0;\n\n            request[3] = atyp;\n\n            request[^2] = (byte)((port >> 8) & 0xff);\n\n            request[^1] = (byte)(port & 0xff);\n\n\n\n            await _remote.SendAsync(request, SocketFlags.None, token);\n\n\n\n            if (await _remote.ReceiveAsync(_receiveBuffer.AsMemory(0, 4), SocketFlags.None, token) != 4)\n\n            {\n\n                throw new Exception(\"Proxy request failed\");\n\n            };\n\n            if (_receiveBuffer[0] != 5 || _receiveBuffer[1] != 0)\n\n            {\n\n                throw new Exception(\"Proxy request failed\");\n\n            }\n\n            var addrLen = _receiveBuffer[3] switch\n\n            {\n\n                1 => 6,\n\n                4 => 18,\n\n                _ => throw new NotImplementedException(),\n\n            };\n\n            if (await _remote.ReceiveAsync(_receiveBuffer.AsMemory(0, addrLen), SocketFlags.None, token) != addrLen)\n\n            {\n\n                throw new Exception(\"Proxy request failed\");\n\n            }\n\n        }\n\n\n\n        public async Task<int> SendAsync(ReadOnlyMemory<byte> buffer, CancellationToken token = default)\n\n        {\n\n            return await _remote.SendAsync(buffer, SocketFlags.None, token);\n\n        }\n\n\n\n        public async Task<int> ReceiveAsync(Memory<byte> buffer, CancellationToken token = default)\n\n        {\n\n            return await _remote.ReceiveAsync(buffer, SocketFlags.None, token);\n\n        }\n\n    }\n\n}\n", "using System;\n\nusing System.Runtime.Serialization;\n\n\n\nnamespace Shadowsocks.Net.SystemProxy\n\n{\n\n    public enum ProxyExceptionType\n\n    {\n\n        Unspecific,\n\n        FailToRun,\n\n        QueryReturnEmpty,\n\n        SysproxyExitError,\n\n        QueryReturnMalformed\n\n    }\n\n\n\n    public class ProxyException : Exception\n\n    {\n\n        // provide more specific information about exception\n\n        public ProxyExceptionType Type { get; }\n\n\n\n        public ProxyException()\n\n        {\n\n        }\n\n\n\n        public ProxyException(string message) : base(message)\n\n        {\n\n        }\n\n\n\n        public ProxyException(string message, Exception innerException) : base(message, innerException)\n\n        {\n\n        }\n\n\n\n        protected ProxyException(SerializationInfo info, StreamingContext context) : base(info, context)\n\n        {\n\n        }\n\n        public ProxyException(ProxyExceptionType type)\n\n        {\n\n            this.Type = type;\n\n        }\n\n\n\n        public ProxyException(ProxyExceptionType type, string message) : base(message)\n\n        {\n\n            this.Type = type;\n\n        }\n\n\n\n        public ProxyException(ProxyExceptionType type, string message, Exception innerException) : base(message, innerException)\n\n        {\n\n            this.Type = type;\n\n        }\n\n\n\n        protected ProxyException(ProxyExceptionType type, SerializationInfo info, StreamingContext context) : base(info, context)\n\n        {\n\n            this.Type = type;\n\n        }\n\n    }\n\n}\n", "using Shadowsocks.Models;\n\nusing System;\n\nusing Xunit;\n\n\n\nnamespace Shadowsocks.Tests\n\n{\n\n    public class UrlTests\n\n    {\n\n        [Theory]\n\n        [InlineData(\"chacha20-ietf-poly1305\", \"kf!V!TFzgeNd93GE\", \"Y2hhY2hhMjAtaWV0Zi1wb2x5MTMwNTprZiFWIVRGemdlTmQ5M0dF\")]\n\n        [InlineData(\"aes-256-gcm\", \"ymghiR#75TNqpa\", \"YWVzLTI1Ni1nY206eW1naGlSIzc1VE5xcGE\")]\n\n        [InlineData(\"aes-128-gcm\", \"tK*sk!9N8@86:UVm\", \"YWVzLTEyOC1nY206dEsqc2shOU44QDg2OlVWbQ\")]\n\n        public void Utilities_Base64Url_Encode(string method, string password, string expectedUserinfoBase64url)\n\n        {\n\n            var userinfoBase64url = Utilities.Base64Url.Encode($\"{method}:{password}\");\n\n\n\n            Assert.Equal(expectedUserinfoBase64url, userinfoBase64url);\n\n        }\n\n \n\n        [Theory]\n\n        [InlineData(\"Y2hhY2hhMjAtaWV0Zi1wb2x5MTMwNTo2JW04RDlhTUI1YkElYTQl\", \"chacha20-ietf-poly1305:6%m8D9aMB5bA%a4%\")]\n\n        [InlineData(\"YWVzLTI1Ni1nY206YnBOZ2sqSjNrYUFZeXhIRQ\", \"aes-256-gcm:bpNgk*J3kaAYyxHE\")]\n\n        [InlineData(\"YWVzLTEyOC1nY206dkFBbiY4a1I6JGlBRTQ\", \"aes-128-gcm:vAAn&8kR:$iAE4\")]\n\n        public void Utilities_Base64Url_Decode(string userinfoBase64url, string expectedUserinfo)\n\n        {\n\n            var userinfo = Utilities.Base64Url.DecodeToString(userinfoBase64url);\n\n\n\n            Assert.Equal(expectedUserinfo, userinfo);\n\n        }\n\n\n\n        [Theory]\n\n        [InlineData(\"aes-256-gcm\", \"wLhN2STZ\", \"github.com\", 443, \"\", null, null, \"ss://YWVzLTI1Ni1nY206d0xoTjJTVFo@github.com:443/\")] // domain name\n\n        [InlineData(\"aes-256-gcm\", \"wLhN2STZ\", \"1.1.1.1\", 853, \"\", null, null, \"ss://YWVzLTI1Ni1nY206d0xoTjJTVFo@1.1.1.1:853/\")] // IPv4\n\n        [InlineData(\"aes-256-gcm\", \"wLhN2STZ\", \"2001:db8:85a3::8a2e:370:7334\", 8388, \"\", null, null, \"ss://YWVzLTI1Ni1nY206d0xoTjJTVFo@[2001:db8:85a3::8a2e:370:7334]:8388/\")] // IPv6\n\n        [InlineData(\"aes-256-gcm\", \"wLhN2STZ\", \"github.com\", 443, \"GitHub\", null, null, \"ss://YWVzLTI1Ni1nY206d0xoTjJTVFo@github.com:443/#GitHub\")] // fragment\n\n        [InlineData(\"aes-256-gcm\", \"wLhN2STZ\", \"github.com\", 443, \"\ud83d\udc69\u200d\ud83d\udcbb\", null, null, \"ss://YWVzLTI1Ni1nY206d0xoTjJTVFo@github.com:443/#%F0%9F%91%A9%E2%80%8D%F0%9F%92%BB\")] // fragment\n\n        [InlineData(\"aes-256-gcm\", \"wLhN2STZ\", \"github.com\", 443, \"\", \"v2ray-plugin\", null, \"ss://YWVzLTI1Ni1nY206d0xoTjJTVFo@github.com:443/?plugin=v2ray-plugin\")] // plugin\n\n        [InlineData(\"aes-256-gcm\", \"wLhN2STZ\", \"github.com\", 443, \"\", null, \"server;tls;host=github.com\", \"ss://YWVzLTI1Ni1nY206d0xoTjJTVFo@github.com:443/\")] // pluginOpts\n\n        [InlineData(\"aes-256-gcm\", \"wLhN2STZ\", \"github.com\", 443, \"\", \"v2ray-plugin\", \"server;tls;host=github.com\", \"ss://YWVzLTI1Ni1nY206d0xoTjJTVFo@github.com:443/?plugin=v2ray-plugin%3Bserver%3Btls%3Bhost%3Dgithub.com\")] // plugin + pluginOpts\n\n        [InlineData(\"aes-256-gcm\", \"wLhN2STZ\", \"github.com\", 443, \"GitHub\", \"v2ray-plugin\", \"server;tls;host=github.com\", \"ss://YWVzLTI1Ni1nY206d0xoTjJTVFo@github.com:443/?plugin=v2ray-plugin%3Bserver%3Btls%3Bhost%3Dgithub.com#GitHub\")] // fragment + plugin + pluginOpts\n\n        public void Server_ToUrl(string method, string password, string host, int port, string fragment, string? plugin, string? pluginOpts, string expectedSSUri)\n\n        {\n\n            var server = new Server()\n\n            {\n\n                Password = password,\n\n                Method = method,\n\n                Host = host,\n\n                Port = port,\n\n                Name = fragment,\n\n                Plugin = plugin,\n\n                PluginOpts = pluginOpts,\n\n            };\n\n\n\n            var ssUriString = server.ToUrl().AbsoluteUri;\n\n\n\n            Assert.Equal(expectedSSUri, ssUriString);\n\n        }\n\n\n\n        [Theory]\n\n        [InlineData(\"ss://YWVzLTI1Ni1nY206d0xoTjJTVFo@github.com:443/\", true, \"aes-256-gcm\", \"wLhN2STZ\", \"github.com\", 443, \"\", null, null)] // domain name\n\n        [InlineData(\"ss://YWVzLTI1Ni1nY206d0xoTjJTVFo@1.1.1.1:853/\", true, \"aes-256-gcm\", \"wLhN2STZ\", \"1.1.1.1\", 853, \"\", null, null)] // IPv4\n\n        [InlineData(\"ss://YWVzLTI1Ni1nY206d0xoTjJTVFo@[2001:db8:85a3::8a2e:370:7334]:8388/\", true, \"aes-256-gcm\", \"wLhN2STZ\", \"2001:db8:85a3::8a2e:370:7334\", 8388, \"\", null, null)] // IPv6\n\n        [InlineData(\"ss://YWVzLTI1Ni1nY206d0xoTjJTVFo@github.com:443/#GitHub\", true, \"aes-256-gcm\", \"wLhN2STZ\", \"github.com\", 443, \"GitHub\", null, null)] // fragment\n\n        [InlineData(\"ss://YWVzLTI1Ni1nY206d0xoTjJTVFo@github.com:443/#%F0%9F%91%A9%E2%80%8D%F0%9F%92%BB\", true, \"aes-256-gcm\", \"wLhN2STZ\", \"github.com\", 443, \"\ud83d\udc69\u200d\ud83d\udcbb\", null, null)] // fragment\n\n        [InlineData(\"ss://YWVzLTI1Ni1nY206d0xoTjJTVFo@github.com:443/?plugin=v2ray-plugin\", true, \"aes-256-gcm\", \"wLhN2STZ\", \"github.com\", 443, \"\", \"v2ray-plugin\", null)] // plugin\n\n        [InlineData(\"ss://YWVzLTI1Ni1nY206d0xoTjJTVFo@github.com:443/?plugin=v2ray-plugin%3Bserver%3Btls%3Bhost%3Dgithub.com\", true, \"aes-256-gcm\", \"wLhN2STZ\", \"github.com\", 443, \"\", \"v2ray-plugin\", \"server;tls;host=github.com\")] // plugin + pluginOpts\n\n        [InlineData(\"ss://YWVzLTI1Ni1nY206d0xoTjJTVFo@github.com:443/?plugin=v2ray-plugin%3Bserver%3Btls%3Bhost%3Dgithub.com#GitHub\", true, \"aes-256-gcm\", \"wLhN2STZ\", \"github.com\", 443, \"GitHub\", \"v2ray-plugin\", \"server;tls;host=github.com\")] // fragment + plugin + pluginOpts\n\n        [InlineData(\"ss://Y2hhY2hhMjAtaWV0Zi1wb2x5MTMwNTo2JW04RDlhTUI1YkElYTQl@github.com:443/\", true, \"chacha20-ietf-poly1305\", \"6%m8D9aMB5bA%a4%\", \"github.com\", 443, \"\", null, null)] // userinfo parsing\n\n        [InlineData(\"ss://YWVzLTI1Ni1nY206YnBOZ2sqSjNrYUFZeXhIRQ@github.com:443/\", true, \"aes-256-gcm\", \"bpNgk*J3kaAYyxHE\", \"github.com\", 443, \"\", null, null)] // userinfo parsing\n\n        [InlineData(\"ss://YWVzLTEyOC1nY206dkFBbiY4a1I6JGlBRTQ@github.com:443/\", true, \"aes-128-gcm\", \"vAAn&8kR:$iAE4\", \"github.com\", 443, \"\", null, null)] // userinfo parsing\n\n        [InlineData(\"ss://YWVzLTI1Ni1nY206d0xoTjJTVFpAZ2l0aHViLmNvbTo0NDM\", false, \"\", \"\", \"\", 0, \"\", null, null)] // unsupported legacy URL\n\n        [InlineData(\"ss://YWVzLTI1Ni1nY206d0xoTjJTVFpAZ2l0aHViLmNvbTo0NDM#some-legacy-url\", false, \"\", \"\", \"\", 0, \"\", null, null)] // unsupported legacy URL with fragment\n\n        [InlineData(\"https://github.com/\", false, \"\", \"\", \"\", 0, \"\", null, null)] // non-Shadowsocks URL\n\n        public void Server_TryParse(string ssUrl, bool expectedResult, string expectedMethod, string expectedPassword, string expectedHost, int expectedPort, string expectedFragment, string? expectedPlugin, string? expectedPluginOpts)\n\n        {\n\n            var result = Server.TryParse(ssUrl, out var server);\n\n\n\n            Assert.Equal(expectedResult, result);\n\n            if (result)\n\n            {\n\n                Assert.Equal(expectedPassword, server.Password);\n\n                Assert.Equal(expectedMethod, server.Method);\n\n                Assert.Equal(expectedHost, server.Host);\n\n                Assert.Equal(expectedPort, server.Port);\n\n                Assert.Equal(expectedFragment, server.Name);\n\n                Assert.Equal(expectedPlugin, server.Plugin);\n\n                Assert.Equal(expectedPluginOpts, server.PluginOpts);\n\n            }\n\n        }\n\n   }\n\n}\n", "using System;\n\nusing System.Collections.Generic;\n\nusing System.Linq;\n\nusing System.Text;\n\nusing System.Threading.Tasks;\n\n\n\nnamespace Shadowsocks.Interop.Settings\n\n{\n\n    public class InteropSettings\n\n    {\n\n        public string SsRustPath { get; set; }\n\n        public string V2RayCorePath { get; set; }\n\n\n\n        public InteropSettings()\n\n        {\n\n            SsRustPath = \"\";\n\n            V2RayCorePath = \"\";\n\n        }\n\n    }\n\n}\n", "using Shadowsocks.Models;\n\nusing System.Text.Encodings.Web;\n\nusing System.Text.Json;\n\nusing System.Text.Json.Serialization;\n\n\n\nnamespace Shadowsocks.Interop.Utils\n\n{\n\n    public static class JsonHelper\n\n    {\n\n        public static readonly JsonSerializerOptions camelCaseJsonSerializerOptions = new JsonSerializerOptions()\n\n        {\n\n            DefaultIgnoreCondition = JsonIgnoreCondition.WhenWritingDefault,\n\n            Encoder = JavaScriptEncoder.UnsafeRelaxedJsonEscaping,\n\n            PropertyNamingPolicy = JsonNamingPolicy.CamelCase,\n\n            WriteIndented = true,\n\n        };\n\n\n\n        public static readonly JsonSerializerOptions snakeCaseJsonSerializerOptions = new JsonSerializerOptions()\n\n        {\n\n            DefaultIgnoreCondition = JsonIgnoreCondition.WhenWritingDefault,\n\n            Encoder = JavaScriptEncoder.UnsafeRelaxedJsonEscaping,\n\n            PropertyNamingPolicy = new JsonSnakeCaseNamingPolicy(),\n\n            WriteIndented = true,\n\n        };\n\n\n\n        public static readonly JsonSerializerOptions camelCaseJsonDeserializerOptions = new JsonSerializerOptions()\n\n        {\n\n            AllowTrailingCommas = true,\n\n            PropertyNamingPolicy = JsonNamingPolicy.CamelCase,\n\n            ReadCommentHandling = JsonCommentHandling.Skip,\n\n            WriteIndented = true,\n\n        };\n\n\n\n        public static readonly JsonSerializerOptions snakeCaseJsonDeserializerOptions = new JsonSerializerOptions()\n\n        {\n\n            AllowTrailingCommas = true,\n\n            PropertyNamingPolicy = new JsonSnakeCaseNamingPolicy(),\n\n            ReadCommentHandling = JsonCommentHandling.Skip,\n\n            WriteIndented = true,\n\n        };\n\n    }\n\n}\n", "using Shadowsocks.Models;\n\nusing System.Collections.Generic;\n\nusing System.Text.Json.Serialization;\n\n\n\nnamespace Shadowsocks.Interop.SsRust\n\n{\n\n    public class Config : IGroup<Server>\n\n    {\n\n        /// <inheritdoc/>\n\n        public int Version { get; set; }\n\n\n\n        /// <inheritdoc/>\n\n        public List<Server> Servers { get; set; }\n\n\n\n        /// <summary>\n\n        /// Gets or sets the listening address.\n\n        /// </summary>\n\n        public string LocalAddress { get; set; }\n\n\n\n        /// <summary>\n\n        /// Gets or sets the listening port.\n\n        /// </summary>\n\n        public int LocalPort { get; set; }\n\n\n\n        /// <inheritdoc cref=\"Server.Host\"/>\n\n        [JsonPropertyName(\"server\")]\n\n        public string? Host { get; set; }\n\n\n\n        /// <inheritdoc cref=\"Server.Port\"/>\n\n        [JsonPropertyName(\"server_port\")]\n\n        public int Port { get; set; }\n\n\n\n        /// <inheritdoc cref=\"Server.Password\"/>\n\n        public string? Password { get; set; }\n\n\n\n        /// <inheritdoc cref=\"Server.Method\"/>\n\n        public string? Method { get; set; }\n\n\n\n        /// <inheritdoc cref=\"Server.Plugin\"/>\n\n        public string? Plugin { get; set; }\n\n\n\n        /// <inheritdoc cref=\"Server.PluginOpts\"/>\n\n        public string? PluginOpts { get; set; }\n\n\n\n        /// <inheritdoc cref=\"Server.PluginArgs\"/>\n\n        public List<string>? PluginArgs { get; set; }\n\n\n\n        /// <summary>\n\n        /// Gets or sets the timeout for UDP associations in seconds.\n\n        /// Defaults to 300 seconds (5 minutes).\n\n        /// </summary>\n\n        public int? UdpTimeout { get; set; }\n\n\n\n        /// <summary>\n\n        /// Gets or sets the maximum number of UDP associations.\n\n        /// Defaults to 0 (unlimited).\n\n        /// </summary>\n\n        public int UdpMaxAssociations { get; set; }\n\n\n\n        /// <summary>\n\n        /// Gets or sets the server manager address.\n\n        /// </summary>\n\n        public string? ManagerAddress { get; set; }\n\n\n\n        /// <summary>\n\n        /// Gets or sets the server manager port.\n\n        /// </summary>\n\n        public int ManagerPort { get; set; }\n\n\n\n        /// <summary>\n\n        /// Gets or sets the DNS server used to resolve hostnames.\n\n        /// </summary>\n\n        public string? Dns { get; set; }\n\n\n\n        /// <summary>\n\n        /// Gets or sets the mode.\n\n        /// Defaults to tcp_only.\n\n        /// Can also be tcp_and_udp or udp_only.\n\n        /// </summary>\n\n        public string Mode { get; set; }\n\n\n\n        /// <summary>\n\n        /// Gets or sets TCP_NODELAY.\n\n        /// Defaults to false.\n\n        /// </summary>\n\n        public bool NoDelay { get; set; }\n\n\n\n        /// <summary>\n\n        /// Gets or sets the soft and hard limit of file descriptors.\n\n        /// </summary>\n\n        public int Nofile { get; set; }\n\n\n\n        /// <summary>\n\n        /// Gets or sets whether IPv6 addresses take precedence over IPv4 addresses for resolved hostnames.\n\n        /// Defaults to false.\n\n        /// </summary>\n\n        public bool Ipv6First { get; set; }\n\n        \n\n        public Config()\n\n        {\n\n            Version = 1;\n\n            Servers = new();\n\n            LocalAddress = \"\";\n\n            LocalPort = 1080;\n\n            Mode = \"tcp_only\";\n\n        }\n\n\n\n        /// <summary>\n\n        /// Gets the default configuration for Linux.\n\n        /// </summary>\n\n        public static Config DefaultLinux => new()\n\n        {\n\n            LocalAddress = \"::1\",\n\n            Mode = \"tcp_and_udp\",\n\n            NoDelay = true,\n\n            Nofile = 32768,\n\n            Ipv6First = true,\n\n        };\n\n\n\n        /// <summary>\n\n        /// Gets the default configuration for Windows.\n\n        /// </summary>\n\n        public static Config DefaultWindows => new()\n\n        {\n\n            LocalAddress = \"::1\",\n\n            Mode = \"tcp_and_udp\",\n\n            NoDelay = true,\n\n            Ipv6First = true,\n\n        };\n\n    }\n\n}\n", "using Shadowsocks.Interop.V2Ray.Inbound;\n\nusing Shadowsocks.Interop.V2Ray.Transport;\n\n\n\nnamespace Shadowsocks.Interop.V2Ray\n\n{\n\n    public class InboundObject\n\n    {\n\n        public string Tag { get; set; }\n\n        public string? Listen { get; set; }\n\n        public object? Port { get; set; }\n\n        public string Protocol { get; set; }\n\n        public object? Settings { get; set; }\n\n        public StreamSettingsObject? StreamSettings { get; set; }\n\n        public SniffingObject? Sniffing { get; set; }\n\n        public AllocateObject? Allocate { get; set; }\n\n\n\n        public InboundObject()\n\n        {\n\n            Tag = \"\";\n\n            Protocol = \"\";\n\n        }\n\n\n\n        public static InboundObject DefaultLocalSocks => new()\n\n        {\n\n            Tag = \"socks-in\",\n\n            Listen = \"127.0.0.1\",\n\n            Port = 1080,\n\n            Protocol = \"socks\",\n\n            Settings = Protocols.Socks.InboundConfigurationObject.Default,\n\n            Sniffing = SniffingObject.Default,\n\n        };\n\n\n\n        public static InboundObject DefaultLocalHttp => new()\n\n        {\n\n            Tag = \"http-in\",\n\n            Listen = \"127.0.0.1\",\n\n            Port = 8080,\n\n            Protocol = \"http\",\n\n            Sniffing = SniffingObject.Default,\n\n        };\n\n    }\n\n}\n", "using Shadowsocks.Interop.V2Ray.Reverse;\n\nusing System.Collections.Generic;\n\n\n\nnamespace Shadowsocks.Interop.V2Ray\n\n{\n\n    public class ReverseObject\n\n    {\n\n        public List<BridgeObject> Bridges { get; set; }\n\n        public List<PortalObject> Portals { get; set; }\n\n\n\n        public ReverseObject()\n\n        {\n\n            Bridges = new();\n\n            Portals = new();\n\n        }\n\n    }\n\n}\n", "using Shadowsocks.Interop.V2Ray.Dns;\n\nusing System.Collections.Generic;\n\n\n\nnamespace Shadowsocks.Interop.V2Ray\n\n{\n\n    public class DnsObject\n\n    {\n\n        /// <summary>\n\n        /// Gets or sets the dictionary storing hosts.\n\n        /// The key is the hostname.\n\n        /// The value can either be a hostname or an IP address.\n\n        /// </summary>\n\n        public Dictionary<string, string> Hosts { get; set; }\n\n\n\n        /// <summary>\n\n        /// Gets or sets the list of DNS servers.\n\n        /// A DNS server can either be a <see cref=\"ServerObject\"/> or a string.\n\n        /// </summary>\n\n        public List<object> Servers { get; set; }\n\n\n\n        /// <summary>\n\n        /// Gets or sets the client IP used when sending requests to DNS server.\n\n        /// </summary>\n\n        public string? ClientIp { get; set; }\n\n\n\n        /// <summary>\n\n        /// Gets or sets whether to disable internal DNS cache.\n\n        /// Defaults to false, or DNS cache is enabled.\n\n        /// </summary>\n\n        public bool DisableCache { get; set; }\n\n\n\n        /// <summary>\n\n        /// Gets or sets the inbound tag for DNS traffic.\n\n        /// </summary>\n\n        public string? Tag { get; set; }\n\n\n\n        public DnsObject()\n\n        {\n\n            Hosts = new();\n\n            Servers = new();\n\n        }\n\n    }\n\n}\n", "using Shadowsocks.Interop.V2Ray.Transport;\n\n\n\nnamespace Shadowsocks.Interop.V2Ray\n\n{\n\n    public class TransportObject\n\n    {\n\n        public TcpObject? TcpSettings { get; set; }\n\n        public KcpObject? KcpSettings { get; set; }\n\n        public WebSocketObject? WsSettings { get; set; }\n\n        public HttpObject? HttpSettings { get; set; }\n\n        public QuicObject? QuicSettings { get; set; }\n\n        public DomainSocketObject? DsSettings { get; set; }\n\n    }\n\n}\n", "namespace Shadowsocks.Interop.V2Ray\n\n{\n\n    public class LogObject\n\n    {\n\n        /// <summary>\n\n        /// Gets or sets the path to the access log file.\n\n        /// Defaults to empty, which prints to stdout.\n\n        /// </summary>\n\n        public string Access { get; set; }\n\n\n\n        /// <summary>\n\n        /// Gets or sets the path to the error log file.\n\n        /// Defaults to empty, which prints to stdout.\n\n        /// </summary>\n\n        public string Error { get; set; }\n\n\n\n        /// <summary>\n\n        /// Gets or sets the log level.\n\n        /// Defaults to warning.\n\n        /// Available values: \"debug\" | \"info\" | \"warning\" | \"error\" | \"none\"\n\n        /// </summary>\n\n        public string Loglevel { get; set; }\n\n\n\n        public LogObject()\n\n        {\n\n            Access = \"\";\n\n            Error = \"\";\n\n            Loglevel = \"warning\";\n\n        }\n\n    }\n\n}\n", "namespace Shadowsocks.Interop.V2Ray\n\n{\n\n    public class FakeDnsObject\n\n    {\n\n        /// <summary>\n\n        /// Gets or sets the IP pool CIDR.\n\n        /// </summary>\n\n        public string IpPool { get; set; } = \"198.18.0.0/15\";\n\n\n\n        /// <summary>\n\n        /// Gets or sets the IP pool size.\n\n        /// </summary>\n\n        public long PoolSize { get; set; } = 65535L;\n\n    }\n\n}\n", "namespace Shadowsocks.Interop.V2Ray\n\n{\n\n    public class StatsObject\n\n    {\n\n    }\n\n}\n", "using Shadowsocks.Interop.V2Ray.Routing;\n\nusing System.Collections.Generic;\n\n\n\nnamespace Shadowsocks.Interop.V2Ray\n\n{\n\n    public class RoutingObject\n\n    {\n\n        /// <summary>\n\n        /// Gets or sets the domain strategy used for routing.\n\n        /// Default value: AsIs.\n\n        /// Available values: \"AsIs\" | \"IPIfNonMatch\" | \"IPOnDemand\"\n\n        /// </summary>\n\n        public string DomainStrategy { get; set; }\n\n\n\n        /// <summary>\n\n        /// Gets or sets the domain matcher used for routing.\n\n        /// Default value: \"linear\".\n\n        /// Available values: \"linear\" | \"mph\"\n\n        /// </summary>\n\n        public string DomainMatcher { get; set; }\n\n\n\n        /// <summary>\n\n        /// Gets or sets the list of routing rules.\n\n        /// </summary>\n\n        public List<RuleObject> Rules { get; set; }\n\n\n\n        /// <summary>\n\n        /// Gets or sets the list of load balancers.\n\n        /// </summary>\n\n        public List<BalancerObject>? Balancers { get; set; }\n\n\n\n        public RoutingObject()\n\n        {\n\n            DomainStrategy = \"AsIs\";\n\n            DomainMatcher = \"linear\";\n\n            Rules = new();\n\n        }\n\n\n\n        public static RoutingObject Default => new()\n\n        {\n\n            DomainStrategy = \"IPOnDemand\",\n\n            DomainMatcher = \"mph\",\n\n        };\n\n\n\n        public static RoutingObject DefaultBalancers => new()\n\n        {\n\n            DomainStrategy = \"IPOnDemand\",\n\n            DomainMatcher = \"mph\",\n\n            Balancers = new(),\n\n        };\n\n    }\n\n}\n", "using System.Collections.Generic;\n\n\n\nnamespace Shadowsocks.Interop.V2Ray\n\n{\n\n    public class Config\n\n    {\n\n        public LogObject? Log { get; set; }\n\n        public ApiObject? Api { get; set; }\n\n        public DnsObject? Dns { get; set; }\n\n        public RoutingObject? Routing { get; set; }\n\n        public PolicyObject? Policy { get; set; }\n\n        public List<InboundObject>? Inbounds { get; set; }\n\n        public List<OutboundObject>? Outbounds { get; set; }\n\n        public TransportObject? Transport { get; set; }\n\n        public StatsObject? Stats { get; set; }\n\n        public ReverseObject? Reverse { get; set; }\n\n\n\n        /// <summary>\n\n        /// Gets the default configuration.\n\n        /// </summary>\n\n        public static Config Default => new()\n\n        {\n\n            Log = new(),\n\n            Api = ApiObject.Default,\n\n            Dns = new(),\n\n            Routing = new(),\n\n            Policy = PolicyObject.Default,\n\n            Inbounds = new(),\n\n            Outbounds = new(),\n\n            Stats = new(),\n\n        };\n\n    }\n\n}\n", "using System.Collections.Generic;\n\n\n\nnamespace Shadowsocks.Interop.V2Ray\n\n{\n\n    public class ApiObject\n\n    {\n\n        /// <summary>\n\n        /// Gets or sets the outbound tag for the API.\n\n        /// </summary>\n\n        public string Tag { get; set; }\n\n\n\n        /// <summary>\n\n        /// Gets or sets the list of API services to enable.\n\n        /// </summary>\n\n        public List<string> Services { get; set; }\n\n\n\n        public ApiObject()\n\n        {\n\n            Tag = \"\";\n\n            Services = new();\n\n        }\n\n\n\n        /// <summary>\n\n        /// Gets the default API object.\n\n        /// </summary>\n\n        public static ApiObject Default => new()\n\n        {\n\n            Tag = \"api\",\n\n            Services = new()\n\n            {\n\n                \"HandlerService\",\n\n                \"LoggerService\",\n\n                \"StatsService\",\n\n            },\n\n        };\n\n    }\n\n}\n", "using Shadowsocks.Interop.V2Ray.Policy;\n\nusing System.Collections.Generic;\n\n\n\nnamespace Shadowsocks.Interop.V2Ray\n\n{\n\n    public class PolicyObject\n\n    {\n\n        public Dictionary<string, LevelPolicyObject>? Levels { get; set; }\n\n        public SystemPolicyObject? System { get; set; }\n\n\n\n        /// <summary>\n\n        /// Gets the default policy object.\n\n        /// </summary>\n\n        public static PolicyObject Default => new()\n\n        {\n\n            Levels = new(),\n\n            System = SystemPolicyObject.Default,\n\n        };\n\n    }\n\n}\n", "using Shadowsocks.Interop.V2Ray.Outbound;\n\nusing Shadowsocks.Interop.V2Ray.Transport;\n\nusing Shadowsocks.Models;\n\nusing System;\n\nusing System.Net;\n\n\n\nnamespace Shadowsocks.Interop.V2Ray\n\n{\n\n    public class OutboundObject\n\n    {\n\n        public string Tag { get; set; }\n\n        public string? SendThrough { get; set; }\n\n        public string Protocol { get; set; }\n\n        public object? Settings { get; set; }\n\n        public StreamSettingsObject? StreamSettings { get; set; }\n\n        public ProxySettingsObject? ProxySettings { get; set; }\n\n        public MuxObject? Mux { get; set; }\n\n\n\n        public OutboundObject()\n\n        {\n\n            Tag = \"\";\n\n            Protocol = \"\";\n\n        }\n\n\n\n        /// <summary>\n\n        /// Gets the <see cref=\"OutboundObject\"/> for the SOCKS server.\n\n        /// </summary>\n\n        /// <param name=\"name\">SOCKS server name. Used as outbound tag.</param>\n\n        /// <param name=\"socksEndPoint\">The SOCKS server.</param>\n\n        /// <param name=\"username\"></param>\n\n        /// <param name=\"password\"></param>\n\n        /// <returns></returns>\n\n        public static OutboundObject GetSocks(string name, DnsEndPoint socksEndPoint, string username = \"\", string password = \"\") => new()\n\n        {\n\n            Tag = name,\n\n            Protocol = \"socks\",\n\n            Settings = new Protocols.Socks.OutboundConfigurationObject(socksEndPoint, username, password),\n\n        };\n\n\n\n        /// <summary>\n\n        /// Gets the <see cref=\"OutboundObject\"/> for the Shadowsocks server.\n\n        /// Plugins are not supported.\n\n        /// </summary>\n\n        /// <param name=\"server\"></param>\n\n        /// <returns></returns>\n\n        public static OutboundObject GetShadowsocks(IServer server)\n\n        {\n\n            if (!string.IsNullOrEmpty(server.Plugin))\n\n                throw new InvalidOperationException(\"V2Ray doesn't support SIP003 plugins.\");\n\n            \n\n            return new()\n\n            {\n\n                Tag = server.Name,\n\n                Protocol = \"shadowsocks\",\n\n                Settings = new Protocols.Shadowsocks.OutboundConfigurationObject(server.Host, server.Port, server.Method, server.Password),\n\n            };\n\n        }\n\n\n\n        /// <summary>\n\n        /// Gets the <see cref=\"OutboundObject\"/> for the Trojan server.\n\n        /// </summary>\n\n        /// <param name=\"address\"></param>\n\n        /// <param name=\"port\"></param>\n\n        /// <param name=\"password\"></param>\n\n        /// <returns></returns>\n\n        public static OutboundObject GetTrojan(string name, string address, int port, string password) => new()\n\n        {\n\n            Tag = name,\n\n            Protocol = \"trojan\",\n\n            Settings = new Protocols.Trojan.OutboundConfigurationObject(address, port, password),\n\n        };\n\n\n\n        /// <summary>\n\n        /// Gets the <see cref=\"OutboundObject\"/> for the VMess server.\n\n        /// </summary>\n\n        /// <param name=\"name\"></param>\n\n        /// <param name=\"address\"></param>\n\n        /// <param name=\"port\"></param>\n\n        /// <param name=\"id\"></param>\n\n        /// <returns></returns>\n\n        public static OutboundObject GetVMess(string name, string address, int port, string id) => new()\n\n        {\n\n            Tag = name,\n\n            Protocol = \"vmess\",\n\n            Settings = new Protocols.VMess.OutboundConfigurationObject(address, port, id),\n\n        };\n\n    }\n\n}\n", "namespace Shadowsocks.Interop.V2Ray.Reverse\n\n{\n\n    public class BridgeObject\n\n    {\n\n        /// <summary>\n\n        /// Gets or sets the inbound tag for the bridge.\n\n        /// </summary>\n\n        public string Tag { get; set; }\n\n\n\n        /// <summary>\n\n        /// Gets or sets the domain name for the bridge.\n\n        /// Can be omitted.\n\n        /// </summary>\n\n        public string? Domain { get; set; }\n\n\n\n        public BridgeObject()\n\n        {\n\n            Tag = \"\";\n\n        }\n\n    }\n\n}\n", "namespace Shadowsocks.Interop.V2Ray.Reverse\n\n{\n\n    public class PortalObject\n\n    {\n\n        /// <summary>\n\n        /// Gets or sets the outbound tag for the portal.\n\n        /// </summary>\n\n        public string Tag { get; set; }\n\n\n\n        /// <summary>\n\n        /// Gets or sets the domain name for the portal.\n\n        /// </summary>\n\n        public string Domain { get; set; }\n\n\n\n        public PortalObject()\n\n        {\n\n            Tag = \"\";\n\n            Domain = \"\";\n\n        }\n\n    }\n\n}\n", "namespace Shadowsocks.Interop.V2Ray.Outbound\n\n{\n\n    public class ProxySettingsObject\n\n    {\n\n        /// <summary>\n\n        /// Gets or sets the tag of the outbound\n\n        /// used as the proxy.\n\n        /// </summary>\n\n        public string Tag { get; set; }\n\n\n\n        /// <summary>\n\n        /// Gets or sets whether to keep the protocol\n\n        /// itself's transport layer intact.\n\n        /// Defaults to false, or only proxy internal TCP traffic.\n\n        /// Set to true to proxy the protocol.\n\n        /// The tag will act as a forward proxy.\n\n        /// </summary>\n\n        public bool TransportLayer { get; set; }\n\n\n\n        public ProxySettingsObject()\n\n        {\n\n            Tag = \"\";\n\n        }\n\n\n\n        public static ProxySettingsObject Default => new()\n\n        {\n\n            TransportLayer = true,\n\n        };\n\n    }\n\n}\n", "namespace Shadowsocks.Interop.V2Ray.Outbound\n\n{\n\n    public class MuxObject\n\n    {\n\n        /// <summary>\n\n        /// Gets or sets whether to enable mux.\n\n        /// Defaults to false (disabled).\n\n        /// </summary>\n\n        public bool Enabled { get; set; }\n\n\n\n        /// <summary>\n\n        /// Gets or sets the concurrency for a single TCP connection when using mux.\n\n        /// Defaults to 8.\n\n        /// Range: [1, 1024].\n\n        /// Set to -1 to disable the mux module.\n\n        /// </summary>\n\n        public int Concurrency { get; set; }\n\n\n\n        public MuxObject()\n\n        {\n\n            Enabled = false;\n\n            Concurrency = 8;\n\n        }\n\n    }\n\n}\n", "namespace Shadowsocks.Interop.V2Ray.Policy\n\n{\n\n    public class LevelPolicyObject\n\n    {\n\n        public int? Handshake { get; set; }\n\n        public int? ConnIdle { get; set; }\n\n        public int? UplinkOnly { get; set; }\n\n        public int? DownlinkOnly { get; set; }\n\n        public bool? StatsUserUplink { get; set; }\n\n        public bool? StatsUserDownlink { get; set; }\n\n        public int? BufferSize { get; set; }\n\n\n\n        public static LevelPolicyObject Default => new()\n\n        {\n\n            Handshake = 4,\n\n            ConnIdle = 300,\n\n            UplinkOnly = 2,\n\n            DownlinkOnly = 5,\n\n            StatsUserUplink = false,\n\n            StatsUserDownlink = false,\n\n            BufferSize = 512,\n\n        };\n\n    }\n\n}\n", "namespace Shadowsocks.Interop.V2Ray.Policy\n\n{\n\n    public class SystemPolicyObject\n\n    {\n\n        public bool StatsInboundUplink { get; set; }\n\n        public bool StatsInboundDownlink { get; set; }\n\n        public bool StatsOutboundUplink { get; set; }\n\n        public bool StatsOutboundDownlink { get; set; }\n\n\n\n        public static SystemPolicyObject Default => new()\n\n        {\n\n            StatsInboundUplink = true,\n\n            StatsInboundDownlink = true,\n\n            StatsOutboundUplink = true,\n\n            StatsOutboundDownlink = true,\n\n        };\n\n    }\n\n}\n", "namespace Shadowsocks.Interop.V2Ray.Protocols\n\n{\n\n    public class AccountObject\n\n    {\n\n        public string User { get; set; }\n\n        public string Pass { get; set; }\n\n\n\n        public AccountObject()\n\n        {\n\n            User = \"\";\n\n            Pass = \"\";\n\n        }\n\n    }\n\n}\n", "namespace Shadowsocks.Interop.V2Ray.Protocols\n\n{\n\n    public class UserObject : AccountObject\n\n    {\n\n        public int Level { get; set; }\n\n    }\n\n}\n", "using System.Collections.Generic;\n\n\n\nnamespace Shadowsocks.Interop.V2Ray.Protocols.VMess\n\n{\n\n    public class OutboundConfigurationObject\n\n    {\n\n        public List<ServerObject> Vnext { get; set; }\n\n\n\n        public OutboundConfigurationObject()\n\n        {\n\n            Vnext = new();\n\n        }\n\n\n\n        public OutboundConfigurationObject(string address, int port, string id)\n\n        {\n\n            Vnext = new()\n\n            {\n\n                new(address, port, id),\n\n            };\n\n        }\n\n    }\n\n}\n", "using System.Collections.Generic;\n\n\n\nnamespace Shadowsocks.Interop.V2Ray.Protocols.VMess\n\n{\n\n    public class ServerObject\n\n    {\n\n        public string Address { get; set; }\n\n        public int Port { get; set; }\n\n        public List<UserObject> Users { get; set; }\n\n\n\n        public ServerObject()\n\n        {\n\n            Address = \"\";\n\n            Port = 0;\n\n            Users = new();\n\n        }\n\n\n\n        public ServerObject(string address, int port, string id)\n\n        {\n\n            Address = address;\n\n            Port = port;\n\n            Users = new()\n\n            {\n\n                new(id),\n\n            };\n\n        }\n\n    }\n\n}\n", "using System.Collections.Generic;\n\n\n\nnamespace Shadowsocks.Interop.V2Ray.Protocols.VMess\n\n{\n\n    public class InboundConfigurationObject\n\n    {\n\n        public List<UserObject> Clients { get; set; }\n\n        public UserObject? Default { get; set; }\n\n        public DetourObject? Detour { get; set; }\n\n\n\n        public InboundConfigurationObject()\n\n        {\n\n            Clients = new();\n\n        }\n\n    }\n\n}\n", "namespace Shadowsocks.Interop.V2Ray.Protocols.VMess\n\n{\n\n    public class DetourObject\n\n    {\n\n        public string To { get; set; }\n\n\n\n        public DetourObject()\n\n        {\n\n            To = \"\";\n\n        }\n\n    }\n\n}\n", "using System;\n\n\n\nnamespace Shadowsocks.Interop.V2Ray.Protocols.VMess\n\n{\n\n    /// <summary>\n\n    /// The user object for VMess AEAD.\n\n    /// </summary>\n\n    public class UserObject\n\n    {\n\n        public string Id { get; set; }\n\n        public string? Email { get; set; }\n\n        public int Level { get; set; }\n\n\n\n        public UserObject(string id = \"\")\n\n        {\n\n            Id = id;\n\n        }\n\n\n\n        public static UserObject Default => new()\n\n        {\n\n            Id = Guid.NewGuid().ToString(),\n\n        };\n\n    }\n\n}\n", "namespace Shadowsocks.Interop.V2Ray.Protocols.Freedom\n\n{\n\n    public class OutboundConfigurationObject\n\n    {\n\n        public string DomainStrategy { get; set; }\n\n        public string? Redirect { get; set; }\n\n        public int? UserLevel { get; set; }\n\n\n\n        public OutboundConfigurationObject()\n\n        {\n\n            DomainStrategy = \"AsIs\";\n\n        }\n\n    }\n\n}\n", "using System.Collections.Generic;\n\nusing System.Net;\n\n\n\nnamespace Shadowsocks.Interop.V2Ray.Protocols.Socks\n\n{\n\n    public class OutboundConfigurationObject\n\n    {\n\n        public List<ServerObject> Servers { get; set; }\n\n\n\n        public OutboundConfigurationObject()\n\n        {\n\n            Servers = new();\n\n        }\n\n\n\n        public OutboundConfigurationObject(DnsEndPoint socksEndPoint, string username = \"\", string password = \"\")\n\n        {\n\n            Servers = new()\n\n            {\n\n                new(socksEndPoint, username, password),\n\n            };\n\n        }\n\n    }\n\n}\n", "using System.Collections.Generic;\n\nusing System.Net;\n\n\n\nnamespace Shadowsocks.Interop.V2Ray.Protocols.Socks\n\n{\n\n    public class ServerObject\n\n    {\n\n        public string Address { get; set; }\n\n        public int Port { get; set; }\n\n        public List<UserObject>? Users { get; set; }\n\n\n\n        public ServerObject()\n\n        {\n\n            Address = \"\";\n\n            Port = 0;\n\n        }\n\n\n\n        public ServerObject(DnsEndPoint socksEndPoint, string? username = null, string? password = null)\n\n        {\n\n            Address = socksEndPoint.Host;\n\n            Port = socksEndPoint.Port;\n\n            Users = new();\n\n            var hasCredential = !string.IsNullOrEmpty(username) && !string.IsNullOrEmpty(password);\n\n            if (hasCredential)\n\n            {\n\n                var user = new UserObject()\n\n                {\n\n                    User = username!, // null check already performed at line 23.\n\n                    Pass = password!,\n\n                };\n\n                Users = new()\n\n                {\n\n                    user,\n\n                };\n\n            }\n\n        }\n\n    }\n\n}\n", "using System.Collections.Generic;\n\n\n\nnamespace Shadowsocks.Interop.V2Ray.Protocols.Socks\n\n{\n\n    public class InboundConfigurationObject\n\n    {\n\n        public string? Auth { get; set; }\n\n        public List<AccountObject>? Accounts { get; set; }\n\n        public bool? Udp { get; set; }\n\n        public string? Ip { get; set; }\n\n        public int? UserLevel { get; set; }\n\n\n\n        public static InboundConfigurationObject Default => new()\n\n        {\n\n            Udp = true,\n\n            Ip = \"127.0.0.1\",\n\n        };\n\n    }\n\n}\n", "using System.Collections.Generic;\n\n\n\nnamespace Shadowsocks.Interop.V2Ray.Protocols.Shadowsocks\n\n{\n\n    public class OutboundConfigurationObject\n\n    {\n\n        public List<ServerObject> Servers { get; set; }\n\n\n\n        public OutboundConfigurationObject()\n\n        {\n\n            Servers = new();\n\n        }\n\n\n\n        public OutboundConfigurationObject(string address, int port, string method, string password)\n\n        {\n\n            Servers = new()\n\n            {\n\n                new(address, port, method, password),\n\n            };\n\n        }\n\n    }\n\n}\n", "using System.Text.Json.Serialization;\n\n\n\nnamespace Shadowsocks.Interop.V2Ray.Protocols.Shadowsocks\n\n{\n\n    public class ServerObject\n\n    {\n\n        public string? Email { get; set; }\n\n\n\n        public string Address { get; set; }\n\n\n\n        public int Port { get; set; }\n\n\n\n        public string Method { get; set; }\n\n\n\n        public string Password { get; set; }\n\n\n\n        public int? Level { get; set; }\n\n\n\n        public ServerObject()\n\n        {\n\n            Address = \"\";\n\n            Port = 8388;\n\n            Method = \"chacha20-ietf-poly1305\";\n\n            Password = \"\";\n\n        }\n\n\n\n        public ServerObject(string address, int port, string method, string password)\n\n        {\n\n            Address = address;\n\n            Port = port;\n\n            Method = method;\n\n            Password = password;\n\n        }\n\n    }\n\n}\n", "using System;\n\nusing System.Text.Json.Serialization;\n\n\n\nnamespace Shadowsocks.Interop.V2Ray.Protocols.Shadowsocks\n\n{\n\n    public class InboundConfigurationObject\n\n    {\n\n        public string? Email { get; set; }\n\n        \n\n        public string Method { get; set; }\n\n\n\n        public string Password { get; set; }\n\n\n\n        public int? Level { get; set; }\n\n\n\n        public string Network { get; set; }\n\n\n\n        public InboundConfigurationObject()\n\n        {\n\n            Method = \"chacha20-ietf-poly1305\";\n\n            Password = Guid.NewGuid().ToString();\n\n            Network = \"tcp,udp\";\n\n        }\n\n    }\n\n}\n", "namespace Shadowsocks.Interop.V2Ray.Protocols.Trojan\n\n{\n\n    public class FallbackObject\n\n    {\n\n        public string? Alpn { get; set; }\n\n        public string? Path { get; set; }\n\n        public object Dest { get; set; }\n\n        public int? Xver { get; set; }\n\n\n\n        public FallbackObject()\n\n        {\n\n            Dest = 0;\n\n        }\n\n\n\n        public static FallbackObject Default => new()\n\n        {\n\n            Alpn = \"\",\n\n            Path = \"\",\n\n            Xver = 0,\n\n        };\n\n    }\n\n}\n", "namespace Shadowsocks.Interop.V2Ray.Protocols.Trojan\n\n{\n\n    public class ClientObject\n\n    {\n\n        public string Password { get; set; }\n\n        public string? Email { get; set; }\n\n        public int? Level { get; set; }\n\n\n\n        public ClientObject()\n\n        {\n\n            Password = \"\";\n\n        }\n\n    }\n\n}\n", "using System.Collections.Generic;\n\n\n\nnamespace Shadowsocks.Interop.V2Ray.Protocols.Trojan\n\n{\n\n    public class OutboundConfigurationObject\n\n    {\n\n        public List<ServerObject> Servers { get; set; }\n\n\n\n        public OutboundConfigurationObject()\n\n        {\n\n            Servers = new();\n\n        }\n\n\n\n        public OutboundConfigurationObject(string address, int port, string password)\n\n        {\n\n            Servers = new()\n\n            {\n\n                new(address, port, password),\n\n            };\n\n        }\n\n    }\n\n}\n", "namespace Shadowsocks.Interop.V2Ray.Protocols.Trojan\n\n{\n\n    public class ServerObject\n\n    {\n\n        public string Address { get; set; }\n\n        public int Port { get; set; }\n\n        public string Password { get; set; }\n\n        public string? Email { get; set; }\n\n        public int? Level { get; set; }\n\n\n\n        public ServerObject()\n\n        {\n\n            Address = \"\";\n\n            Port = 0;\n\n            Password = \"\";\n\n        }\n\n\n\n        public ServerObject(string address, int port, string password)\n\n        {\n\n            Address = address;\n\n            Port = port;\n\n            Password = password;\n\n        }\n\n    }\n\n}\n", "using System.Collections.Generic;\n\n\n\nnamespace Shadowsocks.Interop.V2Ray.Protocols.Trojan\n\n{\n\n    public class InboundConfigurationObject\n\n    {\n\n        public List<ClientObject> Clients { get; set; }\n\n        public List<FallbackObject> Fallbacks { get; set; }\n\n\n\n        public InboundConfigurationObject()\n\n        {\n\n            Clients = new();\n\n            Fallbacks = new();\n\n        }\n\n    }\n\n}\n", "using System.Collections.Generic;\n\n\n\nnamespace Shadowsocks.Interop.V2Ray.Dns\n\n{\n\n    public class ServerObject\n\n    {\n\n        /// <summary>\n\n        /// Gets or sets the DNS server address.\n\n        /// Supports UDP and DoH.\n\n        /// </summary>\n\n        public string Address { get; set; }\n\n\n\n        /// <summary>\n\n        /// Gets or sets the DNS server port.\n\n        /// Defaults to 53.\n\n        /// </summary>\n\n        public int Port { get; set; }\n\n\n\n        /// <summary>\n\n        /// Gets or sets the client IP\n\n        /// to include in DNS queries.\n\n        /// </summary>\n\n        public string? ClientIp { get; set; }\n\n\n\n        /// <summary>\n\n        /// Gets or sets the list of domains\n\n        /// that prefers this DNS server.\n\n        /// </summary>\n\n        public List<string> Domains { get; set; }\n\n\n\n        /// <summary>\n\n        /// Gets or sets the ranges of IP addresses\n\n        /// this DNS server is expected to return.\n\n        /// </summary>\n\n        public List<string> ExpectIPs { get; set; }\n\n\n\n        public ServerObject()\n\n        {\n\n            Address = \"\";\n\n            Port = 53;\n\n            Domains = new();\n\n            ExpectIPs = new();\n\n        }\n\n    }\n\n}\n", "using System.Collections.Generic;\n\n\n\nnamespace Shadowsocks.Interop.V2Ray.Transport\n\n{\n\n    public class CertificateObject\n\n    {\n\n        public string Usage { get; set; }\n\n        public string? CertificateFile { get; set; }\n\n        public string? KeyFile { get; set; }\n\n        public List<string>? Certificate { get; set; }\n\n        public List<string>? Key { get; set; }\n\n\n\n        public CertificateObject()\n\n        {\n\n            Usage = \"encipherment\";\n\n        }\n\n\n\n        public static CertificateObject DefaultFromFile => new()\n\n        {\n\n            CertificateFile = \"\",\n\n            KeyFile = \"\",\n\n        };\n\n\n\n        public static CertificateObject DefaultEmbedded => new()\n\n        {\n\n            Certificate = new(),\n\n            Key = new(),\n\n        };\n\n    }\n\n}\n", "namespace Shadowsocks.Interop.V2Ray.Transport\n\n{\n\n    public class SockoptObject\n\n    {\n\n        public int Mark { get; set; }\n\n        public bool TcpFastOpen { get; set; }\n\n        public string? Tproxy { get; set; }\n\n\n\n        public static SockoptObject DefaultLinux => new()\n\n        {\n\n            Tproxy = \"off\",\n\n        };\n\n    }\n\n}\n", "namespace Shadowsocks.Interop.V2Ray.Transport\n\n{\n\n    public class StreamSettingsObject : TransportObject\n\n    {\n\n        /// <summary>\n\n        /// Gets or sets the transport protocol type.\n\n        /// Defaults to \"tcp\".\n\n        /// Available values: \"tcp\" | \"kcp\" | \"ws\" | \"http\" | \"domainsocket\" | \"quic\"\n\n        /// </summary>\n\n        public string? Network { get; set; }\n\n\n\n        /// <summary>\n\n        /// Gets or sets the transport encryption type.\n\n        /// Defaults to \"none\" (no encryption).\n\n        /// Available values: \"none\" | \"tls\"\n\n        /// </summary>\n\n        public string? Security { get; set; }\n\n\n\n        public TlsObject? TlsSettings { get; set; }\n\n        public SockoptObject? Sockopt { get; set; }\n\n\n\n        public static StreamSettingsObject DefaultWsTls => new()\n\n        {\n\n            Network = \"ws\",\n\n            Security = \"tls\",\n\n            TlsSettings = new(),\n\n        };\n\n    }\n\n}\n", "namespace Shadowsocks.Interop.V2Ray.Transport\n\n{\n\n    public class DomainSocketObject\n\n    {\n\n        /// <summary>\n\n        /// Gets or sets the path to the unix domain socket file.\n\n        /// </summary>\n\n        public string Path { get; set; }\n\n\n\n        /// <summary>\n\n        /// Gets or sets whether the domain socket is abstract.\n\n        /// Defaults to false.\n\n        /// </summary>\n\n        public bool Abstract { get; set; }\n\n\n\n        /// <summary>\n\n        /// Gets or sets whether padding is used.\n\n        /// Defaults to false.\n\n        /// </summary>\n\n        public bool Padding { get; set; }\n\n\n\n        public DomainSocketObject()\n\n        {\n\n            Path = \"\";\n\n            Abstract = false;\n\n            Padding = false;\n\n        }\n\n    }\n\n}\n", "using Shadowsocks.Interop.V2Ray.Transport.Header;\n\n\n\nnamespace Shadowsocks.Interop.V2Ray.Transport\n\n{\n\n    public class TcpObject\n\n    {\n\n        /// <summary>\n\n        /// Gets or sets whether to use PROXY protocol.\n\n        /// </summary>\n\n        public bool AcceptProxyProtocol { get; set; }\n\n\n\n        /// <summary>\n\n        /// Gets or sets the header options.\n\n        /// </summary>\n\n        public object Header { get; set; }\n\n\n\n        public TcpObject()\n\n        {\n\n            AcceptProxyProtocol = false;\n\n            Header = new HeaderObject();\n\n        }\n\n\n\n        public static TcpObject DefaultHttp => new()\n\n        {\n\n            Header = new HttpHeaderObject(),\n\n        };\n\n    }\n\n}\n", "using System.Collections.Generic;\n\n\n\nnamespace Shadowsocks.Interop.V2Ray.Transport\n\n{\n\n    public class WebSocketObject\n\n    {\n\n        /// <summary>\n\n        /// Gets or sets whether to use PROXY protocol.\n\n        /// </summary>\n\n        public bool AcceptProxyProtocol { get; set; }\n\n\n\n        /// <summary>\n\n        /// Gets or sets the HTTP query path.\n\n        /// Defaults to \"/\".\n\n        /// </summary>\n\n        public string Path { get; set; }\n\n\n\n        /// <summary>\n\n        /// Gets or sets HTTP header key-value pairs.\n\n        /// Defaults to empty.\n\n        /// </summary>\n\n        public Dictionary<string, string> Headers { get; set; }\n\n\n\n        public WebSocketObject()\n\n        {\n\n            AcceptProxyProtocol = false;\n\n            Path = \"/\";\n\n            Headers = new();\n\n        }\n\n    }\n\n}\n", "using System.Collections.Generic;\n\n\n\nnamespace Shadowsocks.Interop.V2Ray.Transport\n\n{\n\n    public class TlsObject\n\n    {\n\n        public string? ServerName { get; set; }\n\n        public bool AllowInsecure { get; set; }\n\n        public List<string>? Alpn { get; set; }\n\n        public List<CertificateObject>? Certificates { get; set; }\n\n        public bool DisableSystemRoot { get; set; }\n\n    }\n\n}\n", "using System.Collections.Generic;\n\n\n\nnamespace Shadowsocks.Interop.V2Ray.Transport\n\n{\n\n    public class HttpObject\n\n    {\n\n        public List<string> Host { get; set; }\n\n        public string Path { get; set; }\n\n\n\n        public HttpObject()\n\n        {\n\n            Host = new();\n\n            Path = \"/\";\n\n        }\n\n    }\n\n}\n", "using Shadowsocks.Interop.V2Ray.Transport.Header;\n\n\n\nnamespace Shadowsocks.Interop.V2Ray.Transport\n\n{\n\n    public class QuicObject\n\n    {\n\n        /// <summary>\n\n        /// Gets or sets the encryption method.\n\n        /// Defaults to \"none\" (no encryption).\n\n        /// Available values: \"none\" | \"aes-128-gcm\" | \"chacha20-poly1305\"\n\n        /// </summary>\n\n        public string Security { get; set; }\n\n\n\n        /// <summary>\n\n        /// Gets or sets the encryption key.\n\n        /// </summary>\n\n        public string Key { get; set; }\n\n\n\n        /// <summary>\n\n        /// Gets or sets the header options.\n\n        /// </summary>\n\n        public HeaderObject Header { get; set; }\n\n\n\n        public QuicObject()\n\n        {\n\n            Security = \"none\";\n\n            Key = \"\";\n\n            Header = new();\n\n        }\n\n    }\n\n}\n", "using Shadowsocks.Interop.V2Ray.Transport.Header;\n\n\n\nnamespace Shadowsocks.Interop.V2Ray.Transport\n\n{\n\n    public class KcpObject\n\n    {\n\n        public int Mtu { get; set; }\n\n        public int Tti { get; set; }\n\n        public int UplinkCapacity { get; set; }\n\n        public int DownlinkCapacity { get; set; }\n\n        public bool Congestion { get; set; }\n\n        public int ReadBufferSize { get; set; }\n\n        public int WriteBufferSize { get; set; }\n\n        public HeaderObject Header { get; set; }\n\n        public string Seed { get; set; }\n\n\n\n        public KcpObject()\n\n        {\n\n            Mtu = 1350;\n\n            Tti = 50;\n\n            UplinkCapacity = 5;\n\n            DownlinkCapacity = 20;\n\n            Congestion = false;\n\n            ReadBufferSize = 2;\n\n            WriteBufferSize = 2;\n\n            Header = new();\n\n            Seed = \"\";\n\n        }\n\n    }\n\n}\n", "namespace Shadowsocks.Interop.V2Ray.Transport.Header\n\n{\n\n    public class HeaderObject\n\n    {\n\n        /// <summary>\n\n        /// Gets or sets the header type.\n\n        /// Defaults to none.\n\n        /// Available values:\n\n        /// none\n\n        /// srtp\n\n        /// utp\n\n        /// wechat-video\n\n        /// dtls\n\n        /// wireguard\n\n        /// </summary>\n\n        public string Type { get; set; }\n\n\n\n        public HeaderObject()\n\n        {\n\n            Type = \"none\";\n\n        }\n\n    }\n\n}\n", "using Shadowsocks.Interop.V2Ray.Transport.Header.Http;\n\n\n\nnamespace Shadowsocks.Interop.V2Ray.Transport.Header\n\n{\n\n    public class HttpHeaderObject : HeaderObject\n\n    {\n\n        public HttpRequestObject request { get; set; }\n\n\n\n        public HttpResponseObject response { get; set; }\n\n\n\n        public HttpHeaderObject()\n\n        {\n\n            Type = \"http\";\n\n            request = new();\n\n            response = new();\n\n        }\n\n    }\n\n}\n", "using System.Collections.Generic;\n\n\n\nnamespace Shadowsocks.Interop.V2Ray.Transport.Header.Http\n\n{\n\n    public class HttpRequestObject\n\n    {\n\n        public string Version { get; set; }\n\n        public string Method { get; set; }\n\n        public List<string> Path { get; set; }\n\n        public Dictionary<string, List<string>> Headers { get; set; }\n\n\n\n        public HttpRequestObject()\n\n        {\n\n            Version = \"1.1\";\n\n            Method = \"GET\";\n\n            Path = new()\n\n            {\n\n                \"/\",\n\n            };\n\n            Headers = new()\n\n            {\n\n                [\"Host\"] = new()\n\n                {\n\n                    \"www.baidu.com\",\n\n                    \"www.bing.com\",\n\n                },\n\n                [\"User-Agent\"] = new()\n\n                {\n\n                    \"Mozilla/5.0 (Windows NT 10.0; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/53.0.2785.143 Safari/537.36\",\n\n                    \"Mozilla/5.0 (iPhone; CPU iPhone OS 10_0_2 like Mac OS X) AppleWebKit/601.1 (KHTML, like Gecko) CriOS/53.0.2785.109 Mobile/14A456 Safari/601.1.46\",\n\n                },\n\n                [\"Accept-Encoding\"] = new()\n\n                {\n\n                    \"gzip, deflate\",\n\n                },\n\n                [\"Connection\"] = new()\n\n                {\n\n                    \"keep-alive\",\n\n                },\n\n                [\"Pragma\"] = new()\n\n                {\n\n                    \"no-cache\",\n\n                },\n\n            };\n\n        }\n\n    }\n\n}\n", "using System.Collections.Generic;\n\n\n\nnamespace Shadowsocks.Interop.V2Ray.Transport.Header.Http\n\n{\n\n    public class HttpResponseObject\n\n    {\n\n        public string Version { get; set; }\n\n        public string Status { get; set; }\n\n        public string Reason { get; set; }\n\n        public Dictionary<string, List<string>> Headers { get; set; }\n\n\n\n        public HttpResponseObject()\n\n        {\n\n            Version = \"1.1\";\n\n            Status = \"200\";\n\n            Reason = \"OK\";\n\n            Headers = new()\n\n            {\n\n                [\"Content-Type\"] = new()\n\n                {\n\n                    \"application/octet-stream\",\n\n                    \"video/mpeg\",\n\n                },\n\n                [\"Transfer-Encoding\"] = new()\n\n                {\n\n                    \"chunked\",\n\n                },\n\n                [\"Connection\"] = new()\n\n                {\n\n                    \"keep-alive\",\n\n                },\n\n                [\"Pragma\"] = new()\n\n                {\n\n                    \"no-cache\",\n\n                },\n\n                [\"Cache-Control\"] = new()\n\n                {\n\n                    \"private\",\n\n                    \"no-cache\",\n\n                },\n\n            };\n\n        }\n\n    }\n\n}\n", "namespace Shadowsocks.Interop.V2Ray.Inbound\n\n{\n\n    public class AllocateObject\n\n    {\n\n        /// <summary>\n\n        /// Gets or sets the port allocation strategy.\n\n        /// Defaults to \"always\".\n\n        /// Available values: \"always\" | \"random\"\n\n        /// </summary>\n\n        public string Strategy { get; set; }\n\n\n\n        /// <summary>\n\n        /// Gets or sets the random port refreshing interval in minutes.\n\n        /// Defaults to 5 minutes.\n\n        /// </summary>\n\n        public int? Refresh { get; set; }\n\n\n\n        /// <summary>\n\n        /// Gets or sets the number of random ports.\n\n        /// Defaults to 3.\n\n        /// </summary>\n\n        public int? Concurrency { get; set; }\n\n\n\n        public AllocateObject()\n\n        {\n\n            Strategy = \"always\";\n\n        }\n\n\n\n        public static AllocateObject Default => new()\n\n        {\n\n            Refresh = 5,\n\n            Concurrency = 3,\n\n        };\n\n    }\n\n}\n", "using System.Collections.Generic;\n\n\n\nnamespace Shadowsocks.Interop.V2Ray.Inbound\n\n{\n\n    public class SniffingObject\n\n    {\n\n        /// <summary>\n\n        /// Gets or sets whether to enable sniffing.\n\n        /// Defaults to true (enabled).\n\n        /// </summary>\n\n        public bool Enabled { get; set; }\n\n\n\n        /// <summary>\n\n        /// Gets or sets the list of protocols that destination override is enabled.\n\n        /// </summary>\n\n        public List<string> DestOverride { get; set; }\n\n\n\n        /// <summary>\n\n        /// Gets or sets whether the target address is sniffed\n\n        /// solely based on metadata.\n\n        /// Defaults to false.\n\n        /// Change to true to use FakeDNS.\n\n        /// </summary>\n\n        public bool MetadataOnly { get; set; }\n\n\n\n        public SniffingObject()\n\n        {\n\n            Enabled = true;\n\n            DestOverride = new()\n\n            {\n\n                \"http\",\n\n                \"tls\",\n\n            };\n\n        }\n\n\n\n        public static SniffingObject Default => new()\n\n        {\n\n            Enabled = false,\n\n            DestOverride = new()\n\n            {\n\n                \"http\",\n\n                \"tls\",\n\n            },\n\n        };\n\n\n\n        public static SniffingObject DefaultFakeDns => new()\n\n        {\n\n            Enabled = true,\n\n            DestOverride = new()\n\n            {\n\n                \"http\",\n\n                \"tls\",\n\n                \"fakedns\",\n\n            },\n\n            MetadataOnly = true,\n\n        };\n\n    }\n\n}\n", "using System.Collections.Generic;\n\n\n\nnamespace Shadowsocks.Interop.V2Ray.Routing\n\n{\n\n    public class BalancerObject\n\n    {\n\n        /// <summary>\n\n        /// Gets or sets the outbound tag for the load balancer.\n\n        /// </summary>\n\n        public string Tag { get; set; }\n\n\n\n        /// <summary>\n\n        /// Gets or sets a list of outbound tags\n\n        /// to include in the load balancer.\n\n        /// </summary>\n\n        public List<string> Selector { get; set; }\n\n\n\n        public BalancerObject()\n\n        {\n\n            Tag = \"\";\n\n            Selector = new();\n\n        }\n\n    }\n\n}\n", "using System.Collections.Generic;\n\nusing System.Text.Json.Serialization;\n\n\n\nnamespace Shadowsocks.Interop.V2Ray.Routing\n\n{\n\n    public class RuleObject\n\n    {\n\n        [JsonIgnore(Condition = JsonIgnoreCondition.Never)]\n\n        public string Type { get; set; }\n\n        public List<string>? Domain { get; set; }\n\n        public List<string>? Ip { get; set; }\n\n        public object? Port { get; set; }\n\n        public object? SourcePort { get; set; }\n\n        public string? Network { get; set; }\n\n        public List<string>? Source { get; set; }\n\n        public List<string>? User { get; set; }\n\n        public List<string>? InboundTag { get; set; }\n\n        public List<string>? Protocol { get; set; }\n\n        public string? Attrs { get; set; }\n\n        public string? OutboundTag { get; set; }\n\n        public string? BalancerTag { get; set; }\n\n\n\n        public RuleObject()\n\n        {\n\n            Type = \"field\";\n\n        }\n\n\n\n        public static RuleObject DefaultOutbound => new()\n\n        {\n\n            OutboundTag = \"\",\n\n        };\n\n\n\n        public static RuleObject DefaultBalancer => new()\n\n        {\n\n            BalancerTag = \"\",\n\n        };\n\n    }\n\n}\n", "namespace Shadowsocks.CLI\n\n{\n\n    public enum Backend\n\n    {\n\n        SsRust,\n\n        V2Ray,\n\n        Legacy,\n\n        Pipelines,\n\n    }\n\n}\n", "using Shadowsocks.Models;\n\nusing Splat;\n\nusing System;\n\nusing System.Collections.Generic;\n\nusing System.CommandLine;\n\nusing System.CommandLine.Invocation;\n\nusing System.Diagnostics;\n\nusing System.Linq;\n\nusing System.Net;\n\nusing System.Text;\n\nusing System.Threading;\n\nusing System.Threading.Tasks;\n\n\n\nnamespace Shadowsocks.CLI\n\n{\n\n    internal class Program\n\n    {\n\n        private static Task<int> Main(string[] args)\n\n        {\n\n            var clientCommand = new Command(\"client\", \"Shadowsocks client.\");\n\n            clientCommand.AddAlias(\"c\");\n\n            clientCommand.AddOption(new Option<Backend>(\"--backend\", \"Shadowsocks backend to use. Available backends: shadowsocks-rust, v2ray, legacy, pipelines.\"));\n\n            clientCommand.AddOption(new Option<string?>(\"--listen\", \"Address and port to listen on for both SOCKS5 and HTTP proxy.\"));\n\n            clientCommand.AddOption(new Option<string?>(\"--listen-socks\", \"Address and port to listen on for SOCKS5 proxy.\"));\n\n            clientCommand.AddOption(new Option<string?>(\"--listen-http\", \"Address and port to listen on for HTTP proxy.\"));\n\n            clientCommand.AddOption(new Option<string>(\"--server-address\", \"Address of the remote Shadowsocks server to connect to.\"));\n\n            clientCommand.AddOption(new Option<int>(\"--server-port\", \"Port of the remote Shadowsocks server to connect to.\"));\n\n            clientCommand.AddOption(new Option<string>(\"--method\", \"Encryption method to use for remote Shadowsocks server.\"));\n\n            clientCommand.AddOption(new Option<string?>(\"--password\", \"Password to use for remote Shadowsocks server.\"));\n\n            clientCommand.AddOption(new Option<string?>(\"--key\", \"Encryption key (NOT password!) to use for remote Shadowsocks server.\"));\n\n            clientCommand.AddOption(new Option<string?>(\"--plugin\", \"Plugin binary path.\"));\n\n            clientCommand.AddOption(new Option<string?>(\"--plugin-opts\", \"Plugin options.\"));\n\n            clientCommand.AddOption(new Option<string?>(\"--plugin-args\", \"Plugin startup arguments.\"));\n\n            clientCommand.Handler = CommandHandler.Create(\n\n                async (Backend backend, string? listen, string? listenSocks, string? listenHttp, string serverAddress, int serverPort, string method, string? password, string? key, string? plugin, string? pluginOpts, string? pluginArgs, CancellationToken cancellationToken) =>\n\n                {\n\n                    Locator.CurrentMutable.RegisterConstant<ConsoleLogger>(new());\n\n                    if (string.IsNullOrEmpty(listenSocks))\n\n                    {\n\n                        LogHost.Default.Error(\"You must specify SOCKS5 listen address and port.\");\n\n                        return;\n\n                    }\n\n\n\n                    Client.Legacy? legacyClient = null;\n\n                    Client.Pipelines? pipelinesClient = null;\n\n\n\n                    switch (backend)\n\n                    {\n\n                        case Backend.SsRust:\n\n                            LogHost.Default.Error(\"Not implemented.\");\n\n                            break;\n\n                        case Backend.V2Ray:\n\n                            LogHost.Default.Error(\"Not implemented.\");\n\n                            break;\n\n                        case Backend.Legacy:\n\n                            if (!string.IsNullOrEmpty(password))\n\n                            {\n\n                                legacyClient = new();\n\n                                legacyClient.Start(listenSocks, serverAddress, serverPort, method, password, plugin, pluginOpts, pluginArgs);\n\n                            }\n\n                            else\n\n                                LogHost.Default.Error(\"The legacy backend requires password.\");\n\n                            break;\n\n                        case Backend.Pipelines:\n\n                            pipelinesClient = new();\n\n                            await pipelinesClient.Start(listenSocks, serverAddress, serverPort, method, password, key, plugin, pluginOpts, pluginArgs);\n\n                            break;\n\n                        default:\n\n                            LogHost.Default.Error(\"Not implemented.\");\n\n                            break;\n\n                    }\n\n\n\n                    while (!cancellationToken.IsCancellationRequested)\n\n                    {\n\n                        await Task.Delay(TimeSpan.FromHours(1.00), cancellationToken);\n\n                        Console.WriteLine(\"An hour has passed.\");\n\n                    }\n\n\n\n                    switch (backend)\n\n                    {\n\n                        case Backend.SsRust:\n\n                            LogHost.Default.Error(\"Not implemented.\");\n\n                            break;\n\n                        case Backend.V2Ray:\n\n                            LogHost.Default.Error(\"Not implemented.\");\n\n                            break;\n\n                        case Backend.Legacy:\n\n                            legacyClient?.Stop();\n\n                            break;\n\n                        case Backend.Pipelines:\n\n                            pipelinesClient?.Stop();\n\n                            break;\n\n                        default:\n\n                            LogHost.Default.Error(\"Not implemented.\");\n\n                            break;\n\n                    }\n\n                });\n\n\n\n            var serverCommand = new Command(\"server\", \"Shadowsocks server.\");\n\n            serverCommand.AddAlias(\"s\");\n\n            serverCommand.Handler = CommandHandler.Create(\n\n                () =>\n\n                {\n\n                    Console.WriteLine(\"Not implemented.\");\n\n                });\n\n\n\n            var convertConfigCommand = new Command(\"convert-config\", \"Convert between different config formats. Supported formats: SIP002 links, SIP008 delivery JSON, and V2Ray JSON (outbound only).\");\n\n            convertConfigCommand.AddOption(new Option<string[]?>(\"--from-urls\", \"URL conversion sources. Multiple URLs are supported. Supported protocols are ss:// and https://.\"));\n\n            convertConfigCommand.AddOption(new Option<string[]?>(\"--from-sip008-json\", \"SIP008 JSON conversion sources. Multiple JSON files are supported.\"));\n\n            convertConfigCommand.AddOption(new Option<string[]?>(\"--from-v2ray-json\", \"V2Ray JSON conversion sources. Multiple JSON files are supported.\"));\n\n            convertConfigCommand.AddOption(new Option<bool>(\"--prefix-group-name\", \"Whether to prefix group name to server names after conversion.\"));\n\n            convertConfigCommand.AddOption(new Option<bool>(\"--to-urls\", \"Convert to ss:// links and print.\"));\n\n            convertConfigCommand.AddOption(new Option<string?>(\"--to-sip008-json\", \"Convert to SIP008 JSON and save to the specified path.\"));\n\n            convertConfigCommand.AddOption(new Option<string?>(\"--to-v2ray-json\", \"Convert to V2Ray JSON and save to the specified path.\"));\n\n            convertConfigCommand.Handler = CommandHandler.Create(\n\n                async (string[]? fromUrls, string[]? fromSip008Json, string[]? fromV2rayJson, bool prefixGroupName, bool toUrls, string? toSip008Json, string? toV2rayJson, CancellationToken cancellationToken) =>\n\n                {\n\n                    var configConverter = new ConfigConverter(prefixGroupName);\n\n\n\n                    try\n\n                    {\n\n                        if (fromUrls != null)\n\n                        {\n\n                            var uris = new List<Uri>();\n\n                            foreach (var url in fromUrls)\n\n                            {\n\n                                if (Uri.TryCreate(url, UriKind.Absolute, out var uri))\n\n                                    uris.Add(uri);\n\n                                else\n\n                                    Console.WriteLine($\"Invalid URL: {url}\");\n\n                            }\n\n                            await configConverter.FromUrls(uris, cancellationToken);\n\n                        }\n\n                        if (fromSip008Json != null)\n\n                            await configConverter.FromSip008Json(fromSip008Json, cancellationToken);\n\n                        if (fromV2rayJson != null)\n\n                            await configConverter.FromV2rayJson(fromV2rayJson, cancellationToken);\n\n\n\n                        if (toUrls)\n\n                        {\n\n                            var uris = configConverter.ToUrls();\n\n                            foreach (var uri in uris)\n\n                                Console.WriteLine(uri.AbsoluteUri);\n\n                        }\n\n                        if (!string.IsNullOrEmpty(toSip008Json))\n\n                            await configConverter.ToSip008Json(toSip008Json, cancellationToken);\n\n                        if (!string.IsNullOrEmpty(toV2rayJson))\n\n                            await configConverter.ToV2rayJson(toV2rayJson, cancellationToken);\n\n                    }\n\n                    catch (Exception ex)\n\n                    {\n\n                        Console.WriteLine(ex.Message);\n\n                    }\n\n                });\n\n\n\n            var utilitiesCommand = new Command(\"utilities\", \"Shadowsocks-related utilities.\")\n\n            {\n\n                convertConfigCommand,\n\n            };\n\n            utilitiesCommand.AddAlias(\"u\");\n\n            utilitiesCommand.AddAlias(\"util\");\n\n            utilitiesCommand.AddAlias(\"utils\");\n\n\n\n            var rootCommand = new RootCommand(\"CLI for Shadowsocks server and client implementation in C#.\")\n\n            {\n\n                clientCommand,\n\n                serverCommand,\n\n                utilitiesCommand,\n\n            };\n\n\n\n            Console.OutputEncoding = Encoding.UTF8;\n\n            return rootCommand.InvokeAsync(args);\n\n        }\n\n    }\n\n}\n", "using Shadowsocks.Interop.Utils;\n\nusing Shadowsocks.Models;\n\nusing System;\n\nusing System.Collections.Generic;\n\nusing System.IO;\n\nusing System.Linq;\n\nusing System.Net.Http;\n\nusing System.Net.Http.Json;\n\nusing System.Text.Json;\n\nusing System.Threading;\n\nusing System.Threading.Tasks;\n\n\n\nnamespace Shadowsocks.CLI\n\n{\n\n    public class ConfigConverter\n\n    {\n\n        /// <summary>\n\n        /// Gets or sets whether to prefix group name to server names.\n\n        /// </summary>\n\n        public bool PrefixGroupName { get; set; }\n\n        \n\n        /// <summary>\n\n        /// Gets or sets the list of servers that are not in any groups.\n\n        /// </summary>\n\n        public List<Server> Servers { get; set; } = new();\n\n\n\n        public ConfigConverter(bool prefixGroupName = false) => PrefixGroupName = prefixGroupName;\n\n        \n\n        /// <summary>\n\n        /// Collects servers from ss:// links or SIP008 delivery links.\n\n        /// </summary>\n\n        /// <param name=\"uris\">URLs to collect servers from.</param>\n\n        /// <param name=\"cancellationToken\">A token that may be used to cancel the asynchronous operation.</param>\n\n        /// <returns>A task that represents the asynchronous operation.</returns>\n\n        public async Task FromUrls(IEnumerable<Uri> uris, CancellationToken cancellationToken = default)\n\n        {\n\n            var sip008Links = new List<Uri>();\n\n\n\n            foreach (var uri in uris)\n\n            {\n\n                switch (uri.Scheme)\n\n                {\n\n                    case \"ss\":\n\n                        {\n\n                            if (Server.TryParse(uri, out var server))\n\n                                Servers.Add(server);\n\n                            break;\n\n                        }\n\n\n\n                    case \"https\":\n\n                        sip008Links.Add(uri);\n\n                        break;\n\n                }\n\n            }\n\n\n\n            if (sip008Links.Count > 0)\n\n            {\n\n                var httpClient = new HttpClient\n\n                {\n\n                    Timeout = TimeSpan.FromSeconds(30.0)\n\n                };\n\n                var tasks = sip008Links.Select(async x => await httpClient.GetFromJsonAsync<Group>(x, JsonHelper.snakeCaseJsonDeserializerOptions, cancellationToken))\n\n                                       .ToList();\n\n                while (tasks.Count > 0)\n\n                {\n\n                    var finishedTask = await Task.WhenAny(tasks);\n\n                    var group = await finishedTask;\n\n                    if (group != null)\n\n                        Servers.AddRange(group.Servers);\n\n                    tasks.Remove(finishedTask);\n\n                }\n\n            }\n\n        }\n\n\n\n        /// <summary>\n\n        /// Collects servers from SIP008 JSON files.\n\n        /// </summary>\n\n        /// <param name=\"paths\">JSON file paths.</param>\n\n        /// <param name=\"cancellationToken\">A token that may be used to cancel the read operation.</param>\n\n        /// <returns>A task that represents the asynchronous read operation.</returns>\n\n        public async Task FromSip008Json(IEnumerable<string> paths, CancellationToken cancellationToken = default)\n\n        {\n\n            foreach (var path in paths)\n\n            {\n\n                using var jsonFile = new FileStream(path, FileMode.Open);\n\n                var group = await JsonSerializer.DeserializeAsync<Group>(jsonFile, JsonHelper.snakeCaseJsonDeserializerOptions, cancellationToken);\n\n                if (group != null)\n\n                {\n\n                    if (PrefixGroupName && !string.IsNullOrEmpty(group.Name))\n\n                        group.Servers.ForEach(x => x.Name = $\"{group.Name} - {x.Name}\");\n\n                    Servers.AddRange(group.Servers);\n\n                }\n\n            }\n\n        }\n\n\n\n        /// <summary>\n\n        /// Collects servers from outbounds in V2Ray JSON files.\n\n        /// </summary>\n\n        /// <param name=\"paths\">JSON file paths.</param>\n\n        /// <param name=\"cancellationToken\">A token that may be used to cancel the read operation.</param>\n\n        /// <returns>A task that represents the asynchronous read operation.</returns>\n\n        public async Task FromV2rayJson(IEnumerable<string> paths, CancellationToken cancellationToken = default)\n\n        {\n\n            foreach (var path in paths)\n\n            {\n\n                using var jsonFile = new FileStream(path, FileMode.Open);\n\n                var v2rayConfig = await JsonSerializer.DeserializeAsync<Interop.V2Ray.Config>(jsonFile, JsonHelper.camelCaseJsonDeserializerOptions, cancellationToken);\n\n                if (v2rayConfig?.Outbounds != null)\n\n                {\n\n                    foreach (var outbound in v2rayConfig.Outbounds)\n\n                    {\n\n                        if (outbound.Protocol == \"shadowsocks\"\n\n                            && outbound.Settings is JsonElement jsonElement)\n\n                        {\n\n                            var jsonText = jsonElement.GetRawText();\n\n                            var ssConfig = JsonSerializer.Deserialize<Interop.V2Ray.Protocols.Shadowsocks.OutboundConfigurationObject>(jsonText, JsonHelper.camelCaseJsonDeserializerOptions);\n\n                            if (ssConfig != null)\n\n                                foreach (var ssServer in ssConfig.Servers)\n\n                                {\n\n                                    var server = new Server\n\n                                    {\n\n                                        Name = outbound.Tag,\n\n                                        Host = ssServer.Address,\n\n                                        Port = ssServer.Port,\n\n                                        Method = ssServer.Method,\n\n                                        Password = ssServer.Password\n\n                                    };\n\n                                    Servers.Add(server);\n\n                                }\n\n                        }\n\n                    }\n\n                }\n\n            }\n\n        }\n\n\n\n        /// <summary>\n\n        /// Converts saved servers to ss:// URLs.\n\n        /// </summary>\n\n        /// <returns>A list of ss:// URLs.</returns>\n\n        public List<Uri> ToUrls()\n\n        {\n\n            var urls = new List<Uri>();\n\n\n\n            foreach (var server in Servers)\n\n                urls.Add(server.ToUrl());\n\n\n\n            return urls;\n\n        }\n\n\n\n        /// <summary>\n\n        /// Converts saved servers to SIP008 JSON.\n\n        /// </summary>\n\n        /// <param name=\"path\">JSON file path.</param>\n\n        /// <param name=\"cancellationToken\">A token that may be used to cancel the write operation.</param>\n\n        /// <returns>A task that represents the asynchronous write operation.</returns>\n\n        public Task ToSip008Json(string path, CancellationToken cancellationToken = default)\n\n        {\n\n            var group = new Group();\n\n\n\n            group.Servers.AddRange(Servers);\n\n\n\n            var fullPath = Path.GetFullPath(path);\n\n            var directoryPath = Path.GetDirectoryName(fullPath) ?? throw new ArgumentException(\"Invalid path\", nameof(path));\n\n            Directory.CreateDirectory(directoryPath);\n\n            using var jsonFile = new FileStream(fullPath, FileMode.Create);\n\n            return JsonSerializer.SerializeAsync(jsonFile, group, JsonHelper.snakeCaseJsonSerializerOptions, cancellationToken);\n\n        }\n\n\n\n        /// <summary>\n\n        /// Converts saved servers to V2Ray outbounds.\n\n        /// </summary>\n\n        /// <param name=\"path\">JSON file path.</param>\n\n        /// <param name=\"prefixGroupName\">Whether to prefix group name to server names.</param>\n\n        /// <param name=\"cancellationToken\">A token that may be used to cancel the write operation.</param>\n\n        /// <returns>A task that represents the asynchronous write operation.</returns>\n\n        public Task ToV2rayJson(string path, CancellationToken cancellationToken = default)\n\n        {\n\n            var v2rayConfig = new Interop.V2Ray.Config\n\n            {\n\n                Outbounds = new()\n\n            };\n\n\n\n            foreach (var server in Servers)\n\n            {\n\n                var ssOutbound = Interop.V2Ray.OutboundObject.GetShadowsocks(server);\n\n                v2rayConfig.Outbounds.Add(ssOutbound);\n\n            }\n\n\n\n            // enforce outbound tag uniqueness\n\n            var serversWithDuplicateTags = v2rayConfig.Outbounds.GroupBy(x => x.Tag)\n\n                                                                .Where(x => x.Count() > 1);\n\n            foreach (var serversWithSameTag in serversWithDuplicateTags)\n\n            {\n\n                var duplicates = serversWithSameTag.ToList();\n\n                for (var i = 0; i < duplicates.Count; i++)\n\n                {\n\n                    duplicates[i].Tag = $\"{duplicates[i].Tag} {i}\";\n\n                }\n\n            }\n\n\n\n            var fullPath = Path.GetFullPath(path);\n\n            var directoryPath = Path.GetDirectoryName(fullPath) ?? throw new ArgumentException(\"Invalid path\", nameof(path));\n\n            Directory.CreateDirectory(directoryPath);\n\n            using var jsonFile = new FileStream(fullPath, FileMode.Create);\n\n            return JsonSerializer.SerializeAsync(jsonFile, v2rayConfig, JsonHelper.camelCaseJsonSerializerOptions, cancellationToken);\n\n        }\n\n    }\n\n}\n", "using Shadowsocks.Protocol;\n\nusing System;\n\nusing System.Collections.Generic;\n\nusing System.Linq;\n\nusing System.Net;\n\nusing System.Text;\n\nusing System.Threading.Tasks;\n\n\n\nnamespace Shadowsocks.CLI.Client\n\n{\n\n    public class Pipelines\n\n    {\n\n        private TcpPipeListener? _tcpPipeListener;\n\n        \n\n        public Task Start(string listenSocks, string serverAddress, int serverPort, string method, string? password, string? key, string? plugin, string? pluginOpts, string? pluginArgs)\n\n        {\n\n            // TODO\n\n            var localEP = IPEndPoint.Parse(listenSocks);\n\n            var remoteEp = new DnsEndPoint(serverAddress, serverPort);\n\n            byte[]? mainKey = null;\n\n            if (!string.IsNullOrEmpty(key))\n\n                mainKey = Encoding.UTF8.GetBytes(key);\n\n            _tcpPipeListener = new(localEP);\n\n            return _tcpPipeListener.Start(localEP, remoteEp, method, password, mainKey);\n\n        }\n\n\n\n        public void Stop() => _tcpPipeListener?.Stop();\n\n    }\n\n}\n", "using Shadowsocks.Models;\n\nusing Shadowsocks.Net;\n\nusing System;\n\nusing System.Collections.Generic;\n\nusing System.Diagnostics;\n\nusing System.Linq;\n\nusing System.Net;\n\nusing System.Text;\n\nusing System.Threading.Tasks;\n\n\n\nnamespace Shadowsocks.CLI.Client\n\n{\n\n    public class Legacy\n\n    {\n\n        private TCPListener? _tcpListener;\n\n        private UDPListener? _udpListener;\n\n        \n\n        public void Start(string listenSocks, string serverAddress, int serverPort, string method, string password, string? plugin, string? pluginOpts, string? pluginArgs)\n\n        {\n\n            var localEP = IPEndPoint.Parse(listenSocks);\n\n            var server = new Server()\n\n            {\n\n                Host = serverAddress,\n\n                Port = serverPort,\n\n                Method = method,\n\n                Password = password,\n\n                Plugin = plugin,\n\n                PluginOpts = pluginOpts,\n\n            };\n\n            if (!string.IsNullOrEmpty(plugin) && !string.IsNullOrEmpty(pluginArgs))\n\n            {\n\n                var processStartInfo = new ProcessStartInfo(plugin, pluginArgs);\n\n                server.PluginArgs = processStartInfo.ArgumentList.ToList();\n\n            }\n\n\n\n            var tcpRelay = new TCPRelay(server);\n\n            _tcpListener = new TCPListener(localEP, new List<IStreamService>()\n\n                        {\n\n                            tcpRelay,\n\n                        });\n\n            _tcpListener.Start();\n\n\n\n            var udpRelay = new UDPRelay(server);\n\n            _udpListener = new UDPListener(localEP, new List<IDatagramService>()\n\n                        {\n\n                            udpRelay,\n\n                        });\n\n            _udpListener.Start();\n\n        }\n\n\n\n        public void Stop()\n\n        {\n\n            _tcpListener?.Stop();\n\n            _udpListener?.Stop();\n\n        }\n\n    }\n\n}\n", "using Shadowsocks.Net;\n\nusing Shadowsocks.Utilities;\n\nusing Shadowsocks.Net.Crypto;\n\nusing Splat;\n\nusing System;\n\nusing System.Net;\n\nusing System.Net.Sockets;\n\nusing System.Text;\n\nusing System.Reflection;\n\n\n\nnamespace Shadowsocks.PAC\n\n{\n\n    public class PACServer : StreamService, IEnableLogger\n\n    {\n\n        public const string RESOURCE_NAME = \"pac\";\n\n\n\n        private string PacSecret\n\n        {\n\n            get\n\n            {\n\n                if (string.IsNullOrEmpty(_cachedPacSecret))\n\n                {\n\n                    _cachedPacSecret = Base64Url.Encode(RNG.GetBytes(32));\n\n                }\n\n                return _cachedPacSecret;\n\n            }\n\n        }\n\n        private string _cachedPacSecret = \"\";\n\n        private bool _PACServerEnableSecret;\n\n        public string PacUrl { get; private set; } = \"\";\n\n\n\n        private PACDaemon _pacDaemon;\n\n\n\n        public PACServer(PACDaemon pacDaemon, bool PACServerEnableSecret)\n\n        {\n\n            _pacDaemon = pacDaemon;\n\n            _PACServerEnableSecret = PACServerEnableSecret;\n\n        }\n\n\n\n        public void UpdatePACURL(EndPoint localEndPoint)\n\n        {\n\n            string usedSecret = _PACServerEnableSecret ? $\"&secret={PacSecret}\" : \"\";\n\n            string contentHash = GetHash(_pacDaemon.GetPACContent());\n\n            PacUrl = $\"http://{localEndPoint}/{RESOURCE_NAME}?hash={contentHash}{usedSecret}\";\n\n            this.Log().Debug(\"Setting PAC URL: {PacUrl}\");\n\n        }\n\n\n\n        private static string GetHash(string content)\n\n        {\n\n\n\n            return Base64Url.Encode(CryptoUtils.MD5(Encoding.ASCII.GetBytes(content)));\n\n        }\n\n\n\n        public override bool Handle(CachedNetworkStream stream, object state)\n\n        {\n\n            byte[] fp = new byte[256];\n\n            int len = stream.ReadFirstBlock(fp);\n\n            return Handle(fp, len, stream.Socket, state);\n\n        }\n\n\n\n        [Obsolete]\n\n        public override bool Handle(byte[] firstPacket, int length, Socket socket, object state)\n\n        {\n\n            if (socket.ProtocolType != ProtocolType.Tcp)\n\n            {\n\n                return false;\n\n            }\n\n\n\n            try\n\n            {\n\n                /*\n\n                 *  RFC 7230\n\n                 *  \n\n                    GET /hello.txt HTTP/1.1\n\n                    User-Agent: curl/7.16.3 libcurl/7.16.3 OpenSSL/0.9.7l zlib/1.2.3\n\n                    Host: www.example.com\n\n                    Accept-Language: en, mi \n\n                 */\n\n\n\n                string request = Encoding.UTF8.GetString(firstPacket, 0, length);\n\n                string[] lines = request.Split('\\r', '\\n');\n\n                bool hostMatch = false, pathMatch = false, useSocks = false;\n\n                bool secretMatch = !_PACServerEnableSecret;\n\n\n\n                if (lines.Length < 2)   // need at lease RequestLine + Host\n\n                {\n\n                    return false;\n\n                }\n\n\n\n                // parse request line\n\n                string requestLine = lines[0];\n\n                // GET /pac?t=yyyyMMddHHmmssfff&secret=foobar HTTP/1.1\n\n                string[] requestItems = requestLine.Split(' ');\n\n                if (requestItems.Length == 3 && requestItems[0] == \"GET\")\n\n                {\n\n                    int index = requestItems[1].IndexOf('?');\n\n                    if (index < 0)\n\n                    {\n\n                        index = requestItems[1].Length;\n\n                    }\n\n                    string resourceString = requestItems[1].Substring(0, index).Remove(0, 1);\n\n                    if (string.Equals(resourceString, RESOURCE_NAME, StringComparison.OrdinalIgnoreCase))\n\n                    {\n\n                        pathMatch = true;\n\n                        if (!secretMatch)\n\n                        {\n\n                            string queryString = requestItems[1].Substring(index);\n\n                            if (queryString.Contains(PacSecret))\n\n                            {\n\n                                secretMatch = true;\n\n                            }\n\n                        }\n\n                    }\n\n                }\n\n\n\n                // parse request header\n\n                for (int i = 1; i < lines.Length; i++)\n\n                {\n\n                    if (string.IsNullOrEmpty(lines[i]))\n\n                        continue;\n\n\n\n                    string[] kv = lines[i].Split(new char[] { ':' }, 2);\n\n                    if (kv.Length == 2)\n\n                    {\n\n                        if (kv[0] == \"Host\")\n\n                        {\n\n                            if (kv[1].Trim() == (socket.LocalEndPoint as IPEndPoint)?.ToString())\n\n                            {\n\n                                hostMatch = true;\n\n                            }\n\n                        }\n\n                        //else if (kv[0] == \"User-Agent\")\n\n                        //{\n\n                        //    // we need to drop connections when changing servers\n\n                        //    if (kv[1].IndexOf(\"Chrome\") >= 0)\n\n                        //    {\n\n                        //        useSocks = true;\n\n                        //    }\n\n                        //}\n\n                    }\n\n                }\n\n\n\n                if (hostMatch && pathMatch)\n\n                {\n\n                    if (!secretMatch)\n\n                    {\n\n                        socket.Close(); // Close immediately\n\n                    }\n\n                    else\n\n                    {\n\n                        SendResponse(socket, useSocks);\n\n                    }\n\n                    return true;\n\n                }\n\n                return false;\n\n            }\n\n            catch (ArgumentException)\n\n            {\n\n                return false;\n\n            }\n\n        }\n\n\n\n        public void SendResponse(Socket socket, bool useSocks)\n\n        {\n\n            try\n\n            {\n\n                IPEndPoint localEndPoint = socket.LocalEndPoint as IPEndPoint ?? throw new ArgumentException(\"Invalid socket local endpoint.\", nameof(socket));\n\n\n\n                string proxy = GetPACAddress(localEndPoint, useSocks);\n\n\n\n                string pacContent = $\"var __PROXY__ = '{proxy}';\\n\" + _pacDaemon.GetPACContent();\n\n                string responseHead =\n\n$@\"HTTP/1.1 200 OK\n\nServer: ShadowsocksPAC/{Assembly.GetExecutingAssembly().GetName().Version}\n\nContent-Type: application/x-ns-proxy-autoconfig\n\nContent-Length: { Encoding.UTF8.GetBytes(pacContent).Length}\n\nConnection: Close\n\n\n\n\";\n\n                byte[] response = Encoding.UTF8.GetBytes(responseHead + pacContent);\n\n                socket.BeginSend(response, 0, response.Length, 0, new AsyncCallback(SendCallback), socket);\n\n            }\n\n            catch (Exception e)\n\n            {\n\n                this.Log().Error(e, \"\");\n\n                socket.Close();\n\n            }\n\n        }\n\n\n\n        private void SendCallback(IAsyncResult ar)\n\n        {\n\n            Socket? conn = ar.AsyncState as Socket;\n\n            try\n\n            {\n\n                conn?.Shutdown(SocketShutdown.Send);\n\n            }\n\n            catch\n\n            {\n\n            }\n\n        }\n\n\n\n        private string GetPACAddress(IPEndPoint localEndPoint, bool useSocks) => $\"{(useSocks ? \"SOCKS5\" : \"PROXY\")} {localEndPoint};\";\n\n    }\n\n}\n", "using Splat;\n\nusing System;\n\nusing System.IO;\n\nusing System.Text;\n\nusing System.Threading.Tasks;\n\n\n\nnamespace Shadowsocks.PAC\n\n{\n\n\n\n    /// <summary>\n\n    /// Processing the PAC file content\n\n    /// </summary>\n\n    public class PACDaemon : IEnableLogger\n\n    {\n\n        public const string PAC_FILE = \"pac.txt\";\n\n        public const string USER_RULE_FILE = \"user-rule.txt\";\n\n        public const string USER_ABP_FILE = \"abp.txt\";\n\n\n\n        FileSystemWatcher? PACFileWatcher;\n\n        FileSystemWatcher? UserRuleFileWatcher;\n\n\n\n        public event EventHandler? PACFileChanged;\n\n        public event EventHandler? UserRuleFileChanged;\n\n\n\n        private PACSettings _PACSettings;\n\n        private GeositeUpdater _geositeUpdater;\n\n\n\n        public PACDaemon(PACSettings pACSettings, string workingDirectory, string dlcPath)\n\n        {\n\n            _PACSettings = pACSettings;\n\n            _geositeUpdater = new GeositeUpdater(dlcPath);\n\n            TouchPACFile();\n\n            TouchUserRuleFile();\n\n            WatchPacFile(workingDirectory);\n\n            WatchUserRuleFile(workingDirectory);\n\n        }\n\n\n\n\n\n        public string TouchPACFile()\n\n        {\n\n            if (!File.Exists(PAC_FILE))\n\n            {\n\n                _geositeUpdater.MergeAndWritePACFile(_PACSettings.GeositeDirectGroups, _PACSettings.GeositeProxiedGroups, _PACSettings.PACDefaultToDirect);\n\n            }\n\n            return PAC_FILE;\n\n        }\n\n\n\n        internal string TouchUserRuleFile()\n\n        {\n\n            if (!File.Exists(USER_RULE_FILE))\n\n            {\n\n                File.WriteAllText(USER_RULE_FILE, Properties.Resources.user_rule);\n\n            }\n\n            return USER_RULE_FILE;\n\n        }\n\n\n\n        internal string GetPACContent()\n\n        {\n\n            if (!File.Exists(PAC_FILE))\n\n            {\n\n                _geositeUpdater.MergeAndWritePACFile(_PACSettings.GeositeDirectGroups, _PACSettings.GeositeProxiedGroups, _PACSettings.PACDefaultToDirect);\n\n            }\n\n            return File.ReadAllText(PAC_FILE, Encoding.UTF8);\n\n        }\n\n\n\n\n\n        private void WatchPacFile(string workingDirectory)\n\n        {\n\n            PACFileWatcher?.Dispose();\n\n            PACFileWatcher = new FileSystemWatcher(workingDirectory);\n\n            PACFileWatcher.NotifyFilter = NotifyFilters.LastWrite | NotifyFilters.FileName | NotifyFilters.DirectoryName;\n\n            PACFileWatcher.Filter = PAC_FILE;\n\n            PACFileWatcher.Changed += PACFileWatcher_Changed;\n\n            PACFileWatcher.Created += PACFileWatcher_Changed;\n\n            PACFileWatcher.Deleted += PACFileWatcher_Changed;\n\n            PACFileWatcher.Renamed += PACFileWatcher_Changed;\n\n            PACFileWatcher.EnableRaisingEvents = true;\n\n        }\n\n\n\n        private void WatchUserRuleFile(string workingDirectory)\n\n        {\n\n            UserRuleFileWatcher?.Dispose();\n\n            UserRuleFileWatcher = new FileSystemWatcher(workingDirectory);\n\n            UserRuleFileWatcher.NotifyFilter = NotifyFilters.LastWrite | NotifyFilters.FileName | NotifyFilters.DirectoryName;\n\n            UserRuleFileWatcher.Filter = USER_RULE_FILE;\n\n            UserRuleFileWatcher.Changed += UserRuleFileWatcher_Changed;\n\n            UserRuleFileWatcher.Created += UserRuleFileWatcher_Changed;\n\n            UserRuleFileWatcher.Deleted += UserRuleFileWatcher_Changed;\n\n            UserRuleFileWatcher.Renamed += UserRuleFileWatcher_Changed;\n\n            UserRuleFileWatcher.EnableRaisingEvents = true;\n\n        }\n\n\n\n        #region FileSystemWatcher.OnChanged()\n\n        // FileSystemWatcher Changed event is raised twice\n\n        // http://stackoverflow.com/questions/1764809/filesystemwatcher-changed-event-is-raised-twice\n\n        // Add a short delay to avoid raise event twice in a short period\n\n        private void PACFileWatcher_Changed(object sender, FileSystemEventArgs e)\n\n        {\n\n            if (PACFileChanged != null)\n\n            {\n\n                this.Log().Info($\"Detected: PAC file '{e.Name}' was {e.ChangeType.ToString().ToLower()}.\");\n\n                Task.Factory.StartNew(() =>\n\n                {\n\n                    ((FileSystemWatcher)sender).EnableRaisingEvents = false;\n\n                    System.Threading.Thread.Sleep(10);\n\n                    PACFileChanged(this, new EventArgs());\n\n                    ((FileSystemWatcher)sender).EnableRaisingEvents = true;\n\n                });\n\n            }\n\n        }\n\n\n\n        private void UserRuleFileWatcher_Changed(object sender, FileSystemEventArgs e)\n\n        {\n\n            if (UserRuleFileChanged != null)\n\n            {\n\n                this.Log().Info($\"Detected: User Rule file '{e.Name}' was {e.ChangeType.ToString().ToLower()}.\");\n\n                Task.Factory.StartNew(() =>\n\n                {\n\n                    ((FileSystemWatcher)sender).EnableRaisingEvents = false;\n\n                    System.Threading.Thread.Sleep(10);\n\n                    UserRuleFileChanged(this, new EventArgs());\n\n                    ((FileSystemWatcher)sender).EnableRaisingEvents = true;\n\n                });\n\n            }\n\n        }\n\n        #endregion\n\n    }\n\n}\n", "using System;\n\nusing System.Collections.Generic;\n\nusing System.Text;\n\n\n\nnamespace Shadowsocks.PAC\n\n{\n\n    /// <summary>\n\n    /// Settings used for PAC.\n\n    /// </summary>\n\n    public class PACSettings\n\n    {\n\n        public PACSettings()\n\n        {\n\n            PACDefaultToDirect = false;\n\n            PACServerEnableSecret = true;\n\n            RegeneratePacOnVersionUpdate = true;\n\n            CustomPACUrl = \"\";\n\n            CustomGeositeUrl = \"\";\n\n            CustomGeositeSha256SumUrl = \"\";\n\n            GeositeDirectGroups = new List<string>()\n\n            {\n\n                \"private\",\n\n                \"cn\",\n\n                \"geolocation-!cn@cn\",\n\n            };\n\n            GeositeProxiedGroups = new List<string>()\n\n            {\n\n                \"geolocation-!cn\",\n\n            };\n\n        }\n\n\n\n        /// <summary>\n\n        /// Controls whether direct connection is used for\n\n        /// hostnames not matched by blocking rules\n\n        /// or matched by exception rules.\n\n        /// Defaults to false, or whitelist mode,\n\n        /// where hostnames matching the above conditions\n\n        /// are connected to via proxy.\n\n        /// Enable it to use blacklist mode.\n\n        /// </summary>\n\n        public bool PACDefaultToDirect { get; set; }\n\n\n\n        /// <summary>\n\n        /// Controls whether the PAC server uses a secret\n\n        /// to protect access to the PAC URL.\n\n        /// Defaults to true.\n\n        /// </summary>\n\n        public bool PACServerEnableSecret { get; set; }\n\n\n\n        /// <summary>\n\n        /// Controls whether `pac.txt` should be regenerated\n\n        /// when shadowsocks-windows is updated.\n\n        /// Defaults to true, so new changes can be applied.\n\n        /// Change it to false if you want to manage `pac.txt`\n\n        /// yourself.\n\n        /// </summary>\n\n        public bool RegeneratePacOnVersionUpdate { get; set; }\n\n\n\n        /// <summary>\n\n        /// Specifies a custom PAC URL.\n\n        /// Leave empty to use local PAC.\n\n        /// </summary>\n\n        public string CustomPACUrl { get; set; }\n\n\n\n        /// <summary>\n\n        /// Specifies a custom Geosite database URL.\n\n        /// Leave empty to use the default source.\n\n        /// </summary>\n\n        public string CustomGeositeUrl { get; set; }\n\n\n\n        /// <summary>\n\n        /// Specifies the custom Geosite database's corresponding SHA256 checksum download URL.\n\n        /// Leave empty to disable checksum verification for your custom Geosite database.\n\n        /// </summary>\n\n        public string CustomGeositeSha256SumUrl { get; set; }\n\n\n\n        /// <summary>\n\n        /// A list of Geosite groups\n\n        /// that we use direct connection for.\n\n        /// </summary>\n\n        public List<string> GeositeDirectGroups { get; set; }\n\n\n\n        /// <summary>\n\n        /// A list of Geosite groups\n\n        /// that we always connect to via proxy.\n\n        /// </summary>\n\n        public List<string> GeositeProxiedGroups { get; set; }\n\n    }\n\n}\n", "using Splat;\n\nusing System;\n\nusing System.Collections.Generic;\n\nusing System.IO;\n\nusing System.Linq;\n\nusing System.Text;\n\nusing System.Net.Http;\n\nusing System.Threading.Tasks;\n\nusing System.Security.Cryptography;\n\nusing System.Text.Json;\n\n\n\nnamespace Shadowsocks.PAC\n\n{\n\n    public class GeositeResultEventArgs : EventArgs\n\n    {\n\n        public bool Success;\n\n\n\n        public GeositeResultEventArgs(bool success)\n\n        {\n\n            Success = success;\n\n        }\n\n    }\n\n\n\n    public class GeositeUpdater : IEnableLogger\n\n    {\n\n        public event EventHandler<GeositeResultEventArgs>? UpdateCompleted;\n\n\n\n        private readonly string DATABASE_PATH;\n\n\n\n        private readonly string GEOSITE_URL = \"https://github.com/v2fly/domain-list-community/raw/release/dlc.dat\";\n\n        private readonly string GEOSITE_SHA256SUM_URL = \"https://github.com/v2fly/domain-list-community/raw/release/dlc.dat.sha256sum\";\n\n        private byte[] geositeDB;\n\n\n\n        public readonly Dictionary<string, IList<DomainObject>> Geosites = new Dictionary<string, IList<DomainObject>>();\n\n\n\n        public GeositeUpdater(string dlcPath)\n\n        {\n\n            DATABASE_PATH = dlcPath;\n\n            if (File.Exists(DATABASE_PATH) && new FileInfo(DATABASE_PATH).Length > 0)\n\n            {\n\n                geositeDB = File.ReadAllBytes(DATABASE_PATH);\n\n            }\n\n            else\n\n            {\n\n                geositeDB = Properties.Resources.dlc;\n\n                File.WriteAllBytes(DATABASE_PATH, Properties.Resources.dlc);\n\n            }\n\n            LoadGeositeList();\n\n        }\n\n\n\n        /// <summary>\n\n        /// load new GeoSite data from geositeDB\n\n        /// </summary>\n\n        private void LoadGeositeList()\n\n        {\n\n            var list = GeositeList.Parser.ParseFrom(geositeDB);\n\n            foreach (var item in list.Entries)\n\n            {\n\n                Geosites[item.GroupName.ToLowerInvariant()] = item.Domains;\n\n            }\n\n        }\n\n\n\n        public void ResetEvent()\n\n        {\n\n            UpdateCompleted = null;\n\n        }\n\n\n\n        public async Task UpdatePACFromGeosite(PACSettings pACSettings)\n\n        {\n\n            string geositeUrl = GEOSITE_URL;\n\n            string geositeSha256sumUrl = GEOSITE_SHA256SUM_URL;\n\n            SHA256 mySHA256 = SHA256.Create();\n\n            bool blacklist = pACSettings.PACDefaultToDirect;\n\n            var httpClient = Locator.Current.GetService<HttpClient>();\n\n\n\n            if (!string.IsNullOrWhiteSpace(pACSettings.CustomGeositeUrl))\n\n            {\n\n                this.Log().Info(\"Found custom Geosite URL in config file\");\n\n                geositeUrl = pACSettings.CustomGeositeUrl;\n\n            }\n\n            this.Log().Info($\"Checking Geosite from {geositeUrl}\");\n\n\n\n            try\n\n            {\n\n                // download checksum first\n\n                var geositeSha256sum = await httpClient.GetStringAsync(geositeSha256sumUrl);\n\n                geositeSha256sum = geositeSha256sum.Substring(0, 64).ToUpper();\n\n                this.Log().Info($\"Got Sha256sum: {geositeSha256sum}\");\n\n                // compare downloaded checksum with local geositeDB\n\n                byte[] localDBHashBytes = mySHA256.ComputeHash(geositeDB);\n\n                string localDBHash = BitConverter.ToString(localDBHashBytes).Replace(\"-\", String.Empty);\n\n                this.Log().Info($\"Local Sha256sum: {localDBHash}\");\n\n                // if already latest\n\n                if (geositeSha256sum == localDBHash)\n\n                {\n\n                    this.Log().Info(\"Local GeoSite DB is up to date.\");\n\n                    return;\n\n                }\n\n\n\n                // not latest. download new DB\n\n                var downloadedBytes = await httpClient.GetByteArrayAsync(geositeUrl);\n\n\n\n                // verify sha256sum\n\n                byte[] downloadedDBHashBytes = mySHA256.ComputeHash(downloadedBytes);\n\n                string downloadedDBHash = BitConverter.ToString(downloadedDBHashBytes).Replace(\"-\", String.Empty);\n\n                this.Log().Info($\"Actual Sha256sum: {downloadedDBHash}\");\n\n                if (geositeSha256sum != downloadedDBHash)\n\n                {\n\n                    this.Log().Info(\"Sha256sum Verification: FAILED. Downloaded GeoSite DB is corrupted. Aborting the update.\");\n\n                    throw new Exception(\"Sha256sum mismatch\");\n\n                }\n\n                else\n\n                {\n\n                    this.Log().Info(\"Sha256sum Verification: PASSED. Applying to local GeoSite DB.\");\n\n                }\n\n\n\n                // write to geosite file\n\n                using (FileStream geositeFileStream = File.Create(DATABASE_PATH))\n\n                    await geositeFileStream.WriteAsync(downloadedBytes, 0, downloadedBytes.Length);\n\n\n\n                // update stuff\n\n                geositeDB = downloadedBytes;\n\n                LoadGeositeList();\n\n                bool pacFileChanged = MergeAndWritePACFile(pACSettings.GeositeDirectGroups, pACSettings.GeositeProxiedGroups, blacklist);\n\n                UpdateCompleted?.Invoke(null, new GeositeResultEventArgs(pacFileChanged));\n\n            }\n\n            catch (Exception e)\n\n            {\n\n                this.Log().Error(e, \"An error occurred while updating PAC.\");\n\n            }\n\n        }\n\n\n\n        /// <summary>\n\n        /// Merge and write pac.txt from geosite.\n\n        /// Used at multiple places.\n\n        /// </summary>\n\n        /// <param name=\"directGroups\">A list of geosite groups configured for direct connection.</param>\n\n        /// <param name=\"proxiedGroups\">A list of geosite groups configured for proxied connection.</param>\n\n        /// <param name=\"blacklist\">Whether to use blacklist mode. False for whitelist.</param>\n\n        /// <returns></returns>\n\n        public bool MergeAndWritePACFile(List<string> directGroups, List<string> proxiedGroups, bool blacklist)\n\n        {\n\n            string abpContent = MergePACFile(directGroups, proxiedGroups, blacklist);\n\n            if (File.Exists(PACDaemon.PAC_FILE))\n\n            {\n\n                string original = File.ReadAllText(PACDaemon.PAC_FILE);\n\n                if (original == abpContent)\n\n                {\n\n                    return false;\n\n                }\n\n            }\n\n            File.WriteAllText(PACDaemon.PAC_FILE, abpContent, Encoding.UTF8);\n\n            return true;\n\n        }\n\n\n\n        /// <summary>\n\n        /// Checks if the specified group exists in GeoSite database.\n\n        /// </summary>\n\n        /// <param name=\"group\">The group name to check for.</param>\n\n        /// <returns>True if the group exists. False if the group doesn't exist.</returns>\n\n        public bool CheckGeositeGroup(string group) => SeparateAttributeFromGroupName(group, out string groupName, out _) && Geosites.ContainsKey(groupName);\n\n\n\n        /// <summary>\n\n        /// Separates the attribute (e.g. @cn) from a group name.\n\n        /// No checks are performed.\n\n        /// </summary>\n\n        /// <param name=\"group\">A group name potentially with a trailing attribute.</param>\n\n        /// <param name=\"groupName\">The group name with the attribute stripped.</param>\n\n        /// <param name=\"attribute\">The attribute.</param>\n\n        /// <returns>True for success. False for more than one '@'.</returns>\n\n        private bool SeparateAttributeFromGroupName(string group, out string groupName, out string attribute)\n\n        {\n\n            var splitGroupAttributeList = group.Split('@');\n\n            if (splitGroupAttributeList.Length == 1) // no attribute\n\n            {\n\n                groupName = splitGroupAttributeList[0];\n\n                attribute = \"\";\n\n            }\n\n            else if (splitGroupAttributeList.Length == 2) // has attribute\n\n            {\n\n                groupName = splitGroupAttributeList[0];\n\n                attribute = splitGroupAttributeList[1];\n\n            }\n\n            else\n\n            {\n\n                groupName = \"\";\n\n                attribute = \"\";\n\n                return false;\n\n            }    \n\n            return true;\n\n        }\n\n\n\n        private string MergePACFile(List<string> directGroups, List<string> proxiedGroups, bool blacklist)\n\n        {\n\n            string abpContent;\n\n            if (File.Exists(PACDaemon.USER_ABP_FILE))\n\n            {\n\n                abpContent = File.ReadAllText(PACDaemon.USER_ABP_FILE);\n\n            }\n\n            else\n\n            {\n\n                abpContent = Properties.Resources.abp;\n\n            }\n\n\n\n            List<string> userruleLines = new List<string>();\n\n            if (File.Exists(PACDaemon.USER_RULE_FILE))\n\n            {\n\n                string userrulesString = File.ReadAllText(PACDaemon.USER_RULE_FILE);\n\n                userruleLines = ProcessUserRules(userrulesString);\n\n            }\n\n\n\n            List<string> ruleLines = GenerateRules(directGroups, proxiedGroups, blacklist);\n\n\n\n            var jsonSerializerOptions = new JsonSerializerOptions()\n\n            {\n\n                WriteIndented = true,\n\n            };\n\n            abpContent =\n\n$@\"var __USERRULES__ = {JsonSerializer.Serialize(userruleLines, jsonSerializerOptions)};\n\nvar __RULES__ = {JsonSerializer.Serialize(ruleLines, jsonSerializerOptions)};\n\n{abpContent}\";\n\n            return abpContent;\n\n        }\n\n\n\n        private List<string> ProcessUserRules(string content)\n\n        {\n\n            List<string> valid_lines = new List<string>();\n\n            using (var stringReader = new StringReader(content))\n\n            {\n\n                for (string? line = stringReader.ReadLine(); line != null; line = stringReader.ReadLine())\n\n                {\n\n                    if (string.IsNullOrWhiteSpace(line) || line.StartsWith(\"!\") || line.StartsWith(\"[\"))\n\n                        continue;\n\n                    valid_lines.Add(line);\n\n                }\n\n            }\n\n            return valid_lines;\n\n        }\n\n\n\n        /// <summary>\n\n        /// Generates rule lines based on user preference.\n\n        /// </summary>\n\n        /// <param name=\"directGroups\">A list of geosite groups configured for direct connection.</param>\n\n        /// <param name=\"proxiedGroups\">A list of geosite groups configured for proxied connection.</param>\n\n        /// <param name=\"blacklist\">Whether to use blacklist mode. False for whitelist.</param>\n\n        /// <returns>A list of rule lines.</returns>\n\n        private List<string> GenerateRules(List<string> directGroups, List<string> proxiedGroups, bool blacklist)\n\n        {\n\n            List<string> ruleLines;\n\n            if (blacklist) // blocking + exception rules\n\n            {\n\n                ruleLines = GenerateBlockingRules(proxiedGroups);\n\n                ruleLines.AddRange(GenerateExceptionRules(directGroups));\n\n            }\n\n            else // proxy all + exception rules\n\n            {\n\n                ruleLines = new List<string>()\n\n                {\n\n                    \"/.*/\" // block/proxy all unmatched domains\n\n                };\n\n                ruleLines.AddRange(GenerateExceptionRules(directGroups));\n\n            }\n\n            return ruleLines;\n\n        }\n\n\n\n        /// <summary>\n\n        /// Generates rules that match domains that should be proxied.\n\n        /// </summary>\n\n        /// <param name=\"groups\">A list of source groups.</param>\n\n        /// <returns>A list of rule lines.</returns>\n\n        private List<string> GenerateBlockingRules(List<string> groups)\n\n        {\n\n            List<string> ruleLines = new List<string>();\n\n            foreach (var group in groups)\n\n            {\n\n                // separate group name and attribute\n\n                SeparateAttributeFromGroupName(group, out string groupName, out string attribute);\n\n                var domainObjects = Geosites[groupName];\n\n                if (!string.IsNullOrEmpty(attribute)) // has attribute\n\n                {\n\n                    var attributeObject = new DomainObject.Types.Attribute\n\n                    {\n\n                        Key = attribute,\n\n                        BoolValue = true\n\n                    };\n\n                    foreach (var domainObject in domainObjects)\n\n                    {\n\n                        if (domainObject.Attribute.Contains(attributeObject))\n\n                            switch (domainObject.Type)\n\n                            {\n\n                                case DomainObject.Types.Type.Plain:\n\n                                    ruleLines.Add(domainObject.Value);\n\n                                    break;\n\n                                case DomainObject.Types.Type.Regex:\n\n                                    ruleLines.Add($\"/{domainObject.Value}/\");\n\n                                    break;\n\n                                case DomainObject.Types.Type.Domain:\n\n                                    ruleLines.Add($\"||{domainObject.Value}\");\n\n                                    break;\n\n                                case DomainObject.Types.Type.Full:\n\n                                    ruleLines.Add($\"|http://{domainObject.Value}\");\n\n                                    ruleLines.Add($\"|https://{domainObject.Value}\");\n\n                                    break;\n\n                            }\n\n                    }\n\n                }\n\n                else // no attribute\n\n                    foreach (var domainObject in domainObjects)\n\n                    {\n\n                        switch (domainObject.Type)\n\n                        {\n\n                            case DomainObject.Types.Type.Plain:\n\n                                ruleLines.Add(domainObject.Value);\n\n                                break;\n\n                            case DomainObject.Types.Type.Regex:\n\n                                ruleLines.Add($\"/{domainObject.Value}/\");\n\n                                break;\n\n                            case DomainObject.Types.Type.Domain:\n\n                                ruleLines.Add($\"||{domainObject.Value}\");\n\n                                break;\n\n                            case DomainObject.Types.Type.Full:\n\n                                ruleLines.Add($\"|http://{domainObject.Value}\");\n\n                                ruleLines.Add($\"|https://{domainObject.Value}\");\n\n                                break;\n\n                        }\n\n                    }\n\n            }\n\n            return ruleLines;\n\n        }\n\n\n\n        /// <summary>\n\n        /// Generates rules that match domains that should be connected directly without a proxy.\n\n        /// </summary>\n\n        /// <param name=\"groups\">A list of source groups.</param>\n\n        /// <returns>A list of rule lines.</returns>\n\n        private List<string> GenerateExceptionRules(List<string> groups)\n\n            => GenerateBlockingRules(groups)\n\n                .Select(r => $\"@@{r}\") // convert blocking rules to exception rules\n\n                .ToList();\n\n    }\n\n}\n", "\ufeff//------------------------------------------------------------------------------\n\n// <auto-generated>\n\n//     This code was generated by a tool.\n\n//     Runtime Version:4.0.30319.42000\n\n//\n\n//     Changes to this file may cause incorrect behavior and will be lost if\n\n//     the code is regenerated.\n\n// </auto-generated>\n\n//------------------------------------------------------------------------------\n\n\n\nnamespace Shadowsocks.PAC.Properties {\n\n    using System;\n\n    \n\n    \n\n    /// <summary>\n\n    ///   A strongly-typed resource class, for looking up localized strings, etc.\n\n    /// </summary>\n\n    // This class was auto-generated by the StronglyTypedResourceBuilder\n\n    // class via a tool like ResGen or Visual Studio.\n\n    // To add or remove a member, edit your .ResX file then rerun ResGen\n\n    // with the /str option, or rebuild your VS project.\n\n    [global::System.CodeDom.Compiler.GeneratedCodeAttribute(\"System.Resources.Tools.StronglyTypedResourceBuilder\", \"16.0.0.0\")]\n\n    [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]\n\n    [global::System.Runtime.CompilerServices.CompilerGeneratedAttribute()]\n\n    internal class Resources {\n\n        \n\n        private static global::System.Resources.ResourceManager resourceMan;\n\n        \n\n        private static global::System.Globalization.CultureInfo resourceCulture;\n\n        \n\n        [global::System.Diagnostics.CodeAnalysis.SuppressMessageAttribute(\"Microsoft.Performance\", \"CA1811:AvoidUncalledPrivateCode\")]\n\n        internal Resources() {\n\n        }\n\n        \n\n        /// <summary>\n\n        ///   Returns the cached ResourceManager instance used by this class.\n\n        /// </summary>\n\n        [global::System.ComponentModel.EditorBrowsableAttribute(global::System.ComponentModel.EditorBrowsableState.Advanced)]\n\n        internal static global::System.Resources.ResourceManager ResourceManager {\n\n            get {\n\n                if (object.ReferenceEquals(resourceMan, null)) {\n\n                    global::System.Resources.ResourceManager temp = new global::System.Resources.ResourceManager(\"Shadowsocks.PAC.Properties.Resources\", typeof(Resources).Assembly);\n\n                    resourceMan = temp;\n\n                }\n\n                return resourceMan;\n\n            }\n\n        }\n\n        \n\n        /// <summary>\n\n        ///   Overrides the current thread's CurrentUICulture property for all\n\n        ///   resource lookups using this strongly typed resource class.\n\n        /// </summary>\n\n        [global::System.ComponentModel.EditorBrowsableAttribute(global::System.ComponentModel.EditorBrowsableState.Advanced)]\n\n        internal static global::System.Globalization.CultureInfo Culture {\n\n            get {\n\n                return resourceCulture;\n\n            }\n\n            set {\n\n                resourceCulture = value;\n\n            }\n\n        }\n\n        \n\n        /// <summary>\n\n        ///   Looks up a localized string similar to /* eslint-disable */\n\n        ///// Was generated by gfwlist2pac in precise mode\n\n        ///// https://github.com/clowwindy/gfwlist2pac\n\n        ///\n\n        ///// 2019-10-06: More &apos;javascript&apos; way to interaction with main program\n\n        ///// 2019-02-08: Updated to support shadowsocks-windows user rules.\n\n        ///\n\n        ///var proxy = __PROXY__;\n\n        ///var userrules = [];\n\n        ///var rules = [];\n\n        ///\n\n        ///// convert to abp grammar\n\n        ///var re = /^(@@)?\\|\\|.*?[^\\^]$/;\n\n        ///for (var i = 0; i &lt; __RULES__.length; i++) {\n\n        ///    var s = __RULES__[i];\n\n        ///    if (s.match(re)) s += &quot;^&quot;;\n\n        ///    rules.push(s);\n\n        ///}\n\n        ///\n\n        /// [rest of string was truncated]&quot;;.\n\n        /// </summary>\n\n        internal static string abp {\n\n            get {\n\n                return ResourceManager.GetString(\"abp\", resourceCulture);\n\n            }\n\n        }\n\n        \n\n        /// <summary>\n\n        ///   Looks up a localized resource of type System.Byte[].\n\n        /// </summary>\n\n        internal static byte[] dlc {\n\n            get {\n\n                object obj = ResourceManager.GetObject(\"dlc\", resourceCulture);\n\n                return ((byte[])(obj));\n\n            }\n\n        }\n\n        \n\n        /// <summary>\n\n        ///   Looks up a localized string similar to ! Put user rules line by line in this file.\n\n        ///! See https://adblockplus.org/en/filter-cheatsheet\n\n        ///.\n\n        /// </summary>\n\n        internal static string user_rule {\n\n            get {\n\n                return ResourceManager.GetString(\"user_rule\", resourceCulture);\n\n            }\n\n        }\n\n    }\n\n}\n", "using System;\n\nusing Xunit;\n\n\n\nnamespace Shadowsocks.WPF.Tests\n\n{\n\n    public class DataUsageTests\n\n    {\n\n    }\n\n}\n", "using System.Windows;\n\n\n\n[assembly: ThemeInfo(\n\n    ResourceDictionaryLocation.None, //where theme specific resource dictionaries are located\n\n                                     //(used if a resource is not found in the page,\n\n                                     // or application resource dictionaries)\n\n    ResourceDictionaryLocation.SourceAssembly //where the generic resource dictionary is located\n\n                                              //(used if a resource is not found in the page,\n\n                                              // app, or any theme specific resource dictionaries)\n\n)]\n", "using ReactiveUI;\n\n\n\nusing Splat;\n\n\n\nusing System.Reflection;\n\nusing System.Windows;\n\n\n\nnamespace Shadowsocks.WPF\n\n{\n\n    /// <summary>\n\n    /// Interaction logic for App.xaml\n\n    /// </summary>\n\n    public partial class App : Application\n\n    {\n\n        public App()\n\n        {\n\n            Locator.CurrentMutable.RegisterViewsForViewModels(Assembly.GetCallingAssembly());\n\n        }\n\n    }\n\n}\n", "using Microsoft.Win32;\n\nusing Splat;\n\nusing System;\n\n\n\nnamespace Shadowsocks.WPF.Utils\n\n{\n\n    static class ProtocolHandler\n\n    {\n\n        const string ssURLRegKey = @\"SOFTWARE\\Classes\\ss\";\n\n\n\n        public static bool Set(bool enabled)\n\n        {\n\n            RegistryKey? ssURLAssociation = null;\n\n\n\n            try\n\n            {\n\n                ssURLAssociation = Registry.CurrentUser.CreateSubKey(ssURLRegKey, RegistryKeyPermissionCheck.ReadWriteSubTree);\n\n                if (ssURLAssociation == null)\n\n                {\n\n                    LogHost.Default.Error(@\"Failed to create HKCU\\SOFTWARE\\Classes\\ss to register ss:// association.\");\n\n                    return false;\n\n                }\n\n                if (enabled)\n\n                {\n\n                    ssURLAssociation.SetValue(\"\", \"URL:Shadowsocks\");\n\n                    ssURLAssociation.SetValue(\"URL Protocol\", \"\");\n\n                    var shellOpen = ssURLAssociation.CreateSubKey(\"shell\").CreateSubKey(\"open\").CreateSubKey(\"command\");\n\n                    shellOpen.SetValue(\"\", $\"{Utilities.ExecutablePath} --open-url %1\");\n\n                    LogHost.Default.Info(@\"Successfully added ss:// association.\");\n\n                }\n\n                else\n\n                {\n\n                    Registry.CurrentUser.DeleteSubKeyTree(ssURLRegKey);\n\n                    LogHost.Default.Info(@\"Successfully removed ss:// association.\");\n\n                }\n\n                return true;\n\n            }\n\n            catch (Exception e)\n\n            {\n\n                LogHost.Default.Error(e, \"An error occurred while setting ss:// association registry entries.\");\n\n                return false;\n\n            }\n\n            finally\n\n            {\n\n                if (ssURLAssociation != null)\n\n                {\n\n                    try\n\n                    {\n\n                        ssURLAssociation.Close();\n\n                        ssURLAssociation.Dispose();\n\n                    }\n\n                    catch (Exception e)\n\n                    {\n\n                        LogHost.Default.Error(e, \"An error occurred while setting ss:// association registry entries.\");\n\n                    }\n\n                }\n\n            }\n\n        }\n\n\n\n        public static bool Check()\n\n        {\n\n            RegistryKey? ssURLAssociation = null;\n\n            try\n\n            {\n\n                ssURLAssociation = Registry.CurrentUser.OpenSubKey(ssURLRegKey, true);\n\n                if (ssURLAssociation == null)\n\n                {\n\n                    //logger.Info(@\"ss:// links not associated.\");\n\n                    return false;\n\n                }\n\n\n\n                var shellOpen = ssURLAssociation.OpenSubKey(\"shell\")?.OpenSubKey(\"open\")?.OpenSubKey(\"command\");\n\n                return shellOpen?.GetValue(\"\") as string == $\"{Utilities.ExecutablePath} --open-url %1\";\n\n            }\n\n            catch (Exception e)\n\n            {\n\n                LogHost.Default.Error(e, \"An error occurred while checking ss:// association registry entries.\");\n\n                return false;\n\n            }\n\n            finally\n\n            {\n\n                if (ssURLAssociation != null)\n\n                {\n\n                    try\n\n                    {\n\n                        ssURLAssociation.Close();\n\n                        ssURLAssociation.Dispose();\n\n                    }\n\n                    catch (Exception e)\n\n                    {\n\n                        LogHost.Default.Error(e, \"An error occurred while checking ss:// association registry entries.\");\n\n                    }\n\n                }\n\n            }\n\n        }\n\n\n\n    }\n\n}\n", "using Splat;\n\nusing System;\n\nusing System.IO;\n\nusing System.IO.Compression;\n\nusing System.Text;\n\n\n\nnamespace Shadowsocks.WPF.Utils\n\n{\n\n    public static class FileManager\n\n    {\n\n        public static bool ByteArrayToFile(string fileName, byte[] content)\n\n        {\n\n            try\n\n            {\n\n                using (var fs = new FileStream(fileName, FileMode.Create, FileAccess.Write))\n\n                    fs.Write(content, 0, content.Length);\n\n                return true;\n\n            }\n\n            catch (Exception ex)\n\n            {\n\n                LogHost.Default.Error(ex, \"\");\n\n            }\n\n            return false;\n\n        }\n\n\n\n        public static void UncompressFile(string fileName, byte[] content)\n\n        {\n\n            // Because the uncompressed size of the file is unknown,\n\n            // we are using an arbitrary buffer size.\n\n            byte[] buffer = new byte[4096];\n\n            int n;\n\n\n\n            using(var fs = File.Create(fileName))\n\n            using (var input = new GZipStream(new MemoryStream(content),\n\n                    CompressionMode.Decompress, false))\n\n            {\n\n                while ((n = input.Read(buffer, 0, buffer.Length)) > 0)\n\n                {\n\n                    fs.Write(buffer, 0, n);\n\n                }\n\n            }\n\n        }\n\n\n\n        public static string NonExclusiveReadAllText(string path)\n\n        {\n\n            return NonExclusiveReadAllText(path, Encoding.Default);\n\n        }\n\n\n\n        public static string NonExclusiveReadAllText(string path, Encoding encoding)\n\n        {\n\n            try\n\n            {\n\n                using (var fs = new FileStream(path, FileMode.Open, FileAccess.Read, FileShare.ReadWrite))\n\n                using (var sr = new StreamReader(fs, encoding))\n\n                {\n\n                    return sr.ReadToEnd();\n\n                }\n\n            }\n\n            catch (Exception ex)\n\n            {\n\n                LogHost.Default.Error(ex, \"\");\n\n                throw;\n\n            }\n\n        }\n\n    }\n\n}\n", "using Shadowsocks.Net.SystemProxy;\n\nusing Shadowsocks.PAC;\n\nusing Shadowsocks.WPF.Models;\n\nusing Shadowsocks.WPF.Services.SystemProxy;\n\nusing Splat;\n\nusing System.Windows;\n\n\n\nnamespace Shadowsocks.WPF.Utils\n\n{\n\n    public static class SystemProxy\n\n    {\n\n        public static void Update(bool forceDisable, bool enabled, bool global)\n\n        {\n\n            var settings = Locator.Current.GetService<Settings>();\n\n            var appSettings = settings.App;\n\n            var netSettings = settings.Net;\n\n            var pacSettings = settings.PAC;\n\n\n\n            if (forceDisable || !WinINet.operational)\n\n            {\n\n                enabled = false;\n\n            }\n\n\n\n            try\n\n            {\n\n                if (enabled)\n\n                {\n\n                    if (global)\n\n                    {\n\n                        WinINet.ProxyGlobal($\"localhost:{netSettings.HttpListeningPort}\", \"<local>\");\n\n                    }\n\n                    else\n\n                    {\n\n                        var pacUrl = string.IsNullOrEmpty(pacSettings.CustomPACUrl)\n\n                            ? Locator.Current.GetService<PACServer>().PacUrl : pacSettings.CustomPACUrl;\n\n                        WinINet.ProxyPAC(pacUrl);\n\n                    }\n\n                }\n\n                else\n\n                {\n\n                    WinINet.Restore();\n\n                }\n\n            }\n\n            catch (ProxyException ex)\n\n            {\n\n                LogHost.Default.Error(ex, \"An error occurred while updating system proxy.\");\n\n                /*if (ex.Type != ProxyExceptionType.Unspecific && !noRetry)\n\n                {\n\n                    var ret = MessageBox.Show(I18N.GetString(\"Error occured when process proxy setting, do you want reset current setting and retry?\"), I18N.GetString(\"Shadowsocks\"), MessageBoxButtons.YesNo, MessageBoxIcon.Warning);\n\n                    if (ret == DialogResult.Yes)\n\n                    {\n\n                        WinINet.Reset();\n\n                        Update(config, forceDisable, pacSrv, true);\n\n                    }\n\n                }\n\n                else\n\n                {\n\n                    MessageBox.Show(I18N.GetString(\"Unrecoverable proxy setting error occured, see log for detail\"), I18N.GetString(\"Shadowsocks\"), MessageBoxButtons.OK, MessageBoxIcon.Error);\n\n                }*/\n\n            }\n\n        }\n\n    }\n\n}", "using Microsoft.Win32;\n\nusing Splat;\n\nusing System;\n\nusing System.Collections.Generic;\n\nusing System.Diagnostics;\n\nusing System.Linq;\n\nusing System.Runtime.InteropServices;\n\n\n\nnamespace Shadowsocks.WPF.Utils\n\n{\n\n    public static class AutoStartup\n\n    {\n\n        private static readonly string registryRunKey = @\"Software\\Microsoft\\Windows\\CurrentVersion\\Run\";\n\n        private static readonly string Key = \"Shadowsocks_\" + Utilities.ExecutablePath.GetHashCode();\n\n\n\n        public static bool Set(bool enabled)\n\n        {\n\n            RegistryKey? runKey = null;\n\n            try\n\n            {\n\n                runKey = Registry.CurrentUser.CreateSubKey(registryRunKey, RegistryKeyPermissionCheck.ReadWriteSubTree);\n\n                if (runKey == null)\n\n                {\n\n                    LogHost.Default.Error(@\"Cannot find HKCU\\{registryRunKey}.\");\n\n                    return false;\n\n                }\n\n                if (enabled)\n\n                {\n\n                    runKey.SetValue(Key, Utilities.ExecutablePath);\n\n                }\n\n                else\n\n                {\n\n                    runKey.DeleteValue(Key);\n\n                }\n\n                // When autostartup setting change, change RegisterForRestart state to avoid start 2 times\n\n                RegisterForRestart(!enabled);\n\n                return true;\n\n            }\n\n            catch (Exception e)\n\n            {\n\n                LogHost.Default.Error(e, \"An error occurred while setting auto startup registry entry.\");\n\n                return false;\n\n            }\n\n            finally\n\n            {\n\n                if (runKey != null)\n\n                {\n\n                    try\n\n                    {\n\n                        runKey.Close();\n\n                        runKey.Dispose();\n\n                    }\n\n                    catch (Exception e)\n\n                    {\n\n                        LogHost.Default.Error(e, \"An error occurred while setting auto startup registry entry.\");\n\n                    }\n\n                }\n\n            }\n\n        }\n\n\n\n        public static bool Check()\n\n        {\n\n            RegistryKey? runKey = null;\n\n            try\n\n            {\n\n                runKey = Registry.CurrentUser.CreateSubKey(registryRunKey, RegistryKeyPermissionCheck.ReadWriteSubTree);\n\n                if (runKey == null)\n\n                {\n\n                    LogHost.Default.Error(@\"Cannot find HKCU\\{registryRunKey}.\");\n\n                    return false;\n\n                }\n\n                var check = false;\n\n                foreach (var valueName in runKey.GetValueNames())\n\n                {\n\n                    if (valueName.Equals(Key, StringComparison.InvariantCultureIgnoreCase))\n\n                    {\n\n                        check = true;\n\n                        continue;\n\n                    }\n\n                    // Remove other startup keys with the same executable path. fixes #3011 and also assures compatibility with older versions\n\n                    if (Utilities.ExecutablePath.Equals(runKey.GetValue(valueName)?.ToString(), StringComparison.InvariantCultureIgnoreCase)\n\n                        is bool matchedDuplicate && matchedDuplicate)\n\n                    {\n\n                        runKey.DeleteValue(valueName);\n\n                        runKey.SetValue(Key, Utilities.ExecutablePath);\n\n                        check = true;\n\n                    }\n\n                }\n\n                return check;\n\n            }\n\n            catch (Exception e)\n\n            {\n\n                LogHost.Default.Error(e, \"An error occurred while checking auto startup registry entries.\");\n\n                return false;\n\n            }\n\n            finally\n\n            {\n\n                if (runKey != null)\n\n                {\n\n                    try\n\n                    {\n\n                        runKey.Close();\n\n                        runKey.Dispose();\n\n                    }\n\n                    catch (Exception e)\n\n                    {\n\n                        LogHost.Default.Error(e, \"An error occurred while checking auto startup registry entries.\");\n\n                    }\n\n                }\n\n            }\n\n        }\n\n\n\n        [DllImport(\"kernel32.dll\", SetLastError = true)]\n\n        static extern int RegisterApplicationRestart([MarshalAs(UnmanagedType.LPWStr)] string commandLineArgs, int Flags);\n\n\n\n        [DllImport(\"kernel32.dll\", SetLastError = true)]\n\n        static extern int UnregisterApplicationRestart();\n\n\n\n        [Flags]\n\n        enum ApplicationRestartFlags\n\n        {\n\n            RESTART_ALWAYS = 0,\n\n            RESTART_NO_CRASH = 1,\n\n            RESTART_NO_HANG = 2,\n\n            RESTART_NO_PATCH = 4,\n\n            RESTART_NO_REBOOT = 8,\n\n        }\n\n\n\n        // register restart after system reboot/update\n\n        public static void RegisterForRestart(bool register)\n\n        {\n\n            // requested register and not autostartup\n\n            if (register && !Check())\n\n            {\n\n                // escape command line parameter\n\n                string[] args = new List<string>(Environment.GetCommandLineArgs())\n\n                    .Select(p => p.Replace(\"\\\"\", \"\\\\\\\"\"))                   // escape \" to \\\"\n\n                    .Select(p => p.IndexOf(\" \") >= 0 ? \"\\\"\" + p + \"\\\"\" : p) // encapsule with \"\n\n                    .ToArray();\n\n                string cmdline = string.Join(\" \", args);\n\n                // first parameter is process command line parameter\n\n                // needn't include the name of the executable in the command line\n\n                RegisterApplicationRestart(cmdline, (int)(ApplicationRestartFlags.RESTART_NO_CRASH | ApplicationRestartFlags.RESTART_NO_HANG));\n\n                LogHost.Default.Debug(\"Register restart after system reboot, command line:\" + cmdline);\n\n            }\n\n            // requested unregister, which has no side effect\n\n            else if (!register)\n\n            {\n\n                UnregisterApplicationRestart();\n\n                LogHost.Default.Debug(\"Unregister restart after system reboot\");\n\n            }\n\n        }\n\n    }\n\n}\n", "using Shadowsocks.WPF.Models;\n\nusing Splat;\n\nusing System;\n\nusing System.Diagnostics;\n\nusing System.Drawing;\n\nusing System.IO;\n\nusing System.Runtime.InteropServices;\n\nusing System.Windows;\n\nusing ZXing;\n\nusing ZXing.Common;\n\nusing ZXing.QrCode;\n\n\n\nnamespace Shadowsocks.WPF.Utils\n\n{\n\n    public static class Utilities\n\n    {\n\n        private static string _tempPath = null!;\n\n\n\n        public static readonly string ExecutablePath = Process.GetCurrentProcess().MainModule?.FileName ?? \"\";\n\n        public static readonly string WorkingDirectory = Path.GetDirectoryName(ExecutablePath) ?? \"\";\n\n\n\n        // return path to store temporary files\n\n        public static string GetTempPath()\n\n        {\n\n            if (_tempPath == null)\n\n            {\n\n                bool isPortableMode = false; // TODO: fix --profile-directory\n\n                try\n\n                {\n\n                    if (isPortableMode)\n\n                    {\n\n                        _tempPath = Directory.CreateDirectory(\"ss_win_temp\").FullName;\n\n                        // don't use \"/\", it will fail when we call explorer /select xxx/ss_win_temp\\xxx.log\n\n                    }\n\n                    else\n\n                    {\n\n                        _tempPath = Directory.CreateDirectory(Path.Combine(Path.GetTempPath(), @\"Shadowsocks\\ss_win_temp_\" + ExecutablePath?.GetHashCode())).FullName;\n\n                    }\n\n                }\n\n                catch (Exception e)\n\n                {\n\n                    LogHost.Default.Error(e, \"Error: failed to create temporary directory.\");\n\n                    throw;\n\n                }\n\n            }\n\n            return _tempPath;\n\n        }\n\n\n\n        // return a full path with filename combined which pointed to the temporary directory\n\n        public static string GetTempPath(string filename) => Path.Combine(GetTempPath(), filename);\n\n\n\n        public static string ScanQRCodeFromScreen()\n\n        {\n\n            var screenLeft = SystemParameters.VirtualScreenLeft;\n\n            var screenTop = SystemParameters.VirtualScreenTop;\n\n            var screenWidth = SystemParameters.VirtualScreenWidth;\n\n            var screenHeight = SystemParameters.VirtualScreenHeight;\n\n\n\n            using (Bitmap bmp = new Bitmap((int)screenWidth, (int)screenHeight))\n\n            {\n\n                using (Graphics g = Graphics.FromImage(bmp))\n\n                    g.CopyFromScreen((int)screenLeft, (int)screenTop, 0, 0, bmp.Size);\n\n                int maxTry = 10;\n\n                for (int i = 0; i < maxTry; i++)\n\n                {\n\n                    int marginLeft = (int)((double)bmp.Width * i / 2.5 / maxTry);\n\n                    int marginTop = (int)((double)bmp.Height * i / 2.5 / maxTry);\n\n                    Rectangle cropRect = new Rectangle(marginLeft, marginTop, bmp.Width - marginLeft * 2, bmp.Height - marginTop * 2);\n\n                    Bitmap target = new Bitmap((int)screenWidth, (int)screenHeight);\n\n\n\n                    double imageScale = screenWidth / cropRect.Width;\n\n                    using (Graphics g = Graphics.FromImage(target))\n\n                        g.DrawImage(bmp, new Rectangle(0, 0, target.Width, target.Height), cropRect, GraphicsUnit.Pixel);\n\n                    var source = new BitmapLuminanceSource(target);\n\n                    var bitmap = new BinaryBitmap(new HybridBinarizer(source));\n\n                    QRCodeReader reader = new QRCodeReader();\n\n                    var result = reader.decode(bitmap);\n\n                    if (result != null)\n\n                        return result.Text;\n\n                }\n\n            }\n\n            return \"\";\n\n        }\n\n\n\n        public static void OpenInBrowser(string url)\n\n        {\n\n            try\n\n            {\n\n                Process.Start(url);\n\n            }\n\n            catch\n\n            {\n\n                // hack because of this: https://github.com/dotnet/corefx/issues/10361\n\n                if (RuntimeInformation.IsOSPlatform(OSPlatform.Windows))\n\n                {\n\n                    Process.Start(new ProcessStartInfo(url)\n\n                    {\n\n                        UseShellExecute = true,\n\n                        Verb = \"open\"\n\n                    });\n\n                }\n\n                else if (RuntimeInformation.IsOSPlatform(OSPlatform.Linux))\n\n                {\n\n                    Process.Start(\"xdg-open\", url);\n\n                }\n\n                else if (RuntimeInformation.IsOSPlatform(OSPlatform.OSX))\n\n                {\n\n                    Process.Start(\"open\", url);\n\n                }\n\n                else\n\n                {\n\n                    throw;\n\n                }\n\n            }\n\n        }\n\n    }\n\n}\n", "using System;\n\nusing System.IO.Pipes;\n\nusing System.Net;\n\nusing System.Text;\n\n\n\nnamespace Shadowsocks.WPF.Utils\n\n{\n\n    class RequestAddUrlEventArgs : EventArgs\n\n    {\n\n        public readonly string Url;\n\n\n\n        public RequestAddUrlEventArgs(string url)\n\n        {\n\n            Url = url;\n\n        }\n\n    }\n\n\n\n    internal class IPCService\n\n    {\n\n        private const int INT32_LEN = 4;\n\n        private const int OP_OPEN_URL = 1;\n\n        private static readonly string PIPE_PATH = $\"Shadowsocks\\\\{Utilities.ExecutablePath.GetHashCode()}\";\n\n\n\n        public event EventHandler<RequestAddUrlEventArgs>? OpenUrlRequested;\n\n\n\n        public async void RunServer()\n\n        {\n\n            byte[] buf = new byte[4096];\n\n            while (true)\n\n            {\n\n                using (NamedPipeServerStream stream = new NamedPipeServerStream(PIPE_PATH))\n\n                {\n\n                    await stream.WaitForConnectionAsync();\n\n                    await stream.ReadAsync(buf, 0, INT32_LEN);\n\n                    int opcode = IPAddress.NetworkToHostOrder(BitConverter.ToInt32(buf, 0));\n\n                    if (opcode == OP_OPEN_URL)\n\n                    {\n\n                        await stream.ReadAsync(buf, 0, INT32_LEN);\n\n                        int strlen = IPAddress.NetworkToHostOrder(BitConverter.ToInt32(buf, 0));\n\n\n\n                        await stream.ReadAsync(buf, 0, strlen);\n\n                        string url = Encoding.UTF8.GetString(buf, 0, strlen);\n\n\n\n                        OpenUrlRequested?.Invoke(this, new RequestAddUrlEventArgs(url));\n\n                    }\n\n                    stream.Close();\n\n                }\n\n            }\n\n        }\n\n\n\n        private static (NamedPipeClientStream, bool) TryConnect()\n\n        {\n\n            NamedPipeClientStream pipe = new NamedPipeClientStream(PIPE_PATH);\n\n            bool exist;\n\n            try\n\n            {\n\n                pipe.Connect(10);\n\n                exist = true;\n\n            }\n\n            catch (TimeoutException)\n\n            {\n\n                exist = false;\n\n            }\n\n            return (pipe, exist);\n\n        }\n\n\n\n        public static bool AnotherInstanceRunning()\n\n        {\n\n            (NamedPipeClientStream pipe, bool exist) = TryConnect();\n\n            pipe.Dispose();\n\n            return exist;\n\n        }\n\n\n\n        public static void RequestOpenUrl(string url)\n\n        {\n\n            (NamedPipeClientStream pipe, bool exist) = TryConnect();\n\n            if(!exist) return;\n\n            byte[] opAddUrl = BitConverter.GetBytes(IPAddress.HostToNetworkOrder(OP_OPEN_URL));\n\n            pipe.Write(opAddUrl, 0, INT32_LEN); // opcode addurl\n\n            byte[] b = Encoding.UTF8.GetBytes(url);\n\n            byte[] blen = BitConverter.GetBytes(IPAddress.HostToNetworkOrder(b.Length));\n\n            pipe.Write(blen, 0, INT32_LEN);\n\n            pipe.Write(b, 0, b.Length);\n\n            pipe.Close();\n\n            pipe.Dispose();\n\n        }\n\n    }\n\n}\n", "namespace Shadowsocks.WPF.Models\n\n{\n\n    public class Server : Shadowsocks.Models.Server\n\n    {\n\n        /// <summary>\n\n        /// Gets or sets the amount of data ingress in bytes.\n\n        /// </summary>\n\n        public ulong BytesIngress { get; set; }\n\n\n\n        /// <summary>\n\n        /// Gets or sets the amount of data egress in bytes.\n\n        /// </summary>\n\n        public ulong BytesEgress { get; set; }\n\n\n\n        public Server()\n\n        {\n\n            BytesIngress = 0UL;\n\n            BytesEgress = 0UL;\n\n        }\n\n    }\n\n}\n", "using Shadowsocks.Interop.Settings;\n\nusing Shadowsocks.Net.Settings;\n\nusing Shadowsocks.PAC;\n\nusing System.Collections.Generic;\n\n\n\nnamespace Shadowsocks.WPF.Models\n\n{\n\n    public class Settings\n\n    {\n\n        public AppSettings App { get; set; }\n\n\n\n        public InteropSettings Interop { get; set; }\n\n        \n\n        public NetSettings Net { get; set; }\n\n\n\n        public PACSettings PAC { get; set; }\n\n        \n\n        public List<Group> Groups { get; set; }\n\n        \n\n        public Settings()\n\n        {\n\n            App = new AppSettings();\n\n            Interop = new InteropSettings();\n\n            Net = new NetSettings();\n\n            PAC = new PACSettings();\n\n            Groups = new List<Group>();\n\n        }\n\n    }\n\n}\n", "namespace Shadowsocks.WPF.Models\n\n{\n\n    public class Group : Shadowsocks.Models.Group\n\n    {\n\n        /// <summary>\n\n        /// Gets or sets the URL of SIP008 online configuration delivery source.\n\n        /// </summary>\n\n        public string OnlineConfigSource { get; set; }\n\n\n\n        public Group() : this(string.Empty)\n\n        { }\n\n\n\n        public Group(string name) : base(name)\n\n        {\n\n            OnlineConfigSource = \"\";\n\n        }\n\n    }\n\n}\n", "using System;\n\nusing System.Collections.Generic;\n\nusing System.Text;\n\n\n\nnamespace Shadowsocks.WPF.Models\n\n{\n\n    public class AppSettings\n\n    {\n\n        public bool StartOnBoot { get; set; }\n\n        public bool AssociateSsLinks { get; set; }\n\n        public bool VersionUpdateCheckForPrerelease { get; set; }\n\n        public string SkippedUpdateVersion { get; set; }\n\n\n\n        public AppSettings()\n\n        {\n\n            StartOnBoot = false;\n\n            AssociateSsLinks = false;\n\n            VersionUpdateCheckForPrerelease = false;\n\n            SkippedUpdateVersion = \"\";\n\n        }\n\n    }\n\n}\n", "using ReactiveUI;\n\nusing Shadowsocks.WPF.ViewModels;\n\nusing System.Reactive.Disposables;\n\n\n\nnamespace Shadowsocks.WPF.Views\n\n{\n\n    /// <summary>\n\n    /// Interaction logic for ForwardProxyView.xaml\n\n    /// </summary>\n\n    public partial class ForwardProxyView\n\n    {\n\n        public ForwardProxyView()\n\n        {\n\n            InitializeComponent();\n\n            ViewModel = new ForwardProxyViewModel();\n\n            this.WhenActivated(disposables =>\n\n            {\n\n                this.Bind(ViewModel,\n\n                    viewModel => viewModel.NoProxy,\n\n                    view => view.noProxyRadioButton.IsChecked)\n\n                    .DisposeWith(disposables);\n\n                this.Bind(ViewModel,\n\n                    viewModel => viewModel.UseSocks5Proxy,\n\n                    view => view.socks5RadioButton.IsChecked)\n\n                    .DisposeWith(disposables);\n\n                this.Bind(ViewModel,\n\n                    viewModel => viewModel.UseHttpProxy,\n\n                    view => view.httpRadioButton.IsChecked)\n\n                    .DisposeWith(disposables);\n\n\n\n                this.Bind(ViewModel,\n\n                    viewModel => viewModel.Address,\n\n                    view => view.addressTextBox.Text)\n\n                    .DisposeWith(disposables);\n\n                this.Bind(ViewModel,\n\n                    viewModel => viewModel.Port,\n\n                    view => view.portTextBox.Text)\n\n                    .DisposeWith(disposables);\n\n                this.Bind(ViewModel,\n\n                    viewModel => viewModel.Timeout,\n\n                    view => view.timeoutTextBox.Text)\n\n                    .DisposeWith(disposables);\n\n                this.OneWayBind(ViewModel,\n\n                    viewModel => viewModel.CanModifyDetails,\n\n                    view => view.addressTextBox.IsEnabled)\n\n                    .DisposeWith(disposables);\n\n                this.OneWayBind(ViewModel,\n\n                    viewModel => viewModel.CanModifyDetails,\n\n                    view => view.portTextBox.IsEnabled)\n\n                    .DisposeWith(disposables);\n\n                this.OneWayBind(ViewModel,\n\n                    viewModel => viewModel.CanModifyDetails,\n\n                    view => view.timeoutTextBox.IsEnabled)\n\n                    .DisposeWith(disposables);\n\n\n\n                this.Bind(ViewModel,\n\n                    viewModel => viewModel.Username,\n\n                    view => view.usernameTextBox.Text)\n\n                    .DisposeWith(disposables);\n\n                this.Bind(ViewModel,\n\n                    viewModel => viewModel.Password,\n\n                    view => view.passwordTextBox.Text)\n\n                    .DisposeWith(disposables);\n\n                this.OneWayBind(ViewModel,\n\n                    viewModel => viewModel.UseHttpProxy,\n\n                    view => view.usernameTextBox.IsEnabled)\n\n                    .DisposeWith(disposables);\n\n                this.OneWayBind(ViewModel,\n\n                    viewModel => viewModel.UseHttpProxy,\n\n                    view => view.passwordTextBox.IsEnabled)\n\n                    .DisposeWith(disposables);\n\n\n\n                this.BindCommand(ViewModel,\n\n                    viewModel => viewModel.Save,\n\n                    view => view.saveButton)\n\n                    .DisposeWith(disposables);\n\n                this.BindCommand(ViewModel,\n\n                    viewModel => viewModel.Cancel,\n\n                    view => view.cancelButton)\n\n                    .DisposeWith(disposables);\n\n            });\n\n        }\n\n    }\n\n}\n", "using ReactiveUI;\n\nusing Shadowsocks.WPF.ViewModels;\n\nusing System;\n\nusing System.Collections.Generic;\n\nusing System.Text;\n\nusing System.Windows;\n\nusing System.Windows.Controls;\n\nusing System.Windows.Data;\n\nusing System.Windows.Documents;\n\nusing System.Windows.Input;\n\nusing System.Windows.Media;\n\nusing System.Windows.Media.Imaging;\n\nusing System.Windows.Navigation;\n\nusing System.Windows.Shapes;\n\n\n\nnamespace Shadowsocks.WPF.Views\n\n{\n\n    /// <summary>\n\n    /// Interaction logic for SettingsView.xaml\n\n    /// </summary>\n\n    public partial class SettingsView\n\n    {\n\n        public SettingsView()\n\n        {\n\n            InitializeComponent();\n\n            this.WhenActivated(disposables =>\n\n            {\n\n\n\n            });\n\n        }\n\n    }\n\n}\n", "using ReactiveUI;\n\nusing Shadowsocks.WPF.ViewModels;\n\nusing System;\n\nusing System.Collections.Generic;\n\nusing System.Text;\n\nusing System.Windows;\n\nusing System.Windows.Controls;\n\nusing System.Windows.Data;\n\nusing System.Windows.Documents;\n\nusing System.Windows.Input;\n\nusing System.Windows.Media;\n\nusing System.Windows.Media.Imaging;\n\nusing System.Windows.Navigation;\n\nusing System.Windows.Shapes;\n\n\n\nnamespace Shadowsocks.WPF.Views\n\n{\n\n    /// <summary>\n\n    /// Interaction logic for DashboardView.xaml\n\n    /// </summary>\n\n    public partial class DashboardView\n\n    {\n\n        public DashboardView()\n\n        {\n\n            InitializeComponent();\n\n            this.WhenActivated(disposables =>\n\n            {\n\n\n\n            });\n\n        }\n\n    }\n\n}\n", "using ReactiveUI;\n\nusing Shadowsocks.WPF.ViewModels;\n\nusing System;\n\nusing System.Collections.Generic;\n\nusing System.Text;\n\nusing System.Windows;\n\nusing System.Windows.Controls;\n\nusing System.Windows.Data;\n\nusing System.Windows.Documents;\n\nusing System.Windows.Input;\n\nusing System.Windows.Media;\n\nusing System.Windows.Media.Imaging;\n\nusing System.Windows.Navigation;\n\nusing System.Windows.Shapes;\n\n\n\nnamespace Shadowsocks.WPF.Views\n\n{\n\n    /// <summary>\n\n    /// Interaction logic for ServersView.xaml\n\n    /// </summary>\n\n    public partial class ServersView\n\n    {\n\n        public ServersView()\n\n        {\n\n            InitializeComponent();\n\n            this.WhenActivated(disposables =>\n\n            {\n\n\n\n            });\n\n        }\n\n    }\n\n}\n", "using ReactiveUI;\n\nusing Shadowsocks.WPF.ViewModels;\n\nusing System.Reactive.Disposables;\n\nusing System.Windows.Input;\n\n\n\nnamespace Shadowsocks.WPF.Views\n\n{\n\n    /// <summary>\n\n    /// Interaction logic for ServerSharingView.xaml\n\n    /// </summary>\n\n    public partial class ServerSharingView\n\n    {\n\n        public ServerSharingView()\n\n        {\n\n            InitializeComponent();\n\n            this.WhenActivated(disposables =>\n\n            {\n\n                this.OneWayBind(ViewModel,\n\n                    viewModel => viewModel.SelectedServerUrlImage,\n\n                    view => view.qrCodeImage.Source)\n\n                    .DisposeWith(disposables);\n\n                this.OneWayBind(ViewModel,\n\n                    viewModel => viewModel.Servers,\n\n                    view => view.serversListBox.ItemsSource)\n\n                    .DisposeWith(disposables);\n\n                this.Bind(ViewModel,\n\n                    viewModel => viewModel.SelectedServer,\n\n                    view => view.serversListBox.SelectedItem)\n\n                    .DisposeWith(disposables);\n\n                this.OneWayBind(ViewModel,\n\n                    viewModel => viewModel.SelectedServerUrl,\n\n                    view => view.urlTextBox.Text)\n\n                    .DisposeWith(disposables);\n\n\n\n                this.BindCommand(ViewModel!,\n\n                    viewModel => viewModel.CopyLink,\n\n                    view => view.copyLinkButton)\n\n                    .DisposeWith(disposables);\n\n            });\n\n        }\n\n\n\n        private void urlTextBox_PreviewMouseDoubleClick(object sender, MouseButtonEventArgs e)\n\n        {\n\n            urlTextBox.SelectAll();\n\n        }\n\n    }\n\n}\n", "using ReactiveUI;\n\nusing Shadowsocks.WPF.ViewModels;\n\nusing System.Reactive.Disposables;\n\nusing System.Text.Json;\n\n\n\nnamespace Shadowsocks.WPF.Views\n\n{\n\n    /// <summary>\n\n    /// Interaction logic for VersionUpdatePromptView.xaml\n\n    /// </summary>\n\n    public partial class VersionUpdatePromptView\n\n    {\n\n        public VersionUpdatePromptView()\n\n        {\n\n            InitializeComponent();\n\n            DataContext = ViewModel; // for compatibility with MdXaml\n\n            this.WhenActivated(disposables =>\n\n            {\n\n                /*this.OneWayBind(ViewModel,\n\n                    viewModel => viewModel.ReleaseNotes,\n\n                    view => releaseNotesMarkdownScrollViewer.Markdown)\n\n                    .DisposeWith(disposables);*/\n\n\n\n                this.BindCommand(ViewModel!,\n\n                    viewModel => viewModel.Update,\n\n                    view => view.updateButton)\n\n                    .DisposeWith(disposables);\n\n                this.BindCommand(ViewModel!,\n\n                    viewModel => viewModel.SkipVersion,\n\n                    view => view.skipVersionButton)\n\n                    .DisposeWith(disposables);\n\n                this.BindCommand(ViewModel!,\n\n                    viewModel => viewModel.NotNow,\n\n                    view => view.notNowButton)\n\n                    .DisposeWith(disposables);\n\n            });\n\n        }\n\n    }\n\n}\n", "using ReactiveUI;\n\nusing Shadowsocks.WPF.ViewModels;\n\nusing System.Reactive.Disposables;\n\n\n\nnamespace Shadowsocks.WPF.Views\n\n{\n\n    /// <summary>\n\n    /// Interaction logic for OnlineConfigView.xaml\n\n    /// </summary>\n\n    public partial class OnlineConfigView\n\n    {\n\n        public OnlineConfigView()\n\n        {\n\n            InitializeComponent();\n\n            ViewModel = new OnlineConfigViewModel();\n\n            this.WhenActivated(disposables =>\n\n            {\n\n                this.OneWayBind(ViewModel,\n\n                    viewModel => viewModel.Sources,\n\n                    view => view.sourcesListBox.ItemsSource)\n\n                    .DisposeWith(disposables);\n\n                this.Bind(ViewModel,\n\n                    viewModel => viewModel.SelectedSource,\n\n                    view => view.sourcesListBox.SelectedItem)\n\n                    .DisposeWith(disposables);\n\n                this.Bind(ViewModel,\n\n                    viewModel => viewModel.Address,\n\n                    view => view.urlTextBox.Text)\n\n                    .DisposeWith(disposables);\n\n\n\n                this.BindCommand(ViewModel,\n\n                    viewModel => viewModel.Update,\n\n                    view => view.updateButton)\n\n                    .DisposeWith(disposables);\n\n                this.BindCommand(ViewModel,\n\n                    viewModel => viewModel.UpdateAll,\n\n                    view => view.updateAllButton)\n\n                    .DisposeWith(disposables);\n\n                this.BindCommand(ViewModel,\n\n                    viewModel => viewModel.CopyLink,\n\n                    view => view.copyLinkButton)\n\n                    .DisposeWith(disposables);\n\n                this.BindCommand(ViewModel,\n\n                    viewModel => viewModel.Remove,\n\n                    view => view.removeButton)\n\n                    .DisposeWith(disposables);\n\n                this.BindCommand(ViewModel,\n\n                    viewModel => viewModel.Add,\n\n                    view => view.addButton)\n\n                    .DisposeWith(disposables);\n\n            });\n\n        }\n\n    }\n\n}\n", "using ReactiveUI;\n\nusing Shadowsocks.WPF.ViewModels;\n\nusing System;\n\nusing System.Collections.Generic;\n\nusing System.Text;\n\nusing System.Windows;\n\nusing System.Windows.Controls;\n\nusing System.Windows.Data;\n\nusing System.Windows.Documents;\n\nusing System.Windows.Input;\n\nusing System.Windows.Media;\n\nusing System.Windows.Media.Imaging;\n\nusing System.Windows.Navigation;\n\nusing System.Windows.Shapes;\n\n\n\nnamespace Shadowsocks.WPF.Views\n\n{\n\n    /// <summary>\n\n    /// Interaction logic for RoutingView.xaml\n\n    /// </summary>\n\n    public partial class RoutingView\n\n    {\n\n        public RoutingView()\n\n        {\n\n            InitializeComponent();\n\n            this.WhenActivated(disposables =>\n\n            {\n\n\n\n            });\n\n        }\n\n    }\n\n}\n", "using ReactiveUI;\n\nusing Shadowsocks.WPF.ViewModels;\n\nusing System.Reactive.Disposables;\n\n\n\nnamespace Shadowsocks.WPF.Views\n\n{\n\n    /// <summary>\n\n    /// Interaction logic for MainWindow.xaml\n\n    /// </summary>\n\n    public partial class MainWindow\n\n    {\n\n        public MainWindow()\n\n        {\n\n            InitializeComponent();\n\n            ViewModel = new MainWindowViewModel();\n\n            this.WhenActivated(disposables =>\n\n            {\n\n                this.OneWayBind(ViewModel,\n\n                    viewModel => viewModel.GetDashboardView,\n\n                    view => view.dashboardTabItem.Content)\n\n                    .DisposeWith(disposables);\n\n                this.OneWayBind(ViewModel,\n\n                    viewModel => viewModel.GetServersView,\n\n                    view => view.serversTabItem.Content)\n\n                    .DisposeWith(disposables);\n\n                this.OneWayBind(ViewModel,\n\n                    viewModel => viewModel.GetRoutingView,\n\n                    view => view.routingTabItem.Content)\n\n                    .DisposeWith(disposables);\n\n                this.OneWayBind(ViewModel,\n\n                    viewModel => viewModel.GetSettingsView,\n\n                    view => view.settingsTabItem.Content)\n\n                    .DisposeWith(disposables);\n\n            });\n\n        }\n\n    }\n\n}\n", "\ufeff//------------------------------------------------------------------------------\n\n// <auto-generated>\n\n//     This code was generated by a tool.\n\n//     Runtime Version:4.0.30319.42000\n\n//\n\n//     Changes to this file may cause incorrect behavior and will be lost if\n\n//     the code is regenerated.\n\n// </auto-generated>\n\n//------------------------------------------------------------------------------\n\n\n\nnamespace Shadowsocks.WPF.Localization {\n\n    using System;\n\n    \n\n    \n\n    /// <summary>\n\n    ///   A strongly-typed resource class, for looking up localized strings, etc.\n\n    /// </summary>\n\n    // This class was auto-generated by the StronglyTypedResourceBuilder\n\n    // class via a tool like ResGen or Visual Studio.\n\n    // To add or remove a member, edit your .ResX file then rerun ResGen\n\n    // with the /str option, or rebuild your VS project.\n\n    [global::System.CodeDom.Compiler.GeneratedCodeAttribute(\"System.Resources.Tools.StronglyTypedResourceBuilder\", \"16.0.0.0\")]\n\n    [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]\n\n    [global::System.Runtime.CompilerServices.CompilerGeneratedAttribute()]\n\n    internal class Strings {\n\n        \n\n        private static global::System.Resources.ResourceManager resourceMan;\n\n        \n\n        private static global::System.Globalization.CultureInfo resourceCulture;\n\n        \n\n        [global::System.Diagnostics.CodeAnalysis.SuppressMessageAttribute(\"Microsoft.Performance\", \"CA1811:AvoidUncalledPrivateCode\")]\n\n        internal Strings() {\n\n        }\n\n        \n\n        /// <summary>\n\n        ///   Returns the cached ResourceManager instance used by this class.\n\n        /// </summary>\n\n        [global::System.ComponentModel.EditorBrowsableAttribute(global::System.ComponentModel.EditorBrowsableState.Advanced)]\n\n        internal static global::System.Resources.ResourceManager ResourceManager {\n\n            get {\n\n                if (object.ReferenceEquals(resourceMan, null)) {\n\n                    global::System.Resources.ResourceManager temp = new global::System.Resources.ResourceManager(\"Shadowsocks.Localization.Strings\", typeof(Strings).Assembly);\n\n                    resourceMan = temp;\n\n                }\n\n                return resourceMan;\n\n            }\n\n        }\n\n        \n\n        /// <summary>\n\n        ///   Overrides the current thread's CurrentUICulture property for all\n\n        ///   resource lookups using this strongly typed resource class.\n\n        /// </summary>\n\n        [global::System.ComponentModel.EditorBrowsableAttribute(global::System.ComponentModel.EditorBrowsableState.Advanced)]\n\n        internal static global::System.Globalization.CultureInfo Culture {\n\n            get {\n\n                return resourceCulture;\n\n            }\n\n            set {\n\n                resourceCulture = value;\n\n            }\n\n        }\n\n        \n\n        /// <summary>\n\n        ///   Looks up a localized string similar to _Add.\n\n        /// </summary>\n\n        internal static string addButton_Content {\n\n            get {\n\n                return ResourceManager.GetString(\"addButton_Content\", resourceCulture);\n\n            }\n\n        }\n\n        \n\n        /// <summary>\n\n        ///   Looks up a localized string similar to Address.\n\n        /// </summary>\n\n        internal static string Address {\n\n            get {\n\n                return ResourceManager.GetString(\"Address\", resourceCulture);\n\n            }\n\n        }\n\n        \n\n        /// <summary>\n\n        ///   Looks up a localized string similar to Allow clients from LAN.\n\n        /// </summary>\n\n        internal static string AllowClientsFromLAN {\n\n            get {\n\n                return ResourceManager.GetString(\"AllowClientsFromLAN\", resourceCulture);\n\n            }\n\n        }\n\n        \n\n        /// <summary>\n\n        ///   Looks up a localized string similar to _Cancel.\n\n        /// </summary>\n\n        internal static string cancelButton_Content {\n\n            get {\n\n                return ResourceManager.GetString(\"cancelButton_Content\", resourceCulture);\n\n            }\n\n        }\n\n        \n\n        /// <summary>\n\n        ///   Looks up a localized string similar to _Copy.\n\n        /// </summary>\n\n        internal static string Copy {\n\n            get {\n\n                return ResourceManager.GetString(\"Copy\", resourceCulture);\n\n            }\n\n        }\n\n        \n\n        /// <summary>\n\n        ///   Looks up a localized string similar to _Copy link.\n\n        /// </summary>\n\n        internal static string copyLinkButton_Content {\n\n            get {\n\n                return ResourceManager.GetString(\"copyLinkButton_Content\", resourceCulture);\n\n            }\n\n        }\n\n        \n\n        /// <summary>\n\n        ///   Looks up a localized string similar to Credentials (optional).\n\n        /// </summary>\n\n        internal static string CredentialsOptional {\n\n            get {\n\n                return ResourceManager.GetString(\"CredentialsOptional\", resourceCulture);\n\n            }\n\n        }\n\n        \n\n        /// <summary>\n\n        ///   Looks up a localized string similar to Details.\n\n        /// </summary>\n\n        internal static string Details {\n\n            get {\n\n                return ResourceManager.GetString(\"Details\", resourceCulture);\n\n            }\n\n        }\n\n        \n\n        /// <summary>\n\n        ///   Looks up a localized string similar to Forward Proxy.\n\n        /// </summary>\n\n        internal static string ForwardProxy {\n\n            get {\n\n                return ResourceManager.GetString(\"ForwardProxy\", resourceCulture);\n\n            }\n\n        }\n\n        \n\n        /// <summary>\n\n        ///   Looks up a localized string similar to Hotkeys.\n\n        /// </summary>\n\n        internal static string Hotkeys {\n\n            get {\n\n                return ResourceManager.GetString(\"Hotkeys\", resourceCulture);\n\n            }\n\n        }\n\n        \n\n        /// <summary>\n\n        ///   Looks up a localized string similar to HTTP.\n\n        /// </summary>\n\n        internal static string HTTP {\n\n            get {\n\n                return ResourceManager.GetString(\"HTTP\", resourceCulture);\n\n            }\n\n        }\n\n        \n\n        /// <summary>\n\n        ///   Looks up a localized string similar to No proxy.\n\n        /// </summary>\n\n        internal static string NoProxy {\n\n            get {\n\n                return ResourceManager.GetString(\"NoProxy\", resourceCulture);\n\n            }\n\n        }\n\n        \n\n        /// <summary>\n\n        ///   Looks up a localized string similar to _Not now.\n\n        /// </summary>\n\n        internal static string notNowButton_Content {\n\n            get {\n\n                return ResourceManager.GetString(\"notNowButton_Content\", resourceCulture);\n\n            }\n\n        }\n\n        \n\n        /// <summary>\n\n        ///   Looks up a localized string similar to _OK.\n\n        /// </summary>\n\n        internal static string okButton_Content {\n\n            get {\n\n                return ResourceManager.GetString(\"okButton_Content\", resourceCulture);\n\n            }\n\n        }\n\n        \n\n        /// <summary>\n\n        ///   Looks up a localized string similar to Online Configuration Delivery.\n\n        /// </summary>\n\n        internal static string OnlineConfigDelivery {\n\n            get {\n\n                return ResourceManager.GetString(\"OnlineConfigDelivery\", resourceCulture);\n\n            }\n\n        }\n\n        \n\n        /// <summary>\n\n        ///   Looks up a localized string similar to Open logs window.\n\n        /// </summary>\n\n        internal static string OpenLogsWindow {\n\n            get {\n\n                return ResourceManager.GetString(\"OpenLogsWindow\", resourceCulture);\n\n            }\n\n        }\n\n        \n\n        /// <summary>\n\n        ///   Looks up a localized string similar to Password.\n\n        /// </summary>\n\n        internal static string Password {\n\n            get {\n\n                return ResourceManager.GetString(\"Password\", resourceCulture);\n\n            }\n\n        }\n\n        \n\n        /// <summary>\n\n        ///   Looks up a localized string similar to Port.\n\n        /// </summary>\n\n        internal static string Port {\n\n            get {\n\n                return ResourceManager.GetString(\"Port\", resourceCulture);\n\n            }\n\n        }\n\n        \n\n        /// <summary>\n\n        ///   Looks up a localized string similar to _Register all.\n\n        /// </summary>\n\n        internal static string registerAllButton_Content {\n\n            get {\n\n                return ResourceManager.GetString(\"registerAllButton_Content\", resourceCulture);\n\n            }\n\n        }\n\n        \n\n        /// <summary>\n\n        ///   Looks up a localized string similar to Register hotkeys at startup.\n\n        /// </summary>\n\n        internal static string RegisterHotkeysAtStartup {\n\n            get {\n\n                return ResourceManager.GetString(\"RegisterHotkeysAtStartup\", resourceCulture);\n\n            }\n\n        }\n\n        \n\n        /// <summary>\n\n        ///   Looks up a localized string similar to Remove.\n\n        /// </summary>\n\n        internal static string removeButton_Content {\n\n            get {\n\n                return ResourceManager.GetString(\"removeButton_Content\", resourceCulture);\n\n            }\n\n        }\n\n        \n\n        /// <summary>\n\n        ///   Looks up a localized string similar to _Save.\n\n        /// </summary>\n\n        internal static string saveButton_Content {\n\n            get {\n\n                return ResourceManager.GetString(\"saveButton_Content\", resourceCulture);\n\n            }\n\n        }\n\n        \n\n        /// <summary>\n\n        ///   Looks up a localized string similar to Server Sharing.\n\n        /// </summary>\n\n        internal static string ServerSharing {\n\n            get {\n\n                return ResourceManager.GetString(\"ServerSharing\", resourceCulture);\n\n            }\n\n        }\n\n        \n\n        /// <summary>\n\n        ///   Looks up a localized string similar to The following sources failed to update:\\n\\n.\n\n        /// </summary>\n\n        internal static string sip008UpdateAllFailure {\n\n            get {\n\n                return ResourceManager.GetString(\"sip008UpdateAllFailure\", resourceCulture);\n\n            }\n\n        }\n\n        \n\n        /// <summary>\n\n        ///   Looks up a localized string similar to Successfully updated all sources!.\n\n        /// </summary>\n\n        internal static string sip008UpdateAllSuccess {\n\n            get {\n\n                return ResourceManager.GetString(\"sip008UpdateAllSuccess\", resourceCulture);\n\n            }\n\n        }\n\n        \n\n        /// <summary>\n\n        ///   Looks up a localized string similar to Update failed. See the logs for more information..\n\n        /// </summary>\n\n        internal static string sip008UpdateFailure {\n\n            get {\n\n                return ResourceManager.GetString(\"sip008UpdateFailure\", resourceCulture);\n\n            }\n\n        }\n\n        \n\n        /// <summary>\n\n        ///   Looks up a localized string similar to Successfully updated the selected source!.\n\n        /// </summary>\n\n        internal static string sip008UpdateSuccess {\n\n            get {\n\n                return ResourceManager.GetString(\"sip008UpdateSuccess\", resourceCulture);\n\n            }\n\n        }\n\n        \n\n        /// <summary>\n\n        ///   Looks up a localized string similar to _Skip version.\n\n        /// </summary>\n\n        internal static string skipVersionButton_Content {\n\n            get {\n\n                return ResourceManager.GetString(\"skipVersionButton_Content\", resourceCulture);\n\n            }\n\n        }\n\n        \n\n        /// <summary>\n\n        ///   Looks up a localized string similar to SOCKS5.\n\n        /// </summary>\n\n        internal static string SOCKS5 {\n\n            get {\n\n                return ResourceManager.GetString(\"SOCKS5\", resourceCulture);\n\n            }\n\n        }\n\n        \n\n        /// <summary>\n\n        ///   Looks up a localized string similar to Switch to next server.\n\n        /// </summary>\n\n        internal static string SwitchToNextServer {\n\n            get {\n\n                return ResourceManager.GetString(\"SwitchToNextServer\", resourceCulture);\n\n            }\n\n        }\n\n        \n\n        /// <summary>\n\n        ///   Looks up a localized string similar to Switch to previous server.\n\n        /// </summary>\n\n        internal static string SwitchToPreviousServer {\n\n            get {\n\n                return ResourceManager.GetString(\"SwitchToPreviousServer\", resourceCulture);\n\n            }\n\n        }\n\n        \n\n        /// <summary>\n\n        ///   Looks up a localized string similar to Timeout (sec).\n\n        /// </summary>\n\n        internal static string Timeout {\n\n            get {\n\n                return ResourceManager.GetString(\"Timeout\", resourceCulture);\n\n            }\n\n        }\n\n        \n\n        /// <summary>\n\n        ///   Looks up a localized string similar to Toggle proxy mode.\n\n        /// </summary>\n\n        internal static string ToggleProxyMode {\n\n            get {\n\n                return ResourceManager.GetString(\"ToggleProxyMode\", resourceCulture);\n\n            }\n\n        }\n\n        \n\n        /// <summary>\n\n        ///   Looks up a localized string similar to Toggle system proxy.\n\n        /// </summary>\n\n        internal static string ToggleSystemProxy {\n\n            get {\n\n                return ResourceManager.GetString(\"ToggleSystemProxy\", resourceCulture);\n\n            }\n\n        }\n\n        \n\n        /// <summary>\n\n        ///   Looks up a localized string similar to Type.\n\n        /// </summary>\n\n        internal static string Type {\n\n            get {\n\n                return ResourceManager.GetString(\"Type\", resourceCulture);\n\n            }\n\n        }\n\n        \n\n        /// <summary>\n\n        ///   Looks up a localized string similar to Update all.\n\n        /// </summary>\n\n        internal static string updateAllButton_Content {\n\n            get {\n\n                return ResourceManager.GetString(\"updateAllButton_Content\", resourceCulture);\n\n            }\n\n        }\n\n        \n\n        /// <summary>\n\n        ///   Looks up a localized string similar to _Update.\n\n        /// </summary>\n\n        internal static string updateButton_Content {\n\n            get {\n\n                return ResourceManager.GetString(\"updateButton_Content\", resourceCulture);\n\n            }\n\n        }\n\n        \n\n        /// <summary>\n\n        ///   Looks up a localized string similar to Please read the release notes carefully. Then decide whether to update..\n\n        /// </summary>\n\n        internal static string updatePromptBody {\n\n            get {\n\n                return ResourceManager.GetString(\"updatePromptBody\", resourceCulture);\n\n            }\n\n        }\n\n        \n\n        /// <summary>\n\n        ///   Looks up a localized string similar to An update is available..\n\n        /// </summary>\n\n        internal static string updatePromptTitle {\n\n            get {\n\n                return ResourceManager.GetString(\"updatePromptTitle\", resourceCulture);\n\n            }\n\n        }\n\n        \n\n        /// <summary>\n\n        ///   Looks up a localized string similar to Username.\n\n        /// </summary>\n\n        internal static string Username {\n\n            get {\n\n                return ResourceManager.GetString(\"Username\", resourceCulture);\n\n            }\n\n        }\n\n        \n\n        /// <summary>\n\n        ///   Looks up a localized string similar to VersionUpdate.\n\n        /// </summary>\n\n        internal static string VersionUpdate {\n\n            get {\n\n                return ResourceManager.GetString(\"VersionUpdate\", resourceCulture);\n\n            }\n\n        }\n\n    }\n\n}\n", "using System.Reflection;\n\nusing WPFLocalizeExtension.Extensions;\n\n\n\nnamespace Shadowsocks.WPF.Localization\n\n{\n\n    public class LocalizationProvider\n\n    {\n\n        private static readonly string CallingAssemblyName = Assembly.GetCallingAssembly().GetName().Name ?? \"Shadowsocks.WPF\";\n\n\n\n        public static T GetLocalizedValue<T>(string key) => LocExtension.GetLocalizedValue<T>($\"{CallingAssemblyName}:Strings:{key}\");\n\n    }\n\n}\n", "using Shadowsocks.WPF.Models;\n\nusing Splat;\n\nusing System;\n\nusing System.Collections.Generic;\n\nusing System.Linq;\n\nusing System.Net.Http;\n\nusing System.Net.Http.Json;\n\nusing System.Text;\n\nusing System.Text.Json;\n\nusing System.Threading.Tasks;\n\n\n\nnamespace Shadowsocks.WPF.Services\n\n{\n\n    /// <summary>\n\n    /// The service for updating a group from an SIP008 online configuration source.\n\n    /// </summary>\n\n    public class OnlineConfigService\n\n    {\n\n        private Group _group;\n\n        private HttpClient _httpClient;\n\n        \n\n        public OnlineConfigService(Group group)\n\n        {\n\n            _group = group;\n\n            _httpClient = Locator.Current.GetService<HttpClient>();\n\n        }\n\n\n\n        /// <summary>\n\n        /// Updates the group from the configured online configuration source.\n\n        /// </summary>\n\n        /// <returns></returns>\n\n        public async Task Update()\n\n        {\n\n            // Download\n\n            var downloadedGroup = await _httpClient.GetFromJsonAsync<Group>(_group.OnlineConfigSource);\n\n            if (downloadedGroup == null)\n\n                throw new Exception(\"An error occurred.\");\n\n            // Merge downloaded group into existing group\n\n            _group.Version = downloadedGroup.Version;\n\n            _group.BytesUsed = downloadedGroup.BytesUsed;\n\n            _group.BytesRemaining = downloadedGroup.BytesRemaining;\n\n            _group.Servers = downloadedGroup.Servers; // TODO: preserve per-server statistics\n\n        }\n\n    }\n\n}\n", "using Shadowsocks.Net;\n\nusing Splat;\n\nusing System;\n\nusing System.Net;\n\nusing System.Net.Sockets;\n\n\n\nnamespace Shadowsocks.WPF.Services\n\n{\n\n#nullable disable\n\n    public class PortForwarder : StreamService\n\n    {\n\n        private readonly int _targetPort;\n\n\n\n        public PortForwarder(int targetPort)\n\n        {\n\n            _targetPort = targetPort;\n\n        }\n\n\n\n        public override bool Handle(CachedNetworkStream stream, object state)\n\n        {\n\n            byte[] fp = new byte[256];\n\n            int len = stream.ReadFirstBlock(fp);\n\n\n\n            if (stream.Socket.ProtocolType != ProtocolType.Tcp)\n\n            {\n\n                return false;\n\n            }\n\n            new Handler().Start(fp, len, stream.Socket, _targetPort);\n\n            return true;\n\n        }\n\n\n\n        [Obsolete]\n\n        public override bool Handle(byte[] firstPacket, int length, Socket socket, object state)\n\n        {\n\n            if (socket.ProtocolType != ProtocolType.Tcp)\n\n            {\n\n                return false;\n\n            }\n\n            new Handler().Start(firstPacket, length, socket, _targetPort);\n\n            return true;\n\n        }\n\n\n\n        private class Handler : IEnableLogger\n\n        {\n\n            private byte[] _firstPacket;\n\n            private int _firstPacketLength;\n\n            private Socket _local;\n\n            private Socket _remote;\n\n            private bool _closed = false;\n\n            private bool _localShutdown = false;\n\n            private bool _remoteShutdown = false;\n\n            private const int RecvSize = 2048;\n\n            // remote receive buffer\n\n            private byte[] remoteRecvBuffer = new byte[RecvSize];\n\n            // connection receive buffer\n\n            private byte[] connetionRecvBuffer = new byte[RecvSize];\n\n\n\n            // instance-based lock\n\n            private readonly object _Lock = new object();\n\n\n\n            public void Start(byte[] firstPacket, int length, Socket socket, int targetPort)\n\n            {\n\n                _firstPacket = firstPacket;\n\n                _firstPacketLength = length;\n\n                _local = socket;\n\n                try\n\n                {\n\n                    // Local Port Forward use IP as is\n\n                    EndPoint remoteEP = new IPEndPoint(_local.AddressFamily == AddressFamily.InterNetworkV6 ? IPAddress.IPv6Loopback : IPAddress.Loopback, targetPort);\n\n                    // Connect to the remote endpoint.\n\n                    _remote = new Socket(SocketType.Stream, ProtocolType.Tcp);\n\n                    _remote.BeginConnect(remoteEP, ConnectCallback, null);\n\n                }\n\n                catch (Exception e)\n\n                {\n\n                    this.Log().Error(e, \"\");\n\n                    Close();\n\n                }\n\n            }\n\n\n\n            private void ConnectCallback(IAsyncResult ar)\n\n            {\n\n                if (_closed)\n\n                {\n\n                    return;\n\n                }\n\n                try\n\n                {\n\n                    _remote.EndConnect(ar);\n\n                    _remote.SetSocketOption(SocketOptionLevel.Tcp, SocketOptionName.NoDelay, true);\n\n                    HandshakeReceive();\n\n                }\n\n                catch (Exception e)\n\n                {\n\n                    this.Log().Error(e, \"\");\n\n                    Close();\n\n                }\n\n            }\n\n\n\n            private void HandshakeReceive()\n\n            {\n\n                if (_closed)\n\n                {\n\n                    return;\n\n                }\n\n                try\n\n                {\n\n                    _remote.BeginSend(_firstPacket, 0, _firstPacketLength, 0, StartPipe, null);\n\n                }\n\n                catch (Exception e)\n\n                {\n\n                    this.Log().Error(e, \"\");\n\n                    Close();\n\n                }\n\n            }\n\n\n\n            private void StartPipe(IAsyncResult ar)\n\n            {\n\n                if (_closed)\n\n                {\n\n                    return;\n\n                }\n\n                try\n\n                {\n\n                    _remote.EndSend(ar);\n\n                    _remote.BeginReceive(remoteRecvBuffer, 0, RecvSize, 0,\n\n                        PipeRemoteReceiveCallback, null);\n\n                    _local.BeginReceive(connetionRecvBuffer, 0, RecvSize, 0,\n\n                        PipeConnectionReceiveCallback, null);\n\n                }\n\n                catch (Exception e)\n\n                {\n\n                    this.Log().Error(e, \"\");\n\n                    Close();\n\n                }\n\n            }\n\n\n\n            private void PipeRemoteReceiveCallback(IAsyncResult ar)\n\n            {\n\n                if (_closed)\n\n                {\n\n                    return;\n\n                }\n\n                try\n\n                {\n\n                    int bytesRead = _remote.EndReceive(ar);\n\n                    if (bytesRead > 0)\n\n                    {\n\n                        _local.BeginSend(remoteRecvBuffer, 0, bytesRead, 0, PipeConnectionSendCallback, null);\n\n                    }\n\n                    else\n\n                    {\n\n                        _local.Shutdown(SocketShutdown.Send);\n\n                        _localShutdown = true;\n\n                        CheckClose();\n\n                    }\n\n                }\n\n                catch (Exception e)\n\n                {\n\n                    this.Log().Error(e, \"\");\n\n                    Close();\n\n                }\n\n            }\n\n\n\n            private void PipeConnectionReceiveCallback(IAsyncResult ar)\n\n            {\n\n                if (_closed)\n\n                {\n\n                    return;\n\n                }\n\n                try\n\n                {\n\n                    int bytesRead = _local.EndReceive(ar);\n\n                    if (bytesRead > 0)\n\n                    {\n\n                        _remote.BeginSend(connetionRecvBuffer, 0, bytesRead, 0, PipeRemoteSendCallback, null);\n\n                    }\n\n                    else\n\n                    {\n\n                        _remote.Shutdown(SocketShutdown.Send);\n\n                        _remoteShutdown = true;\n\n                        CheckClose();\n\n                    }\n\n                }\n\n                catch (Exception e)\n\n                {\n\n                    this.Log().Error(e, \"\");\n\n                    Close();\n\n                }\n\n            }\n\n\n\n            private void PipeRemoteSendCallback(IAsyncResult ar)\n\n            {\n\n                if (_closed)\n\n                {\n\n                    return;\n\n                }\n\n                try\n\n                {\n\n                    _remote.EndSend(ar);\n\n                    _local.BeginReceive(connetionRecvBuffer, 0, RecvSize, 0,\n\n                        PipeConnectionReceiveCallback, null);\n\n                }\n\n                catch (Exception e)\n\n                {\n\n                    this.Log().Error(e, \"\");\n\n                    Close();\n\n                }\n\n            }\n\n\n\n            private void PipeConnectionSendCallback(IAsyncResult ar)\n\n            {\n\n                if (_closed)\n\n                {\n\n                    return;\n\n                }\n\n                try\n\n                {\n\n                    _local.EndSend(ar);\n\n                    _remote.BeginReceive(remoteRecvBuffer, 0, RecvSize, 0,\n\n                        PipeRemoteReceiveCallback, null);\n\n                }\n\n                catch (Exception e)\n\n                {\n\n                    this.Log().Error(e, \"\");\n\n                    Close();\n\n                }\n\n            }\n\n\n\n            private void CheckClose()\n\n            {\n\n                if (_localShutdown && _remoteShutdown)\n\n                {\n\n                    Close();\n\n                }\n\n            }\n\n\n\n            public void Close()\n\n            {\n\n                lock (_Lock)\n\n                {\n\n                    if (_closed)\n\n                    {\n\n                        return;\n\n                    }\n\n                    _closed = true;\n\n                }\n\n                if (_local != null)\n\n                {\n\n                    try\n\n                    {\n\n                        _local.Shutdown(SocketShutdown.Both);\n\n                        _local.Close();\n\n                    }\n\n                    catch (Exception e)\n\n                    {\n\n                        this.Log().Error(e, \"\");\n\n                    }\n\n                }\n\n                if (_remote != null)\n\n                {\n\n                    try\n\n                    {\n\n                        _remote.Shutdown(SocketShutdown.Both);\n\n                        _remote.Dispose();\n\n                    }\n\n                    catch (SocketException e)\n\n                    {\n\n                        this.Log().Error(e, \"\");\n\n                    }\n\n                }\n\n            }\n\n        }\n\n    }\n\n}\n", "using Shadowsocks.WPF.Models;\n\nusing System;\n\nusing System.Collections.Generic;\n\nusing System.Collections.Specialized;\n\nusing System.Diagnostics;\n\nusing System.IO;\n\nusing System.Net;\n\nusing System.Net.Sockets;\n\n\n\nnamespace Shadowsocks.WPF.Services\n\n{\n\n    // https://github.com/shadowsocks/shadowsocks-org/wiki/Plugin\n\n    public sealed class Sip003Plugin : IDisposable\n\n    {\n\n        public IPEndPoint? LocalEndPoint { get; private set; }\n\n        public int ProcessId => _started ? _pluginProcess.Id : 0;\n\n\n\n        private readonly object _startProcessLock = new object();\n\n        private readonly Process _pluginProcess;\n\n        private bool _started;\n\n        private bool _disposed;\n\n\n\n        public static Sip003Plugin? CreateIfConfigured(Server server, bool showPluginOutput)\n\n        {\n\n            if (server == null)\n\n            {\n\n                throw new ArgumentNullException(nameof(server));\n\n            }\n\n\n\n            if (string.IsNullOrWhiteSpace(server.Plugin))\n\n            {\n\n                return null;\n\n            }\n\n\n\n            return new Sip003Plugin(\n\n                server.Plugin,\n\n                server.PluginOpts,\n\n                server.PluginArgs,\n\n                server.Host,\n\n                server.Port,\n\n                showPluginOutput);\n\n        }\n\n\n\n        private Sip003Plugin(string plugin, string? pluginOpts, List<string>? pluginArgs, string serverAddress, int serverPort, bool showPluginOutput)\n\n        {\n\n            if (plugin == null) throw new ArgumentNullException(nameof(plugin));\n\n            if (string.IsNullOrWhiteSpace(serverAddress))\n\n            {\n\n                throw new ArgumentException(\"Value cannot be null or whitespace.\", nameof(serverAddress));\n\n            }\n\n            if (serverPort <= 0 || serverPort > 65535)\n\n            {\n\n                throw new ArgumentOutOfRangeException(nameof(serverPort));\n\n            }\n\n\n\n            var pluginProcessStartInfo = new ProcessStartInfo\n\n            {\n\n                FileName = plugin,\n\n                UseShellExecute = false,\n\n                CreateNoWindow = !showPluginOutput,\n\n                ErrorDialog = false,\n\n                WindowStyle = ProcessWindowStyle.Hidden,\n\n                WorkingDirectory = Utils.Utilities.WorkingDirectory ?? Environment.CurrentDirectory,\n\n                Environment =\n\n                    {\n\n                        [\"SS_REMOTE_HOST\"] = serverAddress,\n\n                        [\"SS_REMOTE_PORT\"] = serverPort.ToString(),\n\n                        [\"SS_PLUGIN_OPTIONS\"] = pluginOpts\n\n                    }\n\n            };\n\n            if (pluginArgs != null)\n\n                foreach (var arg in pluginArgs)\n\n                    pluginProcessStartInfo.ArgumentList.Add(arg);\n\n\n\n            _pluginProcess = new Process()\n\n            {\n\n                StartInfo = pluginProcessStartInfo,\n\n            };\n\n        }\n\n\n\n        public bool StartIfNeeded()\n\n        {\n\n            if (_disposed)\n\n            {\n\n                throw new ObjectDisposedException(GetType().FullName);\n\n            }\n\n\n\n            lock (_startProcessLock)\n\n            {\n\n                if (_started && !_pluginProcess.HasExited)\n\n                {\n\n                    return false;\n\n                }\n\n\n\n                var localPort = GetNextFreeTcpPort();\n\n                LocalEndPoint = new IPEndPoint(IPAddress.Loopback, localPort);\n\n\n\n                _pluginProcess.StartInfo.Environment[\"SS_LOCAL_HOST\"] = LocalEndPoint.Address.ToString();\n\n                _pluginProcess.StartInfo.Environment[\"SS_LOCAL_PORT\"] = LocalEndPoint.Port.ToString();\n\n                _pluginProcess.StartInfo.Arguments = ExpandEnvironmentVariables(_pluginProcess.StartInfo.Arguments, _pluginProcess.StartInfo.EnvironmentVariables);\n\n                try\n\n                {\n\n                    _pluginProcess.Start();\n\n                }\n\n                catch (System.ComponentModel.Win32Exception ex)\n\n                {\n\n                    // do not use File.Exists(...), it can not handle the scenarios when the plugin file is in system environment path.\n\n                    // https://docs.microsoft.com/en-us/windows/win32/seccrypto/common-hresult-values\n\n                    //if ((uint)ex.ErrorCode == 0x80004005)\n\n                    //  https://docs.microsoft.com/en-us/openspecs/windows_protocols/ms-erref/18d8fbe8-a967-4f1c-ae50-99ca8e491d2d\n\n                    if (ex.NativeErrorCode == 0x00000002)\n\n                    {\n\n                        throw new FileNotFoundException(\"Cannot find the plugin program file\", _pluginProcess.StartInfo.FileName, ex);\n\n                    }\n\n                    throw new ApplicationException(\"Plugin Program\", ex);\n\n                }\n\n                _started = true;\n\n            }\n\n\n\n            return true;\n\n        }\n\n\n\n        public static string ExpandEnvironmentVariables(string name, StringDictionary? environmentVariables = null)\n\n        {\n\n            // Expand the environment variables from the new process itself\n\n            if (environmentVariables != null)\n\n            {\n\n                foreach(string key in environmentVariables.Keys)\n\n                {\n\n                    name = name.Replace($\"%{key}%\", environmentVariables[key], StringComparison.OrdinalIgnoreCase);\n\n                }\n\n            }\n\n            // Also expand the environment variables from current main process (system)\n\n            name = Environment.ExpandEnvironmentVariables(name);\n\n            return name;\n\n        }\n\n\n\n        public static int GetNextFreeTcpPort()\n\n        {\n\n            var l = new TcpListener(IPAddress.Loopback, 0);\n\n            l.Start();\n\n            var port = ((IPEndPoint)l.LocalEndpoint).Port;\n\n            l.Stop();\n\n            return port;\n\n        }\n\n\n\n        public void Dispose()\n\n        {\n\n            if (_disposed)\n\n            {\n\n                return;\n\n            }\n\n\n\n            try\n\n            {\n\n                if (!_pluginProcess.HasExited)\n\n                {\n\n                    _pluginProcess.Kill();\n\n                    _pluginProcess.WaitForExit();\n\n                }\n\n            }\n\n            catch (Exception) { }\n\n            finally\n\n            {\n\n                try\n\n                {\n\n                    _pluginProcess.Dispose();\n\n                }\n\n                catch (Exception) { }\n\n\n\n                _disposed = true;\n\n            }\n\n        }\n\n    }\n\n}", "using System;\n\nusing System.Diagnostics;\n\nusing System.IO;\n\nusing System.Net.Http;\n\nusing System.Reflection;\n\nusing System.Text.Json;\n\nusing System.Threading.Tasks;\n\nusing System.Windows;\n\nusing NLog;\n\nusing Shadowsocks.WPF.Localization;\n\nusing Shadowsocks.WPF.Models;\n\nusing Shadowsocks.WPF.ViewModels;\n\nusing Shadowsocks.WPF.Views;\n\nusing Splat;\n\n\n\nnamespace Shadowsocks.WPF.Services\n\n{\n\n    public class UpdateChecker : IEnableLogger\n\n    {\n\n        private readonly Logger logger;\n\n        private readonly HttpClient httpClient;\n\n\n\n        // https://developer.github.com/v3/repos/releases/\n\n        private const string UpdateURL = \"https://api.github.com/repos/shadowsocks/shadowsocks-windows/releases\";\n\n\n\n        private Window? versionUpdatePromptWindow;\n\n        private JsonElement _releaseObject;\n\n\n\n        public string NewReleaseVersion { get; private set; }\n\n        public string NewReleaseZipFilename { get; private set; }\n\n\n\n        public event EventHandler? CheckUpdateCompleted;\n\n\n\n        public static readonly string Version = Assembly.GetEntryAssembly()?.GetName().Version?.ToString() ?? \"5.0.0\";\n\n        private readonly Version _version;\n\n\n\n        public UpdateChecker()\n\n        {\n\n            logger = LogManager.GetCurrentClassLogger();\n\n            httpClient = Locator.Current.GetService<HttpClient>();\n\n            _version = new Version(Version);\n\n            NewReleaseVersion = \"\";\n\n            NewReleaseZipFilename = \"\";\n\n        }\n\n\n\n        /// <summary>\n\n        /// Checks for updates and asks the user if updates are found.\n\n        /// </summary>\n\n        /// <param name=\"millisecondsDelay\">A delay in milliseconds before checking.</param>\n\n        /// <returns></returns>\n\n        public async Task CheckForVersionUpdate(int millisecondsDelay = 0)\n\n        {\n\n            // delay\n\n            logger.Info($\"Waiting for {millisecondsDelay}ms before checking for version update.\");\n\n            await Task.Delay(millisecondsDelay);\n\n            // start\n\n            logger.Info($\"Checking for version update.\");\n\n            var appSettings = Locator.Current.GetService<AppSettings>();\n\n            try\n\n            {\n\n                // list releases via API\n\n                var releasesListJsonStream = await httpClient.GetStreamAsync(UpdateURL);\n\n                // parse\n\n                using (JsonDocument jsonDocument = await JsonDocument.ParseAsync(releasesListJsonStream))\n\n                {\n\n                    var releasesList = jsonDocument.RootElement;\n\n                    foreach (var releaseObject in releasesList.EnumerateArray())\n\n                    {\n\n                        var releaseTagName = releaseObject.GetProperty(\"tag_name\").GetString();\n\n                        var releaseVersion = new Version(releaseTagName ?? \"5.0.0\");\n\n                        var releaseIsPrerelease = releaseObject.GetProperty(\"prerelease\").GetBoolean();\n\n                        if (releaseTagName == appSettings.SkippedUpdateVersion) // finished checking\n\n                            break;\n\n                        if (releaseVersion.CompareTo(_version) > 0 &&\n\n                            (!releaseIsPrerelease || appSettings.VersionUpdateCheckForPrerelease && releaseIsPrerelease)) // selected\n\n                        {\n\n                            logger.Info($\"Found new version {releaseTagName}.\");\n\n                            _releaseObject = releaseObject;\n\n                            NewReleaseVersion = releaseTagName ?? \"\";\n\n                            AskToUpdate(releaseObject);\n\n                            return;\n\n                        }\n\n                    }\n\n                }\n\n                logger.Info($\"No new versions found.\");\n\n                CheckUpdateCompleted?.Invoke(this, new EventArgs());\n\n            }\n\n            catch (Exception e)\n\n            {\n\n                this.Log().Error(e, \"An error occurred while checking for version updates.\");\n\n            }\n\n        }\n\n\n\n        /// <summary>\n\n        /// Opens a window to show the update's information.\n\n        /// </summary>\n\n        /// <param name=\"releaseObject\">The update release object.</param>\n\n        private void AskToUpdate(JsonElement releaseObject)\n\n        {\n\n            if (versionUpdatePromptWindow == null)\n\n            {\n\n                var versionUpdatePromptView = new VersionUpdatePromptView()\n\n                {\n\n                    ViewModel = new VersionUpdatePromptViewModel(releaseObject),\n\n                };\n\n                versionUpdatePromptWindow = new Window()\n\n                {\n\n                    Title = LocalizationProvider.GetLocalizedValue<string>(\"VersionUpdate\"),\n\n                    Height = 480,\n\n                    Width = 640,\n\n                    MinHeight = 480,\n\n                    MinWidth = 640,\n\n                    Content = versionUpdatePromptView,\n\n                };\n\n                versionUpdatePromptWindow.Closed += VersionUpdatePromptWindow_Closed;\n\n                versionUpdatePromptWindow.Show();\n\n            }\n\n            versionUpdatePromptWindow.Activate();\n\n        }\n\n\n\n        private void VersionUpdatePromptWindow_Closed(object? sender, EventArgs e)\n\n        {\n\n            versionUpdatePromptWindow = null;\n\n        }\n\n\n\n        /// <summary>\n\n        /// Downloads the selected update and notifies the user.\n\n        /// </summary>\n\n        /// <returns></returns>\n\n        public async Task DoUpdate()\n\n        {\n\n            try\n\n            {\n\n                var assets = _releaseObject.GetProperty(\"assets\");\n\n                // download all assets\n\n                foreach (var asset in assets.EnumerateArray())\n\n                {\n\n                    var filename = asset.GetProperty(\"name\").GetString();\n\n                    var browser_download_url = asset.GetProperty(\"browser_download_url\").GetString();\n\n                    var response = await httpClient.GetAsync(browser_download_url);\n\n                    if (filename is string)\n\n                    {\n\n                        using (var downloadedFileStream = File.Create(Utils.Utilities.GetTempPath(filename)))\n\n                            await response.Content.CopyToAsync(downloadedFileStream);\n\n                        logger.Info($\"Downloaded {filename}.\");\n\n                        // store .zip filename\n\n                        if (filename.EndsWith(\".zip\"))\n\n                            NewReleaseZipFilename = filename;\n\n                    }\n\n                }\n\n                logger.Info(\"Finished downloading.\");\n\n                // notify user\n\n                CloseVersionUpdatePromptWindow();\n\n                Process.Start(\"explorer.exe\", $\"/select, \\\"{Utils.Utilities.GetTempPath(NewReleaseZipFilename)}\\\"\");\n\n            }\n\n            catch (Exception e)\n\n            {\n\n                this.Log().Error(e, \"An error occurred while downloading the version update.\");\n\n            }\n\n        }\n\n\n\n        /// <summary>\n\n        /// Saves the skipped update version.\n\n        /// </summary>\n\n        public void SkipUpdate()\n\n        {\n\n            var appSettings = Locator.Current.GetService<AppSettings>();\n\n            if (_releaseObject.TryGetProperty(\"tag_name\", out var tagNameJsonElement) && tagNameJsonElement.GetString() is string version)\n\n            {\n\n                appSettings.SkippedUpdateVersion = version;\n\n                // TODO: signal settings change\n\n                logger.Info($\"The update {version} has been skipped and will be ignored next time.\");\n\n            }\n\n            CloseVersionUpdatePromptWindow();\n\n        }\n\n\n\n        /// <summary>\n\n        /// Closes the update prompt window.\n\n        /// </summary>\n\n        public void CloseVersionUpdatePromptWindow()\n\n        {\n\n            if (versionUpdatePromptWindow != null)\n\n            {\n\n                versionUpdatePromptWindow.Close();\n\n                versionUpdatePromptWindow = null;\n\n            }\n\n        }\n\n    }\n\n}\n", "using Shadowsocks.Net.Settings;\n\nusing Shadowsocks.WPF.Utils;\n\nusing Splat;\n\nusing System;\n\nusing System.Diagnostics;\n\nusing System.IO;\n\nusing System.Linq;\n\nusing System.Net;\n\nusing System.Net.Sockets;\n\nusing System.Text;\n\n\n\nnamespace Shadowsocks.WPF.Services\n\n{\n\n    public class PrivoxyRunner : IEnableLogger\n\n    {\n\n        private static int _uid;\n\n        private static string _uniqueConfigFile = \"\";\n\n        private Process? _process;\n\n        private int _runningPort;\n\n\n\n        public PrivoxyRunner()\n\n        {\n\n            try\n\n            {\n\n                _uid = Utils.Utilities.WorkingDirectory.GetHashCode(); // Currently we use ss's StartupPath to identify different Privoxy instance.\n\n                _uniqueConfigFile = $\"privoxy_{_uid}.conf\";\n\n\n\n                FileManager.UncompressFile(Utils.Utilities.GetTempPath(\"ss_privoxy.exe\"), Properties.Resources.privoxy_exe);\n\n            }\n\n            catch (IOException e)\n\n            {\n\n                this.Log().Error(e, \"An error occurred while starting Privoxy.\");\n\n                _uniqueConfigFile = \"\";\n\n            }\n\n        }\n\n\n\n        public int RunningPort => _runningPort;\n\n\n\n        public void Start(NetSettings netSettings)\n\n        {\n\n            if (_process == null)\n\n            {\n\n                Process[] existingPrivoxy = Process.GetProcessesByName(\"ss_privoxy\");\n\n                foreach (Process p in existingPrivoxy.Where(IsChildProcess))\n\n                {\n\n                    KillProcess(p);\n\n                }\n\n                string privoxyConfig = Properties.Resources.privoxy_conf;\n\n                _runningPort = GetFreePort(netSettings);\n\n                privoxyConfig = privoxyConfig.Replace(\"__SOCKS_PORT__\", netSettings.Socks5ListeningPort.ToString());\n\n                privoxyConfig = privoxyConfig.Replace(\"__PRIVOXY_BIND_PORT__\", _runningPort.ToString());\n\n                privoxyConfig = privoxyConfig.Replace(\"__PRIVOXY_BIND_IP__\", $\"[{netSettings.Socks5ListeningAddress}]\")\n\n                    .Replace(\"__SOCKS_HOST__\", \"[::1]\"); // TODO: make sure it's correct\n\n                FileManager.ByteArrayToFile(Utils.Utilities.GetTempPath(_uniqueConfigFile), Encoding.UTF8.GetBytes(privoxyConfig));\n\n\n\n                _process = new Process\n\n                {\n\n                    // Configure the process using the StartInfo properties.\n\n                    StartInfo =\n\n                    {\n\n                        FileName = \"ss_privoxy.exe\",\n\n                        Arguments = _uniqueConfigFile,\n\n                        WorkingDirectory = Utils.Utilities.GetTempPath(),\n\n                        WindowStyle = ProcessWindowStyle.Hidden,\n\n                        UseShellExecute = true,\n\n                        CreateNoWindow = true\n\n                    }\n\n                };\n\n                _process.Start();\n\n            }\n\n        }\n\n\n\n        public void Stop()\n\n        {\n\n            if (_process != null)\n\n            {\n\n                KillProcess(_process);\n\n                _process.Dispose();\n\n                _process = null;\n\n            }\n\n        }\n\n\n\n        private void KillProcess(Process p)\n\n        {\n\n            try\n\n            {\n\n                p.CloseMainWindow();\n\n                p.WaitForExit(100);\n\n                if (!p.HasExited)\n\n                {\n\n                    p.Kill();\n\n                    p.WaitForExit();\n\n                }\n\n            }\n\n            catch (Exception e)\n\n            {\n\n                this.Log().Error(e, \"An error occurred while stopping Privoxy.\");\n\n            }\n\n        }\n\n\n\n        /*\n\n         * We won't like to kill other ss instances' ss_privoxy.exe.\n\n         * This function will check whether the given process is created\n\n         * by this process by checking the module path or command line.\n\n         * \n\n         * Since it's required to put ss in different dirs to run muti instances,\n\n         * different instance will create their unique \"privoxy_UID.conf\" where\n\n         * UID is hash of ss's location.\n\n         */\n\n\n\n        private bool IsChildProcess(Process process)\n\n        {\n\n            try\n\n            {\n\n                /*\n\n                 * Under PortableMode, we could identify it by the path of ss_privoxy.exe.\n\n                 */\n\n                var path = process.MainModule?.FileName;\n\n\n\n                return Utils.Utilities.GetTempPath(\"ss_privoxy.exe\").Equals(path);\n\n\n\n            }\n\n            catch (Exception ex)\n\n            {\n\n                /*\n\n                 * Sometimes Process.GetProcessesByName will return some processes that\n\n                 * are already dead, and that will cause exceptions here.\n\n                 * We could simply ignore those exceptions.\n\n                 */\n\n                this.Log().Error(ex, \"\");\n\n                return false;\n\n            }\n\n        }\n\n\n\n        private int GetFreePort(NetSettings netSettings)\n\n        {\n\n            int defaultPort = 8123;\n\n            try\n\n            {\n\n                // TCP stack please do me a favor\n\n                TcpListener l = new TcpListener(IPAddress.Parse(netSettings.Socks5ListeningAddress), 0);\n\n                l.Start();\n\n                var port = ((IPEndPoint)l.LocalEndpoint).Port;\n\n                l.Stop();\n\n                return port;\n\n            }\n\n            catch (Exception e)\n\n            {\n\n                // in case access denied\n\n                this.Log().Error(e, \"\");\n\n                return defaultPort;\n\n            }\n\n        }\n\n    }\n\n}\n", "using System;\n\nusing System.Collections.Generic;\n\nusing System.ComponentModel;\n\nusing System.Linq;\n\nusing System.Runtime.InteropServices;\n\nusing NLog;\n\n\n\nnamespace Shadowsocks.WPF.Services.SystemProxy\n\n{\n\n    #region Windows API data structure definition\n\n    public enum InternetOptions\n\n    {\n\n        Refresh = 37,\n\n        SettingsChanged = 39,\n\n        PerConnectionOption = 75,\n\n        ProxySettingChanged = 95,\n\n    }\n\n\n\n    public enum InternetPerConnectionOptionEnum\n\n    {\n\n        Flags = 1,\n\n        ProxyServer = 2,\n\n        ProxyBypass = 3,\n\n        AutoConfigUrl = 4,\n\n        AutoDiscovery = 5,\n\n        AutoConfigSecondaryUrl = 6,\n\n        AutoConfigReloadDelay = 7,\n\n        AutoConfigLastDetectTime = 8,\n\n        AutoConfigLastDetectUrl = 9,\n\n        FlagsUI = 10,\n\n    }\n\n\n\n    [Flags]\n\n    public enum InternetPerConnectionFlags\n\n    {\n\n        Direct = 0x01,\n\n        Proxy = 0x02,\n\n        AutoProxyUrl = 0x04,\n\n        AutoDetect = 0x08,\n\n    }\n\n\n\n    [StructLayout(LayoutKind.Explicit)]\n\n    public struct InternetPerConnectionOptionUnion : IDisposable\n\n    {\n\n        [FieldOffset(0)]\n\n        public int dwValue;\n\n\n\n        [FieldOffset(0)]\n\n        public IntPtr pszValue;\n\n\n\n        [FieldOffset(0)]\n\n        public System.Runtime.InteropServices.ComTypes.FILETIME ftValue;\n\n\n\n        public void Dispose()\n\n        {\n\n            Dispose(true);\n\n            GC.SuppressFinalize(this);\n\n        }\n\n\n\n        private void Dispose(bool disposing)\n\n        {\n\n            if (disposing)\n\n            {\n\n                if (pszValue != IntPtr.Zero)\n\n                {\n\n                    Marshal.FreeHGlobal(pszValue);\n\n                    pszValue = IntPtr.Zero;\n\n                }\n\n            }\n\n        }\n\n    }\n\n\n\n    [StructLayout(LayoutKind.Sequential)]\n\n    public struct InternetPerConnectionOption\n\n    {\n\n        public int dwOption;\n\n        public InternetPerConnectionOptionUnion Value;\n\n    }\n\n\n\n    [StructLayout(LayoutKind.Sequential, CharSet = CharSet.Auto)]\n\n    public struct InternetPerConnectionOptionList : IDisposable\n\n    {\n\n        public int Size;\n\n\n\n        // The connection to be set. NULL means LAN.\n\n        public IntPtr Connection;\n\n\n\n        public int OptionCount;\n\n        public int OptionError;\n\n\n\n        // List of INTERNET_PER_CONN_OPTIONs.\n\n        public IntPtr pOptions;\n\n\n\n        public void Dispose()\n\n        {\n\n            Dispose(true);\n\n            GC.SuppressFinalize(this);\n\n        }\n\n        private void Dispose(bool disposing)\n\n        {\n\n            if (disposing)\n\n            {\n\n                if (Connection != IntPtr.Zero)\n\n                {\n\n                    Marshal.FreeHGlobal(Connection);\n\n                    Connection = IntPtr.Zero;\n\n                }\n\n\n\n                if (pOptions != IntPtr.Zero)\n\n                {\n\n                    Marshal.FreeHGlobal(pOptions);\n\n                    pOptions = IntPtr.Zero;\n\n                }\n\n            }\n\n        }\n\n    }\n\n    #endregion\n\n\n\n    public class WinINetSetting\n\n    {\n\n        public InternetPerConnectionFlags Flags = InternetPerConnectionFlags.Direct;\n\n        public string ProxyServer = string.Empty;\n\n        public string ProxyBypass = string.Empty;\n\n        public string AutoConfigUrl = string.Empty;\n\n    }\n\n\n\n    public class WinINet\n\n    {\n\n        private static readonly Logger logger = LogManager.GetCurrentClassLogger();\n\n\n\n        private const string SettingFile = \"wininet-setting.json\";\n\n        private static WinINetSetting initialSetting;\n\n\n\n        public static bool operational { get; private set; } = true;\n\n        static WinINet()\n\n        {\n\n            try\n\n            {\n\n                initialSetting = Query();\n\n            }\n\n            catch (DllNotFoundException)\n\n            {\n\n                operational = false;\n\n                // Not on windows\n\n                logger.Info(\"You are not running on Windows platform, system proxy will disable\");\n\n            }\n\n            catch (Win32Exception we)\n\n            {\n\n                if (we.NativeErrorCode == 12178)\n\n                {\n\n                    logger.Warn(\"WPAD service is not running, system proxy will disable\");\n\n                    // WPAD not running\n\n                }\n\n                else\n\n                {\n\n                    throw;\n\n                }\n\n            }\n\n            finally\n\n            {\n\n                if (initialSetting == null)\n\n                    initialSetting = new();\n\n            }\n\n        }\n\n\n\n        public static void ProxyGlobal(string server, string bypass)\n\n        {\n\n            List<InternetPerConnectionOption> options = new List<InternetPerConnectionOption>\n\n            {\n\n                GetOption(InternetPerConnectionOptionEnum.Flags,InternetPerConnectionFlags.Proxy|InternetPerConnectionFlags.Direct),\n\n                GetOption(InternetPerConnectionOptionEnum.ProxyServer,server),\n\n                GetOption(InternetPerConnectionOptionEnum.ProxyBypass,bypass),\n\n            };\n\n            Exec(options);\n\n        }\n\n\n\n        public static void ProxyPAC(string url)\n\n        {\n\n            List<InternetPerConnectionOption> options = new List<InternetPerConnectionOption>\n\n            {\n\n                GetOption(InternetPerConnectionOptionEnum.Flags,InternetPerConnectionFlags.AutoProxyUrl|InternetPerConnectionFlags.Direct),\n\n                GetOption(InternetPerConnectionOptionEnum.AutoConfigUrl,url),\n\n            };\n\n            Exec(options);\n\n        }\n\n\n\n        public static void Direct()\n\n        {\n\n            List<InternetPerConnectionOption> options = new List<InternetPerConnectionOption>\n\n            {\n\n                GetOption(InternetPerConnectionOptionEnum.Flags,InternetPerConnectionFlags.Direct),\n\n            };\n\n            Exec(options);\n\n        }\n\n\n\n        public static void Restore()\n\n        {\n\n            Set(initialSetting);\n\n        }\n\n\n\n        public static void Set(WinINetSetting setting)\n\n        {\n\n            List<InternetPerConnectionOption> options = new List<InternetPerConnectionOption>\n\n            {\n\n                GetOption(InternetPerConnectionOptionEnum.Flags,setting.Flags),\n\n                GetOption(InternetPerConnectionOptionEnum.ProxyServer,setting.ProxyServer),\n\n                GetOption(InternetPerConnectionOptionEnum.ProxyBypass,setting.ProxyBypass),\n\n                GetOption(InternetPerConnectionOptionEnum.AutoConfigUrl,setting.AutoConfigUrl),\n\n            };\n\n            Exec(options);\n\n        }\n\n\n\n        public static void Reset()\n\n        {\n\n            Set(new WinINetSetting());\n\n        }\n\n\n\n        #region Windows API wrapper\n\n        public static WinINetSetting Query()\n\n        {\n\n            if (!operational)\n\n            {\n\n                return new WinINetSetting();\n\n            }\n\n\n\n            List<InternetPerConnectionOption> options = new List<InternetPerConnectionOption>\n\n            {\n\n                new InternetPerConnectionOption{dwOption = (int)InternetPerConnectionOptionEnum.FlagsUI},\n\n                new InternetPerConnectionOption{dwOption = (int)InternetPerConnectionOptionEnum.ProxyServer},\n\n                new InternetPerConnectionOption{dwOption = (int)InternetPerConnectionOptionEnum.ProxyBypass},\n\n                new InternetPerConnectionOption{dwOption = (int)InternetPerConnectionOptionEnum.AutoConfigUrl},\n\n            };\n\n\n\n            (IntPtr unmanagedList, int listSize) = PrepareOptionList(options, \"\");\n\n            bool ok = InternetQueryOption(IntPtr.Zero, (int)InternetOptions.PerConnectionOption, unmanagedList, ref listSize);\n\n            if (!ok)\n\n            {\n\n                throw new Win32Exception(Marshal.GetLastWin32Error());\n\n            }\n\n\n\n            WinINetSetting proxy = new WinINetSetting();\n\n\n\n            InternetPerConnectionOptionList ret = Marshal.PtrToStructure<InternetPerConnectionOptionList>(unmanagedList);\n\n            IntPtr p = ret.pOptions;\n\n            int nOption = ret.OptionCount;\n\n            List<InternetPerConnectionOption> outOptions = new List<InternetPerConnectionOption>();\n\n            for (int i = 0; i < nOption; i++)\n\n            {\n\n                InternetPerConnectionOption o = Marshal.PtrToStructure<InternetPerConnectionOption>(p);\n\n                outOptions.Add(o);\n\n                p += Marshal.SizeOf(o);\n\n            }\n\n\n\n            foreach (InternetPerConnectionOption o in outOptions)\n\n            {\n\n                switch ((InternetPerConnectionOptionEnum)o.dwOption)\n\n                {\n\n                    case InternetPerConnectionOptionEnum.FlagsUI:\n\n                    case InternetPerConnectionOptionEnum.Flags:\n\n                        proxy.Flags = (InternetPerConnectionFlags)o.Value.dwValue;\n\n                        break;\n\n                    case InternetPerConnectionOptionEnum.AutoConfigUrl:\n\n                        proxy.AutoConfigUrl = Marshal.PtrToStringAuto(o.Value.pszValue) ?? \"\";\n\n                        break;\n\n                    case InternetPerConnectionOptionEnum.ProxyBypass:\n\n                        proxy.ProxyBypass = Marshal.PtrToStringAuto(o.Value.pszValue) ?? \"\";\n\n                        break;\n\n                    case InternetPerConnectionOptionEnum.ProxyServer:\n\n                        proxy.ProxyServer = Marshal.PtrToStringAuto(o.Value.pszValue) ?? \"\";\n\n                        break;\n\n                    default:\n\n                        break;\n\n                }\n\n            }\n\n            return proxy;\n\n        }\n\n\n\n        private static InternetPerConnectionOption GetOption(\n\n            InternetPerConnectionOptionEnum option,\n\n            InternetPerConnectionFlags flag\n\n            )\n\n        {\n\n            return new InternetPerConnectionOption\n\n            {\n\n                dwOption = (int)option,\n\n                Value =\n\n                {\n\n                    dwValue = (int)flag,\n\n                }\n\n            };\n\n        }\n\n\n\n        private static InternetPerConnectionOption GetOption(\n\n            InternetPerConnectionOptionEnum option,\n\n            string param\n\n        )\n\n        {\n\n            return new InternetPerConnectionOption\n\n            {\n\n                dwOption = (int)option,\n\n                Value =\n\n                {\n\n                    pszValue = Marshal.StringToCoTaskMemAuto(param),\n\n                }\n\n            };\n\n        }\n\n\n\n        private static (IntPtr, int) PrepareOptionList(List<InternetPerConnectionOption> options, string connName)\n\n        {\n\n            int len = options.Sum(o => Marshal.SizeOf(o));\n\n\n\n            IntPtr buf = Marshal.AllocCoTaskMem(len);\n\n            IntPtr cur = buf;\n\n\n\n            foreach (InternetPerConnectionOption o in options)\n\n            {\n\n                Marshal.StructureToPtr(o, cur, false);\n\n                cur += Marshal.SizeOf(o);\n\n            }\n\n            InternetPerConnectionOptionList optionList = new InternetPerConnectionOptionList\n\n            {\n\n                pOptions = buf,\n\n                OptionCount = options.Count,\n\n                Connection = string.IsNullOrEmpty(connName)\n\n                    ? IntPtr.Zero\n\n                    : Marshal.StringToHGlobalAuto(connName),\n\n                OptionError = 0,\n\n            };\n\n            int listSize = Marshal.SizeOf(optionList);\n\n            optionList.Size = listSize;\n\n\n\n            IntPtr unmanagedList = Marshal.AllocCoTaskMem(listSize);\n\n            Marshal.StructureToPtr(optionList, unmanagedList, true);\n\n            return (unmanagedList, listSize);\n\n        }\n\n\n\n        private static void ClearOptionList(IntPtr list)\n\n        {\n\n            InternetPerConnectionOptionList l = Marshal.PtrToStructure<InternetPerConnectionOptionList>(list);\n\n            Marshal.FreeCoTaskMem(l.pOptions);\n\n            Marshal.FreeCoTaskMem(list);\n\n        }\n\n\n\n        private static void Exec(List<InternetPerConnectionOption> options)\n\n        {\n\n            Exec(options, \"\");\n\n            foreach (string conn in RAS.GetAllConnections())\n\n            {\n\n                Exec(options, conn);\n\n            }\n\n        }\n\n\n\n        private static void Exec(List<InternetPerConnectionOption> options, string connName)\n\n        {\n\n            if (!operational)\n\n            {\n\n                return;\n\n            }\n\n\n\n            (IntPtr unmanagedList, int listSize) = PrepareOptionList(options, connName);\n\n\n\n            bool ok = InternetSetOption(\n\n                IntPtr.Zero,\n\n                (int)InternetOptions.PerConnectionOption,\n\n                unmanagedList,\n\n                listSize\n\n            );\n\n\n\n            if (!ok)\n\n            {\n\n                throw new Win32Exception(Marshal.GetLastWin32Error());\n\n            }\n\n            ClearOptionList(unmanagedList);\n\n            ok = InternetSetOption(\n\n                IntPtr.Zero,\n\n                (int)InternetOptions.ProxySettingChanged,\n\n                IntPtr.Zero,\n\n                0\n\n            );\n\n            if (!ok)\n\n            {\n\n                throw new Win32Exception(Marshal.GetLastWin32Error());\n\n            }\n\n\n\n            ok = InternetSetOption(\n\n                IntPtr.Zero,\n\n                (int)InternetOptions.Refresh,\n\n                IntPtr.Zero,\n\n                0\n\n            );\n\n            if (!ok)\n\n            {\n\n                throw new Win32Exception(Marshal.GetLastWin32Error());\n\n            }\n\n        }\n\n\n\n        [DllImport(\"wininet.dll\", CharSet = CharSet.Auto, SetLastError = true)]\n\n        public static extern bool InternetSetOption(IntPtr hInternet, int dwOption, IntPtr lpBuffer, int dwBufferLength);\n\n\n\n        [DllImport(\"wininet.dll\", CharSet = CharSet.Auto, SetLastError = true)]\n\n        private static extern bool InternetQueryOption(IntPtr hInternet, uint dwOption, IntPtr lpBuffer, ref int lpdwBufferLength);\n\n        #endregion\n\n    }\n\n}\n", "using System;\n\nusing System.Collections.Generic;\n\nusing System.Linq;\n\nusing System.Runtime.InteropServices;\n\nusing System.Text;\n\n\n\nnamespace Shadowsocks.WPF.Services.SystemProxy\n\n{\n\n    public enum RasFieldSizeConst\n\n    {\n\n        MaxEntryName = 256,\n\n        MaxPath = 260,\n\n    }\n\n\n\n    [StructLayout(LayoutKind.Sequential, CharSet = CharSet.Auto)]\n\n    public struct RasEntryName\n\n    {\n\n        public int dwSize;\n\n\n\n        [MarshalAs(UnmanagedType.ByValTStr, SizeConst = RAS.MaxEntryName + 1)]\n\n        public string szEntryName;\n\n\n\n        public int dwFlags;\n\n\n\n        [MarshalAs(UnmanagedType.ByValTStr, SizeConst = RAS.MaxPath + 1)]\n\n        public string szPhonebookPath;\n\n    }\n\n\n\n    public class RAS\n\n    {\n\n        public const int MaxEntryName = 256;\n\n        public const int MaxPath = 260;\n\n\n\n        const int ESuccess = 0;\n\n        const int RasBase = 600;\n\n        const int EBufferTooSmall = 603;\n\n\n\n        [DllImport(\"rasapi32.dll\", CharSet = CharSet.Auto)]\n\n        private static extern uint RasEnumEntries(\n\n            // reserved, must be NULL\n\n            string reserved,\n\n            // pointer to full path and file name of phone-book file\n\n            string lpszPhonebook,\n\n            // buffer to receive phone-book entries\n\n            [In, Out] RasEntryName[]? lprasentryname,\n\n            // size in bytes of buffer\n\n            ref int lpcb,\n\n            // number of entries written to buffer\n\n            out int lpcEntries\n\n        );\n\n\n\n        public static string[] GetAllConnections()\n\n        {\n\n            int lpNames = 0;\n\n            int entryNameSize = 0;\n\n            int lpSize = 0;\n\n            uint retval = ESuccess;\n\n            RasEntryName[] names = Array.Empty<RasEntryName>();\n\n\n\n            entryNameSize = Marshal.SizeOf(typeof(RasEntryName));\n\n\n\n            // Windows Vista or later:  To determine the required buffer size, call RasEnumEntries\n\n            // with lprasentryname set to NULL. The variable pointed to by lpcb should be set to zero.\n\n            // The function will return the required buffer size in lpcb and an error code of ERROR_BUFFER_TOO_SMALL.\n\n            retval = RasEnumEntries(\"\", \"\", null, ref lpSize, out lpNames);\n\n            if (retval == EBufferTooSmall)\n\n            {\n\n                names = new RasEntryName[lpNames];\n\n                for (int i = 0; i < names.Length; i++)\n\n                {\n\n                    names[i].dwSize = entryNameSize;\n\n                }\n\n\n\n                retval = RasEnumEntries(\"\", \"\", names, ref lpSize, out lpNames);\n\n            }\n\n\n\n            if (retval == ESuccess)\n\n            {\n\n                if (lpNames == 0)\n\n                {\n\n                    // no entries found.\n\n                    return Array.Empty<string>();\n\n                }\n\n                return names.Select(n => n.szEntryName).ToArray();\n\n            }\n\n            else\n\n            {\n\n                throw new Exception();\n\n            }\n\n        }\n\n    }\n\n}\n", "using ReactiveUI;\n\nusing ReactiveUI.Fody.Helpers;\n\nusing ReactiveUI.Validation.Extensions;\n\nusing ReactiveUI.Validation.Helpers;\n\nusing Shadowsocks.Net.Settings;\n\nusing Shadowsocks.WPF.Models;\n\nusing Splat;\n\nusing System.Linq;\n\nusing System.Reactive;\n\nusing System.Reactive.Linq;\n\n\n\nnamespace Shadowsocks.WPF.ViewModels\n\n{\n\n    public class ForwardProxyViewModel : ReactiveValidationObject\n\n    {\n\n        public ForwardProxyViewModel()\n\n        {\n\n            _forwardProxySettings = Locator.Current.GetService<Settings>().Net.ForwardProxy;\n\n\n\n            NoProxy = _forwardProxySettings.NoProxy;\n\n            UseSocks5Proxy = _forwardProxySettings.UseSocks5Proxy;\n\n            UseHttpProxy = _forwardProxySettings.UseHttpProxy;\n\n\n\n            Address = _forwardProxySettings.Address;\n\n            Port = _forwardProxySettings.Port;\n\n            Timeout = 5;\n\n\n\n            Username = _forwardProxySettings.Username;\n\n            Password = _forwardProxySettings.Password;\n\n\n\n            this.WhenAnyValue(x => x.NoProxy, x => !x)\n\n                .ToPropertyEx(this, x => x.CanModifyDetails);\n\n\n\n            AddressRule = this.ValidationRule(\n\n                viewModel => viewModel.Address,\n\n                address => !string.IsNullOrWhiteSpace(address),\n\n                \"Address can't be empty or whitespaces.\");\n\n            PortRule = this.ValidationRule(\n\n                viewModel => viewModel.Port,\n\n                port => port > 0 && port <= 65535,\n\n                port => $\"{port} is out of range (0, 65535].\");\n\n            TimeoutRule = this.ValidationRule(\n\n                viewModel => viewModel.Timeout,\n\n                timeout => timeout > 0 && timeout <= 10,\n\n                timeout => $\"{timeout} is out of range (0, 10].\");\n\n\n\n            var authValid = this\n\n                .WhenAnyValue(x => x.Username, x => x.Password, (username, password) => new { Username = username, Password = password })\n\n                .Select(x => string.IsNullOrWhiteSpace(x.Username) == string.IsNullOrWhiteSpace(x.Password));\n\n            AuthRule = this.ValidationRule(authValid, \"You must provide both username and password.\");\n\n\n\n            var canSave = this.IsValid();\n\n\n\n            Save = ReactiveCommand.Create(() =>\n\n            {\n\n                // TODO: save settings\n\n            }, canSave);\n\n            //Cancel = ReactiveCommand.Create(_menuViewController.CloseForwardProxyWindow);\n\n        }\n\n\n\n        private ForwardProxySettings _forwardProxySettings;\n\n\n\n        public ValidationHelper AddressRule { get; }\n\n        public ValidationHelper PortRule { get; }\n\n        public ValidationHelper TimeoutRule { get; }\n\n        public ValidationHelper AuthRule { get; }\n\n\n\n        public ReactiveCommand<Unit, Unit> Save { get; }\n\n        public ReactiveCommand<Unit, Unit> Cancel { get; }\n\n\n\n        [ObservableAsProperty]\n\n        public bool CanModifyDetails { get; }\n\n\n\n        [Reactive]\n\n        public bool NoProxy { get; set; }\n\n\n\n        [Reactive]\n\n        public bool UseSocks5Proxy { get; set; }\n\n\n\n        [Reactive]\n\n        public bool UseHttpProxy { get; set; }\n\n\n\n        [Reactive]\n\n        public string Address { get; set; }\n\n\n\n        [Reactive]\n\n        public int Port { get; set; }\n\n\n\n        [Reactive]\n\n        public int Timeout { get; set; }\n\n\n\n        [Reactive]\n\n        public string Username { get; set; }\n\n\n\n        [Reactive]\n\n        public string Password { get; set; }\n\n\n\n        private ForwardProxySettings GetForwardProxySettings()\n\n            => new ForwardProxySettings()\n\n            {\n\n                NoProxy = NoProxy,\n\n                UseSocks5Proxy = UseSocks5Proxy,\n\n                UseHttpProxy = UseHttpProxy,\n\n                Address = Address,\n\n                Port = Port,\n\n                Username = Username,\n\n                Password = Password,\n\n            };\n\n    }\n\n}\n", "using ReactiveUI;\n\nusing System;\n\nusing System.Collections.Generic;\n\nusing System.Text;\n\n\n\nnamespace Shadowsocks.WPF.ViewModels\n\n{\n\n    public class RoutingViewModel : ReactiveObject\n\n    {\n\n        public RoutingViewModel()\n\n        {\n\n\n\n        }\n\n    }\n\n}\n", "using ReactiveUI;\n\nusing ReactiveUI.Fody.Helpers;\n\nusing ReactiveUI.Validation.Extensions;\n\nusing ReactiveUI.Validation.Helpers;\n\nusing Shadowsocks.WPF.Localization;\n\nusing System;\n\nusing System.Collections.Generic;\n\nusing System.Collections.ObjectModel;\n\nusing System.Linq;\n\nusing System.Reactive;\n\nusing System.Reactive.Linq;\n\nusing System.Text;\n\nusing System.Windows;\n\n\n\nnamespace Shadowsocks.WPF.ViewModels\n\n{\n\n    public class OnlineConfigViewModel : ReactiveValidationObject\n\n    {\n\n        public OnlineConfigViewModel()\n\n        {\n\n            Sources = new ObservableCollection<string>();\n\n            SelectedSource = \"\";\n\n            Address = \"\";\n\n\n\n            // TODO in v5: if http:// show warning as materialDesign:HintAssist.HelperText\n\n            AddressRule = this.ValidationRule(\n\n                viewModel => viewModel.Address,\n\n                address => address.StartsWith(\"http://\"),\n\n                \"Warning: getting online configuration from plain HTTP sources is NOT secure!\");\n\n\n\n            var canUpdateCopyRemove = this.WhenAnyValue(\n\n                x => x.SelectedSource,\n\n                selectedSource => !string.IsNullOrWhiteSpace(selectedSource));\n\n            var canUpdateAll = this.WhenAnyValue(\n\n                x => x.Sources.Count,\n\n                count => count > 0);\n\n            var canAdd = this.WhenAnyValue(\n\n                x => x.Address,\n\n                address => Uri.IsWellFormedUriString(address, UriKind.Absolute) &&\n\n                (address.StartsWith(\"https://\") || address.StartsWith(\"http://\")));\n\n\n\n            //Update = ReactiveCommand.CreateFromTask(() => _controller.UpdateOnlineConfig(SelectedSource), canUpdateCopyRemove);\n\n            //UpdateAll = ReactiveCommand.CreateFromTask(_controller.UpdateAllOnlineConfig, canUpdateAll);\n\n            CopyLink = ReactiveCommand.Create(() => Clipboard.SetText(SelectedSource), canUpdateCopyRemove);\n\n            Remove = ReactiveCommand.Create(() =>\n\n            {\n\n                bool result;\n\n                var urlToRemove = SelectedSource; // save it here because SelectedSource is lost once we remove the selection\n\n                do\n\n                {\n\n                    result = Sources.Remove(urlToRemove);\n\n                } while (result);\n\n                //_controller.RemoveOnlineConfig(urlToRemove);\n\n            }, canUpdateCopyRemove);\n\n            Add = ReactiveCommand.Create(() =>\n\n            {\n\n                Sources.Add(Address);\n\n                SelectedSource = Address;\n\n                //_controller.SaveOnlineConfigSource(Sources.ToList());\n\n                Address = \"\";\n\n            }, canAdd);\n\n\n\n            // TODO in v5: use MaterialDesignThemes snackbar messages\n\n            this.WhenAnyObservable(x => x.Update)\n\n                .Subscribe(x =>\n\n                {\n\n                    if (x)\n\n                        MessageBox.Show(LocalizationProvider.GetLocalizedValue<string>(\"sip008UpdateSuccess\"));\n\n                    else\n\n                        MessageBox.Show(LocalizationProvider.GetLocalizedValue<string>(\"sip008UpdateFailure\"));\n\n                });\n\n            this.WhenAnyObservable(x => x.UpdateAll)\n\n                .Subscribe(x =>\n\n                {\n\n                    if (x.Count == 0)\n\n                        MessageBox.Show(LocalizationProvider.GetLocalizedValue<string>(\"sip008UpdateAllSuccess\"));\n\n                    else\n\n                    {\n\n                        var stringBuilder = new StringBuilder(LocalizationProvider.GetLocalizedValue<string>(\"sip008UpdateAllFailure\"));\n\n                        foreach (var url in x)\n\n                            stringBuilder.AppendLine(url);\n\n                        MessageBox.Show(stringBuilder.ToString());\n\n                    }\n\n                });\n\n        }\n\n\n\n        public ValidationHelper AddressRule { get; }\n\n\n\n        public ReactiveCommand<Unit, bool> Update { get; }\n\n        public ReactiveCommand<Unit, List<string>> UpdateAll { get; }\n\n        public ReactiveCommand<Unit, Unit> CopyLink { get; }\n\n        public ReactiveCommand<Unit, Unit> Remove { get; }\n\n        public ReactiveCommand<Unit, Unit> Add { get; }\n\n\n\n        [Reactive]\n\n        public ObservableCollection<string> Sources { get; private set; }\n\n\n\n        [Reactive]\n\n        public string SelectedSource { get; set; }\n\n\n\n        [Reactive]\n\n        public string Address { get; set; }\n\n    }\n\n}\n", "using ReactiveUI;\n\nusing Shadowsocks.WPF.Services;\n\nusing Splat;\n\nusing System.Reactive;\n\nusing System.Text.Json;\n\n\n\nnamespace Shadowsocks.WPF.ViewModels\n\n{\n\n    public class VersionUpdatePromptViewModel : ReactiveObject\n\n    {\n\n        public VersionUpdatePromptViewModel(JsonElement releaseObject)\n\n        {\n\n            _updateChecker = Locator.Current.GetService<UpdateChecker>();\n\n            _releaseObject = releaseObject;\n\n            var releaseTagName = _releaseObject.GetProperty(\"tag_name\").GetString();\n\n            var releaseNotes = _releaseObject.GetProperty(\"body\").GetString();\n\n            var releaseIsPrerelease = _releaseObject.GetProperty(\"prerelease\").GetBoolean();\n\n            ReleaseNotes = string.Concat(\n\n                $\"# {(releaseIsPrerelease ? \"\u26a0 Pre-release\" : \"\u2139 Release\")} {releaseTagName ?? \"Failed to get tag name\"}\\r\\n\",\n\n                releaseNotes ?? \"Failed to get release notes\");\n\n\n\n            Update = ReactiveCommand.CreateFromTask(_updateChecker.DoUpdate);\n\n            SkipVersion = ReactiveCommand.Create(_updateChecker.SkipUpdate);\n\n            NotNow = ReactiveCommand.Create(_updateChecker.CloseVersionUpdatePromptWindow);\n\n        }\n\n\n\n        private readonly UpdateChecker _updateChecker;\n\n        private readonly JsonElement _releaseObject;\n\n\n\n        public string ReleaseNotes { get; }\n\n\n\n        public ReactiveCommand<Unit, Unit> Update { get; }\n\n\n\n        public ReactiveCommand<Unit, Unit> SkipVersion { get; }\n\n\n\n        public ReactiveCommand<Unit, Unit> NotNow { get; }\n\n    }\n\n}\n", "using ReactiveUI;\n\nusing System;\n\nusing System.Collections.Generic;\n\nusing System.Text;\n\n\n\nnamespace Shadowsocks.WPF.ViewModels\n\n{\n\n    public class DashboardViewModel : ReactiveObject\n\n    {\n\n        public DashboardViewModel()\n\n        {\n\n\n\n        }\n\n    }\n\n}\n", "using ReactiveUI;\n\nusing ReactiveUI.Fody.Helpers;\n\nusing Shadowsocks.WPF.Views;\n\n\n\nnamespace Shadowsocks.WPF.ViewModels\n\n{\n\n    public class MainWindowViewModel : ReactiveObject\n\n    {\n\n        public MainWindowViewModel()\n\n        {\n\n            GetDashboardView = new();\n\n            GetServersView = new();\n\n            GetRoutingView = new();\n\n            GetSettingsView = new();\n\n        }\n\n\n\n        public DashboardView GetDashboardView { get; }\n\n\n\n        public ServersView GetServersView { get; }\n\n\n\n        public RoutingView GetRoutingView { get; }\n\n\n\n        public SettingsView GetSettingsView { get; }\n\n    }\n\n}\n", "using ReactiveUI;\n\nusing System;\n\nusing System.Collections.Generic;\n\nusing System.Text;\n\n\n\nnamespace Shadowsocks.WPF.ViewModels\n\n{\n\n    public class SettingsViewModel : ReactiveObject\n\n    {\n\n        public SettingsViewModel()\n\n        {\n\n\n\n        }\n\n    }\n\n}\n", "using ReactiveUI;\n\nusing ReactiveUI.Fody.Helpers;\n\nusing Shadowsocks.WPF.Models;\n\nusing System;\n\nusing System.Collections.Generic;\n\nusing System.Drawing;\n\nusing System.IO;\n\nusing System.Reactive;\n\nusing System.Windows;\n\nusing System.Windows.Media.Imaging;\n\n\n\nnamespace Shadowsocks.WPF.ViewModels\n\n{\n\n    public class ServerSharingViewModel : ReactiveObject\n\n    {\n\n        /// <summary>\n\n        /// The view model class for the server sharing user control.\n\n        /// </summary>\n\n        public ServerSharingViewModel(List<Server> servers)\n\n        {\n\n            Servers = servers;\n\n            SelectedServer = Servers[0];\n\n\n\n            this.WhenAnyValue(x => x.SelectedServer)\n\n                .Subscribe(_ => UpdateUrlAndImage());\n\n\n\n            CopyLink = ReactiveCommand.Create(() => Clipboard.SetText(SelectedServerUrl));\n\n        }\n\n\n\n        public ReactiveCommand<Unit, Unit> CopyLink { get; }\n\n\n\n        [Reactive]\n\n        public List<Server> Servers { get; private set; }\n\n\n\n        [Reactive]\n\n        public Server SelectedServer { get; set; }\n\n\n\n        [Reactive]\n\n        public string SelectedServerUrl { get; private set; } = null!;\n\n\n\n        [Reactive]\n\n        public BitmapImage SelectedServerUrlImage { get; private set; } = null!;\n\n\n\n        /// <summary>\n\n        /// Called when SelectedServer changed\n\n        /// to update SelectedServerUrl and SelectedServerUrlImage\n\n        /// </summary>\n\n        private void UpdateUrlAndImage()\n\n        {\n\n            // update SelectedServerUrl\n\n            SelectedServerUrl = SelectedServer.ToUrl().AbsoluteUri;\n\n\n\n            // generate QR code\n\n            var qrCode = ZXing.QrCode.Internal.Encoder.encode(SelectedServerUrl, ZXing.QrCode.Internal.ErrorCorrectionLevel.L);\n\n            var byteMatrix = qrCode.Matrix;\n\n\n\n            // paint bitmap\n\n            int blockSize = Math.Max(1024 / byteMatrix.Height, 1);\n\n            Bitmap drawArea = new Bitmap((byteMatrix.Width * blockSize), (byteMatrix.Height * blockSize));\n\n            using (var graphics = Graphics.FromImage(drawArea))\n\n            {\n\n                graphics.Clear(Color.White);\n\n                using (var solidBrush = new SolidBrush(Color.Black))\n\n                {\n\n                    for (int row = 0; row < byteMatrix.Width; row++)\n\n                    {\n\n                        for (int column = 0; column < byteMatrix.Height; column++)\n\n                        {\n\n                            if (byteMatrix[row, column] != 0)\n\n                            {\n\n                                graphics.FillRectangle(solidBrush, blockSize * row, blockSize * column, blockSize, blockSize);\n\n                            }\n\n                        }\n\n                    }\n\n                }\n\n            }\n\n\n\n            // transform to BitmapImage for binding\n\n            BitmapImage bitmapImage = new BitmapImage();\n\n            using (MemoryStream memoryStream = new MemoryStream())\n\n            {\n\n                drawArea.Save(memoryStream, System.Drawing.Imaging.ImageFormat.Bmp);\n\n                memoryStream.Position = 0;\n\n                bitmapImage.BeginInit();\n\n                bitmapImage.StreamSource = memoryStream;\n\n                bitmapImage.CacheOption = BitmapCacheOption.OnLoad;\n\n                bitmapImage.EndInit();\n\n            }\n\n            SelectedServerUrlImage = bitmapImage;\n\n        }\n\n    }\n\n}\n", "using ReactiveUI;\n\nusing System;\n\nusing System.Collections.Generic;\n\nusing System.Text;\n\n\n\nnamespace Shadowsocks.WPF.ViewModels\n\n{\n\n    public class ServersViewModel : ReactiveObject\n\n    {\n\n        public ServersViewModel()\n\n        {\n\n\n\n        }\n\n    }\n\n}\n", "\ufeff//------------------------------------------------------------------------------\n\n// <auto-generated>\n\n//     This code was generated by a tool.\n\n//     Runtime Version:4.0.30319.42000\n\n//\n\n//     Changes to this file may cause incorrect behavior and will be lost if\n\n//     the code is regenerated.\n\n// </auto-generated>\n\n//------------------------------------------------------------------------------\n\n\n\nnamespace Shadowsocks.WPF.Properties {\n\n    using System;\n\n    \n\n    \n\n    /// <summary>\n\n    ///   A strongly-typed resource class, for looking up localized strings, etc.\n\n    /// </summary>\n\n    // This class was auto-generated by the StronglyTypedResourceBuilder\n\n    // class via a tool like ResGen or Visual Studio.\n\n    // To add or remove a member, edit your .ResX file then rerun ResGen\n\n    // with the /str option, or rebuild your VS project.\n\n    [global::System.CodeDom.Compiler.GeneratedCodeAttribute(\"System.Resources.Tools.StronglyTypedResourceBuilder\", \"16.0.0.0\")]\n\n    [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]\n\n    [global::System.Runtime.CompilerServices.CompilerGeneratedAttribute()]\n\n    internal class Resources {\n\n        \n\n        private static global::System.Resources.ResourceManager resourceMan;\n\n        \n\n        private static global::System.Globalization.CultureInfo resourceCulture;\n\n        \n\n        [global::System.Diagnostics.CodeAnalysis.SuppressMessageAttribute(\"Microsoft.Performance\", \"CA1811:AvoidUncalledPrivateCode\")]\n\n        internal Resources() {\n\n        }\n\n        \n\n        /// <summary>\n\n        ///   Returns the cached ResourceManager instance used by this class.\n\n        /// </summary>\n\n        [global::System.ComponentModel.EditorBrowsableAttribute(global::System.ComponentModel.EditorBrowsableState.Advanced)]\n\n        internal static global::System.Resources.ResourceManager ResourceManager {\n\n            get {\n\n                if (object.ReferenceEquals(resourceMan, null)) {\n\n                    global::System.Resources.ResourceManager temp = new global::System.Resources.ResourceManager(\"Shadowsocks.WPF.Properties.Resources\", typeof(Resources).Assembly);\n\n                    resourceMan = temp;\n\n                }\n\n                return resourceMan;\n\n            }\n\n        }\n\n        \n\n        /// <summary>\n\n        ///   Overrides the current thread's CurrentUICulture property for all\n\n        ///   resource lookups using this strongly typed resource class.\n\n        /// </summary>\n\n        [global::System.ComponentModel.EditorBrowsableAttribute(global::System.ComponentModel.EditorBrowsableState.Advanced)]\n\n        internal static global::System.Globalization.CultureInfo Culture {\n\n            get {\n\n                return resourceCulture;\n\n            }\n\n            set {\n\n                resourceCulture = value;\n\n            }\n\n        }\n\n        \n\n        /// <summary>\n\n        ///   Looks up a localized string similar to listen-address __PRIVOXY_BIND_IP__:__PRIVOXY_BIND_PORT__\n\n        ///toggle 0\n\n        ///logfile ss_privoxy.log\n\n        ///show-on-task-bar 0\n\n        ///activity-animation 0\n\n        ///forward-socks5 / __SOCKS_HOST__:__SOCKS_PORT__ .\n\n        ///max-client-connections 2048\n\n        ///hide-console\n\n        ///.\n\n        /// </summary>\n\n        internal static string privoxy_conf {\n\n            get {\n\n                return ResourceManager.GetString(\"privoxy_conf\", resourceCulture);\n\n            }\n\n        }\n\n        \n\n        /// <summary>\n\n        ///   Looks up a localized resource of type System.Byte[].\n\n        /// </summary>\n\n        internal static byte[] privoxy_exe {\n\n            get {\n\n                object obj = ResourceManager.GetObject(\"privoxy_exe\", resourceCulture);\n\n                return ((byte[])(obj));\n\n            }\n\n        }\n\n    }\n\n}\n", "using System;\n\nusing System.Collections.Generic;\n\nusing System.Diagnostics.CodeAnalysis;\n\nusing System.Text.Json.Serialization;\n\n\n\nnamespace Shadowsocks.Models\n\n{\n\n    public class Server : IServer\n\n    {\n\n        /// <inheritdoc/>\n\n        [JsonPropertyName(\"server\")]\n\n        public string Host { get; set; }\n\n\n\n        /// <inheritdoc/>\n\n        [JsonPropertyName(\"server_port\")]\n\n        public int Port { get; set; }\n\n\n\n        /// <inheritdoc/>\n\n        public string Password { get; set; }\n\n\n\n        /// <inheritdoc/>\n\n        public string Method { get; set; }\n\n\n\n        /// <inheritdoc/>\n\n        [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingDefault)]\n\n        public string? Plugin { get; set; }\n\n\n\n        /// <inheritdoc/>\n\n        [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingDefault)]\n\n        public string? PluginOpts { get; set; }\n\n\n\n        /// <summary>\n\n        /// Gets or sets the arguments passed to the plugin process.\n\n        /// </summary>\n\n        [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingDefault)]\n\n        public List<string>? PluginArgs { get; set; }\n\n\n\n        /// <inheritdoc/>\n\n        [JsonPropertyName(\"remarks\")]\n\n        public string Name { get; set; }\n\n\n\n        /// <inheritdoc/>\n\n        [JsonPropertyName(\"id\")]\n\n        public string Uuid { get; set; }\n\n\n\n        public Server()\n\n        {\n\n            Host = \"\";\n\n            Port = 8388;\n\n            Password = \"\";\n\n            Method = \"chacha20-ietf-poly1305\";\n\n            Name = \"\";\n\n            Uuid = Guid.NewGuid().ToString();\n\n        }\n\n\n\n        public bool Equals(IServer? other) => other is Server anotherServer && Uuid == anotherServer.Uuid;\n\n        public override int GetHashCode() => Uuid.GetHashCode();\n\n        public override string ToString() => Name;\n\n\n\n        /// <summary>\n\n        /// Converts this server object into an ss:// URL.\n\n        /// </summary>\n\n        /// <returns></returns>\n\n        public Uri ToUrl()\n\n        {\n\n            UriBuilder uriBuilder = new(\"ss\", Host, Port)\n\n            {\n\n                UserName = Utilities.Base64Url.Encode($\"{Method}:{Password}\"),\n\n                Fragment = Name,\n\n            };\n\n            if (!string.IsNullOrEmpty(Plugin))\n\n                if (!string.IsNullOrEmpty(PluginOpts))\n\n                    uriBuilder.Query = $\"plugin={Uri.EscapeDataString($\"{Plugin};{PluginOpts}\")}\"; // manually escape as a workaround\n\n                else\n\n                    uriBuilder.Query = $\"plugin={Plugin}\";\n\n            return uriBuilder.Uri;\n\n        }\n\n\n\n        /// <summary>\n\n        /// Tries to parse an ss:// URL into a Server object.\n\n        /// </summary>\n\n        /// <param name=\"url\">The ss:// URL to parse.</param>\n\n        /// <param name=\"server\">\n\n        /// A Server object represented by the URL.\n\n        /// A new empty Server object if the URL is invalid.\n\n        /// </param>\n\n        /// <returns>True for success. False for failure.</returns>\n\n        public static bool TryParse(string url, [NotNullWhen(true)] out Server? server)\n\n        {\n\n            server = null;\n\n            return Uri.TryCreate(url, UriKind.Absolute, out var uri) && TryParse(uri, out server);\n\n        }\n\n\n\n        /// <summary>\n\n        /// Tries to parse an ss:// URL into a Server object.\n\n        /// </summary>\n\n        /// <param name=\"uri\">The ss:// URL to parse.</param>\n\n        /// <param name=\"server\">\n\n        /// A Server object represented by the URL.\n\n        /// A new empty Server object if the URL is invalid.\n\n        /// </param>\n\n        /// <returns>True for success. False for failure.</returns>\n\n        public static bool TryParse(Uri uri, [NotNullWhen(true)] out Server? server)\n\n        {\n\n            server = null;\n\n            try\n\n            {\n\n                if (uri.Scheme != \"ss\")\n\n                    return false;\n\n                var userinfo_base64url = uri.UserInfo;\n\n                var userinfo = Utilities.Base64Url.DecodeToString(userinfo_base64url);\n\n                var userinfoSplitArray = userinfo.Split(':', 2);\n\n                var method = userinfoSplitArray[0];\n\n                var password = userinfoSplitArray[1];\n\n                var host = uri.HostNameType == UriHostNameType.IPv6 ? uri.Host[1..^1] : uri.Host;\n\n                var escapedFragment = string.IsNullOrEmpty(uri.Fragment) ? uri.Fragment : uri.Fragment[1..];\n\n                var name = Uri.UnescapeDataString(escapedFragment);\n\n                server = new Server()\n\n                {\n\n                    Name = name,\n\n                    Uuid = Guid.NewGuid().ToString(),\n\n                    Host = host,\n\n                    Port = uri.Port,\n\n                    Password = password,\n\n                    Method = method,\n\n                };\n\n                // find the plugin query\n\n                var parsedQueriesArray = uri.Query.Split('?', '&');\n\n                var pluginQueryContent = \"\";\n\n                foreach (var query in parsedQueriesArray)\n\n                {\n\n                    if (query.StartsWith(\"plugin=\") && query.Length > 7)\n\n                    {\n\n                        pluginQueryContent = query[7..]; // remove \"plugin=\"\n\n                    }\n\n                }\n\n                if (string.IsNullOrEmpty(pluginQueryContent)) // no plugin\n\n                    return true;\n\n                var unescapedpluginQuery = Uri.UnescapeDataString(pluginQueryContent);\n\n                var parsedPluginQueryArray = unescapedpluginQuery.Split(';', 2);\n\n                if (parsedPluginQueryArray.Length == 1)\n\n                {\n\n                    server.Plugin = parsedPluginQueryArray[0];\n\n                }\n\n                else if (parsedPluginQueryArray.Length == 2) // is valid plugin query\n\n                {\n\n                    server.Plugin = parsedPluginQueryArray[0];\n\n                    server.PluginOpts = parsedPluginQueryArray[1];\n\n                }\n\n                return true;\n\n            }\n\n            catch\n\n            {\n\n                return false;\n\n            }\n\n        }\n\n    }\n\n}\n", "// Licensed to the .NET Foundation under one or more agreements.\n\n// The .NET Foundation licenses this file to you under the MIT license.\n\n\n\n// Source: https://github.com/dotnet/corefx/pull/40003\n\n// See also: https://github.com/dotnet/runtime/issues/782\n\n\n\nusing System;\n\nusing System.Text;\n\nusing System.Text.Json;\n\n\n\nnamespace Shadowsocks.Models\n\n{\n\n    public class JsonSnakeCaseNamingPolicy : JsonNamingPolicy\n\n    {\n\n        internal enum SnakeCaseState\n\n        {\n\n            Start,\n\n            Lower,\n\n            Upper,\n\n            NewWord\n\n        }\n\n\n\n        public override string ConvertName(string name)\n\n        {\n\n            if (string.IsNullOrEmpty(name))\n\n            {\n\n                return name;\n\n            }\n\n\n\n            var sb = new StringBuilder();\n\n            var state = SnakeCaseState.Start;\n\n\n\n            var nameSpan = name.AsSpan();\n\n\n\n            for (int i = 0; i < nameSpan.Length; i++)\n\n            {\n\n                if (nameSpan[i] == ' ')\n\n                {\n\n                    if (state != SnakeCaseState.Start)\n\n                    {\n\n                        state = SnakeCaseState.NewWord;\n\n                    }\n\n                }\n\n                else if (char.IsUpper(nameSpan[i]))\n\n                {\n\n                    switch (state)\n\n                    {\n\n                        case SnakeCaseState.Upper:\n\n                            bool hasNext = (i + 1 < nameSpan.Length);\n\n                            if (i > 0 && hasNext)\n\n                            {\n\n                                char nextChar = nameSpan[i + 1];\n\n                                if (!char.IsUpper(nextChar) && nextChar != '_')\n\n                                {\n\n                                    sb.Append('_');\n\n                                }\n\n                            }\n\n                            break;\n\n                        case SnakeCaseState.Lower:\n\n                        case SnakeCaseState.NewWord:\n\n                            sb.Append('_');\n\n                            break;\n\n                    }\n\n                    sb.Append(char.ToLowerInvariant(nameSpan[i]));\n\n                    state = SnakeCaseState.Upper;\n\n                }\n\n                else if (nameSpan[i] == '_')\n\n                {\n\n                    sb.Append('_');\n\n                    state = SnakeCaseState.Start;\n\n                }\n\n                else\n\n                {\n\n                    if (state == SnakeCaseState.NewWord)\n\n                    {\n\n                        sb.Append('_');\n\n                    }\n\n\n\n                    sb.Append(nameSpan[i]);\n\n                    state = SnakeCaseState.Lower;\n\n                }\n\n            }\n\n\n\n            return sb.ToString();\n\n        }\n\n    }\n\n}\n", "using System;\n\nusing System.Collections.Generic;\n\nusing System.Text.Json.Serialization;\n\n\n\nnamespace Shadowsocks.Models\n\n{\n\n    public class Group : IGroup<Server>\n\n    {\n\n        /// <summary>\n\n        /// Gets or sets the group name.\n\n        /// </summary>\n\n        public string Name { get; set; }\n\n        \n\n        /// <summary>\n\n        /// Gets or sets the UUID of the group.\n\n        /// </summary>\n\n        public Guid Id { get; set; }\n\n\n\n        /// <inheritdoc/>\n\n        public int Version { get; set; }\n\n\n\n        /// <inheritdoc/>\n\n        public List<Server> Servers { get; set; }\n\n\n\n        /// <summary>\n\n        /// Gets or sets the data usage in bytes.\n\n        /// The value is fetched from SIP008 provider.\n\n        /// </summary>\n\n        [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingDefault)]\n\n        public ulong BytesUsed { get; set; }\n\n\n\n        /// <summary>\n\n        /// Gets or sets the data remaining to be used in bytes.\n\n        /// The value is fetched from SIP008 provider.\n\n        /// </summary>\n\n        [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingDefault)]\n\n        public ulong BytesRemaining { get; set; }\n\n\n\n        public Group(string name = \"\")\n\n        {\n\n            Name = name;\n\n            Id = Guid.NewGuid();\n\n            Version = 1;\n\n            BytesUsed = 0UL;\n\n            BytesRemaining = 0UL;\n\n            Servers = new List<Server>();\n\n        }\n\n    }\n\n}\n", "using System.Collections.Generic;\n\n\n\nnamespace Shadowsocks.Models\n\n{\n\n    public interface IGroup<T>\n\n    {\n\n        /// <summary>\n\n        /// Gets or sets the SIP008 configuration version.\n\n        /// </summary>\n\n        public int Version { get; set; }\n\n\n\n        /// <summary>\n\n        /// Gets or sets the list of servers in the group.\n\n        /// </summary>\n\n        public List<T> Servers { get; set; }\n\n    }\n\n}\n", "using System;\n\nusing System.Text.Json.Serialization;\n\n\n\nnamespace Shadowsocks.Models\n\n{\n\n    public interface IServer : IEquatable<IServer>\n\n    {\n\n        /// <summary>\n\n        /// Gets or sets the server address.\n\n        /// </summary>\n\n        [JsonPropertyName(\"server\")]\n\n        public string Host { get; set; }\n\n\n\n        /// <summary>\n\n        /// Gets or sets the server port.\n\n        /// </summary>\n\n        [JsonPropertyName(\"server_port\")]\n\n        public int Port { get; set; }\n\n\n\n        /// <summary>\n\n        /// Gets or sets the password for the server.\n\n        /// </summary>\n\n        public string Password { get; set; }\n\n\n\n        /// <summary>\n\n        /// Gets or sets the method used for the server.\n\n        /// </summary>\n\n        public string Method { get; set; }\n\n\n\n        /// <summary>\n\n        /// Gets or sets the plugin executable filename.\n\n        /// </summary>\n\n        [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingDefault)]\n\n        public string? Plugin { get; set; }\n\n\n\n        /// <summary>\n\n        /// Gets or sets the plugin options passed as environment variables.\n\n        /// </summary>\n\n        [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingDefault)]\n\n        public string? PluginOpts { get; set; }\n\n\n\n        /// <summary>\n\n        /// Gets or sets the server name.\n\n        /// </summary>\n\n        [JsonPropertyName(\"remarks\")]\n\n        public string Name { get; set; }\n\n    }\n\n}\n", "using System;\n\nusing System.Text;\n\n\n\nnamespace Shadowsocks.Utilities\n\n{\n\n    public static class Base64Url\n\n    {\n\n        public static string Encode(string data) => Encode(Encoding.UTF8.GetBytes(data));\n\n        \n\n        public static string Encode(byte[] bytes) => Convert.ToBase64String(bytes).TrimEnd('=').Replace('+', '-').Replace('/', '_');\n\n\n\n        public static string DecodeToString(string base64url) => Encoding.UTF8.GetString(DecodeToBytes(base64url));\n\n\n\n        public static byte[] DecodeToBytes(string base64url)\n\n        {\n\n            var base64string = base64url.Replace('_', '/').Replace('-', '+');\n\n            base64string = base64string.PadRight(base64string.Length + (4 - base64string.Length % 4) % 4, '=');\n\n            return Convert.FromBase64String(base64string);\n\n        }\n\n    }\n\n}\n"]