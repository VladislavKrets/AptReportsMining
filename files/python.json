["# Copyright (C) 2018 Google Inc.\n\n#\n\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n\n# you may not use this file except in compliance with the License.\n\n# You may obtain a copy of the License at\n\n#\n\n# http://www.apache.org/licenses/LICENSE-2.0\n\n#\n\n# Unless required by applicable law or agreed to in writing, software\n\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n\n# See the License for the specific language governing permissions and\n\n# limitations under the License.\n\n\n\n\"\"\"The setup.py file for Python Fire.\"\"\"\n\n\n\nfrom setuptools import setup\n\n\n\nLONG_DESCRIPTION = \"\"\"\n\nPython Fire is a library for automatically generating command line interfaces\n\n(CLIs) with a single line of code.\n\n\n\nIt will turn any Python module, class, object, function, etc. (any Python\n\ncomponent will work!) into a CLI. It's called Fire because when you call Fire(),\n\nit fires off your command.\n\n\"\"\".strip()\n\n\n\nSHORT_DESCRIPTION = \"\"\"\n\nA library for automatically generating command line interfaces.\"\"\".strip()\n\n\n\nDEPENDENCIES = [\n\n    'six',\n\n    'termcolor',\n\n    'enum34; python_version < \"3.4\"'\n\n]\n\n\n\nTEST_DEPENDENCIES = [\n\n    'hypothesis',\n\n    'mock',\n\n    'python-Levenshtein',\n\n]\n\n\n\nVERSION = '0.4.0'\n\nURL = 'https://github.com/google/python-fire'\n\n\n\nsetup(\n\n    name='fire',\n\n    version=VERSION,\n\n    description=SHORT_DESCRIPTION,\n\n    long_description=LONG_DESCRIPTION,\n\n    url=URL,\n\n\n\n    author='David Bieber',\n\n    author_email='dbieber@google.com',\n\n    license='Apache Software License',\n\n\n\n    classifiers=[\n\n        'Development Status :: 4 - Beta',\n\n\n\n        'Intended Audience :: Developers',\n\n        'Topic :: Software Development :: Libraries :: Python Modules',\n\n\n\n        'License :: OSI Approved :: Apache Software License',\n\n\n\n        'Programming Language :: Python',\n\n        'Programming Language :: Python :: 2',\n\n        'Programming Language :: Python :: 2.7',\n\n        'Programming Language :: Python :: 3',\n\n        'Programming Language :: Python :: 3.4',\n\n        'Programming Language :: Python :: 3.5',\n\n        'Programming Language :: Python :: 3.6',\n\n        'Programming Language :: Python :: 3.7',\n\n        'Programming Language :: Python :: 3.8',\n\n        'Programming Language :: Python :: 3.9',\n\n\n\n        'Operating System :: OS Independent',\n\n        'Operating System :: POSIX',\n\n        'Operating System :: MacOS',\n\n        'Operating System :: Unix',\n\n    ],\n\n\n\n    keywords='command line interface cli python fire interactive bash tool',\n\n\n\n    packages=['fire', 'fire.console'],\n\n\n\n    install_requires=DEPENDENCIES,\n\n    tests_require=TEST_DEPENDENCIES,\n\n)\n", "", "", "# Copyright (C) 2018 Google Inc.\n\n#\n\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n\n# you may not use this file except in compliance with the License.\n\n# You may obtain a copy of the License at\n\n#\n\n# http://www.apache.org/licenses/LICENSE-2.0\n\n#\n\n# Unless required by applicable law or agreed to in writing, software\n\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n\n# See the License for the specific language governing permissions and\n\n# limitations under the License.\n\n\n\n\"\"\"Tests for the widget module.\"\"\"\n\n\n\nfrom fire import testutils\n\n\n\nfrom examples.widget import widget\n\n\n\n\n\nclass WidgetTest(testutils.BaseTestCase):\n\n\n\n  def testWidgetWhack(self):\n\n    toy = widget.Widget()\n\n    self.assertEqual(toy.whack(), 'whack!')\n\n    self.assertEqual(toy.whack(3), 'whack! whack! whack!')\n\n\n\n  def testWidgetBang(self):\n\n    toy = widget.Widget()\n\n    self.assertEqual(toy.bang(), 'bang bang!')\n\n    self.assertEqual(toy.bang('boom'), 'boom bang!')\n\n\n\n\n\nif __name__ == '__main__':\n\n  testutils.main()\n", "# Copyright (C) 2018 Google Inc.\n\n#\n\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n\n# you may not use this file except in compliance with the License.\n\n# You may obtain a copy of the License at\n\n#\n\n# http://www.apache.org/licenses/LICENSE-2.0\n\n#\n\n# Unless required by applicable law or agreed to in writing, software\n\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n\n# See the License for the specific language governing permissions and\n\n# limitations under the License.\n\n\n\n\"\"\"As a Python Fire demo, a Collector collects widgets, and nobody knows why.\"\"\"\n\n\n\nimport fire\n\n\n\nfrom examples.widget import widget\n\n\n\n\n\nclass Collector(object):\n\n  \"\"\"A Collector has one Widget, but wants more.\"\"\"\n\n\n\n  def __init__(self):\n\n    self.widget = widget.Widget()\n\n    self.desired_widget_count = 10\n\n\n\n  def collect_widgets(self):\n\n    \"\"\"Returns all the widgets the Collector wants.\"\"\"\n\n    return [widget.Widget() for _ in range(self.desired_widget_count)]\n\n\n\n\n\ndef main():\n\n  fire.Fire(Collector(), name='collector')\n\n\n\nif __name__ == '__main__':\n\n  main()\n", "# Copyright (C) 2018 Google Inc.\n\n#\n\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n\n# you may not use this file except in compliance with the License.\n\n# You may obtain a copy of the License at\n\n#\n\n# http://www.apache.org/licenses/LICENSE-2.0\n\n#\n\n# Unless required by applicable law or agreed to in writing, software\n\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n\n# See the License for the specific language governing permissions and\n\n# limitations under the License.\n\n\n\n\"\"\"As a simple example of Python Fire, a Widget serves no clear purpose.\"\"\"\n\n\n\nimport fire\n\n\n\n\n\nclass Widget(object):\n\n\n\n  def whack(self, n=1):\n\n    \"\"\"Prints \"whack!\" n times.\"\"\"\n\n    return ' '.join('whack!' for _ in range(n))\n\n\n\n  def bang(self, noise='bang'):\n\n    \"\"\"Makes a loud noise.\"\"\"\n\n    return '{noise} bang!'.format(noise=noise)\n\n\n\n\n\ndef main():\n\n  fire.Fire(Widget(), name='widget')\n\n\n\nif __name__ == '__main__':\n\n  main()\n", "# Copyright (C) 2018 Google Inc.\n\n#\n\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n\n# you may not use this file except in compliance with the License.\n\n# You may obtain a copy of the License at\n\n#\n\n# http://www.apache.org/licenses/LICENSE-2.0\n\n#\n\n# Unless required by applicable law or agreed to in writing, software\n\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n\n# See the License for the specific language governing permissions and\n\n# limitations under the License.\n\n\n\n\"\"\"Tests for the collector module.\"\"\"\n\n\n\nfrom fire import testutils\n\n\n\nfrom examples.widget import collector\n\nfrom examples.widget import widget\n\n\n\n\n\nclass CollectorTest(testutils.BaseTestCase):\n\n\n\n  def testCollectorHasWidget(self):\n\n    col = collector.Collector()\n\n    self.assertIsInstance(col.widget, widget.Widget)\n\n\n\n  def testCollectorWantsMoreWidgets(self):\n\n    col = collector.Collector()\n\n    self.assertEqual(col.desired_widget_count, 10)\n\n\n\n  def testCollectorGetsWantedWidgets(self):\n\n    col = collector.Collector()\n\n    self.assertEqual(len(col.collect_widgets()), 10)\n\n\n\n\n\nif __name__ == '__main__':\n\n  testutils.main()\n", "", "# Copyright (C) 2018 Google Inc.\n\n#\n\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n\n# you may not use this file except in compliance with the License.\n\n# You may obtain a copy of the License at\n\n#\n\n# http://www.apache.org/licenses/LICENSE-2.0\n\n#\n\n# Unless required by applicable law or agreed to in writing, software\n\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n\n# See the License for the specific language governing permissions and\n\n# limitations under the License.\n\n\n\n\"\"\"Tests for the diff and difffull modules.\"\"\"\n\n\n\nimport tempfile\n\n\n\nfrom fire import testutils\n\n\n\nfrom examples.diff import diff\n\nfrom examples.diff import difffull\n\n\n\n\n\nclass DiffTest(testutils.BaseTestCase):\n\n  \"\"\"The purpose of these tests is to ensure the difflib wrappers works.\n\n\n\n  It is not the goal of these tests to exhaustively test difflib functionality.\n\n  \"\"\"\n\n\n\n  def setUp(self):\n\n    self.file1 = file1 = tempfile.NamedTemporaryFile()\n\n    self.file2 = file2 = tempfile.NamedTemporaryFile()\n\n\n\n    file1.write(b'test\\ntest1\\n')\n\n    file2.write(b'test\\ntest2\\nextraline\\n')\n\n\n\n    file1.flush()\n\n    file2.flush()\n\n\n\n    self.diff = diff.DiffLibWrapper(file1.name, file2.name)\n\n\n\n  def testSetUp(self):\n\n    self.assertEqual(self.diff.fromlines, ['test\\n', 'test1\\n'])\n\n    self.assertEqual(self.diff.tolines, ['test\\n', 'test2\\n', 'extraline\\n'])\n\n\n\n  def testUnifiedDiff(self):\n\n    results = list(self.diff.unified_diff())\n\n    self.assertTrue(results[0].startswith('--- ' + self.file1.name))\n\n    self.assertTrue(results[1].startswith('+++ ' + self.file2.name))\n\n    self.assertEqual(\n\n        results[2:],\n\n        [\n\n            '@@ -1,2 +1,3 @@\\n',\n\n            ' test\\n',\n\n            '-test1\\n',\n\n            '+test2\\n',\n\n            '+extraline\\n',\n\n        ]\n\n    )\n\n\n\n  def testContextDiff(self):\n\n    expected_lines = [\n\n        '***************\\n',\n\n        '*** 1,2 ****\\n',\n\n        '  test\\n',\n\n        '! test1\\n',\n\n        '--- 1,3 ----\\n',\n\n        '  test\\n',\n\n        '! test2\\n',\n\n        '! extraline\\n']\n\n    results = list(self.diff.context_diff())\n\n    self.assertEqual(results[2:], expected_lines)\n\n\n\n  def testNDiff(self):\n\n    expected_lines = [\n\n        '  test\\n',\n\n        '- test1\\n',\n\n        '?     ^\\n',\n\n        '+ test2\\n',\n\n        '?     ^\\n',\n\n        '+ extraline\\n']\n\n    results = list(self.diff.ndiff())\n\n    self.assertEqual(results, expected_lines)\n\n\n\n  def testMakeDiff(self):\n\n    self.assertTrue(''.join(self.diff.make_file()).startswith('\\n<!DOC'))\n\n\n\n  def testDiffFull(self):\n\n    self.assertIsNotNone(difffull)\n\n    self.assertIsNotNone(difffull.difflib)\n\n\n\n\n\nif __name__ == '__main__':\n\n  testutils.main()\n", "# Copyright (C) 2018 Google Inc.\n\n#\n\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n\n# you may not use this file except in compliance with the License.\n\n# You may obtain a copy of the License at\n\n#\n\n# http://www.apache.org/licenses/LICENSE-2.0\n\n#\n\n# Unless required by applicable law or agreed to in writing, software\n\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n\n# See the License for the specific language governing permissions and\n\n# limitations under the License.\n\n\n\nr\"\"\"A command line tool for diffing files.\n\n\n\nThe Python 2.7 documentation demonstrates how to make a command line interface\n\nfor the difflib library using optparse:\n\nhttps://docs.python.org/2/library/difflib.html#a-command-line-interface-to-difflib\n\n\n\nThis file demonstrates how to create a command line interface providing the same\n\nfunctionality using Python Fire.\n\n\n\nUsage:\n\n\n\ndiff FROMFILE TOFILE COMMAND [LINES]\n\n\n\nArguments can be passed positionally or via the Flag syntax.\n\nUsing positional arguments, the usage is:\n\n\n\ndiff FROMFILE TOFILE\n\ndiff FROMFILE TOFILE context-diff [LINES]\n\ndiff FROMFILE TOFILE unified-diff [LINES]\n\ndiff FROMFILE TOFILE ndiff\n\ndiff FROMFILE TOFILE make-file [CONTEXT] [LINES]\n\n\n\nUsing the Flag syntax, the usage is:\n\n\n\ndiff --fromfile=FROMFILE --tofile=TOFILE\n\ndiff --fromfile=FROMFILE --tofile=TOFILE context-diff [--lines=LINES]\n\ndiff --fromfile=FROMFILE --tofile=TOFILE unified-diff [--lines=LINES]\n\ndiff --fromfile=FROMFILE --tofile=TOFILE ndiff\n\ndiff --fromfile=FROMFILE --tofile=TOFILE make-file \\\n\n    [--context=CONTEXT] [--lines LINES]\n\n\n\nAs with any Fire CLI, you can append '--' followed by any Flags to any command.\n\n\n\nThe Flags available for all Fire CLIs are:\n\n  --help\n\n  --interactive\n\n  --trace\n\n  --separator=SEPARATOR\n\n  --completion\n\n  --verbose\n\n\"\"\"\n\n\n\nimport difflib\n\nimport os\n\nimport time\n\n\n\nimport fire\n\n\n\n\n\nclass DiffLibWrapper(object):\n\n  \"\"\"Provides a simple interface to the difflib module.\n\n\n\n  The purpose of this simple interface is to offer a limited subset of the\n\n  difflib functionality as a command line interface.\n\n  \"\"\"\n\n\n\n  def __init__(self, fromfile, tofile):\n\n    self._fromfile = fromfile\n\n    self._tofile = tofile\n\n\n\n    self.fromdate = time.ctime(os.stat(fromfile).st_mtime)\n\n    self.todate = time.ctime(os.stat(tofile).st_mtime)\n\n    with open(fromfile) as f:\n\n      self.fromlines = f.readlines()\n\n    with open(tofile) as f:\n\n      self.tolines = f.readlines()\n\n\n\n  def unified_diff(self, lines=3):\n\n    return difflib.unified_diff(\n\n        self.fromlines, self.tolines, self._fromfile,\n\n        self._tofile, self.fromdate, self.todate, n=lines)\n\n\n\n  def ndiff(self):\n\n    return difflib.ndiff(self.fromlines, self.tolines)\n\n\n\n  def make_file(self, context=False, lines=3):\n\n    return difflib.HtmlDiff().make_file(\n\n        self.fromlines, self.tolines, self._fromfile, self._tofile,\n\n        context=context, numlines=lines)\n\n\n\n  def context_diff(self, lines=3):\n\n    return difflib.context_diff(\n\n        self.fromlines, self.tolines, self._fromfile,\n\n        self._tofile, self.fromdate, self.todate, n=lines)\n\n\n\n\n\ndef main():\n\n  fire.Fire(DiffLibWrapper, name='diff')\n\n\n\nif __name__ == '__main__':\n\n  main()\n", "# Copyright (C) 2018 Google Inc.\n\n#\n\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n\n# you may not use this file except in compliance with the License.\n\n# You may obtain a copy of the License at\n\n#\n\n# http://www.apache.org/licenses/LICENSE-2.0\n\n#\n\n# Unless required by applicable law or agreed to in writing, software\n\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n\n# See the License for the specific language governing permissions and\n\n# limitations under the License.\n\n\n\n\"\"\"A command line tool for diffing files.\n\n\n\nThis demonstrates the simplest possible way to turn a module into a command line\n\ninterface with Python Fire. It exemplifies the power and shortcomings of relying\n\non Python Fire's simplicity.\n\n\n\nSee //fire/examples/diff/diff.py for another way of turning\n\ndifflib into a CLI that requires more code, but gives the developer more control\n\nover the CLI's API.\n\n\n\nUse the help flag to see usage for all the things this CLI can do. For example:\n\n\n\ndifffull -- -h\n\ndifffull HtmlDiff -- -h  # Help for the HtmlDiff class\n\ndifffull HtmlDiff - -- -h  # Help for an HtmlDiff object, not the HtmlDiff class\n\n\n\nHere are some of the diff commands available:\n\n\n\ndifffull ndiff A B [LINEJUNK] [CHARJUNK]\n\ndifffull context-diff A B [FROMFILE] [TOFILE] [FROMFILEDATE] [TOFILEDATE] [N]\n\ndifffull unified-diff A B [FROMFILE] [TOFILE] [FROMFILEDATE] [TOFILEDATE] [N]\n\ndifffull HtmlDiff - make-file FROMLINES TOLINES [FROMDESC] [TODESC] [CONTEXT]\n\n\n\nFor more useful versions of those last four commands using Python Fire, see\n\n//fire/examples/diff:diff.par\n\n\"\"\"\n\n\n\nimport difflib\n\n\n\nimport fire\n\n\n\n\n\ndef main():\n\n  fire.Fire(difflib, name='difffull')\n\n\n\nif __name__ == '__main__':\n\n  main()\n", "", "# Copyright (C) 2018 Google Inc.\n\n#\n\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n\n# you may not use this file except in compliance with the License.\n\n# You may obtain a copy of the License at\n\n#\n\n# http://www.apache.org/licenses/LICENSE-2.0\n\n#\n\n# Unless required by applicable law or agreed to in writing, software\n\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n\n# See the License for the specific language governing permissions and\n\n# limitations under the License.\n\n\n\n\"\"\"A simple command line tool for testing purposes.\"\"\"\n\n\n\nimport fire\n\n\n\n\n\ndef identity(arg=None):\n\n  return arg, type(arg)\n\n\n\n\n\ndef main(_=None):\n\n  fire.Fire(identity, name='identity')\n\n\n\nif __name__ == '__main__':\n\n  main()\n", "", "# Copyright (C) 2018 Google Inc.\n\n#\n\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n\n# you may not use this file except in compliance with the License.\n\n# You may obtain a copy of the License at\n\n#\n\n# http://www.apache.org/licenses/LICENSE-2.0\n\n#\n\n# Unless required by applicable law or agreed to in writing, software\n\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n\n# See the License for the specific language governing permissions and\n\n# limitations under the License.\n\n\n\n\"\"\"The Caesar Shift Cipher example Fire CLI.\n\n\n\nThis module demonstrates the use of Fire without specifying a target component.\n\nNotice how the call to Fire() in the main method doesn't indicate a component.\n\nSo, all local and global variables (including all functions defined in the\n\nmodule) are made available as part of the Fire CLI.\n\n\n\nExample usage:\n\ncipher rot13 'Hello world!'  # Uryyb jbeyq!\n\ncipher rot13 'Uryyb jbeyq!'  # Hello world!\n\ncipher caesar-encode 1 'Hello world!'  # Ifmmp xpsme!\n\ncipher caesar-decode 1 'Ifmmp xpsme!'  # Hello world!\n\n\"\"\"\n\n\n\nimport fire\n\n\n\n\n\ndef caesar_encode(n=0, text=''):\n\n  return ''.join(\n\n      _caesar_shift_char(n, char)\n\n      for char in text\n\n  )\n\n\n\n\n\ndef caesar_decode(n=0, text=''):\n\n  return caesar_encode(-n, text)\n\n\n\n\n\ndef rot13(text):\n\n  return caesar_encode(13, text)\n\n\n\n\n\ndef _caesar_shift_char(n=0, char=' '):\n\n  if not char.isalpha():\n\n    return char\n\n  if char.isupper():\n\n    return chr((ord(char) - ord('A') + n) % 26 + ord('A'))\n\n  return chr((ord(char) - ord('a') + n) % 26 + ord('a'))\n\n\n\n\n\ndef main():\n\n  fire.Fire(name='cipher')\n\n\n\nif __name__ == '__main__':\n\n  main()\n", "# Copyright (C) 2018 Google Inc.\n\n#\n\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n\n# you may not use this file except in compliance with the License.\n\n# You may obtain a copy of the License at\n\n#\n\n# http://www.apache.org/licenses/LICENSE-2.0\n\n#\n\n# Unless required by applicable law or agreed to in writing, software\n\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n\n# See the License for the specific language governing permissions and\n\n# limitations under the License.\n\n\n\n\"\"\"Tests for the cipher module.\"\"\"\n\n\n\nfrom fire import testutils\n\n\n\nfrom examples.cipher import cipher\n\n\n\n\n\nclass CipherTest(testutils.BaseTestCase):\n\n\n\n  def testCipher(self):\n\n    self.assertEqual(cipher.rot13('Hello world!'), 'Uryyb jbeyq!')\n\n    self.assertEqual(cipher.caesar_encode(13, 'Hello world!'), 'Uryyb jbeyq!')\n\n    self.assertEqual(cipher.caesar_decode(13, 'Uryyb jbeyq!'), 'Hello world!')\n\n\n\n    self.assertEqual(cipher.caesar_encode(1, 'Hello world!'), 'Ifmmp xpsme!')\n\n    self.assertEqual(cipher.caesar_decode(1, 'Ifmmp xpsme!'), 'Hello world!')\n\n\n\n\n\nif __name__ == '__main__':\n\n  testutils.main()\n", "# Copyright (C) 2018 Google Inc.\n\n#\n\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n\n# you may not use this file except in compliance with the License.\n\n# You may obtain a copy of the License at\n\n#\n\n# http://www.apache.org/licenses/LICENSE-2.0\n\n#\n\n# Unless required by applicable law or agreed to in writing, software\n\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n\n# See the License for the specific language governing permissions and\n\n# limitations under the License.\n\n\n\n\"\"\"The Python Fire module.\"\"\"\n\n\n\nfrom __future__ import absolute_import\n\nfrom __future__ import division\n\nfrom __future__ import print_function\n\n\n\nfrom fire.core import Fire\n\n\n\n__all__ = ['Fire']\n\n__version__ = '0.4.0'\n", "# Copyright (C) 2018 Google Inc.\n\n#\n\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n\n# you may not use this file except in compliance with the License.\n\n# You may obtain a copy of the License at\n\n#\n\n# http://www.apache.org/licenses/LICENSE-2.0\n\n#\n\n# Unless required by applicable law or agreed to in writing, software\n\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n\n# See the License for the specific language governing permissions and\n\n# limitations under the License.\n\n\n\n\"\"\"Tests for fire docstrings module.\"\"\"\n\n\n\nfrom __future__ import absolute_import\n\nfrom __future__ import division\n\nfrom __future__ import print_function\n\n\n\nfrom fire import docstrings\n\nfrom fire import testutils\n\n\n\n# pylint: disable=invalid-name\n\nDocstringInfo = docstrings.DocstringInfo\n\nArgInfo = docstrings.ArgInfo\n\nKwargInfo = docstrings.KwargInfo\n\n# pylint: enable=invalid-name\n\n\n\n\n\nclass DocstringsTest(testutils.BaseTestCase):\n\n\n\n  def test_one_line_simple(self):\n\n    docstring = \"\"\"A simple one line docstring.\"\"\"\n\n    docstring_info = docstrings.parse(docstring)\n\n    expected_docstring_info = DocstringInfo(\n\n        summary='A simple one line docstring.',\n\n    )\n\n    self.assertEqual(expected_docstring_info, docstring_info)\n\n\n\n  def test_one_line_simple_whitespace(self):\n\n    docstring = \"\"\"\n\n      A simple one line docstring.\n\n    \"\"\"\n\n    docstring_info = docstrings.parse(docstring)\n\n    expected_docstring_info = DocstringInfo(\n\n        summary='A simple one line docstring.',\n\n    )\n\n    self.assertEqual(expected_docstring_info, docstring_info)\n\n\n\n  def test_one_line_too_long(self):\n\n    # pylint: disable=line-too-long\n\n    docstring = \"\"\"A one line docstring thats both a little too verbose and a little too long so it keeps going well beyond a reasonable length for a one-liner.\n\n    \"\"\"\n\n    # pylint: enable=line-too-long\n\n    docstring_info = docstrings.parse(docstring)\n\n    expected_docstring_info = DocstringInfo(\n\n        summary='A one line docstring thats both a little too verbose and '\n\n        'a little too long so it keeps going well beyond a reasonable length '\n\n        'for a one-liner.',\n\n    )\n\n    self.assertEqual(expected_docstring_info, docstring_info)\n\n\n\n  def test_one_line_runs_over(self):\n\n    # pylint: disable=line-too-long\n\n    docstring = \"\"\"A one line docstring thats both a little too verbose and a little too long\n\n    so it runs onto a second line.\n\n    \"\"\"\n\n    # pylint: enable=line-too-long\n\n    docstring_info = docstrings.parse(docstring)\n\n    expected_docstring_info = DocstringInfo(\n\n        summary='A one line docstring thats both a little too verbose and '\n\n        'a little too long so it runs onto a second line.',\n\n    )\n\n    self.assertEqual(expected_docstring_info, docstring_info)\n\n\n\n  def test_one_line_runs_over_whitespace(self):\n\n    docstring = \"\"\"\n\n      A one line docstring thats both a little too verbose and a little too long\n\n      so it runs onto a second line.\n\n    \"\"\"\n\n    docstring_info = docstrings.parse(docstring)\n\n    expected_docstring_info = DocstringInfo(\n\n        summary='A one line docstring thats both a little too verbose and '\n\n        'a little too long so it runs onto a second line.',\n\n    )\n\n    self.assertEqual(expected_docstring_info, docstring_info)\n\n\n\n  def test_google_format_args_only(self):\n\n    docstring = \"\"\"One line description.\n\n\n\n    Args:\n\n      arg1: arg1_description\n\n      arg2: arg2_description\n\n    \"\"\"\n\n    docstring_info = docstrings.parse(docstring)\n\n    expected_docstring_info = DocstringInfo(\n\n        summary='One line description.',\n\n        args=[\n\n            ArgInfo(name='arg1', description='arg1_description'),\n\n            ArgInfo(name='arg2', description='arg2_description'),\n\n        ]\n\n    )\n\n    self.assertEqual(expected_docstring_info, docstring_info)\n\n\n\n  def test_google_format_arg_named_args(self):\n\n    docstring = \"\"\"\n\n    Args:\n\n      args: arg_description\n\n    \"\"\"\n\n    docstring_info = docstrings.parse(docstring)\n\n    expected_docstring_info = DocstringInfo(\n\n        args=[\n\n            ArgInfo(name='args', description='arg_description'),\n\n        ]\n\n    )\n\n    self.assertEqual(expected_docstring_info, docstring_info)\n\n\n\n  def test_google_format_typed_args_and_returns(self):\n\n    docstring = \"\"\"Docstring summary.\n\n\n\n    This is a longer description of the docstring. It spans multiple lines, as\n\n    is allowed.\n\n\n\n    Args:\n\n        param1 (int): The first parameter.\n\n        param2 (str): The second parameter.\n\n\n\n    Returns:\n\n        bool: The return value. True for success, False otherwise.\n\n    \"\"\"\n\n    docstring_info = docstrings.parse(docstring)\n\n    expected_docstring_info = DocstringInfo(\n\n        summary='Docstring summary.',\n\n        description='This is a longer description of the docstring. It spans '\n\n        'multiple lines, as\\nis allowed.',\n\n        args=[\n\n            ArgInfo(name='param1', type='int',\n\n                    description='The first parameter.'),\n\n            ArgInfo(name='param2', type='str',\n\n                    description='The second parameter.'),\n\n        ],\n\n        returns='bool: The return value. True for success, False otherwise.'\n\n    )\n\n    self.assertEqual(expected_docstring_info, docstring_info)\n\n\n\n  def test_google_format_multiline_arg_description(self):\n\n    docstring = \"\"\"Docstring summary.\n\n\n\n    This is a longer description of the docstring. It spans multiple lines, as\n\n    is allowed.\n\n\n\n    Args:\n\n        param1 (int): The first parameter.\n\n        param2 (str): The second parameter. This has a lot of text, enough to\n\n        cover two lines.\n\n    \"\"\"\n\n    docstring_info = docstrings.parse(docstring)\n\n    expected_docstring_info = DocstringInfo(\n\n        summary='Docstring summary.',\n\n        description='This is a longer description of the docstring. It spans '\n\n        'multiple lines, as\\nis allowed.',\n\n        args=[\n\n            ArgInfo(name='param1', type='int',\n\n                    description='The first parameter.'),\n\n            ArgInfo(name='param2', type='str',\n\n                    description='The second parameter. This has a lot of text, '\n\n                                'enough to cover two lines.'),\n\n        ],\n\n    )\n\n    self.assertEqual(expected_docstring_info, docstring_info)\n\n\n\n  def test_rst_format_typed_args_and_returns(self):\n\n    docstring = \"\"\"Docstring summary.\n\n\n\n    This is a longer description of the docstring. It spans across multiple\n\n    lines.\n\n\n\n    :param arg1: Description of arg1.\n\n    :type arg1: str.\n\n    :param arg2: Description of arg2.\n\n    :type arg2: bool.\n\n    :returns:  int -- description of the return value.\n\n    :raises: AttributeError, KeyError\n\n    \"\"\"\n\n    docstring_info = docstrings.parse(docstring)\n\n    expected_docstring_info = DocstringInfo(\n\n        summary='Docstring summary.',\n\n        description='This is a longer description of the docstring. It spans '\n\n        'across multiple\\nlines.',\n\n        args=[\n\n            ArgInfo(name='arg1', type='str',\n\n                    description='Description of arg1.'),\n\n            ArgInfo(name='arg2', type='bool',\n\n                    description='Description of arg2.'),\n\n        ],\n\n        returns='int -- description of the return value.',\n\n        raises='AttributeError, KeyError',\n\n    )\n\n    self.assertEqual(expected_docstring_info, docstring_info)\n\n\n\n  def test_numpy_format_typed_args_and_returns(self):\n\n    docstring = \"\"\"Docstring summary.\n\n\n\n    This is a longer description of the docstring. It spans across multiple\n\n    lines.\n\n\n\n    Parameters\n\n    ----------\n\n    param1 : int\n\n        The first parameter.\n\n    param2 : str\n\n        The second parameter.\n\n\n\n    Returns\n\n    -------\n\n    bool\n\n        True if successful, False otherwise.\n\n    \"\"\"\n\n    docstring_info = docstrings.parse(docstring)\n\n    expected_docstring_info = DocstringInfo(\n\n        summary='Docstring summary.',\n\n        description='This is a longer description of the docstring. It spans '\n\n        'across multiple\\nlines.',\n\n        args=[\n\n            ArgInfo(name='param1', type='int',\n\n                    description='The first parameter.'),\n\n            ArgInfo(name='param2', type='str',\n\n                    description='The second parameter.'),\n\n        ],\n\n        # TODO(dbieber): Support return type.\n\n        returns='bool True if successful, False otherwise.',\n\n    )\n\n    self.assertEqual(expected_docstring_info, docstring_info)\n\n\n\n  def test_numpy_format_multiline_arg_description(self):\n\n    docstring = \"\"\"Docstring summary.\n\n\n\n    This is a longer description of the docstring. It spans across multiple\n\n    lines.\n\n\n\n    Parameters\n\n    ----------\n\n    param1 : int\n\n        The first parameter.\n\n    param2 : str\n\n        The second parameter. This has a lot of text, enough to cover two\n\n        lines.\n\n    \"\"\"\n\n    docstring_info = docstrings.parse(docstring)\n\n    expected_docstring_info = DocstringInfo(\n\n        summary='Docstring summary.',\n\n        description='This is a longer description of the docstring. It spans '\n\n        'across multiple\\nlines.',\n\n        args=[\n\n            ArgInfo(name='param1', type='int',\n\n                    description='The first parameter.'),\n\n            ArgInfo(name='param2', type='str',\n\n                    description='The second parameter. This has a lot of text, '\n\n                                'enough to cover two lines.'),\n\n        ],\n\n    )\n\n    self.assertEqual(expected_docstring_info, docstring_info)\n\n\n\n  def test_multisection_docstring(self):\n\n    docstring = \"\"\"Docstring summary.\n\n\n\n    This is the first section of a docstring description.\n\n\n\n    This is the second section of a docstring description. This docstring\n\n    description has just two sections.\n\n    \"\"\"\n\n    docstring_info = docstrings.parse(docstring)\n\n    expected_docstring_info = DocstringInfo(\n\n        summary='Docstring summary.',\n\n        description='This is the first section of a docstring description.'\n\n        '\\n\\n'\n\n        'This is the second section of a docstring description. This docstring'\n\n        '\\n'\n\n        'description has just two sections.',\n\n    )\n\n    self.assertEqual(expected_docstring_info, docstring_info)\n\n\n\n  def test_google_section_with_blank_first_line(self):\n\n    docstring = \"\"\"Inspired by requests HTTPAdapter docstring.\n\n\n\n    :param x: Simple param.\n\n\n\n    Usage:\n\n\n\n      >>> import requests\n\n    \"\"\"\n\n    docstring_info = docstrings.parse(docstring)\n\n    self.assertEqual('Inspired by requests HTTPAdapter docstring.',\n\n                     docstring_info.summary)\n\n\n\n  def test_ill_formed_docstring(self):\n\n    docstring = \"\"\"Docstring summary.\n\n\n\n    args: raises ::\n\n    :\n\n    pathological docstrings should not fail, and ideally should behave\n\n    reasonably.\n\n    \"\"\"\n\n    docstrings.parse(docstring)\n\n\n\n  def test_strip_blank_lines(self):\n\n    lines = ['   ', '  foo  ', '   ']\n\n    expected_output = ['  foo  ']\n\n\n\n    self.assertEqual(expected_output, docstrings._strip_blank_lines(lines))  # pylint: disable=protected-access\n\n\n\n  def test_numpy_colon_in_description(self):\n\n    docstring = \"\"\"\n\n     Greets name.\n\n\n\n     Arguments\n\n     ---------\n\n     name : str\n\n         name, default : World\n\n     arg2 : int\n\n         arg2, default:None\n\n     arg3 : bool\n\n     \"\"\"\n\n    docstring_info = docstrings.parse(docstring)\n\n    expected_docstring_info = DocstringInfo(\n\n        summary='Greets name.',\n\n        description=None,\n\n        args=[\n\n            ArgInfo(name='name', type='str',\n\n                    description='name, default : World'),\n\n            ArgInfo(name='arg2', type='int',\n\n                    description='arg2, default:None'),\n\n            ArgInfo(name='arg3', type='bool', description=None),\n\n        ]\n\n    )\n\n    self.assertEqual(expected_docstring_info, docstring_info)\n\n\n\n  def test_rst_format_typed_args_and_kwargs(self):\n\n    docstring = \"\"\"Docstring summary.\n\n\n\n    :param arg1: Description of arg1.\n\n    :type arg1: str.\n\n    :key arg2: Description of arg2.\n\n    :type arg2: bool.\n\n    :key arg3: Description of arg3.\n\n    :type arg3: str.\n\n    \"\"\"\n\n    docstring_info = docstrings.parse(docstring)\n\n    expected_docstring_info = DocstringInfo(\n\n        summary='Docstring summary.',\n\n        args=[\n\n            ArgInfo(name='arg1', type='str',\n\n                    description='Description of arg1.'),\n\n            KwargInfo(name='arg2', type='bool',\n\n                      description='Description of arg2.'),\n\n            KwargInfo(name='arg3', type='str',\n\n                      description='Description of arg3.'),\n\n        ],\n\n    )\n\n    self.assertEqual(expected_docstring_info, docstring_info)\n\n\n\n\n\nif __name__ == '__main__':\n\n  testutils.main()\n", "# Copyright (C) 2018 Google Inc.\n\n#\n\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n\n# you may not use this file except in compliance with the License.\n\n# You may obtain a copy of the License at\n\n#\n\n# http://www.apache.org/licenses/LICENSE-2.0\n\n#\n\n# Unless required by applicable law or agreed to in writing, software\n\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n\n# See the License for the specific language governing permissions and\n\n# limitations under the License.\n\n\n\n\"\"\"Fuzz tests for the parser module.\"\"\"\n\n\n\nfrom __future__ import absolute_import\n\nfrom __future__ import division\n\nfrom __future__ import print_function\n\n\n\nfrom fire import parser\n\nfrom fire import testutils\n\nfrom hypothesis import example\n\nfrom hypothesis import given\n\nfrom hypothesis import settings\n\nfrom hypothesis import strategies as st\n\nimport Levenshtein\n\nimport six\n\n\n\n\n\nclass ParserFuzzTest(testutils.BaseTestCase):\n\n\n\n  @settings(max_examples=10000)\n\n  @given(st.text(min_size=1))\n\n  @example('True')\n\n  @example(r'\"test\\t\\t\\a\\\\a\"')\n\n  @example(r' \"test\\t\\t\\a\\\\a\"   ')\n\n  @example('\"(1, 2)\"')\n\n  @example('(1, 2)')\n\n  @example('(1,                   2)')\n\n  @example('(1,       2) ')\n\n  @example('a,b,c,d')\n\n  @example('(a,b,c,d)')\n\n  @example('[a,b,c,d]')\n\n  @example('{a,b,c,d}')\n\n  @example('test:(a,b,c,d)')\n\n  @example('{test:(a,b,c,d)}')\n\n  @example('{test:a,b,c,d}')\n\n  @example('{test:a,b:(c,d)}')  # Note: Edit distance may be high for dicts.\n\n  @example('0,')\n\n  @example('#')\n\n  @example('A#00000')  # Note: '#'' is treated as a comment.\n\n  @example('\\x80')  # Note: Causes UnicodeDecodeError.\n\n  @example(100 * '[' + '0')  # Note: Causes MemoryError.\n\n  @example('\\r\\r\\r\\r1\\r\\r')\n\n  def testDefaultParseValueFuzz(self, value):\n\n    try:\n\n      result = parser.DefaultParseValue(value)\n\n    except TypeError:\n\n      # It's OK to get a TypeError if the string has the null character.\n\n      if u'\\x00' in value:\n\n        return\n\n      raise\n\n    except MemoryError:\n\n      if len(value) > 100:\n\n        # This is not what we're testing.\n\n        return\n\n      raise\n\n\n\n    try:\n\n      uvalue = six.text_type(value)\n\n      uresult = six.text_type(result)\n\n    except UnicodeDecodeError:\n\n      # This is not what we're testing.\n\n      return\n\n\n\n    # Check that the parsed value doesn't differ too much from the input.\n\n    distance = Levenshtein.distance(uresult, uvalue)\n\n    max_distance = (\n\n        2 +  # Quotes or parenthesis can be implicit.\n\n        sum(c.isspace() for c in value) +\n\n        value.count('\"') + value.count(\"'\") +\n\n        3 * (value.count(',') + 1) +  # 'a,' can expand to \"'a', \"\n\n        3 * (value.count(':')) +  # 'a:' can expand to \"'a': \"\n\n        2 * value.count('\\\\'))\n\n    if '#' in value:\n\n      max_distance += len(value) - value.index('#')\n\n\n\n    if not isinstance(result, six.string_types):\n\n      max_distance += value.count('0')  # Leading 0s are stripped.\n\n\n\n    # Note: We don't check distance for dicts since item order can be changed.\n\n    if '{' not in value:\n\n      self.assertLessEqual(distance, max_distance,\n\n                           (distance, max_distance, uvalue, uresult))\n\n\n\n\n\nif __name__ == '__main__':\n\n  testutils.main()\n", "# Copyright (C) 2018 Google Inc.\n\n#\n\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n\n# you may not use this file except in compliance with the License.\n\n# You may obtain a copy of the License at\n\n#\n\n# http://www.apache.org/licenses/LICENSE-2.0\n\n#\n\n# Unless required by applicable law or agreed to in writing, software\n\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n\n# See the License for the specific language governing permissions and\n\n# limitations under the License.\n\n\n\n\"\"\"Tests for custom description module.\"\"\"\n\n\n\nfrom __future__ import absolute_import\n\nfrom __future__ import division\n\nfrom __future__ import print_function\n\n\n\nfrom fire import custom_descriptions\n\nfrom fire import testutils\n\n\n\nLINE_LENGTH = 80\n\n\n\n\n\nclass CustomDescriptionTest(testutils.BaseTestCase):\n\n\n\n  def test_string_type_summary_enough_space(self):\n\n    component = 'Test'\n\n    summary = custom_descriptions.GetSummary(\n\n        obj=component, available_space=80, line_length=LINE_LENGTH)\n\n    self.assertEqual(summary, '\"Test\"')\n\n\n\n  def test_string_type_summary_not_enough_space_truncated(self):\n\n    component = 'Test'\n\n    summary = custom_descriptions.GetSummary(\n\n        obj=component, available_space=5, line_length=LINE_LENGTH)\n\n    self.assertEqual(summary, '\"...\"')\n\n\n\n  def test_string_type_summary_not_enough_space_new_line(self):\n\n    component = 'Test'\n\n    summary = custom_descriptions.GetSummary(\n\n        obj=component, available_space=4, line_length=LINE_LENGTH)\n\n    self.assertEqual(summary, '\"Test\"')\n\n\n\n  def test_string_type_summary_not_enough_space_long_truncated(self):\n\n    component = 'Lorem ipsum dolor sit amet'\n\n    summary = custom_descriptions.GetSummary(\n\n        obj=component, available_space=10, line_length=LINE_LENGTH)\n\n    self.assertEqual(summary, '\"Lorem...\"')\n\n\n\n  def test_string_type_description_enough_space(self):\n\n    component = 'Test'\n\n    description = custom_descriptions.GetDescription(\n\n        obj=component, available_space=80, line_length=LINE_LENGTH)\n\n    self.assertEqual(description, 'The string \"Test\"')\n\n\n\n  def test_string_type_description_not_enough_space_truncated(self):\n\n    component = 'Lorem ipsum dolor sit amet'\n\n    description = custom_descriptions.GetDescription(\n\n        obj=component, available_space=20, line_length=LINE_LENGTH)\n\n    self.assertEqual(description, 'The string \"Lore...\"')\n\n\n\n  def test_string_type_description_not_enough_space_new_line(self):\n\n    component = 'Lorem ipsum dolor sit amet'\n\n    description = custom_descriptions.GetDescription(\n\n        obj=component, available_space=10, line_length=LINE_LENGTH)\n\n    self.assertEqual(description, 'The string \"Lorem ipsum dolor sit amet\"')\n\n\n\n\n\nif __name__ == '__main__':\n\n  testutils.main()\n", "# Copyright (C) 2018 Google Inc.\n\n#\n\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n\n# you may not use this file except in compliance with the License.\n\n# You may obtain a copy of the License at\n\n#\n\n# http://www.apache.org/licenses/LICENSE-2.0\n\n#\n\n# Unless required by applicable law or agreed to in writing, software\n\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n\n# See the License for the specific language governing permissions and\n\n# limitations under the License.\n\n\n\n\"\"\"Test the test utilities for Fire's tests.\"\"\"\n\n\n\nfrom __future__ import absolute_import\n\nfrom __future__ import division\n\nfrom __future__ import print_function\n\n\n\nimport sys\n\n\n\nfrom fire import testutils\n\n\n\nimport six\n\n\n\n\n\nclass TestTestUtils(testutils.BaseTestCase):\n\n  \"\"\"Let's get meta.\"\"\"\n\n\n\n  def testNoCheckOnException(self):\n\n    with self.assertRaises(ValueError):\n\n      with self.assertOutputMatches(stdout='blah'):\n\n        raise ValueError()\n\n\n\n  def testCheckStdoutOrStderrNone(self):\n\n    with six.assertRaisesRegex(self, AssertionError, 'stdout:'):\n\n      with self.assertOutputMatches(stdout=None):\n\n        print('blah')\n\n\n\n    with six.assertRaisesRegex(self, AssertionError, 'stderr:'):\n\n      with self.assertOutputMatches(stderr=None):\n\n        print('blah', file=sys.stderr)\n\n\n\n    with six.assertRaisesRegex(self, AssertionError, 'stderr:'):\n\n      with self.assertOutputMatches(stdout='apple', stderr=None):\n\n        print('apple')\n\n        print('blah', file=sys.stderr)\n\n\n\n  def testCorrectOrderingOfAssertRaises(self):\n\n    # Check to make sure FireExit tests are correct.\n\n    with self.assertOutputMatches(stdout='Yep.*first.*second'):\n\n      with self.assertRaises(ValueError):\n\n        print('Yep, this is the first line.\\nThis is the second.')\n\n        raise ValueError()\n\n\n\n\n\nif __name__ == '__main__':\n\n  testutils.main()\n", "# Copyright (C) 2018 Google Inc.\n\n#\n\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n\n# you may not use this file except in compliance with the License.\n\n# You may obtain a copy of the License at\n\n#\n\n# http://www.apache.org/licenses/LICENSE-2.0\n\n#\n\n# Unless required by applicable law or agreed to in writing, software\n\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n\n# See the License for the specific language governing permissions and\n\n# limitations under the License.\n\n\n\n\"\"\"Python Fire is a library for creating CLIs from absolutely any Python object.\n\n\n\nYou can call Fire on any Python object:\n\nfunctions, classes, modules, objects, dictionaries, lists, tuples, etc.\n\nThey all work!\n\n\n\nPython Fire turns any Python object into a command line interface.\n\nSimply call the Fire function as your main method to create a CLI.\n\n\n\nWhen using Fire to build a CLI, your main method includes a call to Fire. Eg:\n\n\n\ndef main(argv):\n\n  fire.Fire(Component)\n\n\n\nA Fire CLI command is run by consuming the arguments in the command in order to\n\naccess a member of current component, call the current component (if it's a\n\nfunction), or instantiate the current component (if it's a class). The target\n\ncomponent begins as Component, and at each operation the component becomes the\n\nresult of the preceding operation.\n\n\n\nFor example \"command fn arg1 arg2\" might access the \"fn\" property of the initial\n\ntarget component, and then call that function with arguments 'arg1' and 'arg2'.\n\nAdditional examples are available in the examples directory.\n\n\n\nFire Flags, common to all Fire CLIs, must go after a separating \"--\". For\n\nexample, to get help for a command you might run: `command -- --help`.\n\n\n\nThe available flags for all Fire CLIs are:\n\n  -v --verbose: Include private members in help and usage information.\n\n  -h --help: Provide help and usage information for the command.\n\n  -i --interactive: Drop into a Python REPL after running the command.\n\n  --completion: Write the Bash completion script for the tool to stdout.\n\n  --completion fish: Write the Fish completion script for the tool to stdout.\n\n  --separator SEPARATOR: Use SEPARATOR in place of the default separator, '-'.\n\n  --trace: Get the Fire Trace for the command.\n\n\"\"\"\n\n\n\nfrom __future__ import absolute_import\n\nfrom __future__ import division\n\nfrom __future__ import print_function\n\n\n\nimport inspect\n\nimport json\n\nimport os\n\nimport pipes\n\nimport re\n\nimport shlex\n\nimport sys\n\nimport types\n\n\n\nfrom fire import completion\n\nfrom fire import decorators\n\nfrom fire import formatting\n\nfrom fire import helptext\n\nfrom fire import inspectutils\n\nfrom fire import interact\n\nfrom fire import parser\n\nfrom fire import trace\n\nfrom fire import value_types\n\nfrom fire.console import console_io\n\nimport six\n\n\n\nif six.PY34:\n\n  import asyncio  # pylint: disable=import-error,g-import-not-at-top  # pytype: disable=import-error\n\n\n\n\n\ndef Fire(component=None, command=None, name=None):\n\n  \"\"\"This function, Fire, is the main entrypoint for Python Fire.\n\n\n\n  Executes a command either from the `command` argument or from sys.argv by\n\n  recursively traversing the target object `component`'s members consuming\n\n  arguments, evaluating functions, and instantiating classes as it goes.\n\n\n\n  When building a CLI with Fire, your main method should call this function.\n\n\n\n  Args:\n\n    component: The initial target component.\n\n    command: Optional. If supplied, this is the command executed. If not\n\n        supplied, then the command is taken from sys.argv instead. This can be\n\n        a string or a list of strings; a list of strings is preferred.\n\n    name: Optional. The name of the command as entered at the command line.\n\n        Used in interactive mode and for generating the completion script.\n\n  Returns:\n\n    The result of executing the Fire command. Execution begins with the initial\n\n    target component. The component is updated by using the command arguments\n\n    to either access a member of the current component, call the current\n\n    component (if it's a function), or instantiate the current component (if\n\n    it's a class). When all arguments are consumed and there's no function left\n\n    to call or class left to instantiate, the resulting current component is\n\n    the final result.\n\n  Raises:\n\n    ValueError: If the command argument is supplied, but not a string or a\n\n        sequence of arguments.\n\n    FireExit: When Fire encounters a FireError, Fire will raise a FireExit with\n\n        code 2. When used with the help or trace flags, Fire will raise a\n\n        FireExit with code 0 if successful.\n\n  \"\"\"\n\n  name = name or os.path.basename(sys.argv[0])\n\n\n\n  # Get args as a list.\n\n  if isinstance(command, six.string_types):\n\n    args = shlex.split(command)\n\n  elif isinstance(command, (list, tuple)):\n\n    args = command\n\n  elif command is None:\n\n    # Use the command line args by default if no command is specified.\n\n    args = sys.argv[1:]\n\n  else:\n\n    raise ValueError('The command argument must be a string or a sequence of '\n\n                     'arguments.')\n\n\n\n  args, flag_args = parser.SeparateFlagArgs(args)\n\n\n\n  argparser = parser.CreateParser()\n\n  parsed_flag_args, unused_args = argparser.parse_known_args(flag_args)\n\n\n\n  context = {}\n\n  if parsed_flag_args.interactive or component is None:\n\n    # Determine the calling context.\n\n    caller = inspect.stack()[1]\n\n    caller_frame = caller[0]\n\n    caller_globals = caller_frame.f_globals\n\n    caller_locals = caller_frame.f_locals\n\n    context.update(caller_globals)\n\n    context.update(caller_locals)\n\n\n\n  component_trace = _Fire(component, args, parsed_flag_args, context, name)\n\n\n\n  if component_trace.HasError():\n\n    _DisplayError(component_trace)\n\n    raise FireExit(2, component_trace)\n\n  if component_trace.show_trace and component_trace.show_help:\n\n    output = ['Fire trace:\\n{trace}\\n'.format(trace=component_trace)]\n\n    result = component_trace.GetResult()\n\n    help_text = helptext.HelpText(\n\n        result, trace=component_trace, verbose=component_trace.verbose)\n\n    output.append(help_text)\n\n    Display(output, out=sys.stderr)\n\n    raise FireExit(0, component_trace)\n\n  if component_trace.show_trace:\n\n    output = ['Fire trace:\\n{trace}'.format(trace=component_trace)]\n\n    Display(output, out=sys.stderr)\n\n    raise FireExit(0, component_trace)\n\n  if component_trace.show_help:\n\n    result = component_trace.GetResult()\n\n    help_text = helptext.HelpText(\n\n        result, trace=component_trace, verbose=component_trace.verbose)\n\n    output = [help_text]\n\n    Display(output, out=sys.stderr)\n\n    raise FireExit(0, component_trace)\n\n\n\n  # The command succeeded normally; print the result.\n\n  _PrintResult(component_trace, verbose=component_trace.verbose)\n\n  result = component_trace.GetResult()\n\n  return result\n\n\n\n\n\ndef Display(lines, out):\n\n  text = '\\n'.join(lines) + '\\n'\n\n  console_io.More(text, out=out)\n\n\n\n\n\ndef CompletionScript(name, component, shell):\n\n  \"\"\"Returns the text of the completion script for a Fire CLI.\"\"\"\n\n  return completion.Script(name, component, shell=shell)\n\n\n\n\n\nclass FireError(Exception):\n\n  \"\"\"Exception used by Fire when a Fire command cannot be executed.\n\n\n\n  These exceptions are not raised by the Fire function, but rather are caught\n\n  and added to the FireTrace.\n\n  \"\"\"\n\n\n\n\n\nclass FireExit(SystemExit):  # pylint: disable=g-bad-exception-name\n\n  \"\"\"An exception raised by Fire to the client in the case of a FireError.\n\n\n\n  The trace of the Fire program is available on the `trace` property.\n\n\n\n  This exception inherits from SystemExit, so clients may explicitly catch it\n\n  with `except SystemExit` or `except FireExit`. If not caught, this exception\n\n  will cause the client program to exit without a stacktrace.\n\n  \"\"\"\n\n\n\n  def __init__(self, code, component_trace):\n\n    \"\"\"Constructs a FireExit exception.\n\n\n\n    Args:\n\n      code: (int) Exit code for the Fire CLI.\n\n      component_trace: (FireTrace) The trace for the Fire command.\n\n    \"\"\"\n\n    super(FireExit, self).__init__(code)\n\n    self.trace = component_trace\n\n\n\n\n\ndef _IsHelpShortcut(component_trace, remaining_args):\n\n  \"\"\"Determines if the user is trying to access help without '--' separator.\n\n\n\n  For example, mycmd.py --help instead of mycmd.py -- --help.\n\n\n\n  Args:\n\n    component_trace: (FireTrace) The trace for the Fire command.\n\n    remaining_args: List of remaining args that haven't been consumed yet.\n\n  Returns:\n\n    True if help is requested, False otherwise.\n\n  \"\"\"\n\n  show_help = False\n\n  if remaining_args:\n\n    target = remaining_args[0]\n\n    if target in ('-h', '--help'):\n\n      # Check if --help would be consumed as a keyword argument, or is a member.\n\n      component = component_trace.GetResult()\n\n      if inspect.isclass(component) or inspect.isroutine(component):\n\n        fn_spec = inspectutils.GetFullArgSpec(component)\n\n        _, remaining_kwargs, _ = _ParseKeywordArgs(remaining_args, fn_spec)\n\n        show_help = target in remaining_kwargs\n\n      else:\n\n        members = dict(inspect.getmembers(component))\n\n        show_help = target not in members\n\n\n\n  if show_help:\n\n    component_trace.show_help = True\n\n    command = '{cmd} -- --help'.format(cmd=component_trace.GetCommand())\n\n    print('INFO: Showing help with the command {cmd}.\\n'.format(\n\n        cmd=pipes.quote(command)), file=sys.stderr)\n\n  return show_help\n\n\n\n\n\ndef _PrintResult(component_trace, verbose=False):\n\n  \"\"\"Prints the result of the Fire call to stdout in a human readable way.\"\"\"\n\n  # TODO(dbieber): Design human readable deserializable serialization method\n\n  # and move serialization to its own module.\n\n  result = component_trace.GetResult()\n\n\n\n  if value_types.HasCustomStr(result):\n\n    # If the object has a custom __str__ method, rather than one inherited from\n\n    # object, then we use that to serialize the object.\n\n    print(str(result))\n\n    return\n\n\n\n  if isinstance(result, (list, set, frozenset, types.GeneratorType)):\n\n    for i in result:\n\n      print(_OneLineResult(i))\n\n  elif inspect.isgeneratorfunction(result):\n\n    raise NotImplementedError\n\n  elif isinstance(result, dict) and value_types.IsSimpleGroup(result):\n\n    print(_DictAsString(result, verbose))\n\n  elif isinstance(result, tuple):\n\n    print(_OneLineResult(result))\n\n  elif isinstance(result, value_types.VALUE_TYPES):\n\n    if result is not None:\n\n      print(result)\n\n  else:\n\n    help_text = helptext.HelpText(\n\n        result, trace=component_trace, verbose=verbose)\n\n    output = [help_text]\n\n    Display(output, out=sys.stdout)\n\n\n\n\n\ndef _DisplayError(component_trace):\n\n  \"\"\"Prints the Fire trace and the error to stdout.\"\"\"\n\n  result = component_trace.GetResult()\n\n\n\n  output = []\n\n  show_help = False\n\n  for help_flag in ('-h', '--help'):\n\n    if help_flag in component_trace.elements[-1].args:\n\n      show_help = True\n\n\n\n  if show_help:\n\n    command = '{cmd} -- --help'.format(cmd=component_trace.GetCommand())\n\n    print('INFO: Showing help with the command {cmd}.\\n'.format(\n\n        cmd=pipes.quote(command)), file=sys.stderr)\n\n    help_text = helptext.HelpText(result, trace=component_trace,\n\n                                  verbose=component_trace.verbose)\n\n    output.append(help_text)\n\n    Display(output, out=sys.stderr)\n\n  else:\n\n    print(formatting.Error('ERROR: ')\n\n          + component_trace.elements[-1].ErrorAsStr(),\n\n          file=sys.stderr)\n\n    error_text = helptext.UsageText(result, trace=component_trace,\n\n                                    verbose=component_trace.verbose)\n\n    print(error_text, file=sys.stderr)\n\n\n\n\n\ndef _DictAsString(result, verbose=False):\n\n  \"\"\"Returns a dict as a string.\n\n\n\n  Args:\n\n    result: The dict to convert to a string\n\n    verbose: Whether to include 'hidden' members, those keys starting with _.\n\n  Returns:\n\n    A string representing the dict\n\n  \"\"\"\n\n\n\n  # We need to do 2 iterations over the items in the result dict\n\n  # 1) Getting visible items and the longest key for output formatting\n\n  # 2) Actually construct the output lines\n\n  class_attrs = inspectutils.GetClassAttrsDict(result)\n\n  result_visible = {\n\n      key: value for key, value in result.items()\n\n      if completion.MemberVisible(result, key, value,\n\n                                  class_attrs=class_attrs, verbose=verbose)\n\n  }\n\n\n\n  if not result_visible:\n\n    return '{}'\n\n\n\n  longest_key = max(len(str(key)) for key in result_visible.keys())\n\n  format_string = '{{key:{padding}s}} {{value}}'.format(padding=longest_key + 1)\n\n\n\n  lines = []\n\n  for key, value in result.items():\n\n    if completion.MemberVisible(result, key, value, class_attrs=class_attrs,\n\n                                verbose=verbose):\n\n      line = format_string.format(key=str(key) + ':',\n\n                                  value=_OneLineResult(value))\n\n      lines.append(line)\n\n  return '\\n'.join(lines)\n\n\n\n\n\ndef _OneLineResult(result):\n\n  \"\"\"Returns result serialized to a single line string.\"\"\"\n\n  # TODO(dbieber): Ensure line is fewer than eg 120 characters.\n\n  if isinstance(result, six.string_types):\n\n    return str(result).replace('\\n', ' ')\n\n\n\n  # TODO(dbieber): Show a small amount of usage information about the function\n\n  # or module if it fits cleanly on the line.\n\n  if inspect.isfunction(result):\n\n    return '<function {name}>'.format(name=result.__name__)\n\n\n\n  if inspect.ismodule(result):\n\n    return '<module {name}>'.format(name=result.__name__)\n\n\n\n  try:\n\n    # Don't force conversion to ascii.\n\n    return json.dumps(result, ensure_ascii=False)\n\n  except (TypeError, ValueError):\n\n    return str(result).replace('\\n', ' ')\n\n\n\n\n\ndef _Fire(component, args, parsed_flag_args, context, name=None):\n\n  \"\"\"Execute a Fire command on a target component using the args supplied.\n\n\n\n  Arguments that come after a final isolated '--' are treated as Flags, eg for\n\n  interactive mode or completion script generation.\n\n\n\n  Other arguments are consumed by the execution of the Fire command, eg in the\n\n  traversal of the members of the component, or in calling a function or\n\n  instantiating a class found during the traversal.\n\n\n\n  The steps performed by this method are:\n\n\n\n  1. Parse any Flag args (the args after the final --)\n\n\n\n  2. Start with component as the current component.\n\n  2a. If the current component is a class, instantiate it using args from args.\n\n  2b. If the component is a routine, call it using args from args.\n\n  2c. If the component is a sequence, index into it using an arg from\n\n      args.\n\n  2d. If possible, access a member from the component using an arg from args.\n\n  2e. If the component is a callable object, call it using args from args.\n\n  2f. Repeat 2a-2e until no args remain.\n\n  Note: Only the first applicable rule from 2a-2e is applied in each iteration.\n\n  After each iteration of step 2a-2e, the current component is updated to be the\n\n  result of the applied rule.\n\n\n\n  3a. Embed into ipython REPL if interactive mode is selected.\n\n  3b. Generate a completion script if that flag is provided.\n\n\n\n  In step 2, arguments will only ever be consumed up to a separator; a single\n\n  step will never consume arguments from both sides of a separator.\n\n  The separator defaults to a hyphen (-), and can be overwritten with the\n\n  --separator Fire argument.\n\n\n\n  Args:\n\n    component: The target component for Fire.\n\n    args: A list of args to consume in Firing on the component, usually from\n\n        the command line.\n\n    parsed_flag_args: The values of the flag args (e.g. --verbose, --separator)\n\n        that are part of every Fire CLI.\n\n    context: A dict with the local and global variables available at the call\n\n        to Fire.\n\n    name: Optional. The name of the command. Used in interactive mode and in\n\n        the tab completion script.\n\n  Returns:\n\n    FireTrace of components starting with component, tracing Fire's execution\n\n        path as it consumes args.\n\n  Raises:\n\n    ValueError: If there are arguments that cannot be consumed.\n\n    ValueError: If --completion is specified but no name available.\n\n  \"\"\"\n\n  verbose = parsed_flag_args.verbose\n\n  interactive = parsed_flag_args.interactive\n\n  separator = parsed_flag_args.separator\n\n  show_completion = parsed_flag_args.completion\n\n  show_help = parsed_flag_args.help\n\n  show_trace = parsed_flag_args.trace\n\n\n\n  # component can be a module, class, routine, object, etc.\n\n  if component is None:\n\n    component = context\n\n\n\n  initial_component = component\n\n  component_trace = trace.FireTrace(\n\n      initial_component=initial_component, name=name, separator=separator,\n\n      verbose=verbose, show_help=show_help, show_trace=show_trace)\n\n\n\n  instance = None\n\n  remaining_args = args\n\n  while True:\n\n    last_component = component\n\n    initial_args = remaining_args\n\n\n\n    if not remaining_args and (show_help or interactive or show_trace\n\n                               or show_completion is not None):\n\n      # Don't initialize the final class or call the final function unless\n\n      # there's a separator after it, and instead process the current component.\n\n      break\n\n\n\n    if _IsHelpShortcut(component_trace, remaining_args):\n\n      remaining_args = []\n\n      break\n\n\n\n    saved_args = []\n\n    used_separator = False\n\n    if separator in remaining_args:\n\n      # For the current component, only use arguments up to the separator.\n\n      separator_index = remaining_args.index(separator)\n\n      saved_args = remaining_args[separator_index + 1:]\n\n      remaining_args = remaining_args[:separator_index]\n\n      used_separator = True\n\n    assert separator not in remaining_args\n\n\n\n    handled = False\n\n    candidate_errors = []\n\n\n\n    is_callable = inspect.isclass(component) or inspect.isroutine(component)\n\n    is_callable_object = callable(component) and not is_callable\n\n    is_sequence = isinstance(component, (list, tuple))\n\n    is_map = isinstance(component, dict) or inspectutils.IsNamedTuple(component)\n\n\n\n    if not handled and is_callable:\n\n      # The component is a class or a routine; we'll try to initialize it or\n\n      # call it.\n\n      is_class = inspect.isclass(component)\n\n\n\n      try:\n\n        component, remaining_args = _CallAndUpdateTrace(\n\n            component,\n\n            remaining_args,\n\n            component_trace,\n\n            treatment='class' if is_class else 'routine',\n\n            target=component.__name__)\n\n        handled = True\n\n      except FireError as error:\n\n        candidate_errors.append((error, initial_args))\n\n\n\n      if handled and last_component is initial_component:\n\n        # If the initial component is a class, keep an instance for use with -i.\n\n        instance = component\n\n\n\n    if not handled and is_sequence and remaining_args:\n\n      # The component is a tuple or list; we'll try to access a member.\n\n      arg = remaining_args[0]\n\n      try:\n\n        index = int(arg)\n\n        component = component[index]\n\n        handled = True\n\n      except (ValueError, IndexError):\n\n        error = FireError(\n\n            'Unable to index into component with argument:', arg)\n\n        candidate_errors.append((error, initial_args))\n\n\n\n      if handled:\n\n        remaining_args = remaining_args[1:]\n\n        filename = None\n\n        lineno = None\n\n        component_trace.AddAccessedProperty(\n\n            component, index, [arg], filename, lineno)\n\n\n\n    if not handled and is_map and remaining_args:\n\n      # The component is a dict or other key-value map; try to access a member.\n\n      target = remaining_args[0]\n\n\n\n      # Treat namedtuples as dicts when handling them as a map.\n\n      if inspectutils.IsNamedTuple(component):\n\n        component_dict = component._asdict()  # pytype: disable=attribute-error\n\n      else:\n\n        component_dict = component\n\n\n\n      if target in component_dict:\n\n        component = component_dict[target]\n\n        handled = True\n\n      elif target.replace('-', '_') in component_dict:\n\n        component = component_dict[target.replace('-', '_')]\n\n        handled = True\n\n      else:\n\n        # The target isn't present in the dict as a string key, but maybe it is\n\n        # a key as another type.\n\n        # TODO(dbieber): Consider alternatives for accessing non-string keys.\n\n        for key, value in component_dict.items():\n\n          if target == str(key):\n\n            component = value\n\n            handled = True\n\n            break\n\n\n\n      if handled:\n\n        remaining_args = remaining_args[1:]\n\n        filename = None\n\n        lineno = None\n\n        component_trace.AddAccessedProperty(\n\n            component, target, [target], filename, lineno)\n\n      else:\n\n        error = FireError('Cannot find key:', target)\n\n        candidate_errors.append((error, initial_args))\n\n\n\n    if not handled and remaining_args:\n\n      # Object handler. We'll try to access a member of the component.\n\n      try:\n\n        target = remaining_args[0]\n\n\n\n        component, consumed_args, remaining_args = _GetMember(\n\n            component, remaining_args)\n\n        handled = True\n\n\n\n        filename, lineno = inspectutils.GetFileAndLine(component)\n\n\n\n        component_trace.AddAccessedProperty(\n\n            component, target, consumed_args, filename, lineno)\n\n\n\n      except FireError as error:\n\n        # Couldn't access member.\n\n        candidate_errors.append((error, initial_args))\n\n\n\n    if not handled and is_callable_object:\n\n      # The component is a callable object; we'll try to call it.\n\n      try:\n\n        component, remaining_args = _CallAndUpdateTrace(\n\n            component,\n\n            remaining_args,\n\n            component_trace,\n\n            treatment='callable')\n\n        handled = True\n\n      except FireError as error:\n\n        candidate_errors.append((error, initial_args))\n\n\n\n    if not handled and candidate_errors:\n\n      error, initial_args = candidate_errors[0]\n\n      component_trace.AddError(error, initial_args)\n\n      return component_trace\n\n\n\n    if used_separator:\n\n      # Add back in the arguments from after the separator.\n\n      if remaining_args:\n\n        remaining_args = remaining_args + [separator] + saved_args\n\n      elif (inspect.isclass(last_component)\n\n            or inspect.isroutine(last_component)):\n\n        remaining_args = saved_args\n\n        component_trace.AddSeparator()\n\n      elif component is not last_component:\n\n        remaining_args = [separator] + saved_args\n\n      else:\n\n        # It was an unnecessary separator.\n\n        remaining_args = saved_args\n\n\n\n    if component is last_component and remaining_args == initial_args:\n\n      # We're making no progress.\n\n      break\n\n\n\n  if remaining_args:\n\n    component_trace.AddError(\n\n        FireError('Could not consume arguments:', remaining_args),\n\n        initial_args)\n\n    return component_trace\n\n\n\n  if show_completion is not None:\n\n    if name is None:\n\n      raise ValueError('Cannot make completion script without command name')\n\n    script = CompletionScript(name, initial_component, shell=show_completion)\n\n    component_trace.AddCompletionScript(script)\n\n\n\n  if interactive:\n\n    variables = context.copy()\n\n\n\n    if name is not None:\n\n      variables[name] = initial_component\n\n    variables['component'] = initial_component\n\n    variables['result'] = component\n\n    variables['trace'] = component_trace\n\n\n\n    if instance is not None:\n\n      variables['self'] = instance\n\n\n\n    interact.Embed(variables, verbose)\n\n\n\n    component_trace.AddInteractiveMode()\n\n\n\n  return component_trace\n\n\n\n\n\ndef _GetMember(component, args):\n\n  \"\"\"Returns a subcomponent of component by consuming an arg from args.\n\n\n\n  Given a starting component and args, this function gets a member from that\n\n  component, consuming one arg in the process.\n\n\n\n  Args:\n\n    component: The component from which to get a member.\n\n    args: Args from which to consume in the search for the next component.\n\n  Returns:\n\n    component: The component that was found by consuming an arg.\n\n    consumed_args: The args that were consumed by getting this member.\n\n    remaining_args: The remaining args that haven't been consumed yet.\n\n  Raises:\n\n    FireError: If we cannot consume an argument to get a member.\n\n  \"\"\"\n\n  members = dir(component)\n\n  arg = args[0]\n\n  arg_names = [\n\n      arg,\n\n      arg.replace('-', '_'),  # treat '-' as '_'.\n\n  ]\n\n\n\n  for arg_name in arg_names:\n\n    if arg_name in members:\n\n      return getattr(component, arg_name), [arg], args[1:]\n\n\n\n  raise FireError('Could not consume arg:', arg)\n\n\n\n\n\ndef _CallAndUpdateTrace(component, args, component_trace, treatment='class',\n\n                        target=None):\n\n  \"\"\"Call the component by consuming args from args, and update the FireTrace.\n\n\n\n  The component could be a class, a routine, or a callable object. This function\n\n  calls the component and adds the appropriate action to component_trace.\n\n\n\n  Args:\n\n    component: The component to call\n\n    args: Args for calling the component\n\n    component_trace: FireTrace object that contains action trace\n\n    treatment: Type of treatment used. Indicating whether we treat the component\n\n        as a class, a routine, or a callable.\n\n    target: Target in FireTrace element, default is None. If the value is None,\n\n        the component itself will be used as target.\n\n  Returns:\n\n    component: The object that is the result of the callable call.\n\n    remaining_args: The remaining args that haven't been consumed yet.\n\n  \"\"\"\n\n  if not target:\n\n    target = component\n\n  filename, lineno = inspectutils.GetFileAndLine(component)\n\n  metadata = decorators.GetMetadata(component)\n\n  fn = component.__call__ if treatment == 'callable' else component\n\n  parse = _MakeParseFn(fn, metadata)\n\n  (varargs, kwargs), consumed_args, remaining_args, capacity = parse(args)\n\n\n\n  # Call the function.\n\n  if inspectutils.IsCoroutineFunction(fn):\n\n    loop = asyncio.get_event_loop()\n\n    component = loop.run_until_complete(fn(*varargs, **kwargs))\n\n  else:\n\n    component = fn(*varargs, **kwargs)\n\n\n\n  if treatment == 'class':\n\n    action = trace.INSTANTIATED_CLASS\n\n  elif treatment == 'routine':\n\n    action = trace.CALLED_ROUTINE\n\n  else:\n\n    action = trace.CALLED_CALLABLE\n\n  component_trace.AddCalledComponent(\n\n      component, target, consumed_args, filename, lineno, capacity,\n\n      action=action)\n\n\n\n  return component, remaining_args\n\n\n\n\n\ndef _MakeParseFn(fn, metadata):\n\n  \"\"\"Creates a parse function for fn.\n\n\n\n  Args:\n\n    fn: The function or class to create the parse function for.\n\n    metadata: Additional metadata about the component the parse function is for.\n\n  Returns:\n\n    A parse function for fn. The parse function accepts a list of arguments\n\n    and returns (varargs, kwargs), remaining_args. The original function fn\n\n    can then be called with fn(*varargs, **kwargs). The remaining_args are\n\n    the leftover args from the arguments to the parse function.\n\n  \"\"\"\n\n  fn_spec = inspectutils.GetFullArgSpec(fn)\n\n\n\n  # Note: num_required_args is the number of positional arguments without\n\n  # default values. All of these arguments are required.\n\n  num_required_args = len(fn_spec.args) - len(fn_spec.defaults)\n\n  required_kwonly = set(fn_spec.kwonlyargs) - set(fn_spec.kwonlydefaults)\n\n\n\n  def _ParseFn(args):\n\n    \"\"\"Parses the list of `args` into (varargs, kwargs), remaining_args.\"\"\"\n\n    kwargs, remaining_kwargs, remaining_args = _ParseKeywordArgs(args, fn_spec)\n\n\n\n    # Note: _ParseArgs modifies kwargs.\n\n    parsed_args, kwargs, remaining_args, capacity = _ParseArgs(\n\n        fn_spec.args, fn_spec.defaults, num_required_args, kwargs,\n\n        remaining_args, metadata)\n\n\n\n    if fn_spec.varargs or fn_spec.varkw:\n\n      # If we're allowed *varargs or **kwargs, there's always capacity.\n\n      capacity = True\n\n\n\n    extra_kw = set(kwargs) - set(fn_spec.kwonlyargs)\n\n    if fn_spec.varkw is None and extra_kw:\n\n      raise FireError('Unexpected kwargs present:', extra_kw)\n\n\n\n    missing_kwonly = set(required_kwonly) - set(kwargs)\n\n    if missing_kwonly:\n\n      raise FireError('Missing required flags:', missing_kwonly)\n\n\n\n    # If we accept *varargs, then use all remaining arguments for *varargs.\n\n    if fn_spec.varargs is not None:\n\n      varargs, remaining_args = remaining_args, []\n\n    else:\n\n      varargs = []\n\n\n\n    for index, value in enumerate(varargs):\n\n      varargs[index] = _ParseValue(value, None, None, metadata)\n\n\n\n    varargs = parsed_args + varargs\n\n    remaining_args += remaining_kwargs\n\n\n\n    consumed_args = args[:len(args) - len(remaining_args)]\n\n    return (varargs, kwargs), consumed_args, remaining_args, capacity\n\n\n\n  return _ParseFn\n\n\n\n\n\ndef _ParseArgs(fn_args, fn_defaults, num_required_args, kwargs,\n\n               remaining_args, metadata):\n\n  \"\"\"Parses the positional and named arguments from the available supplied args.\n\n\n\n  Modifies kwargs, removing args as they are used.\n\n\n\n  Args:\n\n    fn_args: A list of argument names that the target function accepts,\n\n        including positional and named arguments, but not the varargs or kwargs\n\n        names.\n\n    fn_defaults: A list of the default values in the function argspec.\n\n    num_required_args: The number of required arguments from the function's\n\n        argspec. This is the number of arguments without a default value.\n\n    kwargs: Dict with named command line arguments and their values.\n\n    remaining_args: The remaining command line arguments, which may still be\n\n        used as positional arguments.\n\n    metadata: Metadata about the function, typically from Fire decorators.\n\n  Returns:\n\n    parsed_args: A list of values to be used as positional arguments for calling\n\n        the target function.\n\n    kwargs: The input dict kwargs modified with the used kwargs removed.\n\n    remaining_args: A list of the supplied args that have not been used yet.\n\n    capacity: Whether the call could have taken args in place of defaults.\n\n  Raises:\n\n    FireError: If additional positional arguments are expected, but none are\n\n        available.\n\n  \"\"\"\n\n  accepts_positional_args = metadata.get(decorators.ACCEPTS_POSITIONAL_ARGS)\n\n  capacity = False  # If we see a default get used, we'll set capacity to True\n\n\n\n  # Select unnamed args.\n\n  parsed_args = []\n\n  for index, arg in enumerate(fn_args):\n\n    value = kwargs.pop(arg, None)\n\n    if value is not None:  # A value is specified at the command line.\n\n      value = _ParseValue(value, index, arg, metadata)\n\n      parsed_args.append(value)\n\n    else:  # No value has been explicitly specified.\n\n      if remaining_args and accepts_positional_args:\n\n        # Use a positional arg.\n\n        value = remaining_args.pop(0)\n\n        value = _ParseValue(value, index, arg, metadata)\n\n        parsed_args.append(value)\n\n      elif index < num_required_args:\n\n        raise FireError(\n\n            'The function received no value for the required argument:', arg)\n\n      else:\n\n        # We're past the args for which there's no default value.\n\n        # There's a default value for this arg.\n\n        capacity = True\n\n        default_index = index - num_required_args  # index into the defaults.\n\n        parsed_args.append(fn_defaults[default_index])\n\n\n\n  for key, value in kwargs.items():\n\n    kwargs[key] = _ParseValue(value, None, key, metadata)\n\n\n\n  return parsed_args, kwargs, remaining_args, capacity\n\n\n\n\n\ndef _ParseKeywordArgs(args, fn_spec):\n\n  \"\"\"Parses the supplied arguments for keyword arguments.\n\n\n\n  Given a list of arguments, finds occurrences of --name value, and uses 'name'\n\n  as the keyword and 'value' as the value. Constructs and returns a dictionary\n\n  of these keyword arguments, and returns a list of the remaining arguments.\n\n\n\n  Only if fn_keywords is None, this only finds argument names used by the\n\n  function, specified through fn_args.\n\n\n\n  This returns the values of the args as strings. They are later processed by\n\n  _ParseArgs, which converts them to the appropriate type.\n\n\n\n  Args:\n\n    args: A list of arguments.\n\n    fn_spec: The inspectutils.FullArgSpec describing the given callable.\n\n  Returns:\n\n    kwargs: A dictionary mapping keywords to values.\n\n    remaining_kwargs: A list of the unused kwargs from the original args.\n\n    remaining_args: A list of the unused arguments from the original args.\n\n  Raises:\n\n    FireError: If a single-character flag is passed that could refer to multiple\n\n        possible args.\n\n  \"\"\"\n\n  kwargs = {}\n\n  remaining_kwargs = []\n\n  remaining_args = []\n\n  fn_keywords = fn_spec.varkw\n\n  fn_args = fn_spec.args + fn_spec.kwonlyargs\n\n\n\n  if not args:\n\n    return kwargs, remaining_kwargs, remaining_args\n\n\n\n  skip_argument = False\n\n\n\n  for index, argument in enumerate(args):\n\n    if skip_argument:\n\n      skip_argument = False\n\n      continue\n\n\n\n    if _IsFlag(argument):\n\n      # This is a named argument. We get its value from this arg or the next.\n\n\n\n      # Terminology:\n\n      # argument: A full token from the command line, e.g. '--alpha=10'\n\n      # stripped_argument: An argument without leading hyphens.\n\n      # key: The contents of the stripped argument up to the first equal sign.\n\n      # \"shortcut flag\": refers to an argument where the key is just the first\n\n      #   letter of a longer keyword.\n\n      # keyword: The Python function argument being set by this argument.\n\n      # value: The unparsed value for that Python function argument.\n\n      contains_equals = '=' in argument\n\n      stripped_argument = argument.lstrip('-')\n\n      if contains_equals:\n\n        key, value = stripped_argument.split('=', 1)\n\n      else:\n\n        key = stripped_argument\n\n\n\n      key = key.replace('-', '_')\n\n      is_bool_syntax = (not contains_equals and\n\n                        (index + 1 == len(args) or _IsFlag(args[index + 1])))\n\n\n\n      # Determine the keyword.\n\n      keyword = ''  # Indicates no valid keyword has been found yet.\n\n      if (key in fn_args\n\n          or (is_bool_syntax and key.startswith('no') and key[2:] in fn_args)\n\n          or fn_keywords):\n\n        keyword = key\n\n      elif len(key) == 1:\n\n        # This may be a shortcut flag.\n\n        matching_fn_args = [arg for arg in fn_args if arg[0] == key]\n\n        if len(matching_fn_args) == 1:\n\n          keyword = matching_fn_args[0]\n\n        elif len(matching_fn_args) > 1:\n\n          raise FireError(\"The argument '{}' is ambiguous as it could \"\n\n                          \"refer to any of the following arguments: {}\".format(\n\n                              argument, matching_fn_args))\n\n\n\n      # Determine the value.\n\n      if not keyword:\n\n        got_argument = False\n\n      elif contains_equals:\n\n        # Already got the value above.\n\n        got_argument = True\n\n      elif is_bool_syntax:\n\n        # There's no next arg or the next arg is a Flag, so we consider this\n\n        # flag to be a boolean.\n\n        got_argument = True\n\n        if keyword in fn_args:\n\n          value = 'True'\n\n        elif keyword.startswith('no'):\n\n          keyword = keyword[2:]\n\n          value = 'False'\n\n        else:\n\n          value = 'True'\n\n      else:\n\n        # The assert should pass. Otherwise either contains_equals or\n\n        # is_bool_syntax would have been True.\n\n        assert index + 1 < len(args)\n\n        value = args[index + 1]\n\n        got_argument = True\n\n\n\n      # In order for us to consume the argument as a keyword arg, we either:\n\n      # Need to be explicitly expecting the keyword, or we need to be\n\n      # accepting **kwargs.\n\n      skip_argument = not contains_equals and not is_bool_syntax\n\n      if got_argument:\n\n        kwargs[keyword] = value\n\n      else:\n\n        remaining_kwargs.append(argument)\n\n        if skip_argument:\n\n          remaining_kwargs.append(args[index + 1])\n\n    else:  # not _IsFlag(argument)\n\n      remaining_args.append(argument)\n\n\n\n  return kwargs, remaining_kwargs, remaining_args\n\n\n\n\n\ndef _IsFlag(argument):\n\n  \"\"\"Determines if the argument is a flag argument.\n\n\n\n  If it starts with a hyphen and isn't a negative number, it's a flag.\n\n\n\n  Args:\n\n    argument: A command line argument that may or may not be a flag.\n\n  Returns:\n\n    A boolean indicating whether the argument is a flag.\n\n  \"\"\"\n\n  return _IsSingleCharFlag(argument) or _IsMultiCharFlag(argument)\n\n\n\n\n\ndef _IsSingleCharFlag(argument):\n\n  \"\"\"Determines if the argument is a single char flag (e.g. '-a').\"\"\"\n\n  return re.match('^-[a-zA-Z]$', argument) or re.match('^-[a-zA-Z]=', argument)\n\n\n\n\n\ndef _IsMultiCharFlag(argument):\n\n  \"\"\"Determines if the argument is a multi char flag (e.g. '--alpha').\"\"\"\n\n  return argument.startswith('--') or re.match('^-[a-zA-Z]', argument)\n\n\n\n\n\ndef _ParseValue(value, index, arg, metadata):\n\n  \"\"\"Parses value, a string, into the appropriate type.\n\n\n\n  The function used to parse value is determined by the remaining arguments.\n\n\n\n  Args:\n\n    value: The string value to be parsed, typically a command line argument.\n\n    index: The index of the value in the function's argspec.\n\n    arg: The name of the argument the value is being parsed for.\n\n    metadata: Metadata about the function, typically from Fire decorators.\n\n  Returns:\n\n    value, parsed into the appropriate type for calling a function.\n\n  \"\"\"\n\n  parse_fn = parser.DefaultParseValue\n\n\n\n  # We check to see if any parse function from the fn metadata applies here.\n\n  parse_fns = metadata.get(decorators.FIRE_PARSE_FNS)\n\n  if parse_fns:\n\n    default = parse_fns['default']\n\n    positional = parse_fns['positional']\n\n    named = parse_fns['named']\n\n\n\n    if index is not None and 0 <= index < len(positional):\n\n      parse_fn = positional[index]\n\n    elif arg in named:\n\n      parse_fn = named[arg]\n\n    elif default is not None:\n\n      parse_fn = default\n\n\n\n  return parse_fn(value)\n", "# Copyright (C) 2018 Google Inc.\n\n#\n\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n\n# you may not use this file except in compliance with the License.\n\n# You may obtain a copy of the License at\n\n#\n\n# http://www.apache.org/licenses/LICENSE-2.0\n\n#\n\n# Unless required by applicable law or agreed to in writing, software\n\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n\n# See the License for the specific language governing permissions and\n\n# limitations under the License.\n\n\n\n\"\"\"Tests for the test_components module.\"\"\"\n\n\n\nfrom __future__ import absolute_import\n\nfrom __future__ import division\n\nfrom __future__ import print_function\n\n\n\nfrom fire import test_components as tc\n\nfrom fire import testutils\n\n\n\n\n\nclass TestComponentsTest(testutils.BaseTestCase):\n\n  \"\"\"Tests to verify that the test components are importable and okay.\"\"\"\n\n\n\n  def testTestComponents(self):\n\n    self.assertIsNotNone(tc.Empty)\n\n    self.assertIsNotNone(tc.OldStyleEmpty)\n\n\n\n  def testNonComparable(self):\n\n    with self.assertRaises(ValueError):\n\n      tc.NonComparable() != 2  # pylint: disable=expression-not-assigned\n\n    with self.assertRaises(ValueError):\n\n      tc.NonComparable() == 2  # pylint: disable=expression-not-assigned\n\n\n\n\n\nif __name__ == '__main__':\n\n  testutils.main()\n", "# Copyright (C) 2018 Google Inc.\n\n#\n\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n\n# you may not use this file except in compliance with the License.\n\n# You may obtain a copy of the License at\n\n#\n\n# http://www.apache.org/licenses/LICENSE-2.0\n\n#\n\n# Unless required by applicable law or agreed to in writing, software\n\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n\n# See the License for the specific language governing permissions and\n\n# limitations under the License.\n\n\n\n\"\"\"Tests for the helptext module.\"\"\"\n\n\n\nfrom __future__ import absolute_import\n\nfrom __future__ import division\n\nfrom __future__ import print_function\n\n\n\nimport os\n\nimport sys\n\nimport textwrap\n\n\n\nfrom fire import formatting\n\nfrom fire import helptext\n\nfrom fire import test_components as tc\n\nfrom fire import testutils\n\nfrom fire import trace\n\nimport six\n\n\n\n\n\nclass HelpTest(testutils.BaseTestCase):\n\n\n\n  def setUp(self):\n\n    super(HelpTest, self).setUp()\n\n    os.environ['ANSI_COLORS_DISABLED'] = '1'\n\n\n\n  def testHelpTextNoDefaults(self):\n\n    component = tc.NoDefaults\n\n    help_screen = helptext.HelpText(\n\n        component=component,\n\n        trace=trace.FireTrace(component, name='NoDefaults'))\n\n    self.assertIn('NAME\\n    NoDefaults', help_screen)\n\n    self.assertIn('SYNOPSIS\\n    NoDefaults', help_screen)\n\n    self.assertNotIn('DESCRIPTION', help_screen)\n\n    self.assertNotIn('NOTES', help_screen)\n\n\n\n  def testHelpTextNoDefaultsObject(self):\n\n    component = tc.NoDefaults()\n\n    help_screen = helptext.HelpText(\n\n        component=component,\n\n        trace=trace.FireTrace(component, name='NoDefaults'))\n\n    self.assertIn('NAME\\n    NoDefaults', help_screen)\n\n    self.assertIn('SYNOPSIS\\n    NoDefaults COMMAND', help_screen)\n\n    self.assertNotIn('DESCRIPTION', help_screen)\n\n    self.assertIn('COMMANDS\\n    COMMAND is one of the following:',\n\n                  help_screen)\n\n    self.assertIn('double', help_screen)\n\n    self.assertIn('triple', help_screen)\n\n    self.assertNotIn('NOTES', help_screen)\n\n\n\n  def testHelpTextFunction(self):\n\n    component = tc.NoDefaults().double\n\n    help_screen = helptext.HelpText(\n\n        component=component,\n\n        trace=trace.FireTrace(component, name='double'))\n\n    self.assertIn('NAME\\n    double', help_screen)\n\n    self.assertIn('SYNOPSIS\\n    double COUNT', help_screen)\n\n    self.assertNotIn('DESCRIPTION', help_screen)\n\n    self.assertIn('POSITIONAL ARGUMENTS\\n    COUNT', help_screen)\n\n    self.assertIn(\n\n        'NOTES\\n    You can also use flags syntax for POSITIONAL ARGUMENTS',\n\n        help_screen)\n\n\n\n  def testHelpTextFunctionWithDefaults(self):\n\n    component = tc.WithDefaults().triple\n\n    help_screen = helptext.HelpText(\n\n        component=component,\n\n        trace=trace.FireTrace(component, name='triple'))\n\n    self.assertIn('NAME\\n    triple', help_screen)\n\n    self.assertIn('SYNOPSIS\\n    triple <flags>', help_screen)\n\n    self.assertNotIn('DESCRIPTION', help_screen)\n\n    self.assertIn('FLAGS\\n    --count=COUNT\\n        Default: 0', help_screen)\n\n    self.assertNotIn('NOTES', help_screen)\n\n\n\n  def testHelpTextFunctionWithLongDefaults(self):\n\n    component = tc.WithDefaults().text\n\n    help_screen = helptext.HelpText(\n\n        component=component,\n\n        trace=trace.FireTrace(component, name='text'))\n\n    self.assertIn('NAME\\n    text', help_screen)\n\n    self.assertIn('SYNOPSIS\\n    text <flags>', help_screen)\n\n    self.assertNotIn('DESCRIPTION', help_screen)\n\n    self.assertIn(\n\n        'FLAGS\\n    --string=STRING\\n'\n\n        '        Default: \\'0001020304050607080910'\n\n        '1112131415161718192021222324252627282...',\n\n        help_screen)\n\n    self.assertNotIn('NOTES', help_screen)\n\n\n\n  def testHelpTextFunctionWithKwargs(self):\n\n    component = tc.fn_with_kwarg\n\n    help_screen = helptext.HelpText(\n\n        component=component,\n\n        trace=trace.FireTrace(component, name='text'))\n\n    self.assertIn('NAME\\n    text', help_screen)\n\n    self.assertIn('SYNOPSIS\\n    text ARG1 ARG2 <flags>', help_screen)\n\n    self.assertIn('DESCRIPTION\\n    Function with kwarg', help_screen)\n\n    self.assertIn(\n\n        'FLAGS\\n    --arg3\\n        Description of arg3.\\n    '\n\n        'Additional undocumented flags may also be accepted.',\n\n        help_screen)\n\n\n\n  def testHelpTextFunctionWithKwargsAndDefaults(self):\n\n    component = tc.fn_with_kwarg_and_defaults\n\n    help_screen = helptext.HelpText(\n\n        component=component,\n\n        trace=trace.FireTrace(component, name='text'))\n\n    self.assertIn('NAME\\n    text', help_screen)\n\n    self.assertIn('SYNOPSIS\\n    text ARG1 ARG2 <flags>', help_screen)\n\n    self.assertIn('DESCRIPTION\\n    Function with kwarg', help_screen)\n\n    self.assertIn(\n\n        'FLAGS\\n    --opt=OPT\\n        Default: True\\n'\n\n        '    The following flags are also accepted.'\n\n        '\\n    --arg3\\n        Description of arg3.\\n    '\n\n        'Additional undocumented flags may also be accepted.',\n\n        help_screen)\n\n\n\n  @testutils.skipIf(\n\n      sys.version_info[0:2] < (3, 5),\n\n      'Python < 3.5 does not support type hints.')\n\n  def testHelpTextFunctionWithDefaultsAndTypes(self):\n\n    component = (\n\n        tc.py3.WithDefaultsAndTypes().double)  # pytype: disable=module-attr\n\n    help_screen = helptext.HelpText(\n\n        component=component,\n\n        trace=trace.FireTrace(component, name='double'))\n\n    self.assertIn('NAME\\n    double', help_screen)\n\n    self.assertIn('SYNOPSIS\\n    double <flags>', help_screen)\n\n    self.assertIn('DESCRIPTION', help_screen)\n\n    self.assertIn(\n\n        'FLAGS\\n    --count=COUNT\\n        Type: float\\n        Default: 0',\n\n        help_screen)\n\n    self.assertNotIn('NOTES', help_screen)\n\n\n\n  @testutils.skipIf(\n\n      sys.version_info[0:2] < (3, 5),\n\n      'Python < 3.5 does not support type hints.')\n\n  def testHelpTextFunctionWithTypesAndDefaultNone(self):\n\n    component = (\n\n        tc.py3.WithDefaultsAndTypes().get_int)  # pytype: disable=module-attr\n\n    help_screen = helptext.HelpText(\n\n        component=component,\n\n        trace=trace.FireTrace(component, name='get_int'))\n\n    self.assertIn('NAME\\n    get_int', help_screen)\n\n    self.assertIn('SYNOPSIS\\n    get_int <flags>', help_screen)\n\n    self.assertNotIn('DESCRIPTION', help_screen)\n\n    self.assertIn(\n\n        'FLAGS\\n    --value=VALUE\\n'\n\n        '        Type: Optional[int]\\n        Default: None',\n\n        help_screen)\n\n    self.assertNotIn('NOTES', help_screen)\n\n\n\n  @testutils.skipIf(\n\n      sys.version_info[0:2] < (3, 5),\n\n      'Python < 3.5 does not support type hints.')\n\n  def testHelpTextFunctionWithTypes(self):\n\n    component = tc.py3.WithTypes().double  # pytype: disable=module-attr\n\n    help_screen = helptext.HelpText(\n\n        component=component,\n\n        trace=trace.FireTrace(component, name='double'))\n\n    self.assertIn('NAME\\n    double', help_screen)\n\n    self.assertIn('SYNOPSIS\\n    double COUNT', help_screen)\n\n    self.assertIn('DESCRIPTION', help_screen)\n\n    self.assertIn(\n\n        'POSITIONAL ARGUMENTS\\n    COUNT\\n        Type: float',\n\n        help_screen)\n\n    self.assertIn(\n\n        'NOTES\\n    You can also use flags syntax for POSITIONAL ARGUMENTS',\n\n        help_screen)\n\n\n\n  @testutils.skipIf(\n\n      sys.version_info[0:2] < (3, 5),\n\n      'Python < 3.5 does not support type hints.')\n\n  def testHelpTextFunctionWithLongTypes(self):\n\n    component = tc.py3.WithTypes().long_type  # pytype: disable=module-attr\n\n    help_screen = helptext.HelpText(\n\n        component=component,\n\n        trace=trace.FireTrace(component, name='long_type'))\n\n    self.assertIn('NAME\\n    long_type', help_screen)\n\n    self.assertIn('SYNOPSIS\\n    long_type LONG_OBJ', help_screen)\n\n    self.assertNotIn('DESCRIPTION', help_screen)\n\n    # TODO(dbieber): Assert type is displayed correctly. Type displayed\n\n    # differently in Travis vs in Google.\n\n    # self.assertIn(\n\n    #     'POSITIONAL ARGUMENTS\\n    LONG_OBJ\\n'\n\n    #     '        Type: typing.Tuple[typing.Tuple['\n\n    #     'typing.Tuple[typing.Tuple[typing.Tupl...',\n\n    #     help_screen)\n\n    self.assertIn(\n\n        'NOTES\\n    You can also use flags syntax for POSITIONAL ARGUMENTS',\n\n        help_screen)\n\n\n\n  def testHelpTextFunctionWithBuiltin(self):\n\n    component = 'test'.upper\n\n    help_screen = helptext.HelpText(\n\n        component=component,\n\n        trace=trace.FireTrace(component, 'upper'))\n\n    self.assertIn('NAME\\n    upper', help_screen)\n\n    self.assertIn('SYNOPSIS\\n    upper', help_screen)\n\n    # We don't check description content here since the content is python\n\n    # version dependent.\n\n    self.assertIn('DESCRIPTION\\n', help_screen)\n\n    self.assertNotIn('NOTES', help_screen)\n\n\n\n  def testHelpTextFunctionIntType(self):\n\n    component = int\n\n    help_screen = helptext.HelpText(\n\n        component=component, trace=trace.FireTrace(component, 'int'))\n\n    self.assertIn('NAME\\n    int', help_screen)\n\n    self.assertIn('SYNOPSIS\\n    int', help_screen)\n\n    # We don't check description content here since the content is python\n\n    # version dependent.\n\n    self.assertIn('DESCRIPTION\\n', help_screen)\n\n\n\n  def testHelpTextEmptyList(self):\n\n    component = []\n\n    help_screen = helptext.HelpText(\n\n        component=component,\n\n        trace=trace.FireTrace(component, 'list'))\n\n    self.assertIn('NAME\\n    list', help_screen)\n\n    self.assertIn('SYNOPSIS\\n    list COMMAND', help_screen)\n\n    # TODO(zuhaochen): Change assertion after custom description is\n\n    # implemented for list type.\n\n    self.assertNotIn('DESCRIPTION', help_screen)\n\n    # We don't check the listed commands either since the list API could\n\n    # potentially change between Python versions.\n\n    self.assertIn('COMMANDS\\n    COMMAND is one of the following:\\n',\n\n                  help_screen)\n\n\n\n  def testHelpTextShortList(self):\n\n    component = [10]\n\n    help_screen = helptext.HelpText(\n\n        component=component,\n\n        trace=trace.FireTrace(component, 'list'))\n\n    self.assertIn('NAME\\n    list', help_screen)\n\n    self.assertIn('SYNOPSIS\\n    list COMMAND', help_screen)\n\n    # TODO(zuhaochen): Change assertion after custom description is\n\n    # implemented for list type.\n\n    self.assertNotIn('DESCRIPTION', help_screen)\n\n\n\n    # We don't check the listed commands comprehensively since the list API\n\n    # could potentially change between Python versions. Check a few\n\n    # functions(command) that we're confident likely remain available.\n\n    self.assertIn('COMMANDS\\n    COMMAND is one of the following:\\n',\n\n                  help_screen)\n\n    self.assertIn('     append\\n', help_screen)\n\n\n\n  def testHelpTextInt(self):\n\n    component = 7\n\n    help_screen = helptext.HelpText(\n\n        component=component, trace=trace.FireTrace(component, '7'))\n\n    self.assertIn('NAME\\n    7', help_screen)\n\n    self.assertIn('SYNOPSIS\\n    7 COMMAND | VALUE', help_screen)\n\n    # TODO(zuhaochen): Change assertion after implementing custom\n\n    # description for int.\n\n    self.assertNotIn('DESCRIPTION', help_screen)\n\n    self.assertIn('COMMANDS\\n    COMMAND is one of the following:\\n',\n\n                  help_screen)\n\n    self.assertIn('VALUES\\n    VALUE is one of the following:\\n', help_screen)\n\n\n\n  def testHelpTextNoInit(self):\n\n    component = tc.OldStyleEmpty\n\n    help_screen = helptext.HelpText(\n\n        component=component,\n\n        trace=trace.FireTrace(component, 'OldStyleEmpty'))\n\n    self.assertIn('NAME\\n    OldStyleEmpty', help_screen)\n\n    self.assertIn('SYNOPSIS\\n    OldStyleEmpty', help_screen)\n\n\n\n  @testutils.skipIf(\n\n      six.PY2, 'Python 2 does not support keyword-only arguments.')\n\n  def testHelpTextKeywordOnlyArgumentsWithDefault(self):\n\n    component = tc.py3.KeywordOnly.with_default  # pytype: disable=module-attr\n\n    output = helptext.HelpText(\n\n        component=component, trace=trace.FireTrace(component, 'with_default'))\n\n    self.assertIn('NAME\\n    with_default', output)\n\n    self.assertIn('FLAGS\\n    --x=X', output)\n\n\n\n  @testutils.skipIf(\n\n      six.PY2, 'Python 2 does not support keyword-only arguments.')\n\n  def testHelpTextKeywordOnlyArgumentsWithoutDefault(self):\n\n    component = tc.py3.KeywordOnly.double  # pytype: disable=module-attr\n\n    output = helptext.HelpText(\n\n        component=component, trace=trace.FireTrace(component, 'double'))\n\n    self.assertIn('NAME\\n    double', output)\n\n    self.assertIn('FLAGS\\n    --count=COUNT (required)', output)\n\n\n\n  def testHelpScreen(self):\n\n    component = tc.ClassWithDocstring()\n\n    t = trace.FireTrace(component, name='ClassWithDocstring')\n\n    help_output = helptext.HelpText(component, t)\n\n    expected_output = \"\"\"\n\nNAME\n\n    ClassWithDocstring - Test class for testing help text output.\n\n\n\nSYNOPSIS\n\n    ClassWithDocstring COMMAND | VALUE\n\n\n\nDESCRIPTION\n\n    This is some detail description of this test class.\n\n\n\nCOMMANDS\n\n    COMMAND is one of the following:\n\n\n\n     print_msg\n\n       Prints a message.\n\n\n\nVALUES\n\n    VALUE is one of the following:\n\n\n\n     message\n\n       The default message to print.\"\"\"\n\n    self.assertEqual(textwrap.dedent(expected_output).strip(),\n\n                     help_output.strip())\n\n\n\n  def testHelpScreenForFunctionDocstringWithLineBreak(self):\n\n    component = tc.ClassWithMultilineDocstring.example_generator\n\n    t = trace.FireTrace(component, name='example_generator')\n\n    help_output = helptext.HelpText(component, t)\n\n    expected_output = \"\"\"\n\n    NAME\n\n        example_generator - Generators have a ``Yields`` section instead of a ``Returns`` section.\n\n\n\n    SYNOPSIS\n\n        example_generator N\n\n\n\n    DESCRIPTION\n\n        Generators have a ``Yields`` section instead of a ``Returns`` section.\n\n\n\n    POSITIONAL ARGUMENTS\n\n        N\n\n            The upper limit of the range to generate, from 0 to `n` - 1.\n\n\n\n    NOTES\n\n        You can also use flags syntax for POSITIONAL ARGUMENTS\"\"\"\n\n    self.assertEqual(textwrap.dedent(expected_output).strip(),\n\n                     help_output.strip())\n\n\n\n  def testHelpScreenForFunctionFunctionWithDefaultArgs(self):\n\n    component = tc.WithDefaults().double\n\n    t = trace.FireTrace(component, name='double')\n\n    help_output = helptext.HelpText(component, t)\n\n    expected_output = \"\"\"\n\n    NAME\n\n        double - Returns the input multiplied by 2.\n\n\n\n    SYNOPSIS\n\n        double <flags>\n\n\n\n    DESCRIPTION\n\n        Returns the input multiplied by 2.\n\n\n\n    FLAGS\n\n        --count=COUNT\n\n            Default: 0\n\n            Input number that you want to double.\"\"\"\n\n    self.assertEqual(textwrap.dedent(expected_output).strip(),\n\n                     help_output.strip())\n\n\n\n  def testHelpTextUnderlineFlag(self):\n\n    component = tc.WithDefaults().triple\n\n    t = trace.FireTrace(component, name='triple')\n\n    help_screen = helptext.HelpText(component, t)\n\n    self.assertIn(formatting.Bold('NAME') + '\\n    triple', help_screen)\n\n    self.assertIn(\n\n        formatting.Bold('SYNOPSIS') + '\\n    triple <flags>',\n\n        help_screen)\n\n    self.assertIn(\n\n        formatting.Bold('FLAGS') + '\\n    --' + formatting.Underline('count'),\n\n        help_screen)\n\n\n\n  def testHelpTextBoldCommandName(self):\n\n    component = tc.ClassWithDocstring()\n\n    t = trace.FireTrace(component, name='ClassWithDocstring')\n\n    help_screen = helptext.HelpText(component, t)\n\n    self.assertIn(\n\n        formatting.Bold('NAME') + '\\n    ClassWithDocstring', help_screen)\n\n    self.assertIn(formatting.Bold('COMMANDS') + '\\n', help_screen)\n\n    self.assertIn(\n\n        formatting.BoldUnderline('COMMAND') + ' is one of the following:\\n',\n\n        help_screen)\n\n    self.assertIn(formatting.Bold('print_msg') + '\\n', help_screen)\n\n\n\n  def testHelpTextObjectWithGroupAndValues(self):\n\n    component = tc.TypedProperties()\n\n    t = trace.FireTrace(component, name='TypedProperties')\n\n    help_screen = helptext.HelpText(\n\n        component=component, trace=t, verbose=True)\n\n    print(help_screen)\n\n    self.assertIn('GROUPS', help_screen)\n\n    self.assertIn('GROUP is one of the following:', help_screen)\n\n    self.assertIn(\n\n        'charlie\\n       Class with functions that have default arguments.',\n\n        help_screen)\n\n    self.assertIn('VALUES', help_screen)\n\n    self.assertIn('VALUE is one of the following:', help_screen)\n\n    self.assertIn('alpha', help_screen)\n\n\n\n  def testHelpTextNameSectionCommandWithSeparator(self):\n\n    component = 9\n\n    t = trace.FireTrace(component, name='int', separator='-')\n\n    t.AddSeparator()\n\n    help_screen = helptext.HelpText(component=component, trace=t, verbose=False)\n\n    self.assertIn('int -', help_screen)\n\n    self.assertNotIn('int - -', help_screen)\n\n\n\n  def testHelpTextNameSectionCommandWithSeparatorVerbose(self):\n\n    component = tc.WithDefaults().double\n\n    t = trace.FireTrace(component, name='double', separator='-')\n\n    t.AddSeparator()\n\n    help_screen = helptext.HelpText(component=component, trace=t, verbose=True)\n\n    self.assertIn('double -', help_screen)\n\n    self.assertIn('double - -', help_screen)\n\n\n\n\n\nclass UsageTest(testutils.BaseTestCase):\n\n\n\n  def testUsageOutput(self):\n\n    component = tc.NoDefaults()\n\n    t = trace.FireTrace(component, name='NoDefaults')\n\n    usage_output = helptext.UsageText(component, trace=t, verbose=False)\n\n    expected_output = \"\"\"\n\n    Usage: NoDefaults <command>\n\n      available commands:    double | triple\n\n\n\n    For detailed information on this command, run:\n\n      NoDefaults --help\"\"\"\n\n\n\n    self.assertEqual(\n\n        usage_output,\n\n        textwrap.dedent(expected_output).lstrip('\\n'))\n\n\n\n  def testUsageOutputVerbose(self):\n\n    component = tc.NoDefaults()\n\n    t = trace.FireTrace(component, name='NoDefaults')\n\n    usage_output = helptext.UsageText(component, trace=t, verbose=True)\n\n    expected_output = \"\"\"\n\n    Usage: NoDefaults <command>\n\n      available commands:    double | triple\n\n\n\n    For detailed information on this command, run:\n\n      NoDefaults --help\"\"\"\n\n    self.assertEqual(\n\n        usage_output,\n\n        textwrap.dedent(expected_output).lstrip('\\n'))\n\n\n\n  def testUsageOutputMethod(self):\n\n    component = tc.NoDefaults().double\n\n    t = trace.FireTrace(component, name='NoDefaults')\n\n    t.AddAccessedProperty(component, 'double', ['double'], None, None)\n\n    usage_output = helptext.UsageText(component, trace=t, verbose=False)\n\n    expected_output = \"\"\"\n\n    Usage: NoDefaults double COUNT\n\n\n\n    For detailed information on this command, run:\n\n      NoDefaults double --help\"\"\"\n\n    self.assertEqual(\n\n        usage_output,\n\n        textwrap.dedent(expected_output).lstrip('\\n'))\n\n\n\n  def testUsageOutputFunctionWithHelp(self):\n\n    component = tc.function_with_help\n\n    t = trace.FireTrace(component, name='function_with_help')\n\n    usage_output = helptext.UsageText(component, trace=t, verbose=False)\n\n    expected_output = \"\"\"\n\n    Usage: function_with_help <flags>\n\n      optional flags:        --help\n\n\n\n    For detailed information on this command, run:\n\n      function_with_help -- --help\"\"\"\n\n    self.assertEqual(\n\n        usage_output,\n\n        textwrap.dedent(expected_output).lstrip('\\n'))\n\n\n\n  def testUsageOutputFunctionWithDocstring(self):\n\n    component = tc.multiplier_with_docstring\n\n    t = trace.FireTrace(component, name='multiplier_with_docstring')\n\n    usage_output = helptext.UsageText(component, trace=t, verbose=False)\n\n    expected_output = \"\"\"\n\n    Usage: multiplier_with_docstring NUM <flags>\n\n      optional flags:        --rate\n\n\n\n    For detailed information on this command, run:\n\n      multiplier_with_docstring --help\"\"\"\n\n    self.assertEqual(\n\n        textwrap.dedent(expected_output).lstrip('\\n'),\n\n        usage_output)\n\n\n\n  def testUsageOutputCallable(self):\n\n    # This is both a group and a command.\n\n    component = tc.CallableWithKeywordArgument()\n\n    t = trace.FireTrace(component, name='CallableWithKeywordArgument',\n\n                        separator='@')\n\n    usage_output = helptext.UsageText(component, trace=t, verbose=False)\n\n    expected_output = \"\"\"\n\n    Usage: CallableWithKeywordArgument <command> | <flags>\n\n      available commands:    print_msg\n\n      flags are accepted\n\n\n\n    For detailed information on this command, run:\n\n      CallableWithKeywordArgument -- --help\"\"\"\n\n    self.assertEqual(\n\n        textwrap.dedent(expected_output).lstrip('\\n'),\n\n        usage_output)\n\n\n\n  def testUsageOutputConstructorWithParameter(self):\n\n    component = tc.InstanceVars\n\n    t = trace.FireTrace(component, name='InstanceVars')\n\n    usage_output = helptext.UsageText(component, trace=t, verbose=False)\n\n    expected_output = \"\"\"\n\n    Usage: InstanceVars --arg1=ARG1 --arg2=ARG2\n\n\n\n    For detailed information on this command, run:\n\n      InstanceVars --help\"\"\"\n\n    self.assertEqual(\n\n        textwrap.dedent(expected_output).lstrip('\\n'),\n\n        usage_output)\n\n\n\n  def testUsageOutputConstructorWithParameterVerbose(self):\n\n    component = tc.InstanceVars\n\n    t = trace.FireTrace(component, name='InstanceVars')\n\n    usage_output = helptext.UsageText(component, trace=t, verbose=True)\n\n    expected_output = \"\"\"\n\n    Usage: InstanceVars <command> | --arg1=ARG1 --arg2=ARG2\n\n      available commands:    run\n\n\n\n    For detailed information on this command, run:\n\n      InstanceVars --help\"\"\"\n\n    self.assertEqual(\n\n        textwrap.dedent(expected_output).lstrip('\\n'),\n\n        usage_output)\n\n\n\n  def testUsageOutputEmptyDict(self):\n\n    component = {}\n\n    t = trace.FireTrace(component, name='EmptyDict')\n\n    usage_output = helptext.UsageText(component, trace=t, verbose=True)\n\n    expected_output = \"\"\"\n\n    Usage: EmptyDict\n\n\n\n    For detailed information on this command, run:\n\n      EmptyDict --help\"\"\"\n\n    self.assertEqual(\n\n        textwrap.dedent(expected_output).lstrip('\\n'),\n\n        usage_output)\n\n\n\n  def testUsageOutputNone(self):\n\n    component = None\n\n    t = trace.FireTrace(component, name='None')\n\n    usage_output = helptext.UsageText(component, trace=t, verbose=True)\n\n    expected_output = \"\"\"\n\n    Usage: None\n\n\n\n    For detailed information on this command, run:\n\n      None --help\"\"\"\n\n    self.assertEqual(\n\n        textwrap.dedent(expected_output).lstrip('\\n'),\n\n        usage_output)\n\n\n\n  def testInitRequiresFlagSyntaxSubclassNamedTuple(self):\n\n    component = tc.SubPoint\n\n    t = trace.FireTrace(component, name='SubPoint')\n\n    usage_output = helptext.UsageText(component, trace=t, verbose=False)\n\n    expected_output = 'Usage: SubPoint --x=X --y=Y'\n\n    self.assertIn(expected_output, usage_output)\n\n\n\nif __name__ == '__main__':\n\n  testutils.main()\n", "# Copyright (C) 2018 Google Inc.\n\n#\n\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n\n# you may not use this file except in compliance with the License.\n\n# You may obtain a copy of the License at\n\n#\n\n# http://www.apache.org/licenses/LICENSE-2.0\n\n#\n\n# Unless required by applicable law or agreed to in writing, software\n\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n\n# See the License for the specific language governing permissions and\n\n# limitations under the License.\n\n\n\n\"\"\"Formatting utilities for use in creating help text.\"\"\"\n\n\n\nfrom __future__ import absolute_import\n\nfrom __future__ import division\n\nfrom __future__ import print_function\n\n\n\nfrom fire import formatting_windows  # pylint: disable=unused-import\n\nimport termcolor\n\n\n\n\n\nELLIPSIS = '...'\n\n\n\n\n\ndef Indent(text, spaces=2):\n\n  lines = text.split('\\n')\n\n  return '\\n'.join(\n\n      ' ' * spaces + line if line else line\n\n      for line in lines)\n\n\n\n\n\ndef Bold(text):\n\n  return termcolor.colored(text, attrs=['bold'])\n\n\n\n\n\ndef Underline(text):\n\n  return termcolor.colored(text, attrs=['underline'])\n\n\n\n\n\ndef BoldUnderline(text):\n\n  return Bold(Underline(text))\n\n\n\n\n\ndef WrappedJoin(items, separator=' | ', width=80):\n\n  \"\"\"Joins the items by the separator, wrapping lines at the given width.\"\"\"\n\n  lines = []\n\n  current_line = ''\n\n  for index, item in enumerate(items):\n\n    is_final_item = index == len(items) - 1\n\n    if is_final_item:\n\n      if len(current_line) + len(item) <= width:\n\n        current_line += item\n\n      else:\n\n        lines.append(current_line.rstrip())\n\n        current_line = item\n\n    else:\n\n      if len(current_line) + len(item) + len(separator) <= width:\n\n        current_line += item + separator\n\n      else:\n\n        lines.append(current_line.rstrip())\n\n        current_line = item + separator\n\n\n\n  lines.append(current_line)\n\n  return lines\n\n\n\n\n\ndef Error(text):\n\n  return termcolor.colored(text, color='red', attrs=['bold'])\n\n\n\n\n\ndef EllipsisTruncate(text, available_space, line_length):\n\n  \"\"\"Truncate text from the end with ellipsis.\"\"\"\n\n  if available_space < len(ELLIPSIS):\n\n    available_space = line_length\n\n  # No need to truncate\n\n  if len(text) <= available_space:\n\n    return text\n\n  return text[:available_space - len(ELLIPSIS)] + ELLIPSIS\n\n\n\n\n\ndef EllipsisMiddleTruncate(text, available_space, line_length):\n\n  \"\"\"Truncates text from the middle with ellipsis.\"\"\"\n\n  if available_space < len(ELLIPSIS):\n\n    available_space = line_length\n\n  if len(text) < available_space:\n\n    return text\n\n  available_string_len = available_space - len(ELLIPSIS)\n\n  first_half_len = int(available_string_len / 2)  # start from middle\n\n  second_half_len = available_string_len - first_half_len\n\n  return text[:first_half_len] + ELLIPSIS + text[-second_half_len:]\n\n\n\n\n\ndef DoubleQuote(text):\n\n  return '\"%s\"' % text\n", "# Copyright (C) 2018 Google Inc.\n\n#\n\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n\n# you may not use this file except in compliance with the License.\n\n# You may obtain a copy of the License at\n\n#\n\n# http://www.apache.org/licenses/LICENSE-2.0\n\n#\n\n# Unless required by applicable law or agreed to in writing, software\n\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n\n# See the License for the specific language governing permissions and\n\n# limitations under the License.\n\n\n\n\"\"\"Provides parsing functionality used by Python Fire.\"\"\"\n\n\n\nfrom __future__ import absolute_import\n\nfrom __future__ import division\n\nfrom __future__ import print_function\n\n\n\nimport argparse\n\nimport ast\n\n\n\n\n\ndef CreateParser():\n\n  parser = argparse.ArgumentParser(add_help=False)\n\n  parser.add_argument('--verbose', '-v', action='store_true')\n\n  parser.add_argument('--interactive', '-i', action='store_true')\n\n  parser.add_argument('--separator', default='-')\n\n  parser.add_argument('--completion', nargs='?', const='bash', type=str)\n\n  parser.add_argument('--help', '-h', action='store_true')\n\n  parser.add_argument('--trace', '-t', action='store_true')\n\n  # TODO(dbieber): Consider allowing name to be passed as an argument.\n\n  return parser\n\n\n\n\n\ndef SeparateFlagArgs(args):\n\n  \"\"\"Splits a list of args into those for Flags and those for Fire.\n\n\n\n  If an isolated '--' arg is not present in the arg list, then all of the args\n\n  are for Fire. If there is an isolated '--', then the args after the final '--'\n\n  are flag args, and the rest of the args are fire args.\n\n\n\n  Args:\n\n    args: The list of arguments received by the Fire command.\n\n  Returns:\n\n    A tuple with the Fire args (a list), followed by the Flag args (a list).\n\n  \"\"\"\n\n  if '--' in args:\n\n    separator_index = len(args) - 1 - args[::-1].index('--')  # index of last --\n\n    flag_args = args[separator_index + 1:]\n\n    args = args[:separator_index]\n\n    return args, flag_args\n\n  return args, []\n\n\n\n\n\ndef DefaultParseValue(value):\n\n  \"\"\"The default argument parsing function used by Fire CLIs.\n\n\n\n  If the value is made of only Python literals and containers, then the value\n\n  is parsed as it's Python value. Otherwise, provided the value contains no\n\n  quote, escape, or parenthetical characters, the value is treated as a string.\n\n\n\n  Args:\n\n    value: A string from the command line to be parsed for use in a Fire CLI.\n\n  Returns:\n\n    The parsed value, of the type determined most appropriate.\n\n  \"\"\"\n\n  # Note: _LiteralEval will treat '#' as the start of a comment.\n\n  try:\n\n    return _LiteralEval(value)\n\n  except (SyntaxError, ValueError):\n\n    # If _LiteralEval can't parse the value, treat it as a string.\n\n    return value\n\n\n\n\n\ndef _LiteralEval(value):\n\n  \"\"\"Parse value as a Python literal, or container of containers and literals.\n\n\n\n  First the AST of the value is updated so that bare-words are turned into\n\n  strings. Then the resulting AST is evaluated as a literal or container of\n\n  only containers and literals.\n\n\n\n  This allows for the YAML-like syntax {a: b} to represent the dict {'a': 'b'}\n\n\n\n  Args:\n\n    value: A string to be parsed as a literal or container of containers and\n\n      literals.\n\n  Returns:\n\n    The Python value representing the value arg.\n\n  Raises:\n\n    ValueError: If the value is not an expression with only containers and\n\n      literals.\n\n    SyntaxError: If the value string has a syntax error.\n\n  \"\"\"\n\n  root = ast.parse(value, mode='eval')\n\n  if isinstance(root.body, ast.BinOp):  # pytype: disable=attribute-error\n\n    raise ValueError(value)\n\n\n\n  for node in ast.walk(root):\n\n    for field, child in ast.iter_fields(node):\n\n      if isinstance(child, list):\n\n        for index, subchild in enumerate(child):\n\n          if isinstance(subchild, ast.Name):\n\n            child[index] = _Replacement(subchild)\n\n\n\n      elif isinstance(child, ast.Name):\n\n        replacement = _Replacement(child)\n\n        node.__setattr__(field, replacement)\n\n\n\n  # ast.literal_eval supports the following types:\n\n  # strings, bytes, numbers, tuples, lists, dicts, sets, booleans, and None\n\n  # (bytes and set literals only starting with Python 3.2)\n\n  return ast.literal_eval(root)\n\n\n\n\n\ndef _Replacement(node):\n\n  \"\"\"Returns a node to use in place of the supplied node in the AST.\n\n\n\n  Args:\n\n    node: A node of type Name. Could be a variable, or builtin constant.\n\n  Returns:\n\n    A node to use in place of the supplied Node. Either the same node, or a\n\n    String node whose value matches the Name node's id.\n\n  \"\"\"\n\n  value = node.id\n\n  # These are the only builtin constants supported by literal_eval.\n\n  if value in ('True', 'False', 'None'):\n\n    return node\n\n  return ast.Str(value)\n", "# Copyright (C) 2018 Google Inc.\n\n#\n\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n\n# you may not use this file except in compliance with the License.\n\n# You may obtain a copy of the License at\n\n#\n\n# http://www.apache.org/licenses/LICENSE-2.0\n\n#\n\n# Unless required by applicable law or agreed to in writing, software\n\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n\n# See the License for the specific language governing permissions and\n\n# limitations under the License.\n\n\n\n\"\"\"Tests for the parser module.\"\"\"\n\n\n\nfrom __future__ import absolute_import\n\nfrom __future__ import division\n\nfrom __future__ import print_function\n\n\n\nfrom fire import parser\n\nfrom fire import testutils\n\n\n\n\n\nclass ParserTest(testutils.BaseTestCase):\n\n\n\n  def testCreateParser(self):\n\n    self.assertIsNotNone(parser.CreateParser())\n\n\n\n  def testSeparateFlagArgs(self):\n\n    self.assertEqual(parser.SeparateFlagArgs([]), ([], []))\n\n    self.assertEqual(parser.SeparateFlagArgs(['a', 'b']), (['a', 'b'], []))\n\n    self.assertEqual(parser.SeparateFlagArgs(['a', 'b', '--']),\n\n                     (['a', 'b'], []))\n\n    self.assertEqual(parser.SeparateFlagArgs(['a', 'b', '--', 'c']),\n\n                     (['a', 'b'], ['c']))\n\n    self.assertEqual(parser.SeparateFlagArgs(['--']),\n\n                     ([], []))\n\n    self.assertEqual(parser.SeparateFlagArgs(['--', 'c', 'd']),\n\n                     ([], ['c', 'd']))\n\n    self.assertEqual(parser.SeparateFlagArgs(['a', 'b', '--', 'c', 'd']),\n\n                     (['a', 'b'], ['c', 'd']))\n\n    self.assertEqual(parser.SeparateFlagArgs(['a', 'b', '--', 'c', 'd', '--']),\n\n                     (['a', 'b', '--', 'c', 'd'], []))\n\n    self.assertEqual(parser.SeparateFlagArgs(['a', 'b', '--', 'c', '--', 'd']),\n\n                     (['a', 'b', '--', 'c'], ['d']))\n\n\n\n  def testDefaultParseValueStrings(self):\n\n    self.assertEqual(parser.DefaultParseValue('hello'), 'hello')\n\n    self.assertEqual(parser.DefaultParseValue('path/file.jpg'), 'path/file.jpg')\n\n    self.assertEqual(parser.DefaultParseValue('hello world'), 'hello world')\n\n    self.assertEqual(parser.DefaultParseValue('--flag'), '--flag')\n\n\n\n  def testDefaultParseValueQuotedStrings(self):\n\n    self.assertEqual(parser.DefaultParseValue(\"'hello'\"), 'hello')\n\n    self.assertEqual(parser.DefaultParseValue(\"'hello world'\"), 'hello world')\n\n    self.assertEqual(parser.DefaultParseValue(\"'--flag'\"), '--flag')\n\n    self.assertEqual(parser.DefaultParseValue('\"hello\"'), 'hello')\n\n    self.assertEqual(parser.DefaultParseValue('\"hello world\"'), 'hello world')\n\n    self.assertEqual(parser.DefaultParseValue('\"--flag\"'), '--flag')\n\n\n\n  def testDefaultParseValueSpecialStrings(self):\n\n    self.assertEqual(parser.DefaultParseValue('-'), '-')\n\n    self.assertEqual(parser.DefaultParseValue('--'), '--')\n\n    self.assertEqual(parser.DefaultParseValue('---'), '---')\n\n    self.assertEqual(parser.DefaultParseValue('----'), '----')\n\n    self.assertEqual(parser.DefaultParseValue('None'), None)\n\n    self.assertEqual(parser.DefaultParseValue(\"'None'\"), 'None')\n\n\n\n  def testDefaultParseValueNumbers(self):\n\n    self.assertEqual(parser.DefaultParseValue('23'), 23)\n\n    self.assertEqual(parser.DefaultParseValue('-23'), -23)\n\n    self.assertEqual(parser.DefaultParseValue('23.0'), 23.0)\n\n    self.assertIsInstance(parser.DefaultParseValue('23'), int)\n\n    self.assertIsInstance(parser.DefaultParseValue('23.0'), float)\n\n    self.assertEqual(parser.DefaultParseValue('23.5'), 23.5)\n\n    self.assertEqual(parser.DefaultParseValue('-23.5'), -23.5)\n\n\n\n  def testDefaultParseValueStringNumbers(self):\n\n    self.assertEqual(parser.DefaultParseValue(\"'23'\"), '23')\n\n    self.assertEqual(parser.DefaultParseValue(\"'23.0'\"), '23.0')\n\n    self.assertEqual(parser.DefaultParseValue(\"'23.5'\"), '23.5')\n\n    self.assertEqual(parser.DefaultParseValue('\"23\"'), '23')\n\n    self.assertEqual(parser.DefaultParseValue('\"23.0\"'), '23.0')\n\n    self.assertEqual(parser.DefaultParseValue('\"23.5\"'), '23.5')\n\n\n\n  def testDefaultParseValueQuotedStringNumbers(self):\n\n    self.assertEqual(parser.DefaultParseValue('\"\\'123\\'\"'), \"'123'\")\n\n\n\n  def testDefaultParseValueOtherNumbers(self):\n\n    self.assertEqual(parser.DefaultParseValue('1e5'), 100000.0)\n\n\n\n  def testDefaultParseValueLists(self):\n\n    self.assertEqual(parser.DefaultParseValue('[1, 2, 3]'), [1, 2, 3])\n\n    self.assertEqual(parser.DefaultParseValue('[1, \"2\", 3]'), [1, '2', 3])\n\n    self.assertEqual(parser.DefaultParseValue('[1, \\'\"2\"\\', 3]'), [1, '\"2\"', 3])\n\n    self.assertEqual(parser.DefaultParseValue(\n\n        '[1, \"hello\", 3]'), [1, 'hello', 3])\n\n\n\n  def testDefaultParseValueBareWordsLists(self):\n\n    self.assertEqual(parser.DefaultParseValue('[one, 2, \"3\"]'), ['one', 2, '3'])\n\n\n\n  def testDefaultParseValueDict(self):\n\n    self.assertEqual(\n\n        parser.DefaultParseValue('{\"abc\": 5, \"123\": 1}'), {'abc': 5, '123': 1})\n\n\n\n  def testDefaultParseValueNone(self):\n\n    self.assertEqual(parser.DefaultParseValue('None'), None)\n\n\n\n  def testDefaultParseValueBool(self):\n\n    self.assertEqual(parser.DefaultParseValue('True'), True)\n\n    self.assertEqual(parser.DefaultParseValue('False'), False)\n\n\n\n  def testDefaultParseValueBareWordsTuple(self):\n\n    self.assertEqual(parser.DefaultParseValue('(one, 2, \"3\")'), ('one', 2, '3'))\n\n    self.assertEqual(parser.DefaultParseValue('one, \"2\", 3'), ('one', '2', 3))\n\n\n\n  def testDefaultParseValueNestedContainers(self):\n\n    self.assertEqual(\n\n        parser.DefaultParseValue('[(A, 2, \"3\"), 5, {alph: 10.2, beta: \"cat\"}]'),\n\n        [('A', 2, '3'), 5, {'alph': 10.2, 'beta': 'cat'}])\n\n\n\n  def testDefaultParseValueComments(self):\n\n    self.assertEqual(parser.DefaultParseValue('\"0#comments\"'), '0#comments')\n\n    # Comments are stripped. This behavior may change in the future.\n\n    self.assertEqual(parser.DefaultParseValue('0#comments'), 0)\n\n\n\n  def testDefaultParseValueBadLiteral(self):\n\n    # If it can't be parsed, we treat it as a string. This behavior may change.\n\n    self.assertEqual(\n\n        parser.DefaultParseValue('[(A, 2, \"3\"), 5'), '[(A, 2, \"3\"), 5')\n\n    self.assertEqual(parser.DefaultParseValue('x=10'), 'x=10')\n\n\n\n  def testDefaultParseValueSyntaxError(self):\n\n    # If it can't be parsed, we treat it as a string.\n\n    self.assertEqual(parser.DefaultParseValue('\"'), '\"')\n\n\n\n  def testDefaultParseValueIgnoreBinOp(self):\n\n    self.assertEqual(parser.DefaultParseValue('2017-10-10'), '2017-10-10')\n\n    self.assertEqual(parser.DefaultParseValue('1+1'), '1+1')\n\n\n\nif __name__ == '__main__':\n\n  testutils.main()\n", "# Copyright (C) 2018 Google Inc.\n\n#\n\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n\n# you may not use this file except in compliance with the License.\n\n# You may obtain a copy of the License at\n\n#\n\n# http://www.apache.org/licenses/LICENSE-2.0\n\n#\n\n# Unless required by applicable law or agreed to in writing, software\n\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n\n# See the License for the specific language governing permissions and\n\n# limitations under the License.\n\n\n\n\"\"\"This module enables interactive mode in Python Fire.\n\n\n\nIt uses IPython as an optional dependency. When IPython is installed, the\n\ninteractive flag will use IPython's REPL. When IPython is not installed, the\n\ninteractive flag will start a Python REPL with the builtin `code` module's\n\nInteractiveConsole class.\n\n\"\"\"\n\n\n\nfrom __future__ import absolute_import\n\nfrom __future__ import division\n\nfrom __future__ import print_function\n\n\n\nimport inspect\n\n\n\n\n\ndef Embed(variables, verbose=False):\n\n  \"\"\"Drops into a Python REPL with variables available as local variables.\n\n\n\n  Args:\n\n    variables: A dict of variables to make available. Keys are variable names.\n\n        Values are variable values.\n\n    verbose: Whether to include 'hidden' members, those keys starting with _.\n\n  \"\"\"\n\n  print(_AvailableString(variables, verbose))\n\n\n\n  try:\n\n    _EmbedIPython(variables)\n\n  except ImportError:\n\n    _EmbedCode(variables)\n\n\n\n\n\ndef _AvailableString(variables, verbose=False):\n\n  \"\"\"Returns a string describing what objects are available in the Python REPL.\n\n\n\n  Args:\n\n    variables: A dict of the object to be available in the REPL.\n\n    verbose: Whether to include 'hidden' members, those keys starting with _.\n\n  Returns:\n\n    A string fit for printing at the start of the REPL, indicating what objects\n\n    are available for the user to use.\n\n  \"\"\"\n\n  modules = []\n\n  other = []\n\n  for name, value in variables.items():\n\n    if not verbose and name.startswith('_'):\n\n      continue\n\n    if '-' in name or '/' in name:\n\n      continue\n\n\n\n    if inspect.ismodule(value):\n\n      modules.append(name)\n\n    else:\n\n      other.append(name)\n\n\n\n  lists = [\n\n      ('Modules', modules),\n\n      ('Objects', other)]\n\n  liststrs = []\n\n  for name, varlist in lists:\n\n    if varlist:\n\n      liststrs.append(\n\n          '{name}: {items}'.format(name=name, items=', '.join(sorted(varlist))))\n\n\n\n  return (\n\n      'Fire is starting a Python REPL with the following objects:\\n'\n\n      '{liststrs}\\n'\n\n  ).format(liststrs='\\n'.join(liststrs))\n\n\n\n\n\ndef _EmbedIPython(variables, argv=None):\n\n  \"\"\"Drops into an IPython REPL with variables available for use.\n\n\n\n  Args:\n\n    variables: A dict of variables to make available. Keys are variable names.\n\n        Values are variable values.\n\n    argv: The argv to use for starting ipython. Defaults to an empty list.\n\n  \"\"\"\n\n  import IPython  # pylint: disable=import-outside-toplevel,g-import-not-at-top\n\n  argv = argv or []\n\n  IPython.start_ipython(argv=argv, user_ns=variables)\n\n\n\n\n\ndef _EmbedCode(variables):\n\n  import code  # pylint: disable=import-outside-toplevel,g-import-not-at-top\n\n  code.InteractiveConsole(variables).interact()\n", "# Copyright (C) 2018 Google Inc.\n\n#\n\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n\n# you may not use this file except in compliance with the License.\n\n# You may obtain a copy of the License at\n\n#\n\n# http://www.apache.org/licenses/LICENSE-2.0\n\n#\n\n# Unless required by applicable law or agreed to in writing, software\n\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n\n# See the License for the specific language governing permissions and\n\n# limitations under the License.\n\n\n\n# Lint as: python3\n\n\"\"\"This module has components that use Python 3 specific syntax.\"\"\"\n\n\n\nimport asyncio\n\nimport functools\n\nfrom typing import Tuple\n\n\n\n\n\n# pylint: disable=keyword-arg-before-vararg\n\ndef identity(arg1, arg2: int, arg3=10, arg4: int = 20, *arg5,\n\n             arg6, arg7: int, arg8=30, arg9: int = 40, **arg10):\n\n  return arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9, arg10\n\n\n\n\n\nclass KeywordOnly(object):\n\n\n\n  def double(self, *, count):\n\n    return count * 2\n\n\n\n  def triple(self, *, count):\n\n    return count * 3\n\n\n\n  def with_default(self, *, x=\"x\"):\n\n    print(\"x: \" + x)\n\n\n\n\n\nclass LruCacheDecoratedMethod(object):\n\n\n\n  @functools.lru_cache()\n\n  def lru_cache_in_class(self, arg1):\n\n    return arg1\n\n\n\n\n\n@functools.lru_cache()\n\ndef lru_cache_decorated(arg1):\n\n  return arg1\n\n\n\n\n\nclass WithAsyncio(object):\n\n\n\n  @asyncio.coroutine\n\n  def double(self, count=0):\n\n    return 2 * count\n\n\n\n\n\nclass WithTypes(object):\n\n  \"\"\"Class with functions that have default arguments and types.\"\"\"\n\n\n\n  def double(self, count: float) -> float:\n\n    \"\"\"Returns the input multiplied by 2.\n\n\n\n    Args:\n\n      count: Input number that you want to double.\n\n\n\n    Returns:\n\n      A number that is the double of count.\n\n    \"\"\"\n\n    return 2 * count\n\n\n\n  def long_type(\n\n      self,\n\n      long_obj: (Tuple[Tuple[Tuple[Tuple[Tuple[Tuple[Tuple[\n\n          Tuple[Tuple[Tuple[Tuple[Tuple[int]]]]]]]]]]]])\n\n  ):\n\n    return long_obj\n\n\n\n\n\nclass WithDefaultsAndTypes(object):\n\n  \"\"\"Class with functions that have default arguments and types.\"\"\"\n\n\n\n  def double(self, count: float = 0) -> float:\n\n    \"\"\"Returns the input multiplied by 2.\n\n\n\n    Args:\n\n      count: Input number that you want to double.\n\n\n\n    Returns:\n\n      A number that is the double of count.\n\n    \"\"\"\n\n    return 2 * count\n\n\n\n  def get_int(self, value: int = None):\n\n    return 0 if value is None else value\n", "# Copyright (C) 2018 Google Inc.\n\n#\n\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n\n# you may not use this file except in compliance with the License.\n\n# You may obtain a copy of the License at\n\n#\n\n# http://www.apache.org/licenses/LICENSE-2.0\n\n#\n\n# Unless required by applicable law or agreed to in writing, software\n\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n\n# See the License for the specific language governing permissions and\n\n# limitations under the License.\n\n\n\n\"\"\"Inspection utility functions for Python Fire.\"\"\"\n\n\n\nfrom __future__ import absolute_import\n\nfrom __future__ import division\n\nfrom __future__ import print_function\n\n\n\nimport inspect\n\nimport sys\n\nimport types\n\n\n\nfrom fire import docstrings\n\n\n\nimport six\n\n\n\nif six.PY34:\n\n  import asyncio  # pylint: disable=import-error,g-import-not-at-top  # pytype: disable=import-error\n\n\n\n\n\nclass FullArgSpec(object):\n\n  \"\"\"The arguments of a function, as in Python 3's inspect.FullArgSpec.\"\"\"\n\n\n\n  def __init__(self, args=None, varargs=None, varkw=None, defaults=None,\n\n               kwonlyargs=None, kwonlydefaults=None, annotations=None):\n\n    \"\"\"Constructs a FullArgSpec with each provided attribute, or the default.\n\n\n\n    Args:\n\n      args: A list of the argument names accepted by the function.\n\n      varargs: The name of the *varargs argument or None if there isn't one.\n\n      varkw: The name of the **kwargs argument or None if there isn't one.\n\n      defaults: A tuple of the defaults for the arguments that accept defaults.\n\n      kwonlyargs: A list of argument names that must be passed with a keyword.\n\n      kwonlydefaults: A dictionary of keyword only arguments and their defaults.\n\n      annotations: A dictionary of arguments and their annotated types.\n\n    \"\"\"\n\n    self.args = args or []\n\n    self.varargs = varargs\n\n    self.varkw = varkw\n\n    self.defaults = defaults or ()\n\n    self.kwonlyargs = kwonlyargs or []\n\n    self.kwonlydefaults = kwonlydefaults or {}\n\n    self.annotations = annotations or {}\n\n\n\n\n\ndef _GetArgSpecInfo(fn):\n\n  \"\"\"Gives information pertaining to computing the ArgSpec of fn.\n\n\n\n  Determines if the first arg is supplied automatically when fn is called.\n\n  This arg will be supplied automatically if fn is a bound method or a class\n\n  with an __init__ method.\n\n\n\n  Also returns the function who's ArgSpec should be used for determining the\n\n  calling parameters for fn. This may be different from fn itself if fn is a\n\n  class with an __init__ method.\n\n\n\n  Args:\n\n    fn: The function or class of interest.\n\n  Returns:\n\n    A tuple with the following two items:\n\n      fn: The function to use for determining the arg spec of this function.\n\n      skip_arg: Whether the first argument will be supplied automatically, and\n\n        hence should be skipped when supplying args from a Fire command.\n\n  \"\"\"\n\n  skip_arg = False\n\n  if inspect.isclass(fn):\n\n    # If the function is a class, we try to use its init method.\n\n    skip_arg = True\n\n    if six.PY2 and hasattr(fn, '__init__'):\n\n      fn = fn.__init__\n\n  elif inspect.ismethod(fn):\n\n    # If the function is a bound method, we skip the `self` argument.\n\n    skip_arg = fn.__self__ is not None\n\n  elif inspect.isbuiltin(fn):\n\n    # If the function is a bound builtin, we skip the `self` argument, unless\n\n    # the function is from a standard library module in which case its __self__\n\n    # attribute is that module.\n\n    if not isinstance(fn.__self__, types.ModuleType):\n\n      skip_arg = True\n\n  elif not inspect.isfunction(fn):\n\n    # The purpose of this else clause is to set skip_arg for callable objects.\n\n    skip_arg = True\n\n  return fn, skip_arg\n\n\n\n\n\ndef Py2GetArgSpec(fn):\n\n  \"\"\"A wrapper around getargspec that tries both fn and fn.__call__.\"\"\"\n\n  try:\n\n    return inspect.getargspec(fn)  # pylint: disable=deprecated-method\n\n  except TypeError:\n\n    if hasattr(fn, '__call__'):\n\n      return inspect.getargspec(fn.__call__)  # pylint: disable=deprecated-method\n\n    raise\n\n\n\n\n\ndef Py3GetFullArgSpec(fn):\n\n  \"\"\"A alternative to the builtin getfullargspec.\n\n\n\n  The builtin inspect.getfullargspec uses:\n\n  `skip_bound_args=False, follow_wrapped_chains=False`\n\n  in order to be backwards compatible.\n\n\n\n  This function instead skips bound args (self) and follows wrapped chains.\n\n\n\n  Args:\n\n    fn: The function or class of interest.\n\n  Returns:\n\n    An inspect.FullArgSpec namedtuple with the full arg spec of the function.\n\n  \"\"\"\n\n  # pylint: disable=no-member\n\n  # pytype: disable=module-attr\n\n  try:\n\n    sig = inspect._signature_from_callable(  # pylint: disable=protected-access\n\n        fn,\n\n        skip_bound_arg=True,\n\n        follow_wrapper_chains=True,\n\n        sigcls=inspect.Signature)\n\n  except Exception:\n\n    # 'signature' can raise ValueError (most common), AttributeError, and\n\n    # possibly others. We catch all exceptions here, and reraise a TypeError.\n\n    raise TypeError('Unsupported callable.')\n\n\n\n  args = []\n\n  varargs = None\n\n  varkw = None\n\n  kwonlyargs = []\n\n  defaults = ()\n\n  annotations = {}\n\n  defaults = ()\n\n  kwdefaults = {}\n\n\n\n  if sig.return_annotation is not sig.empty:\n\n    annotations['return'] = sig.return_annotation\n\n\n\n  for param in sig.parameters.values():\n\n    kind = param.kind\n\n    name = param.name\n\n\n\n    # pylint: disable=protected-access\n\n    if kind is inspect._POSITIONAL_ONLY:\n\n      args.append(name)\n\n    elif kind is  inspect._POSITIONAL_OR_KEYWORD:\n\n      args.append(name)\n\n      if param.default is not param.empty:\n\n        defaults += (param.default,)\n\n    elif kind is  inspect._VAR_POSITIONAL:\n\n      varargs = name\n\n    elif kind is  inspect._KEYWORD_ONLY:\n\n      kwonlyargs.append(name)\n\n      if param.default is not param.empty:\n\n        kwdefaults[name] = param.default\n\n    elif kind is  inspect._VAR_KEYWORD:\n\n      varkw = name\n\n    if param.annotation is not param.empty:\n\n      annotations[name] = param.annotation\n\n    # pylint: enable=protected-access\n\n\n\n  if not kwdefaults:\n\n    # compatibility with 'func.__kwdefaults__'\n\n    kwdefaults = None\n\n\n\n  if not defaults:\n\n    # compatibility with 'func.__defaults__'\n\n    defaults = None\n\n  return inspect.FullArgSpec(args, varargs, varkw, defaults,\n\n                             kwonlyargs, kwdefaults, annotations)\n\n  # pylint: enable=no-member\n\n  # pytype: enable=module-attr\n\n\n\n\n\ndef GetFullArgSpec(fn):\n\n  \"\"\"Returns a FullArgSpec describing the given callable.\"\"\"\n\n  original_fn = fn\n\n  fn, skip_arg = _GetArgSpecInfo(fn)\n\n\n\n  try:\n\n    if sys.version_info[0:2] >= (3, 5):\n\n      (args, varargs, varkw, defaults,\n\n       kwonlyargs, kwonlydefaults, annotations) = Py3GetFullArgSpec(fn)\n\n    elif six.PY3:  # Specifically Python 3.4.\n\n      (args, varargs, varkw, defaults,\n\n       kwonlyargs, kwonlydefaults, annotations) = inspect.getfullargspec(fn)  # pylint: disable=deprecated-method,no-member\n\n    else:  # six.PY2\n\n      args, varargs, varkw, defaults = Py2GetArgSpec(fn)\n\n      kwonlyargs = kwonlydefaults = None\n\n      annotations = getattr(fn, '__annotations__', None)\n\n\n\n  except TypeError:\n\n    # If we can't get the argspec, how do we know if the fn should take args?\n\n    # 1. If it's a builtin, it can take args.\n\n    # 2. If it's an implicit __init__ function (a 'slot wrapper'), that comes\n\n    # from a namedtuple, use _fields to determine the args.\n\n    # 3. If it's another slot wrapper (that comes from not subclassing object in\n\n    # Python 2), then there are no args.\n\n    # Are there other cases? We just don't know.\n\n\n\n    # Case 1: Builtins accept args.\n\n    if inspect.isbuiltin(fn):\n\n      # TODO(dbieber): Try parsing the docstring, if available.\n\n      # TODO(dbieber): Use known argspecs, like set.add and namedtuple.count.\n\n      return FullArgSpec(varargs='vars', varkw='kwargs')\n\n\n\n    # Case 2: namedtuples store their args in their _fields attribute.\n\n    # TODO(dbieber): Determine if there's a way to detect false positives.\n\n    # In Python 2, a class that does not subclass anything, does not define\n\n    # __init__, and has an attribute named _fields will cause Fire to think it\n\n    # expects args for its constructor when in fact it does not.\n\n    fields = getattr(original_fn, '_fields', None)\n\n    if fields is not None:\n\n      return FullArgSpec(args=list(fields))\n\n\n\n    # Case 3: Other known slot wrappers do not accept args.\n\n    return FullArgSpec()\n\n\n\n  # In Python 3.5+ Py3GetFullArgSpec uses skip_bound_arg=True already.\n\n  skip_arg_required = six.PY2 or sys.version_info[0:2] == (3, 4)\n\n  if skip_arg_required and skip_arg and args:\n\n    args.pop(0)  # Remove 'self' or 'cls' from the list of arguments.\n\n  return FullArgSpec(args, varargs, varkw, defaults,\n\n                     kwonlyargs, kwonlydefaults, annotations)\n\n\n\n\n\ndef GetFileAndLine(component):\n\n  \"\"\"Returns the filename and line number of component.\n\n\n\n  Args:\n\n    component: A component to find the source information for, usually a class\n\n        or routine.\n\n  Returns:\n\n    filename: The name of the file where component is defined.\n\n    lineno: The line number where component is defined.\n\n  \"\"\"\n\n  if inspect.isbuiltin(component):\n\n    return None, None\n\n\n\n  try:\n\n    filename = inspect.getsourcefile(component)\n\n  except TypeError:\n\n    return None, None\n\n\n\n  try:\n\n    unused_code, lineindex = inspect.findsource(component)\n\n    lineno = lineindex + 1\n\n  except (IOError, IndexError):\n\n    lineno = None\n\n\n\n  return filename, lineno\n\n\n\n\n\ndef Info(component):\n\n  \"\"\"Returns a dict with information about the given component.\n\n\n\n  The dict will have at least some of the following fields.\n\n    type_name: The type of `component`.\n\n    string_form: A string representation of `component`.\n\n    file: The file in which `component` is defined.\n\n    line: The line number at which `component` is defined.\n\n    docstring: The docstring of `component`.\n\n    init_docstring: The init docstring of `component`.\n\n    class_docstring: The class docstring of `component`.\n\n    call_docstring: The call docstring of `component`.\n\n    length: The length of `component`.\n\n\n\n  Args:\n\n    component: The component to analyze.\n\n  Returns:\n\n    A dict with information about the component.\n\n  \"\"\"\n\n  try:\n\n    from IPython.core import oinspect  # pylint: disable=import-outside-toplevel,g-import-not-at-top\n\n    inspector = oinspect.Inspector()\n\n    info = inspector.info(component)\n\n\n\n    # IPython's oinspect.Inspector.info may return '<no docstring>'\n\n    if info['docstring'] == '<no docstring>':\n\n      info['docstring'] = None\n\n  except ImportError:\n\n    info = _InfoBackup(component)\n\n\n\n  try:\n\n    unused_code, lineindex = inspect.findsource(component)\n\n    info['line'] = lineindex + 1\n\n  except (TypeError, IOError):\n\n    info['line'] = None\n\n\n\n  if 'docstring' in info:\n\n    info['docstring_info'] = docstrings.parse(info['docstring'])\n\n\n\n  return info\n\n\n\n\n\ndef _InfoBackup(component):\n\n  \"\"\"Returns a dict with information about the given component.\n\n\n\n  This function is to be called only in the case that IPython's\n\n  oinspect module is not available. The info dict it produces may\n\n  contain less information that contained in the info dict produced\n\n  by oinspect.\n\n\n\n  Args:\n\n    component: The component to analyze.\n\n  Returns:\n\n    A dict with information about the component.\n\n  \"\"\"\n\n  info = {}\n\n\n\n  info['type_name'] = type(component).__name__\n\n  info['string_form'] = str(component)\n\n\n\n  filename, lineno = GetFileAndLine(component)\n\n  info['file'] = filename\n\n  info['line'] = lineno\n\n  info['docstring'] = inspect.getdoc(component)\n\n\n\n  try:\n\n    info['length'] = str(len(component))\n\n  except (TypeError, AttributeError):\n\n    pass\n\n\n\n  return info\n\n\n\n\n\ndef IsNamedTuple(component):\n\n  \"\"\"Return true if the component is a namedtuple.\n\n\n\n  Unfortunately, Python offers no native way to check for a namedtuple type.\n\n  Instead, we need to use a simple hack which should suffice for our case.\n\n  namedtuples are internally implemented as tuples, therefore we need to:\n\n    1. Check if the component is an instance of tuple.\n\n    2. Check if the component has a _fields attribute which regular tuples do\n\n       not have.\n\n\n\n  Args:\n\n    component: The component to analyze.\n\n  Returns:\n\n    True if the component is a namedtuple or False otherwise.\n\n  \"\"\"\n\n  if not isinstance(component, tuple):\n\n    return False\n\n\n\n  has_fields = bool(getattr(component, '_fields', None))\n\n  return has_fields\n\n\n\n\n\ndef GetClassAttrsDict(component):\n\n  \"\"\"Gets the attributes of the component class, as a dict with name keys.\"\"\"\n\n  if not inspect.isclass(component):\n\n    return None\n\n  class_attrs_list = inspect.classify_class_attrs(component)\n\n  return {\n\n      class_attr.name: class_attr\n\n      for class_attr in class_attrs_list\n\n  }\n\n\n\n\n\ndef IsCoroutineFunction(fn):\n\n  try:\n\n    return six.PY34 and asyncio.iscoroutinefunction(fn)\n\n  except:  # pylint: disable=bare-except\n\n    return False\n", "# Copyright (C) 2018 Google Inc.\n\n#\n\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n\n# you may not use this file except in compliance with the License.\n\n# You may obtain a copy of the License at\n\n#\n\n# http://www.apache.org/licenses/LICENSE-2.0\n\n#\n\n# Unless required by applicable law or agreed to in writing, software\n\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n\n# See the License for the specific language governing permissions and\n\n# limitations under the License.\n\n\n\n\"\"\"Python Fire test components Fire CLI.\n\n\n\nThis file is useful for replicating test results manually.\n\n\"\"\"\n\n\n\nfrom __future__ import absolute_import\n\nfrom __future__ import division\n\nfrom __future__ import print_function\n\n\n\nimport fire\n\nfrom fire import test_components\n\n\n\n\n\ndef main():\n\n  fire.Fire(test_components)\n\n\n\nif __name__ == '__main__':\n\n  main()\n", "# Copyright (C) 2018 Google Inc.\n\n#\n\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n\n# you may not use this file except in compliance with the License.\n\n# You may obtain a copy of the License at\n\n#\n\n# http://www.apache.org/licenses/LICENSE-2.0\n\n#\n\n# Unless required by applicable law or agreed to in writing, software\n\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n\n# See the License for the specific language governing permissions and\n\n# limitations under the License.\n\n\n\n\"\"\"Test using Fire via `python -m fire`.\"\"\"\n\n\n\nimport os\n\nimport tempfile\n\n\n\nfrom fire import __main__\n\nfrom fire import testutils\n\n\n\n\n\nclass MainModuleTest(testutils.BaseTestCase):\n\n  \"\"\"Tests to verify the behavior of __main__ (python -m fire).\"\"\"\n\n\n\n  def testNameSetting(self):\n\n    # Confirm one of the usage lines has the gettempdir member.\n\n    with self.assertOutputMatches('gettempdir'):\n\n      __main__.main(['__main__.py', 'tempfile'])\n\n\n\n  def testArgPassing(self):\n\n    expected = os.path.join('part1', 'part2', 'part3')\n\n    with self.assertOutputMatches('%s\\n' % expected):\n\n      __main__.main(\n\n          ['__main__.py', 'os.path', 'join', 'part1', 'part2', 'part3'])\n\n    with self.assertOutputMatches('%s\\n' % expected):\n\n      __main__.main(\n\n          ['__main__.py', 'os', 'path', '-', 'join', 'part1', 'part2', 'part3'])\n\n\n\n\n\nclass MainModuleFileTest(testutils.BaseTestCase):\n\n  \"\"\"Tests to verify correct import behavior for file executables.\"\"\"\n\n\n\n  def setUp(self):\n\n    super(MainModuleFileTest, self).setUp()\n\n    self.file = tempfile.NamedTemporaryFile(suffix='.py')\n\n    self.file.write(b'class Foo:\\n  def double(self, n):\\n    return 2 * n\\n')\n\n    self.file.flush()\n\n\n\n    self.file2 = tempfile.NamedTemporaryFile()\n\n\n\n  def testFileNameFire(self):\n\n    # Confirm that the file is correctly imported and doubles the number.\n\n    with self.assertOutputMatches('4'):\n\n      __main__.main(\n\n          ['__main__.py', self.file.name, 'Foo', 'double', '--n', '2'])\n\n\n\n  def testFileNameFailure(self):\n\n    # Confirm that an existing file without a .py suffix raises a ValueError.\n\n    with self.assertRaises(ValueError):\n\n      __main__.main(\n\n          ['__main__.py', self.file2.name, 'Foo', 'double', '--n', '2'])\n\n\n\n  def testFileNameModuleDuplication(self):\n\n    # Confirm that a file that masks a module still loads the module.\n\n    with self.assertOutputMatches('gettempdir'):\n\n      dirname = os.path.dirname(self.file.name)\n\n      with testutils.ChangeDirectory(dirname):\n\n        with open('tempfile', 'w'):\n\n          __main__.main([\n\n              '__main__.py',\n\n              'tempfile',\n\n          ])\n\n\n\n        os.remove('tempfile')\n\n\n\n  def testFileNameModuleFileFailure(self):\n\n    # Confirm that an invalid file that masks a non-existent module fails.\n\n    with self.assertRaisesRegex(ValueError,\n\n                                r'Fire can only be called on \\.py files\\.'):  # pylint: disable=line-too-long,  # pytype: disable=attribute-error\n\n      dirname = os.path.dirname(self.file.name)\n\n      with testutils.ChangeDirectory(dirname):\n\n        with open('foobar', 'w'):\n\n          __main__.main([\n\n              '__main__.py',\n\n              'foobar',\n\n          ])\n\n\n\n        os.remove('foobar')\n\n\n\n\n\nif __name__ == '__main__':\n\n  testutils.main()\n", "# Copyright (C) 2018 Google Inc.\n\n#\n\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n\n# you may not use this file except in compliance with the License.\n\n# You may obtain a copy of the License at\n\n#\n\n# http://www.apache.org/licenses/LICENSE-2.0\n\n#\n\n# Unless required by applicable law or agreed to in writing, software\n\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n\n# See the License for the specific language governing permissions and\n\n# limitations under the License.\n\n\n\n\"\"\"Custom descriptions and summaries for the builtin types.\n\n\n\nThe docstrings for objects of primitive types reflect the type of the object,\n\nrather than the object itself. For example, the docstring for any dict is this:\n\n\n\n> print({'key': 'value'}.__doc__)\n\ndict() -> new empty dictionary\n\ndict(mapping) -> new dictionary initialized from a mapping object's\n\n    (key, value) pairs\n\ndict(iterable) -> new dictionary initialized as if via:\n\n    d = {}\n\n    for k, v in iterable:\n\n        d[k] = v\n\ndict(**kwargs) -> new dictionary initialized with the name=value pairs\n\n    in the keyword argument list.  For example:  dict(one=1, two=2)\n\n\n\nAs you can see, this docstring is more pertinant to the function `dict` and\n\nwould be suitable as the result of `dict.__doc__`, but is wholely unsuitable\n\nas a description for the dict `{'key': 'value'}`.\n\n\n\nThis modules aims to resolve that problem, providing custom summaries and\n\ndescriptions for primitive typed values.\n\n\"\"\"\n\n\n\nfrom __future__ import absolute_import\n\nfrom __future__ import division\n\nfrom __future__ import print_function\n\n\n\nfrom fire import formatting\n\nimport six\n\n\n\nTWO_DOUBLE_QUOTES = '\"\"'\n\nSTRING_DESC_PREFIX = 'The string '\n\n\n\n\n\ndef NeedsCustomDescription(component):\n\n  \"\"\"Whether the component should use a custom description and summary.\n\n\n\n  Components of primitive type, such as ints, floats, dicts, lists, and others\n\n  have messy builtin docstrings. These are inappropriate for display as\n\n  descriptions and summaries in a CLI. This function determines whether the\n\n  provided component has one of these docstrings.\n\n\n\n  Note that an object such as `int` has the same docstring as an int like `3`.\n\n  The docstring is OK for `int`, but is inappropriate as a docstring for `3`.\n\n\n\n  Args:\n\n    component: The component of interest.\n\n  Returns:\n\n    Whether the component should use a custom description and summary.\n\n  \"\"\"\n\n  type_ = type(component)\n\n  if (type_ in six.string_types\n\n      or type_ in six.integer_types\n\n      or type_ is six.text_type\n\n      or type_ is six.binary_type\n\n      or type_ in (float, complex, bool)\n\n      or type_ in (dict, tuple, list, set, frozenset)\n\n     ):\n\n    return True\n\n  return False\n\n\n\n\n\ndef GetStringTypeSummary(obj, available_space, line_length):\n\n  \"\"\"Returns a custom summary for string type objects.\n\n\n\n  This function constructs a summary for string type objects by double quoting\n\n  the string value. The double quoted string value will be potentially truncated\n\n  with ellipsis depending on whether it has enough space available to show the\n\n  full string value.\n\n\n\n  Args:\n\n    obj: The object to generate summary for.\n\n    available_space: Number of character spaces available.\n\n    line_length: The full width of the terminal, default is 80.\n\n\n\n  Returns:\n\n    A summary for the input object.\n\n  \"\"\"\n\n  if len(obj) + len(TWO_DOUBLE_QUOTES) <= available_space:\n\n    content = obj\n\n  else:\n\n    additional_len_needed = len(TWO_DOUBLE_QUOTES) + len(formatting.ELLIPSIS)\n\n    if available_space < additional_len_needed:\n\n      available_space = line_length\n\n    content = formatting.EllipsisTruncate(\n\n        obj, available_space - len(TWO_DOUBLE_QUOTES), line_length)\n\n  return formatting.DoubleQuote(content)\n\n\n\n\n\ndef GetStringTypeDescription(obj, available_space, line_length):\n\n  \"\"\"Returns the predefined description for string obj.\n\n\n\n  This function constructs a description for string type objects in the format\n\n  of 'The string \"<string_value>\"'. <string_value> could be potentially\n\n  truncated depending on whether it has enough space available to show the full\n\n  string value.\n\n\n\n  Args:\n\n    obj: The object to generate description for.\n\n    available_space: Number of character spaces available.\n\n    line_length: The full width of the terminal, default if 80.\n\n\n\n  Returns:\n\n    A description for input object.\n\n  \"\"\"\n\n  additional_len_needed = len(STRING_DESC_PREFIX) + len(\n\n      TWO_DOUBLE_QUOTES) + len(formatting.ELLIPSIS)\n\n  if available_space < additional_len_needed:\n\n    available_space = line_length\n\n\n\n  return STRING_DESC_PREFIX + formatting.DoubleQuote(\n\n      formatting.EllipsisTruncate(\n\n          obj, available_space - len(STRING_DESC_PREFIX) -\n\n          len(TWO_DOUBLE_QUOTES), line_length))\n\n\n\n\n\nCUSTOM_DESC_SUM_FN_DICT = {\n\n    'str': (GetStringTypeSummary, GetStringTypeDescription),\n\n    'unicode': (GetStringTypeSummary, GetStringTypeDescription),\n\n}\n\n\n\n\n\ndef GetSummary(obj, available_space, line_length):\n\n  obj_type_name = type(obj).__name__\n\n  if obj_type_name in CUSTOM_DESC_SUM_FN_DICT.keys():\n\n    return CUSTOM_DESC_SUM_FN_DICT.get(obj_type_name)[0](obj, available_space,\n\n                                                         line_length)\n\n  return None\n\n\n\n\n\ndef GetDescription(obj, available_space, line_length):\n\n  obj_type_name = type(obj).__name__\n\n  if obj_type_name in CUSTOM_DESC_SUM_FN_DICT.keys():\n\n    return CUSTOM_DESC_SUM_FN_DICT.get(obj_type_name)[1](obj, available_space,\n\n                                                         line_length)\n\n  return None\n", "# Copyright (C) 2018 Google Inc.\n\n#\n\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n\n# you may not use this file except in compliance with the License.\n\n# You may obtain a copy of the License at\n\n#\n\n# http://www.apache.org/licenses/LICENSE-2.0\n\n#\n\n# Unless required by applicable law or agreed to in writing, software\n\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n\n# See the License for the specific language governing permissions and\n\n# limitations under the License.\n\n\n\n\"\"\"Types of values.\"\"\"\n\n\n\nfrom __future__ import absolute_import\n\nfrom __future__ import division\n\nfrom __future__ import print_function\n\n\n\nimport inspect\n\n\n\nfrom fire import inspectutils\n\nimport six\n\n\n\n\n\nVALUE_TYPES = (bool, six.string_types, six.integer_types, float, complex,\n\n               type(Ellipsis), type(None), type(NotImplemented))\n\n\n\n\n\ndef IsGroup(component):\n\n  # TODO(dbieber): Check if there are any subcomponents.\n\n  return not IsCommand(component) and not IsValue(component)\n\n\n\n\n\ndef IsCommand(component):\n\n  return inspect.isroutine(component) or inspect.isclass(component)\n\n\n\n\n\ndef IsValue(component):\n\n  return isinstance(component, VALUE_TYPES) or HasCustomStr(component)\n\n\n\n\n\ndef IsSimpleGroup(component):\n\n  \"\"\"If a group is simple enough, then we treat it as a value in PrintResult.\n\n\n\n  Only if a group contains all value types do we consider it simple enough to\n\n  print as a value.\n\n\n\n  Args:\n\n    component: The group to check for value-group status.\n\n  Returns:\n\n    A boolean indicating if the group should be treated as a value for printing\n\n    purposes.\n\n  \"\"\"\n\n  assert isinstance(component, dict)\n\n  for unused_key, value in component.items():\n\n    if not IsValue(value) and not isinstance(value, (list, dict)):\n\n      return False\n\n  return True\n\n\n\n\n\ndef HasCustomStr(component):\n\n  \"\"\"Determines if a component has a custom __str__ method.\n\n\n\n  Uses inspect.classify_class_attrs to determine the origin of the object's\n\n  __str__ method, if one is present. If it defined by `object` itself, then\n\n  it is not considered custom. Otherwise it is. This means that the __str__\n\n  methods of primitives like ints and floats are considered custom.\n\n\n\n  Objects with custom __str__ methods are treated as values and can be\n\n  serialized in places where more complex objects would have their help screen\n\n  shown instead.\n\n\n\n  Args:\n\n    component: The object to check for a custom __str__ method.\n\n  Returns:\n\n    Whether `component` has a custom __str__ method.\n\n  \"\"\"\n\n  if hasattr(component, '__str__'):\n\n    class_attrs = inspectutils.GetClassAttrsDict(type(component)) or {}\n\n    str_attr = class_attrs.get('__str__')\n\n    if str_attr and str_attr.defining_class is not object:\n\n      return True\n\n  return False\n", "# Copyright (C) 2018 Google Inc.\n\n#\n\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n\n# you may not use this file except in compliance with the License.\n\n# You may obtain a copy of the License at\n\n#\n\n# http://www.apache.org/licenses/LICENSE-2.0\n\n#\n\n# Unless required by applicable law or agreed to in writing, software\n\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n\n# See the License for the specific language governing permissions and\n\n# limitations under the License.\n\n\n\n\"\"\"Provides tab completion functionality for CLIs built with Fire.\"\"\"\n\n\n\nfrom __future__ import absolute_import\n\nfrom __future__ import division\n\nfrom __future__ import print_function\n\n\n\nimport collections\n\nimport copy\n\nimport inspect\n\n\n\nfrom fire import inspectutils\n\nimport six\n\n\n\n\n\ndef Script(name, component, default_options=None, shell='bash'):\n\n  if shell == 'fish':\n\n    return _FishScript(name, _Commands(component), default_options)\n\n  return _BashScript(name, _Commands(component), default_options)\n\n\n\n\n\ndef _BashScript(name, commands, default_options=None):\n\n  \"\"\"Returns a Bash script registering a completion function for the commands.\n\n\n\n  Args:\n\n    name: The first token in the commands, also the name of the command.\n\n    commands: A list of all possible commands that tab completion can complete\n\n        to. Each command is a list or tuple of the string tokens that make up\n\n        that command.\n\n    default_options: A dict of options that can be used with any command. Use\n\n        this if there are flags that can always be appended to a command.\n\n  Returns:\n\n    A string which is the Bash script. Source the bash script to enable tab\n\n    completion in Bash.\n\n  \"\"\"\n\n  default_options = default_options or set()\n\n  global_options, options_map, subcommands_map = _GetMaps(\n\n      name, commands, default_options\n\n  )\n\n\n\n  bash_completion_template = \"\"\"# bash completion support for {name}\n\n# DO NOT EDIT.\n\n# This script is autogenerated by fire/completion.py.\n\n\n\n_complete-{identifier}()\n\n{{\n\n  local cur prev opts lastcommand\n\n  COMPREPLY=()\n\n  prev=\"${{COMP_WORDS[COMP_CWORD-1]}}\"\n\n  cur=\"${{COMP_WORDS[COMP_CWORD]}}\"\n\n  lastcommand=$(get_lastcommand)\n\n\n\n  opts=\"{default_options}\"\n\n  GLOBAL_OPTIONS=\"{global_options}\"\n\n\n\n{checks}\n\n\n\n  COMPREPLY=( $(compgen -W \"${{opts}}\" -- ${{cur}}) )\n\n  return 0\n\n}}\n\n\n\nget_lastcommand()\n\n{{\n\n  local lastcommand i\n\n\n\n  lastcommand=\n\n  for ((i=0; i < ${{#COMP_WORDS[@]}}; ++i)); do\n\n    if [[ ${{COMP_WORDS[i]}} != -* ]] && [[ -n ${{COMP_WORDS[i]}} ]] && [[\n\n      ${{COMP_WORDS[i]}} != $cur ]]; then\n\n      lastcommand=${{COMP_WORDS[i]}}\n\n    fi\n\n  done\n\n\n\n  echo $lastcommand\n\n}}\n\n\n\nfilter_options()\n\n{{\n\n  local opts\n\n  opts=\"\"\n\n  for opt in \"$@\"\n\n  do\n\n    if ! option_already_entered $opt; then\n\n      opts=\"$opts $opt\"\n\n    fi\n\n  done\n\n\n\n  echo $opts\n\n}}\n\n\n\noption_already_entered()\n\n{{\n\n  local opt\n\n  for opt in ${{COMP_WORDS[@]:0:COMP_CWORD}}\n\n  do\n\n    if [ $1 == $opt ]; then\n\n      return 0\n\n    fi\n\n  done\n\n  return 1\n\n}}\n\n\n\nis_prev_global()\n\n{{\n\n  local opt\n\n  for opt in $GLOBAL_OPTIONS\n\n  do\n\n    if [ $opt == $prev ]; then\n\n      return 0\n\n    fi\n\n  done\n\n  return 1\n\n}}\n\n\n\ncomplete -F _complete-{identifier} {command}\n\n\"\"\"\n\n\n\n  check_wrapper = \"\"\"\n\n  case \"${{lastcommand}}\" in\n\n  {lastcommand_checks}\n\n  esac\"\"\"\n\n\n\n  lastcommand_check_template = \"\"\"\n\n    {command})\n\n      {opts_assignment}\n\n      opts=$(filter_options $opts)\n\n    ;;\"\"\"\n\n\n\n  opts_assignment_subcommand_template = \"\"\"\n\n      if is_prev_global; then\n\n        opts=\"${{GLOBAL_OPTIONS}}\"\n\n      else\n\n        opts=\"{options} ${{GLOBAL_OPTIONS}}\"\n\n      fi\"\"\"\n\n\n\n  opts_assignment_main_command_template = \"\"\"\n\n      opts=\"{options} ${{GLOBAL_OPTIONS}}\" \"\"\"\n\n\n\n  def _GetOptsAssignmentTemplate(command):\n\n    if command == name:\n\n      return opts_assignment_main_command_template\n\n    else:\n\n      return opts_assignment_subcommand_template\n\n\n\n  lines = []\n\n  for command in set(subcommands_map.keys()).union(set(options_map.keys())):\n\n    opts_assignment = _GetOptsAssignmentTemplate(command).format(\n\n        options=' '.join(\n\n            sorted(options_map[command].union(subcommands_map[command]))\n\n        ),\n\n    )\n\n    lines.append(\n\n        lastcommand_check_template.format(\n\n            command=command,\n\n            opts_assignment=opts_assignment)\n\n    )\n\n  lastcommand_checks = '\\n'.join(lines)\n\n\n\n  checks = check_wrapper.format(\n\n      lastcommand_checks=lastcommand_checks,\n\n  )\n\n\n\n  return (\n\n      bash_completion_template.format(\n\n          name=name,\n\n          command=name,\n\n          checks=checks,\n\n          default_options=' '.join(default_options),\n\n          identifier=name.replace('/', '').replace('.', '').replace(',', ''),\n\n          global_options=' '.join(global_options),\n\n      )\n\n  )\n\n\n\n\n\ndef _FishScript(name, commands, default_options=None):\n\n  \"\"\"Returns a Fish script registering a completion function for the commands.\n\n\n\n  Args:\n\n    name: The first token in the commands, also the name of the command.\n\n    commands: A list of all possible commands that tab completion can complete\n\n        to. Each command is a list or tuple of the string tokens that make up\n\n        that command.\n\n    default_options: A dict of options that can be used with any command. Use\n\n        this if there are flags that can always be appended to a command.\n\n  Returns:\n\n    A string which is the Fish script. Source the fish script to enable tab\n\n    completion in Fish.\n\n  \"\"\"\n\n  default_options = default_options or set()\n\n  global_options, options_map, subcommands_map = _GetMaps(\n\n      name, commands, default_options\n\n  )\n\n\n\n  fish_source = \"\"\"function __fish_using_command\n\n    set cmd (commandline -opc)\n\n    for i in (seq (count $cmd) 1)\n\n        switch $cmd[$i]\n\n        case \"-*\"\n\n        case \"*\"\n\n            if [ $cmd[$i] = $argv[1] ]\n\n                return 0\n\n            else\n\n                return 1\n\n            end\n\n        end\n\n    end\n\n    return 1\n\nend\n\n\n\nfunction __option_entered_check\n\n    set cmd (commandline -opc)\n\n    for i in (seq (count $cmd))\n\n        switch $cmd[$i]\n\n        case \"-*\"\n\n            if [ $cmd[$i] = $argv[1] ]\n\n                return 1\n\n            end\n\n        end\n\n    end\n\n    return 0\n\nend\n\n\n\nfunction __is_prev_global\n\n    set cmd (commandline -opc)\n\n    set global_options {global_options}\n\n    set prev (count $cmd)\n\n\n\n    for opt in $global_options\n\n        if [ \"--$opt\" = $cmd[$prev] ]\n\n            echo $prev\n\n            return 0\n\n        end\n\n    end\n\n    return 1\n\nend\n\n\n\n\"\"\"\n\n\n\n  subcommand_template = (\"complete -c {name} -n '__fish_using_command \"\n\n                         \"{command}' -f -a {subcommand}\\n\")\n\n  flag_template = (\"complete -c {name} -n \"\n\n                   \"'__fish_using_command {command};{prev_global_check} and \"\n\n                   \"__option_entered_check --{option}' -l {option}\\n\")\n\n\n\n  prev_global_check = ' and __is_prev_global;'\n\n  for command in set(subcommands_map.keys()).union(set(options_map.keys())):\n\n    for subcommand in subcommands_map[command]:\n\n      fish_source += subcommand_template.format(\n\n          name=name,\n\n          command=command,\n\n          subcommand=subcommand,\n\n      )\n\n\n\n    for option in options_map[command].union(global_options):\n\n      check_needed = command != name\n\n      fish_source += flag_template.format(\n\n          name=name,\n\n          command=command,\n\n          prev_global_check=prev_global_check if check_needed else '',\n\n          option=option.lstrip('--'),\n\n      )\n\n\n\n  return fish_source.format(\n\n      global_options=' '.join(\n\n          '\"{option}\"'.format(option=option)\n\n          for option in global_options\n\n      )\n\n  )\n\n\n\n\n\ndef MemberVisible(component, name, member, class_attrs=None, verbose=False):\n\n  \"\"\"Returns whether a member should be included in auto-completion or help.\n\n\n\n  Determines whether a member of an object with the specified name should be\n\n  included in auto-completion or help text(both usage and detailed help).\n\n\n\n  If the member name starts with '__', it will always be excluded. If it\n\n  starts with only one '_', it will be included for all non-string types. If\n\n  verbose is True, the members, including the private members, are included.\n\n\n\n  When not in verbose mode, some modules and functions are excluded as well.\n\n\n\n  Args:\n\n    component: The component containing the member.\n\n    name: The name of the member.\n\n    member: The member itself.\n\n    class_attrs: (optional) If component is a class, provide this as:\n\n      inspectutils.GetClassAttrsDict(component). If not provided, it will be\n\n      computed.\n\n    verbose: Whether to include private members.\n\n  Returns\n\n    A boolean value indicating whether the member should be included.\n\n  \"\"\"\n\n  if isinstance(name, six.string_types) and name.startswith('__'):\n\n    return False\n\n  if verbose:\n\n    return True\n\n  if (member is absolute_import\n\n      or member is division\n\n      or member is print_function):\n\n    return False\n\n  if isinstance(member, type(absolute_import)) and six.PY34:\n\n    return False\n\n  if inspect.ismodule(member) and member is six:\n\n    # TODO(dbieber): Determine more generally which modules to hide.\n\n    return False\n\n  if inspect.isclass(component):\n\n    # If class_attrs has not been provided, compute it.\n\n    if class_attrs is None:\n\n      class_attrs = inspectutils.GetClassAttrsDict(class_attrs) or {}\n\n    class_attr = class_attrs.get(name)\n\n    if class_attr:\n\n      # Methods and properties should only be accessible on instantiated\n\n      # objects, not on uninstantiated classes.\n\n      if class_attr.kind in ('method', 'property'):\n\n        return False\n\n      # Backward compatibility notes: Before Python 3.8, namedtuple attributes\n\n      # were properties. In Python 3.8, they have type tuplegetter.\n\n      tuplegetter = getattr(collections, '_tuplegetter', type(None))\n\n      if isinstance(class_attr.object, tuplegetter):\n\n        return False\n\n  if (six.PY2 and inspect.isfunction(component)\n\n      and name in ('func_closure', 'func_code', 'func_defaults',\n\n                   'func_dict', 'func_doc', 'func_globals', 'func_name')):\n\n    return False\n\n  if (six.PY2 and inspect.ismethod(component)\n\n      and name in ('im_class', 'im_func', 'im_self')):\n\n    return False\n\n  if isinstance(name, six.string_types):\n\n    return not name.startswith('_')\n\n  return True  # Default to including the member\n\n\n\n\n\ndef VisibleMembers(component, class_attrs=None, verbose=False):\n\n  \"\"\"Returns a list of the members of the given component.\n\n\n\n  If verbose is True, then members starting with _ (normally ignored) are\n\n  included.\n\n\n\n  Args:\n\n    component: The component whose members to list.\n\n    class_attrs: (optional) If component is a class, you may provide this as:\n\n      inspectutils.GetClassAttrsDict(component). If not provided, it will be\n\n      computed. If provided, this determines how class members will be treated\n\n      for visibility. In particular, methods are generally hidden for\n\n      non-instantiated classes, but if you wish them to be shown (e.g. for\n\n      completion scripts) then pass in a different class_attr for them.\n\n    verbose: Whether to include private members.\n\n  Returns:\n\n    A list of tuples (member_name, member) of all members of the component.\n\n  \"\"\"\n\n  if isinstance(component, dict):\n\n    members = component.items()\n\n  else:\n\n    members = inspect.getmembers(component)\n\n\n\n  # If class_attrs has not been provided, compute it.\n\n  if class_attrs is None:\n\n    class_attrs = inspectutils.GetClassAttrsDict(component)\n\n  return [\n\n      (member_name, member) for member_name, member in members\n\n      if MemberVisible(component, member_name, member, class_attrs=class_attrs,\n\n                       verbose=verbose)\n\n  ]\n\n\n\n\n\ndef _CompletionsFromArgs(fn_args):\n\n  \"\"\"Takes a list of fn args and returns a list of the fn's completion strings.\n\n\n\n  Args:\n\n    fn_args: A list of the args accepted by a function.\n\n  Returns:\n\n    A list of possible completion strings for that function.\n\n  \"\"\"\n\n  completions = []\n\n  for arg in fn_args:\n\n    arg = arg.replace('_', '-')\n\n    completions.append('--{arg}'.format(arg=arg))\n\n  return completions\n\n\n\n\n\ndef Completions(component, verbose=False):\n\n  \"\"\"Gives possible Fire command completions for the component.\n\n\n\n  A completion is a string that can be appended to a command to continue that\n\n  command. These are used for TAB-completions in Bash for Fire CLIs.\n\n\n\n  Args:\n\n    component: The component whose completions to list.\n\n    verbose: Whether to include all completions, even private members.\n\n  Returns:\n\n    A list of completions for a command that would so far return the component.\n\n  \"\"\"\n\n  if inspect.isroutine(component) or inspect.isclass(component):\n\n    spec = inspectutils.GetFullArgSpec(component)\n\n    return _CompletionsFromArgs(spec.args + spec.kwonlyargs)\n\n\n\n  if isinstance(component, (tuple, list)):\n\n    return [str(index) for index in range(len(component))]\n\n\n\n  if inspect.isgenerator(component):\n\n    # TODO(dbieber): There are currently no commands available for generators.\n\n    return []\n\n\n\n  return [\n\n      _FormatForCommand(member_name)\n\n      for member_name, _ in VisibleMembers(component, verbose=verbose)\n\n  ]\n\n\n\n\n\ndef _FormatForCommand(token):\n\n  \"\"\"Replaces underscores with hyphens, unless the token starts with a token.\n\n\n\n  This is because we typically prefer hyphens to underscores at the command\n\n  line, but we reserve hyphens at the start of a token for flags. This becomes\n\n  relevant when --verbose is activated, so that things like __str__ don't get\n\n  transformed into --str--, which would get confused for a flag.\n\n\n\n  Args:\n\n    token: The token to transform.\n\n  Returns:\n\n    The transformed token.\n\n  \"\"\"\n\n  if not isinstance(token, six.string_types):\n\n    token = str(token)\n\n\n\n  if token.startswith('_'):\n\n    return token\n\n\n\n  return token.replace('_', '-')\n\n\n\n\n\ndef _Commands(component, depth=3):\n\n  \"\"\"Yields tuples representing commands.\n\n\n\n  To use the command from Python, insert '.' between each element of the tuple.\n\n  To use the command from the command line, insert ' ' between each element of\n\n  the tuple.\n\n\n\n  Args:\n\n    component: The component considered to be the root of the yielded commands.\n\n    depth: The maximum depth with which to traverse the member DAG for commands.\n\n  Yields:\n\n    Tuples, each tuple representing one possible command for this CLI.\n\n    Only traverses the member DAG up to a depth of depth.\n\n  \"\"\"\n\n  if inspect.isroutine(component) or inspect.isclass(component):\n\n    for completion in Completions(component, verbose=False):\n\n      yield (completion,)\n\n  if inspect.isroutine(component):\n\n    return  # Don't descend into routines.\n\n\n\n  if depth < 1:\n\n    return\n\n\n\n  # By setting class_attrs={} we don't hide methods in completion.\n\n  for member_name, member in VisibleMembers(component, class_attrs={},\n\n                                            verbose=False):\n\n    # TODO(dbieber): Also skip components we've already seen.\n\n    member_name = _FormatForCommand(member_name)\n\n\n\n    yield (member_name,)\n\n\n\n    for command in _Commands(member, depth - 1):\n\n      yield (member_name,) + command\n\n\n\n\n\ndef _IsOption(arg):\n\n  return arg.startswith('-')\n\n\n\n\n\ndef _GetMaps(name, commands, default_options):\n\n  \"\"\"Returns sets of subcommands and options for each command.\n\n\n\n  Args:\n\n    name: The first token in the commands, also the name of the command.\n\n    commands: A list of all possible commands that tab completion can complete\n\n        to. Each command is a list or tuple of the string tokens that make up\n\n        that command.\n\n    default_options: A dict of options that can be used with any command. Use\n\n        this if there are flags that can always be appended to a command.\n\n  Returns:\n\n    global_options: A set of all options of the first token of the command.\n\n    subcommands_map: A dict storing set of subcommands for each\n\n        command/subcommand.\n\n    options_map: A dict storing set of options for each subcommand.\n\n  \"\"\"\n\n  global_options = copy.copy(default_options)\n\n  options_map = collections.defaultdict(lambda: copy.copy(default_options))\n\n  subcommands_map = collections.defaultdict(set)\n\n\n\n  for command in commands:\n\n    if len(command) == 1:\n\n      if _IsOption(command[0]):\n\n        global_options.add(command[0])\n\n      else:\n\n        subcommands_map[name].add(command[0])\n\n\n\n    elif command:\n\n      subcommand = command[-2]\n\n      arg = _FormatForCommand(command[-1])\n\n\n\n      if _IsOption(arg):\n\n        args_map = options_map\n\n      else:\n\n        args_map = subcommands_map\n\n\n\n      args_map[subcommand].add(arg)\n\n      args_map[subcommand.replace('_', '-')].add(arg)\n\n\n\n  return global_options, options_map, subcommands_map\n", "# Copyright (C) 2018 Google Inc.\n\n#\n\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n\n# you may not use this file except in compliance with the License.\n\n# You may obtain a copy of the License at\n\n#\n\n# http://www.apache.org/licenses/LICENSE-2.0\n\n#\n\n# Unless required by applicable law or agreed to in writing, software\n\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n\n# See the License for the specific language governing permissions and\n\n# limitations under the License.\n\n\n\n# Lint as: python2, python3\n\n# pylint: disable=invalid-name\n\n\"\"\"Enables use of Python Fire as a \"main\" function (i.e. \"python -m fire\").\n\n\n\nThis allows using Fire with third-party libraries without modifying their code.\n\n\"\"\"\n\n\n\nfrom __future__ import absolute_import\n\nfrom __future__ import division\n\nfrom __future__ import print_function\n\n\n\nimport importlib\n\nimport os\n\nimport sys\n\n\n\nimport fire\n\n\n\ncli_string = \"\"\"usage: python -m fire [module] [arg] ...\"\n\n\n\nPython Fire is a library for creating CLIs from absolutely any Python\n\nobject or program. To run Python Fire from the command line on an\n\nexisting Python file, it can be invoked with \"python -m fire [module]\"\n\nand passed a Python module using module notation:\n\n\n\n\"python -m fire packageA.packageB.module\"\n\n\n\nor with a file path:\n\n\n\n\"python -m fire packageA/packageB/module.py\" \"\"\"\n\n\n\n\n\ndef import_from_file_path(path):\n\n  \"\"\"Performs a module import given the filename.\n\n\n\n  Args:\n\n    path (str): the path to the file to be imported.\n\n\n\n  Raises:\n\n    IOError: if the given file does not exist or importlib fails to load it.\n\n\n\n  Returns:\n\n    Tuple[ModuleType, str]: returns the imported module and the module name,\n\n      usually extracted from the path itself.\n\n  \"\"\"\n\n\n\n  if not os.path.exists(path):\n\n    raise IOError('Given file path does not exist.')\n\n\n\n  module_name = os.path.basename(path)\n\n\n\n  if sys.version_info.major == 3 and sys.version_info.minor < 5:\n\n    loader = importlib.machinery.SourceFileLoader(  # pylint: disable=no-member\n\n        fullname=module_name,\n\n        path=path,\n\n    )\n\n\n\n    module = loader.load_module(module_name)  # pylint: disable=deprecated-method\n\n\n\n  elif sys.version_info.major == 3:\n\n    from importlib import util  # pylint: disable=g-import-not-at-top,import-outside-toplevel,no-name-in-module\n\n    spec = util.spec_from_file_location(module_name, path)\n\n\n\n    if spec is None:\n\n      raise IOError('Unable to load module from specified path.')\n\n\n\n    module = util.module_from_spec(spec)  # pylint: disable=no-member\n\n    spec.loader.exec_module(module)  # pytype: disable=attribute-error\n\n\n\n  else:\n\n    import imp  # pylint: disable=g-import-not-at-top,import-outside-toplevel\n\n    module = imp.load_source(module_name, path)\n\n\n\n  return module, module_name\n\n\n\n\n\ndef import_from_module_name(module_name):\n\n  \"\"\"Imports a module and returns it and its name.\"\"\"\n\n  module = importlib.import_module(module_name)\n\n  return module, module_name\n\n\n\n\n\ndef import_module(module_or_filename):\n\n  \"\"\"Imports a given module or filename.\n\n\n\n  If the module_or_filename exists in the file system and ends with .py, we\n\n  attempt to import it. If that import fails, try to import it as a module.\n\n\n\n  Args:\n\n    module_or_filename (str): string name of path or module.\n\n\n\n  Raises:\n\n    ValueError: if the given file is invalid.\n\n    IOError: if the file or module can not be found or imported.\n\n\n\n  Returns:\n\n    Tuple[ModuleType, str]: returns the imported module and the module name,\n\n      usually extracted from the path itself.\n\n  \"\"\"\n\n\n\n  if os.path.exists(module_or_filename):\n\n    # importlib.util.spec_from_file_location requires .py\n\n    if not module_or_filename.endswith('.py'):\n\n      try:  # try as module instead\n\n        return import_from_module_name(module_or_filename)\n\n      except ImportError:\n\n        raise ValueError('Fire can only be called on .py files.')\n\n\n\n    return import_from_file_path(module_or_filename)\n\n\n\n  if os.path.sep in module_or_filename:  # Use / to detect if it was a filename.\n\n    raise IOError('Fire was passed a filename which could not be found.')\n\n\n\n  return import_from_module_name(module_or_filename)  # Assume it's a module.\n\n\n\n\n\ndef main(args):\n\n  \"\"\"Entrypoint for fire when invoked as a module with python -m fire.\"\"\"\n\n\n\n  if len(args) < 2:\n\n    print(cli_string)\n\n    sys.exit(1)\n\n\n\n  module_or_filename = args[1]\n\n  module, module_name = import_module(module_or_filename)\n\n\n\n  fire.Fire(module, name=module_name, command=args[2:])\n\n\n\n\n\nif __name__ == '__main__':\n\n  main(sys.argv)\n", "# Copyright (C) 2018 Google Inc.\n\n#\n\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n\n# you may not use this file except in compliance with the License.\n\n# You may obtain a copy of the License at\n\n#\n\n# http://www.apache.org/licenses/LICENSE-2.0\n\n#\n\n# Unless required by applicable law or agreed to in writing, software\n\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n\n# See the License for the specific language governing permissions and\n\n# limitations under the License.\n\n\n\n\"\"\"This module is used for enabling formatting on Windows.\"\"\"\n\n\n\nfrom __future__ import absolute_import\n\nfrom __future__ import division\n\nfrom __future__ import print_function\n\n\n\nimport ctypes\n\nimport os\n\nimport platform\n\nimport subprocess\n\nimport sys\n\n\n\ntry:\n\n  import colorama  # pylint: disable=g-import-not-at-top,  # pytype: disable=import-error\n\n  HAS_COLORAMA = True\n\nexcept ImportError:\n\n  HAS_COLORAMA = False\n\n\n\n\n\ndef initialize_or_disable():\n\n  \"\"\"Enables ANSI processing on Windows or disables it as needed.\"\"\"\n\n  if HAS_COLORAMA:\n\n    wrap = True\n\n    if sys.stdout.isatty() and platform.release() == '10':\n\n      # Enables native ANSI sequences in console.\n\n      # Windows 10, 2016, and 2019 only.\n\n\n\n      wrap = False\n\n      kernel32 = ctypes.windll.kernel32  # pytype: disable=module-attr\n\n      enable_virtual_terminal_processing = 0x04\n\n      out_handle = kernel32.GetStdHandle(subprocess.STD_OUTPUT_HANDLE)  # pylint: disable=line-too-long,  # pytype: disable=module-attr\n\n      # GetConsoleMode fails if the terminal isn't native.\n\n      mode = ctypes.wintypes.DWORD()\n\n      if kernel32.GetConsoleMode(out_handle, ctypes.byref(mode)) == 0:\n\n        wrap = True\n\n      if not mode.value & enable_virtual_terminal_processing:\n\n        if kernel32.SetConsoleMode(\n\n            out_handle, mode.value | enable_virtual_terminal_processing) == 0:\n\n          # kernel32.SetConsoleMode to enable ANSI sequences failed\n\n          wrap = True\n\n    colorama.init(wrap=wrap)\n\n  else:\n\n    os.environ['ANSI_COLORS_DISABLED'] = '1'\n\n\n\nif sys.platform.startswith('win'):\n\n  initialize_or_disable()\n", "# Copyright (C) 2018 Google Inc.\n\n#\n\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n\n# you may not use this file except in compliance with the License.\n\n# You may obtain a copy of the License at\n\n#\n\n# http://www.apache.org/licenses/LICENSE-2.0\n\n#\n\n# Unless required by applicable law or agreed to in writing, software\n\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n\n# See the License for the specific language governing permissions and\n\n# limitations under the License.\n\n\n\n\"\"\"Tests for the completion module.\"\"\"\n\n\n\nfrom __future__ import absolute_import\n\nfrom __future__ import division\n\nfrom __future__ import print_function\n\n\n\nfrom fire import completion\n\nfrom fire import test_components as tc\n\nfrom fire import testutils\n\n\n\n\n\nclass TabCompletionTest(testutils.BaseTestCase):\n\n\n\n  def testCompletionBashScript(self):\n\n    # A sanity check test to make sure the bash completion script satisfies\n\n    # some basic assumptions.\n\n    commands = [\n\n        ['run'],\n\n        ['halt'],\n\n        ['halt', '--now'],\n\n    ]\n\n    script = completion._BashScript(name='command', commands=commands)  # pylint: disable=protected-access\n\n    self.assertIn('command', script)\n\n    self.assertIn('halt', script)\n\n\n\n    assert_template = '{command})'\n\n    for last_command in ['command', 'halt']:\n\n      self.assertIn(assert_template.format(command=last_command), script)\n\n\n\n  def testCompletionFishScript(self):\n\n    # A sanity check test to make sure the fish completion script satisfies\n\n    # some basic assumptions.\n\n    commands = [\n\n        ['run'],\n\n        ['halt'],\n\n        ['halt', '--now'],\n\n    ]\n\n    script = completion._FishScript(name='command', commands=commands)  # pylint: disable=protected-access\n\n    self.assertIn('command', script)\n\n    self.assertIn('halt', script)\n\n    self.assertIn('-l now', script)\n\n\n\n  def testFnCompletions(self):\n\n    def example(one, two, three):\n\n      return one, two, three\n\n\n\n    completions = completion.Completions(example)\n\n    self.assertIn('--one', completions)\n\n    self.assertIn('--two', completions)\n\n    self.assertIn('--three', completions)\n\n\n\n  def testListCompletions(self):\n\n    completions = completion.Completions(['red', 'green', 'blue'])\n\n    self.assertIn('0', completions)\n\n    self.assertIn('1', completions)\n\n    self.assertIn('2', completions)\n\n    self.assertNotIn('3', completions)\n\n\n\n  def testDictCompletions(self):\n\n    colors = {\n\n        'red': 'green',\n\n        'blue': 'yellow',\n\n        '_rainbow': True,\n\n    }\n\n    completions = completion.Completions(colors)\n\n    self.assertIn('red', completions)\n\n    self.assertIn('blue', completions)\n\n    self.assertNotIn('green', completions)\n\n    self.assertNotIn('yellow', completions)\n\n    self.assertNotIn('_rainbow', completions)\n\n    self.assertNotIn('True', completions)\n\n    self.assertNotIn(True, completions)\n\n\n\n  def testDictCompletionsVerbose(self):\n\n    colors = {\n\n        'red': 'green',\n\n        'blue': 'yellow',\n\n        '_rainbow': True,\n\n    }\n\n    completions = completion.Completions(colors, verbose=True)\n\n    self.assertIn('red', completions)\n\n    self.assertIn('blue', completions)\n\n    self.assertNotIn('green', completions)\n\n    self.assertNotIn('yellow', completions)\n\n    self.assertIn('_rainbow', completions)\n\n    self.assertNotIn('True', completions)\n\n    self.assertNotIn(True, completions)\n\n\n\n  def testDeepDictCompletions(self):\n\n    deepdict = {'level1': {'level2': {'level3': {'level4': {}}}}}\n\n    completions = completion.Completions(deepdict)\n\n    self.assertIn('level1', completions)\n\n    self.assertNotIn('level2', completions)\n\n\n\n  def testDeepDictScript(self):\n\n    deepdict = {'level1': {'level2': {'level3': {'level4': {}}}}}\n\n    script = completion.Script('deepdict', deepdict)\n\n    self.assertIn('level1', script)\n\n    self.assertIn('level2', script)\n\n    self.assertIn('level3', script)\n\n    self.assertNotIn('level4', script)  # The default depth is 3.\n\n\n\n  def testFnScript(self):\n\n    script = completion.Script('identity', tc.identity)\n\n    self.assertIn('--arg1', script)\n\n    self.assertIn('--arg2', script)\n\n    self.assertIn('--arg3', script)\n\n    self.assertIn('--arg4', script)\n\n\n\n  def testClassScript(self):\n\n    script = completion.Script('', tc.MixedDefaults)\n\n    self.assertIn('ten', script)\n\n    self.assertIn('sum', script)\n\n    self.assertIn('identity', script)\n\n    self.assertIn('--alpha', script)\n\n    self.assertIn('--beta', script)\n\n\n\n  def testDeepDictFishScript(self):\n\n    deepdict = {'level1': {'level2': {'level3': {'level4': {}}}}}\n\n    script = completion.Script('deepdict', deepdict, shell='fish')\n\n    self.assertIn('level1', script)\n\n    self.assertIn('level2', script)\n\n    self.assertIn('level3', script)\n\n    self.assertNotIn('level4', script)  # The default depth is 3.\n\n\n\n  def testFnFishScript(self):\n\n    script = completion.Script('identity', tc.identity, shell='fish')\n\n    self.assertIn('arg1', script)\n\n    self.assertIn('arg2', script)\n\n    self.assertIn('arg3', script)\n\n    self.assertIn('arg4', script)\n\n\n\n  def testClassFishScript(self):\n\n    script = completion.Script('', tc.MixedDefaults, shell='fish')\n\n    self.assertIn('ten', script)\n\n    self.assertIn('sum', script)\n\n    self.assertIn('identity', script)\n\n    self.assertIn('alpha', script)\n\n    self.assertIn('beta', script)\n\n\n\n  def testNonStringDictCompletions(self):\n\n    completions = completion.Completions({\n\n        10: 'green',\n\n        3.14: 'yellow',\n\n        ('t1', 't2'): 'pink',\n\n    })\n\n    self.assertIn('10', completions)\n\n    self.assertIn('3.14', completions)\n\n    self.assertIn(\"('t1', 't2')\", completions)\n\n    self.assertNotIn('green', completions)\n\n    self.assertNotIn('yellow', completions)\n\n    self.assertNotIn('pink', completions)\n\n\n\n  def testGeneratorCompletions(self):\n\n    def generator():\n\n      x = 0\n\n      while True:\n\n        yield x\n\n        x += 1\n\n    completions = completion.Completions(generator())\n\n    self.assertEqual(completions, [])\n\n\n\n  def testClassCompletions(self):\n\n    completions = completion.Completions(tc.NoDefaults)\n\n    self.assertEqual(completions, [])\n\n\n\n  def testObjectCompletions(self):\n\n    completions = completion.Completions(tc.NoDefaults())\n\n    self.assertIn('double', completions)\n\n    self.assertIn('triple', completions)\n\n\n\n  def testMethodCompletions(self):\n\n    completions = completion.Completions(tc.NoDefaults().double)\n\n    self.assertNotIn('--self', completions)\n\n    self.assertIn('--count', completions)\n\n\n\n\n\nif __name__ == '__main__':\n\n  testutils.main()\n", "# Copyright (C) 2018 Google Inc.\n\n#\n\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n\n# you may not use this file except in compliance with the License.\n\n# You may obtain a copy of the License at\n\n#\n\n# http://www.apache.org/licenses/LICENSE-2.0\n\n#\n\n# Unless required by applicable law or agreed to in writing, software\n\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n\n# See the License for the specific language governing permissions and\n\n# limitations under the License.\n\n\n\n\"\"\"Tests for the interact module.\"\"\"\n\n\n\nfrom __future__ import absolute_import\n\nfrom __future__ import division\n\nfrom __future__ import print_function\n\n\n\nfrom fire import interact\n\nfrom fire import testutils\n\n\n\nimport mock\n\n\n\n\n\ntry:\n\n  import IPython  # pylint: disable=unused-import, g-import-not-at-top\n\n  INTERACT_METHOD = 'IPython.start_ipython'\n\nexcept ImportError:\n\n  INTERACT_METHOD = 'code.InteractiveConsole'\n\n\n\n\n\nclass InteractTest(testutils.BaseTestCase):\n\n\n\n  @mock.patch(INTERACT_METHOD)\n\n  def testInteract(self, mock_interact_method):\n\n    self.assertFalse(mock_interact_method.called)\n\n    interact.Embed({})\n\n    self.assertTrue(mock_interact_method.called)\n\n\n\n  @mock.patch(INTERACT_METHOD)\n\n  def testInteractVariables(self, mock_interact_method):\n\n    self.assertFalse(mock_interact_method.called)\n\n    interact.Embed({\n\n        'count': 10,\n\n        'mock': mock,\n\n    })\n\n    self.assertTrue(mock_interact_method.called)\n\n\n\nif __name__ == '__main__':\n\n  testutils.main()\n", "# Copyright (C) 2018 Google Inc.\n\n#\n\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n\n# you may not use this file except in compliance with the License.\n\n# You may obtain a copy of the License at\n\n#\n\n# http://www.apache.org/licenses/LICENSE-2.0\n\n#\n\n# Unless required by applicable law or agreed to in writing, software\n\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n\n# See the License for the specific language governing permissions and\n\n# limitations under the License.\n\n\n\n\"\"\"Tests importing the fire module.\"\"\"\n\n\n\nimport sys\n\n\n\nimport fire\n\nfrom fire import testutils\n\nimport mock\n\n\n\n\n\nclass FireImportTest(testutils.BaseTestCase):\n\n  \"\"\"Tests importing Fire.\"\"\"\n\n\n\n  def testFire(self):\n\n    with mock.patch.object(sys, 'argv', ['commandname']):\n\n      fire.Fire()\n\n\n\n  def testFireMethods(self):\n\n    self.assertIsNotNone(fire.Fire)\n\n\n\n  def testNoPrivateMethods(self):\n\n    self.assertTrue(hasattr(fire, 'Fire'))\n\n    self.assertFalse(hasattr(fire, '_Fire'))\n\n\n\n\n\nif __name__ == '__main__':\n\n  testutils.main()\n", "# Copyright (C) 2018 Google Inc.\n\n#\n\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n\n# you may not use this file except in compliance with the License.\n\n# You may obtain a copy of the License at\n\n#\n\n# http://www.apache.org/licenses/LICENSE-2.0\n\n#\n\n# Unless required by applicable law or agreed to in writing, software\n\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n\n# See the License for the specific language governing permissions and\n\n# limitations under the License.\n\n\n\n\"\"\"Utilities for producing help strings for use in Fire CLIs.\n\n\n\nCan produce help strings suitable for display in Fire CLIs for any type of\n\nPython object, module, class, or function.\n\n\n\nThere are two types of informative strings: Usage and Help screens.\n\n\n\nUsage screens are shown when the user accesses a group or accesses a command\n\nwithout calling it. A Usage screen shows information about how to use that group\n\nor command. Usage screens are typically short and show the minimal information\n\nnecessary for the user to determine how to proceed.\n\n\n\nHelp screens are shown when the user requests help with the help flag (--help).\n\nHelp screens are shown in a less-style console view, and contain detailed help\n\ninformation.\n\n\"\"\"\n\n\n\nfrom __future__ import absolute_import\n\nfrom __future__ import division\n\nfrom __future__ import print_function\n\n\n\nimport itertools\n\nimport sys\n\n\n\nfrom fire import completion\n\nfrom fire import custom_descriptions\n\nfrom fire import decorators\n\nfrom fire import docstrings\n\nfrom fire import formatting\n\nfrom fire import inspectutils\n\nfrom fire import value_types\n\n\n\nLINE_LENGTH = 80\n\nSECTION_INDENTATION = 4\n\nSUBSECTION_INDENTATION = 4\n\n\n\n\n\ndef HelpText(component, trace=None, verbose=False):\n\n  \"\"\"Gets the help string for the current component, suitable for a help screen.\n\n\n\n  Args:\n\n    component: The component to construct the help string for.\n\n    trace: The Fire trace of the command so far. The command executed so far\n\n      can be extracted from this trace.\n\n    verbose: Whether to include private members in the help screen.\n\n\n\n  Returns:\n\n    The full help screen as a string.\n\n  \"\"\"\n\n  # Preprocessing needed to create the sections:\n\n  info = inspectutils.Info(component)\n\n  actions_grouped_by_kind = _GetActionsGroupedByKind(component, verbose=verbose)\n\n  spec = inspectutils.GetFullArgSpec(component)\n\n  metadata = decorators.GetMetadata(component)\n\n\n\n  # Sections:\n\n  name_section = _NameSection(component, info, trace=trace, verbose=verbose)\n\n  synopsis_section = _SynopsisSection(\n\n      component, actions_grouped_by_kind, spec, metadata, trace=trace)\n\n  description_section = _DescriptionSection(component, info)\n\n  # TODO(dbieber): Add returns and raises sections for functions.\n\n\n\n  if callable(component):\n\n    args_and_flags_sections, notes_sections = _ArgsAndFlagsSections(\n\n        info, spec, metadata)\n\n  else:\n\n    args_and_flags_sections = []\n\n    notes_sections = []\n\n  usage_details_sections = _UsageDetailsSections(component,\n\n                                                 actions_grouped_by_kind)\n\n\n\n  sections = (\n\n      [name_section, synopsis_section, description_section]\n\n      + args_and_flags_sections\n\n      + usage_details_sections\n\n      + notes_sections\n\n  )\n\n  return '\\n\\n'.join(\n\n      _CreateOutputSection(*section)\n\n      for section in sections if section is not None\n\n  )\n\n\n\n\n\ndef _NameSection(component, info, trace=None, verbose=False):\n\n  \"\"\"The \"Name\" section of the help string.\"\"\"\n\n\n\n  # Only include separators in the name in verbose mode.\n\n  current_command = _GetCurrentCommand(trace, include_separators=verbose)\n\n  summary = _GetSummary(info)\n\n\n\n  # If the docstring is one of the messy builtin docstrings, show custom one.\n\n  if custom_descriptions.NeedsCustomDescription(component):\n\n    available_space = LINE_LENGTH - SECTION_INDENTATION - len(current_command +\n\n                                                              ' - ')\n\n    summary = custom_descriptions.GetSummary(component, available_space,\n\n                                             LINE_LENGTH)\n\n\n\n  if summary:\n\n    text = current_command + ' - ' + summary\n\n  else:\n\n    text = current_command\n\n  return ('NAME', text)\n\n\n\n\n\ndef _SynopsisSection(component, actions_grouped_by_kind, spec, metadata,\n\n                     trace=None):\n\n  \"\"\"The \"Synopsis\" section of the help string.\"\"\"\n\n  current_command = _GetCurrentCommand(trace=trace, include_separators=True)\n\n\n\n  possible_actions = _GetPossibleActions(actions_grouped_by_kind)\n\n\n\n  continuations = []\n\n  if possible_actions:\n\n    continuations.append(_GetPossibleActionsString(possible_actions))\n\n  if callable(component):\n\n    callable_continuation = _GetArgsAndFlagsString(spec, metadata)\n\n    if callable_continuation:\n\n      continuations.append(callable_continuation)\n\n    elif trace:\n\n      # This continuation might be blank if no args are needed.\n\n      # In this case, show a separator.\n\n      continuations.append(trace.separator)\n\n  continuation = ' | '.join(continuations)\n\n\n\n  synopsis_template = '{current_command} {continuation}'\n\n  text = synopsis_template.format(\n\n      current_command=current_command,\n\n      continuation=continuation)\n\n\n\n  return ('SYNOPSIS', text)\n\n\n\n\n\ndef _DescriptionSection(component, info):\n\n  \"\"\"The \"Description\" sections of the help string.\n\n\n\n  Args:\n\n    component: The component to produce the description section for.\n\n    info: The info dict for the component of interest.\n\n\n\n  Returns:\n\n    Returns the description if available. If not, returns the summary.\n\n    If neither are available, returns None.\n\n  \"\"\"\n\n  if custom_descriptions.NeedsCustomDescription(component):\n\n    available_space = LINE_LENGTH - SECTION_INDENTATION\n\n    description = custom_descriptions.GetDescription(component, available_space,\n\n                                                     LINE_LENGTH)\n\n    summary = custom_descriptions.GetSummary(component, available_space,\n\n                                             LINE_LENGTH)\n\n  else:\n\n    description = _GetDescription(info)\n\n    summary = _GetSummary(info)\n\n  # Fall back to summary if description is not available.\n\n  text = description or summary or None\n\n  if text:\n\n    return ('DESCRIPTION', text)\n\n  else:\n\n    return None\n\n\n\n\n\ndef _CreateKeywordOnlyFlagItem(flag, docstring_info, spec):\n\n  return _CreateFlagItem(\n\n      flag, docstring_info, spec, required=flag not in spec.kwonlydefaults)\n\n\n\n\n\ndef _ArgsAndFlagsSections(info, spec, metadata):\n\n  \"\"\"The \"Args and Flags\" sections of the help string.\"\"\"\n\n  args_with_no_defaults = spec.args[:len(spec.args) - len(spec.defaults)]\n\n  args_with_defaults = spec.args[len(spec.args) - len(spec.defaults):]\n\n\n\n  # Check if positional args are allowed. If not, require flag syntax for args.\n\n  accepts_positional_args = metadata.get(decorators.ACCEPTS_POSITIONAL_ARGS)\n\n\n\n  args_and_flags_sections = []\n\n  notes_sections = []\n\n\n\n  docstring_info = info['docstring_info']\n\n\n\n  arg_items = [\n\n      _CreateArgItem(arg, docstring_info, spec)\n\n      for arg in args_with_no_defaults\n\n  ]\n\n\n\n  if spec.varargs:\n\n    arg_items.append(\n\n        _CreateArgItem(spec.varargs, docstring_info, spec)\n\n    )\n\n\n\n  if arg_items:\n\n    title = 'POSITIONAL ARGUMENTS' if accepts_positional_args else 'ARGUMENTS'\n\n    arguments_section = (title, '\\n'.join(arg_items).rstrip('\\n'))\n\n    args_and_flags_sections.append(arguments_section)\n\n    if args_with_no_defaults and accepts_positional_args:\n\n      notes_sections.append(\n\n          ('NOTES', 'You can also use flags syntax for POSITIONAL ARGUMENTS')\n\n      )\n\n\n\n  positional_flag_items = [\n\n      _CreateFlagItem(flag, docstring_info, spec, required=False)\n\n      for flag in args_with_defaults\n\n  ]\n\n  kwonly_flag_items = [\n\n      _CreateKeywordOnlyFlagItem(flag, docstring_info, spec)\n\n      for flag in spec.kwonlyargs\n\n  ]\n\n  flag_items = positional_flag_items + kwonly_flag_items\n\n\n\n  if spec.varkw:\n\n    # Include kwargs documented via :key param:\n\n    flag_string = '--{name}'\n\n    documented_kwargs = []\n\n    for flag in docstring_info.args or []:\n\n      if isinstance(flag, docstrings.KwargInfo):\n\n        flag_item = _CreateFlagItem(\n\n            flag.name, docstring_info, spec,\n\n            flag_string=flag_string.format(name=flag.name))\n\n        documented_kwargs.append(flag_item)\n\n    if documented_kwargs:\n\n      # Separate documented kwargs from other flags using a message\n\n      if flag_items:\n\n        message = 'The following flags are also accepted.'\n\n        item = _CreateItem(message, None, indent=4)\n\n        flag_items.append(item)\n\n      flag_items.extend(documented_kwargs)\n\n\n\n    description = _GetArgDescription(spec.varkw, docstring_info)\n\n    if documented_kwargs:\n\n      message = 'Additional undocumented flags may also be accepted.'\n\n    elif flag_items:\n\n      message = 'Additional flags are accepted.'\n\n    else:\n\n      message = 'Flags are accepted.'\n\n    item = _CreateItem(message, description, indent=4)\n\n    flag_items.append(item)\n\n\n\n  if flag_items:\n\n    flags_section = ('FLAGS', '\\n'.join(flag_items))\n\n    args_and_flags_sections.append(flags_section)\n\n\n\n  return args_and_flags_sections, notes_sections\n\n\n\n\n\ndef _UsageDetailsSections(component, actions_grouped_by_kind):\n\n  \"\"\"The usage details sections of the help string.\"\"\"\n\n  groups, commands, values, indexes = actions_grouped_by_kind\n\n\n\n  sections = []\n\n  if groups.members:\n\n    sections.append(_MakeUsageDetailsSection(groups))\n\n  if commands.members:\n\n    sections.append(_MakeUsageDetailsSection(commands))\n\n  if values.members:\n\n    sections.append(_ValuesUsageDetailsSection(component, values))\n\n  if indexes.members:\n\n    sections.append(('INDEXES', _NewChoicesSection('INDEX', indexes.names)))\n\n\n\n  return sections\n\n\n\n\n\ndef _GetSummary(info):\n\n  docstring_info = info['docstring_info']\n\n  return docstring_info.summary if docstring_info.summary else None\n\n\n\n\n\ndef _GetDescription(info):\n\n  docstring_info = info['docstring_info']\n\n  return docstring_info.description if docstring_info.description else None\n\n\n\n\n\ndef _GetArgsAndFlagsString(spec, metadata):\n\n  \"\"\"The args and flags string for showing how to call a function.\n\n\n\n  If positional arguments are accepted, the args will be shown as positional.\n\n  E.g. \"ARG1 ARG2 [--flag=FLAG]\"\n\n\n\n  If positional arguments are disallowed, the args will be shown with flags\n\n  syntax.\n\n  E.g. \"--arg1=ARG1 [--flag=FLAG]\"\n\n\n\n  Args:\n\n    spec: The full arg spec for the component to construct the args and flags\n\n      string for.\n\n    metadata: Metadata for the component, including whether it accepts\n\n      positional arguments.\n\n\n\n  Returns:\n\n    The constructed args and flags string.\n\n  \"\"\"\n\n  args_with_no_defaults = spec.args[:len(spec.args) - len(spec.defaults)]\n\n  args_with_defaults = spec.args[len(spec.args) - len(spec.defaults):]\n\n\n\n  # Check if positional args are allowed. If not, require flag syntax for args.\n\n  accepts_positional_args = metadata.get(decorators.ACCEPTS_POSITIONAL_ARGS)\n\n\n\n  arg_and_flag_strings = []\n\n  if args_with_no_defaults:\n\n    if accepts_positional_args:\n\n      arg_strings = [formatting.Underline(arg.upper())\n\n                     for arg in args_with_no_defaults]\n\n    else:\n\n      arg_strings = [\n\n          '--{arg}={arg_upper}'.format(\n\n              arg=arg, arg_upper=formatting.Underline(arg.upper()))\n\n          for arg in args_with_no_defaults]\n\n    arg_and_flag_strings.extend(arg_strings)\n\n\n\n  # If there are any arguments that are treated as flags:\n\n  if args_with_defaults or spec.kwonlyargs or spec.varkw:\n\n    arg_and_flag_strings.append('<flags>')\n\n\n\n  if spec.varargs:\n\n    varargs_string = '[{varargs}]...'.format(\n\n        varargs=formatting.Underline(spec.varargs.upper()))\n\n    arg_and_flag_strings.append(varargs_string)\n\n\n\n  return ' '.join(arg_and_flag_strings)\n\n\n\n\n\ndef _GetPossibleActions(actions_grouped_by_kind):\n\n  \"\"\"The list of possible action kinds.\"\"\"\n\n  possible_actions = []\n\n  for action_group in actions_grouped_by_kind:\n\n    if action_group.members:\n\n      possible_actions.append(action_group.name)\n\n  return possible_actions\n\n\n\n\n\ndef _GetPossibleActionsString(possible_actions):\n\n  \"\"\"A help screen string listing the possible action kinds available.\"\"\"\n\n  return ' | '.join(formatting.Underline(action.upper())\n\n                    for action in possible_actions)\n\n\n\n\n\ndef _GetActionsGroupedByKind(component, verbose=False):\n\n  \"\"\"Gets lists of available actions, grouped by action kind.\"\"\"\n\n  groups = ActionGroup(name='group', plural='groups')\n\n  commands = ActionGroup(name='command', plural='commands')\n\n  values = ActionGroup(name='value', plural='values')\n\n  indexes = ActionGroup(name='index', plural='indexes')\n\n\n\n  members = completion.VisibleMembers(component, verbose=verbose)\n\n  for member_name, member in members:\n\n    member_name = str(member_name)\n\n    if value_types.IsGroup(member):\n\n      groups.Add(name=member_name, member=member)\n\n    if value_types.IsCommand(member):\n\n      commands.Add(name=member_name, member=member)\n\n    if value_types.IsValue(member):\n\n      values.Add(name=member_name, member=member)\n\n\n\n  if isinstance(component, (list, tuple)) and component:\n\n    component_len = len(component)\n\n    if component_len < 10:\n\n      indexes.Add(name=', '.join(str(x) for x in range(component_len)))\n\n    else:\n\n      indexes.Add(name='0..{max}'.format(max=component_len-1))\n\n\n\n  return [groups, commands, values, indexes]\n\n\n\n\n\ndef _GetCurrentCommand(trace=None, include_separators=True):\n\n  \"\"\"Returns current command for the purpose of generating help text.\"\"\"\n\n  if trace:\n\n    current_command = trace.GetCommand(include_separators=include_separators)\n\n  else:\n\n    current_command = ''\n\n  return current_command\n\n\n\n\n\ndef _CreateOutputSection(name, content):\n\n  return \"\"\"{name}\n\n{content}\"\"\".format(\n\n    name=formatting.Bold(name),\n\n    content=formatting.Indent(content, SECTION_INDENTATION))\n\n\n\n\n\ndef _CreateArgItem(arg, docstring_info, spec):\n\n  \"\"\"Returns a string describing a positional argument.\n\n\n\n  Args:\n\n    arg: The name of the positional argument.\n\n    docstring_info: A docstrings.DocstringInfo namedtuple with information about\n\n      the containing function's docstring.\n\n    spec: An instance of fire.inspectutils.FullArgSpec, containing type and\n\n     default information about the arguments to a callable.\n\n\n\n  Returns:\n\n    A string to be used in constructing the help screen for the function.\n\n  \"\"\"\n\n\n\n  # The help string is indented, so calculate the maximum permitted length\n\n  # before indentation to avoid exceeding the maximum line length.\n\n  max_str_length = LINE_LENGTH - SECTION_INDENTATION - SUBSECTION_INDENTATION\n\n\n\n  description = _GetArgDescription(arg, docstring_info)\n\n\n\n  arg_string = formatting.BoldUnderline(arg.upper())\n\n\n\n  arg_type = _GetArgType(arg, spec)\n\n  arg_type = 'Type: {}'.format(arg_type) if arg_type else ''\n\n  available_space = max_str_length - len(arg_type)\n\n  arg_type = (\n\n      formatting.EllipsisTruncate(arg_type, available_space, max_str_length))\n\n\n\n  description = '\\n'.join(part for part in (arg_type, description) if part)\n\n\n\n  return _CreateItem(arg_string, description, indent=SUBSECTION_INDENTATION)\n\n\n\n\n\ndef _CreateFlagItem(flag, docstring_info, spec, required=False,\n\n                    flag_string=None):\n\n  \"\"\"Returns a string describing a flag using docstring and FullArgSpec info.\n\n\n\n  Args:\n\n    flag: The name of the flag.\n\n    docstring_info: A docstrings.DocstringInfo namedtuple with information about\n\n      the containing function's docstring.\n\n    spec: An instance of fire.inspectutils.FullArgSpec, containing type and\n\n     default information about the arguments to a callable.\n\n    required: Whether the flag is required.\n\n    flag_string: If provided, use this string for the flag, rather than\n\n      constructing one from the flag name.\n\n  Returns:\n\n    A string to be used in constructing the help screen for the function.\n\n  \"\"\"\n\n  # pylint: disable=g-bad-todo\n\n  # TODO(MichaelCG8): Get type and default information from docstrings if it is\n\n  # not available in FullArgSpec. This will require updating\n\n  # fire.docstrings.parser().\n\n\n\n  # The help string is indented, so calculate the maximum permitted length\n\n  # before indentation to avoid exceeding the maximum line length.\n\n  max_str_length = LINE_LENGTH - SECTION_INDENTATION - SUBSECTION_INDENTATION\n\n\n\n  description = _GetArgDescription(flag, docstring_info)\n\n\n\n  if not flag_string:\n\n    flag_string_template = '--{flag_name}={flag_name_upper}'\n\n    flag_string = flag_string_template.format(\n\n        flag_name=flag,\n\n        flag_name_upper=formatting.Underline(flag.upper()))\n\n  if required:\n\n    flag_string += ' (required)'\n\n\n\n  arg_type = _GetArgType(flag, spec)\n\n  arg_default = _GetArgDefault(flag, spec)\n\n\n\n  # We need to handle the case where there is a default of None, but otherwise\n\n  # the argument has another type.\n\n  if arg_default == 'None':\n\n    arg_type = 'Optional[{}]'.format(arg_type)\n\n\n\n  arg_type = 'Type: {}'.format(arg_type) if arg_type else ''\n\n  available_space = max_str_length - len(arg_type)\n\n  arg_type = (\n\n      formatting.EllipsisTruncate(arg_type, available_space, max_str_length))\n\n\n\n  arg_default = 'Default: {}'.format(arg_default) if arg_default else ''\n\n  available_space = max_str_length - len(arg_default)\n\n  arg_default = (\n\n      formatting.EllipsisTruncate(arg_default, available_space, max_str_length))\n\n\n\n  description = '\\n'.join(\n\n      part for part in (arg_type, arg_default, description) if part\n\n  )\n\n\n\n  return _CreateItem(flag_string, description, indent=SUBSECTION_INDENTATION)\n\n\n\n\n\ndef _GetArgType(arg, spec):\n\n  \"\"\"Returns a string describing the type of an argument.\n\n\n\n  Args:\n\n    arg: The name of the argument.\n\n    spec: An instance of fire.inspectutils.FullArgSpec, containing type and\n\n     default information about the arguments to a callable.\n\n  Returns:\n\n    A string to be used in constructing the help screen for the function, the\n\n    empty string if the argument type is not available.\n\n  \"\"\"\n\n  if arg in spec.annotations:\n\n    arg_type = spec.annotations[arg]\n\n    try:\n\n      if sys.version_info[0:2] >= (3, 3):\n\n        return arg_type.__qualname__\n\n      return arg_type.__name__\n\n    except AttributeError:\n\n      # Some typing objects, such as typing.Union do not have either a __name__\n\n      # or __qualname__ attribute.\n\n      # repr(typing.Union[int, str]) will return ': typing.Union[int, str]'\n\n      return repr(arg_type)\n\n  return ''\n\n\n\n\n\ndef _GetArgDefault(flag, spec):\n\n  \"\"\"Returns a string describing a flag's default value.\n\n\n\n  Args:\n\n    flag: The name of the flag.\n\n    spec: An instance of fire.inspectutils.FullArgSpec, containing type and\n\n     default information about the arguments to a callable.\n\n  Returns:\n\n    A string to be used in constructing the help screen for the function, the\n\n    empty string if the flag does not have a default or the default is not\n\n    available.\n\n  \"\"\"\n\n  num_defaults = len(spec.defaults)\n\n  args_with_defaults = spec.args[-num_defaults:]\n\n\n\n  for arg, default in zip(args_with_defaults, spec.defaults):\n\n    if arg == flag:\n\n      return repr(default)\n\n  return ''\n\n\n\n\n\ndef _CreateItem(name, description, indent=2):\n\n  if not description:\n\n    return name\n\n  return \"\"\"{name}\n\n{description}\"\"\".format(name=name,\n\n                        description=formatting.Indent(description, indent))\n\n\n\n\n\ndef _GetArgDescription(name, docstring_info):\n\n  if docstring_info.args:\n\n    for arg_in_docstring in docstring_info.args:\n\n      if arg_in_docstring.name in (name, '*' + name, '**' + name):\n\n        return arg_in_docstring.description\n\n  return None\n\n\n\n\n\ndef _MakeUsageDetailsSection(action_group):\n\n  \"\"\"Creates a usage details section for the provided action group.\"\"\"\n\n  item_strings = []\n\n  for name, member in action_group.GetItems():\n\n    info = inspectutils.Info(member)\n\n    item = name\n\n    docstring_info = info.get('docstring_info')\n\n    if (docstring_info\n\n        and not custom_descriptions.NeedsCustomDescription(member)):\n\n      summary = docstring_info.summary\n\n    elif custom_descriptions.NeedsCustomDescription(member):\n\n      summary = custom_descriptions.GetSummary(\n\n          member, LINE_LENGTH - SECTION_INDENTATION, LINE_LENGTH)\n\n    else:\n\n      summary = None\n\n    item = _CreateItem(name, summary)\n\n    item_strings.append(item)\n\n  return (action_group.plural.upper(),\n\n          _NewChoicesSection(action_group.name.upper(), item_strings))\n\n\n\n\n\ndef _ValuesUsageDetailsSection(component, values):\n\n  \"\"\"Creates a section tuple for the values section of the usage details.\"\"\"\n\n  value_item_strings = []\n\n  for value_name, value in values.GetItems():\n\n    del value\n\n    init_info = inspectutils.Info(component.__class__.__init__)\n\n    value_item = None\n\n    if 'docstring_info' in init_info:\n\n      init_docstring_info = init_info['docstring_info']\n\n      if init_docstring_info.args:\n\n        for arg_info in init_docstring_info.args:\n\n          if arg_info.name == value_name:\n\n            value_item = _CreateItem(value_name, arg_info.description)\n\n    if value_item is None:\n\n      value_item = str(value_name)\n\n    value_item_strings.append(value_item)\n\n  return ('VALUES', _NewChoicesSection('VALUE', value_item_strings))\n\n\n\n\n\ndef _NewChoicesSection(name, choices):\n\n  return _CreateItem(\n\n      '{name} is one of the following:'.format(\n\n          name=formatting.Bold(formatting.Underline(name))),\n\n      '\\n' + '\\n\\n'.join(choices),\n\n      indent=1)\n\n\n\n\n\ndef UsageText(component, trace=None, verbose=False):\n\n  \"\"\"Returns usage text for the given component.\n\n\n\n  Args:\n\n    component: The component to determine the usage text for.\n\n    trace: The Fire trace object containing all metadata of current execution.\n\n    verbose: Whether to display the usage text in verbose mode.\n\n\n\n  Returns:\n\n    String suitable for display in an error screen.\n\n  \"\"\"\n\n  output_template = \"\"\"Usage: {continued_command}\n\n{availability_lines}\n\nFor detailed information on this command, run:\n\n  {help_command}\"\"\"\n\n\n\n  # Get the command so far:\n\n  if trace:\n\n    command = trace.GetCommand()\n\n    needs_separating_hyphen_hyphen = trace.NeedsSeparatingHyphenHyphen()\n\n  else:\n\n    command = None\n\n    needs_separating_hyphen_hyphen = False\n\n\n\n  if not command:\n\n    command = ''\n\n\n\n  # Build the continuations for the command:\n\n  continued_command = command\n\n\n\n  spec = inspectutils.GetFullArgSpec(component)\n\n  metadata = decorators.GetMetadata(component)\n\n\n\n  # Usage for objects.\n\n  actions_grouped_by_kind = _GetActionsGroupedByKind(component, verbose=verbose)\n\n  possible_actions = _GetPossibleActions(actions_grouped_by_kind)\n\n\n\n  continuations = []\n\n  if possible_actions:\n\n    continuations.append(_GetPossibleActionsUsageString(possible_actions))\n\n\n\n  availability_lines = _UsageAvailabilityLines(actions_grouped_by_kind)\n\n\n\n  if callable(component):\n\n    callable_items = _GetCallableUsageItems(spec, metadata)\n\n    if callable_items:\n\n      continuations.append(' '.join(callable_items))\n\n    elif trace:\n\n      continuations.append(trace.separator)\n\n    availability_lines.extend(_GetCallableAvailabilityLines(spec))\n\n\n\n  if continuations:\n\n    continued_command += ' ' + ' | '.join(continuations)\n\n  help_command = (\n\n      command\n\n      + (' -- ' if needs_separating_hyphen_hyphen else ' ')\n\n      + '--help'\n\n  )\n\n\n\n  return output_template.format(\n\n      continued_command=continued_command,\n\n      availability_lines=''.join(availability_lines),\n\n      help_command=help_command)\n\n\n\n\n\ndef _GetPossibleActionsUsageString(possible_actions):\n\n  if possible_actions:\n\n    return '<{actions}>'.format(actions='|'.join(possible_actions))\n\n  return None\n\n\n\n\n\ndef _UsageAvailabilityLines(actions_grouped_by_kind):\n\n  availability_lines = []\n\n  for action_group in actions_grouped_by_kind:\n\n    if action_group.members:\n\n      availability_line = _CreateAvailabilityLine(\n\n          header='available {plural}:'.format(plural=action_group.plural),\n\n          items=action_group.names\n\n      )\n\n      availability_lines.append(availability_line)\n\n  return availability_lines\n\n\n\n\n\ndef _GetCallableUsageItems(spec, metadata):\n\n  \"\"\"A list of elements that comprise the usage summary for a callable.\"\"\"\n\n  args_with_no_defaults = spec.args[:len(spec.args) - len(spec.defaults)]\n\n  args_with_defaults = spec.args[len(spec.args) - len(spec.defaults):]\n\n\n\n  # Check if positional args are allowed. If not, show flag syntax for args.\n\n  accepts_positional_args = metadata.get(decorators.ACCEPTS_POSITIONAL_ARGS)\n\n\n\n  if not accepts_positional_args:\n\n    items = ['--{arg}={upper}'.format(arg=arg, upper=arg.upper())\n\n             for arg in args_with_no_defaults]\n\n  else:\n\n    items = [arg.upper() for arg in args_with_no_defaults]\n\n\n\n  # If there are any arguments that are treated as flags:\n\n  if args_with_defaults or spec.kwonlyargs or spec.varkw:\n\n    items.append('<flags>')\n\n\n\n  if spec.varargs:\n\n    items.append('[{varargs}]...'.format(varargs=spec.varargs.upper()))\n\n\n\n  return items\n\n\n\n\n\ndef _KeywordOnlyArguments(spec, required=True):\n\n  return (flag for flag in spec.kwonlyargs\n\n          if required == (flag in spec.kwonlydefaults))\n\n\n\n\n\ndef _GetCallableAvailabilityLines(spec):\n\n  \"\"\"The list of availability lines for a callable for use in a usage string.\"\"\"\n\n  args_with_defaults = spec.args[len(spec.args) - len(spec.defaults):]\n\n\n\n  # TODO(dbieber): Handle args_with_no_defaults if not accepts_positional_args.\n\n  optional_flags = [('--' + flag) for flag in itertools.chain(\n\n      args_with_defaults, _KeywordOnlyArguments(spec, required=False))]\n\n  required_flags = [\n\n      ('--' + flag) for flag in _KeywordOnlyArguments(spec, required=True)\n\n  ]\n\n\n\n  # Flags section:\n\n  availability_lines = []\n\n  if optional_flags:\n\n    availability_lines.append(\n\n        _CreateAvailabilityLine(header='optional flags:', items=optional_flags,\n\n                                header_indent=2))\n\n  if required_flags:\n\n    availability_lines.append(\n\n        _CreateAvailabilityLine(header='required flags:', items=required_flags,\n\n                                header_indent=2))\n\n  if spec.varkw:\n\n    additional_flags = ('additional flags are accepted'\n\n                        if optional_flags or required_flags else\n\n                        'flags are accepted')\n\n    availability_lines.append(\n\n        _CreateAvailabilityLine(header=additional_flags, items=[],\n\n                                header_indent=2))\n\n  return availability_lines\n\n\n\n\n\ndef _CreateAvailabilityLine(header, items,\n\n                            header_indent=2, items_indent=25,\n\n                            line_length=LINE_LENGTH):\n\n  items_width = line_length - items_indent\n\n  items_text = '\\n'.join(formatting.WrappedJoin(items, width=items_width))\n\n  indented_items_text = formatting.Indent(items_text, spaces=items_indent)\n\n  indented_header = formatting.Indent(header, spaces=header_indent)\n\n  return indented_header + indented_items_text[len(indented_header):] + '\\n'\n\n\n\n\n\nclass ActionGroup(object):\n\n  \"\"\"A group of actions of the same kind.\"\"\"\n\n\n\n  def __init__(self, name, plural):\n\n    self.name = name\n\n    self.plural = plural\n\n    self.names = []\n\n    self.members = []\n\n\n\n  def Add(self, name, member=None):\n\n    self.names.append(name)\n\n    self.members.append(member)\n\n\n\n  def GetItems(self):\n\n    return zip(self.names, self.members)\n", "# Copyright (C) 2018 Google Inc.\n\n#\n\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n\n# you may not use this file except in compliance with the License.\n\n# You may obtain a copy of the License at\n\n#\n\n# http://www.apache.org/licenses/LICENSE-2.0\n\n#\n\n# Unless required by applicable law or agreed to in writing, software\n\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n\n# See the License for the specific language governing permissions and\n\n# limitations under the License.\n\n\n\n\"\"\"Tests for formatting.py.\"\"\"\n\n\n\nfrom __future__ import absolute_import\n\nfrom __future__ import division\n\nfrom __future__ import print_function\n\n\n\nfrom fire import formatting\n\nfrom fire import testutils\n\n\n\nLINE_LENGTH = 80\n\n\n\n\n\nclass FormattingTest(testutils.BaseTestCase):\n\n\n\n  def test_bold(self):\n\n    text = formatting.Bold('hello')\n\n    self.assertEqual('\\x1b[1mhello\\x1b[0m', text)\n\n\n\n  def test_underline(self):\n\n    text = formatting.Underline('hello')\n\n    self.assertEqual('\\x1b[4mhello\\x1b[0m', text)\n\n\n\n  def test_indent(self):\n\n    text = formatting.Indent('hello', spaces=2)\n\n    self.assertEqual('  hello', text)\n\n\n\n  def test_indent_multiple_lines(self):\n\n    text = formatting.Indent('hello\\nworld', spaces=2)\n\n    self.assertEqual('  hello\\n  world', text)\n\n\n\n  def test_wrap_one_item(self):\n\n    lines = formatting.WrappedJoin(['rice'])\n\n    self.assertEqual(['rice'], lines)\n\n\n\n  def test_wrap_multiple_items(self):\n\n    lines = formatting.WrappedJoin(['rice', 'beans', 'chicken', 'cheese'],\n\n                                   width=15)\n\n    self.assertEqual(['rice | beans |',\n\n                      'chicken |',\n\n                      'cheese'], lines)\n\n\n\n  def test_ellipsis_truncate(self):\n\n    text = 'This is a string'\n\n    truncated_text = formatting.EllipsisTruncate(\n\n        text=text, available_space=10, line_length=LINE_LENGTH)\n\n    self.assertEqual('This is...', truncated_text)\n\n\n\n  def test_ellipsis_truncate_not_enough_space(self):\n\n    text = 'This is a string'\n\n    truncated_text = formatting.EllipsisTruncate(\n\n        text=text, available_space=2, line_length=LINE_LENGTH)\n\n    self.assertEqual('This is a string', truncated_text)\n\n\n\n  def test_ellipsis_middle_truncate(self):\n\n    text = '1000000000L'\n\n    truncated_text = formatting.EllipsisMiddleTruncate(\n\n        text=text, available_space=7, line_length=LINE_LENGTH)\n\n    self.assertEqual('10...0L', truncated_text)\n\n\n\n  def test_ellipsis_middle_truncate_not_enough_space(self):\n\n    text = '1000000000L'\n\n    truncated_text = formatting.EllipsisMiddleTruncate(\n\n        text=text, available_space=2, line_length=LINE_LENGTH)\n\n    self.assertEqual('1000000000L', truncated_text)\n\n\n\n\n\nif __name__ == '__main__':\n\n  testutils.main()\n", "# Copyright (C) 2018 Google Inc.\n\n#\n\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n\n# you may not use this file except in compliance with the License.\n\n# You may obtain a copy of the License at\n\n#\n\n# http://www.apache.org/licenses/LICENSE-2.0\n\n#\n\n# Unless required by applicable law or agreed to in writing, software\n\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n\n# See the License for the specific language governing permissions and\n\n# limitations under the License.\n\n\n\n\"\"\"This module has components that are used for testing Python Fire.\"\"\"\n\n\n\nfrom __future__ import absolute_import\n\nfrom __future__ import division\n\nfrom __future__ import print_function\n\n\n\nimport collections\n\nimport enum\n\nimport functools\n\n\n\nimport six\n\n\n\nif six.PY3:\n\n  from fire import test_components_py3 as py3  # pylint: disable=unused-import,no-name-in-module,g-import-not-at-top\n\n\n\n\n\ndef identity(arg1, arg2, arg3=10, arg4=20, *arg5, **arg6):  # pylint: disable=keyword-arg-before-vararg\n\n  return arg1, arg2, arg3, arg4, arg5, arg6\n\n\n\nidentity.__annotations__ = {'arg2': int, 'arg4': int}\n\n\n\n\n\ndef multiplier_with_docstring(num, rate=2):\n\n  \"\"\"Multiplies num by rate.\n\n\n\n  Args:\n\n    num (int): the num you want to multiply\n\n    rate (int): the rate for multiplication\n\n  Returns:\n\n    Multiplication of num by rate\n\n  \"\"\"\n\n  return num * rate\n\n\n\n\n\ndef function_with_help(help=True):  # pylint: disable=redefined-builtin\n\n  return help\n\n\n\n\n\nclass Empty(object):\n\n  pass\n\n\n\n\n\nclass OldStyleEmpty:  # pylint: disable=old-style-class,no-init\n\n  pass\n\n\n\n\n\nclass WithInit(object):\n\n\n\n  def __init__(self):\n\n    pass\n\n\n\n\n\nclass ErrorInConstructor(object):\n\n\n\n  def __init__(self, value='value'):\n\n    self.value = value\n\n    raise ValueError('Error in constructor')\n\n\n\n\n\nclass WithHelpArg(object):\n\n  \"\"\"Test class for testing when class has a help= arg.\"\"\"\n\n\n\n  def __init__(self, help=True):  # pylint: disable=redefined-builtin\n\n    self.has_help = help\n\n    self.dictionary = {'__help': 'help in a dict'}\n\n\n\n\n\nclass NoDefaults(object):\n\n\n\n  def double(self, count):\n\n    return 2 * count\n\n\n\n  def triple(self, count):\n\n    return 3 * count\n\n\n\n\n\nclass WithDefaults(object):\n\n  \"\"\"Class with functions that have default arguments.\"\"\"\n\n\n\n  def double(self, count=0):\n\n    \"\"\"Returns the input multiplied by 2.\n\n\n\n    Args:\n\n      count: Input number that you want to double.\n\n\n\n    Returns:\n\n      A number that is the double of count.\n\n    \"\"\"\n\n    return 2 * count\n\n\n\n  def triple(self, count=0):\n\n    return 3 * count\n\n\n\n  def text(\n\n      self,\n\n      string=('0001020304050607080910111213141516171819'\n\n              '2021222324252627282930313233343536373839')\n\n  ):\n\n    return string\n\n\n\n\n\nclass OldStyleWithDefaults:  # pylint: disable=old-style-class,no-init\n\n\n\n  def double(self, count=0):\n\n    return 2 * count\n\n\n\n  def triple(self, count=0):\n\n    return 3 * count\n\n\n\n\n\nclass MixedDefaults(object):\n\n\n\n  def ten(self):\n\n    return 10\n\n\n\n  def sum(self, alpha=0, beta=0):\n\n    return alpha + 2 * beta\n\n\n\n  def identity(self, alpha, beta='0'):\n\n    return alpha, beta\n\n\n\n\n\nclass SimilarArgNames(object):\n\n\n\n  def identity(self, bool_one=False, bool_two=False):\n\n    return bool_one, bool_two\n\n\n\n  def identity2(self, a=None, alpha=None):\n\n    return a, alpha\n\n\n\n\n\nclass CapitalizedArgNames(object):\n\n\n\n  def sum(self, Delta=1.0, Gamma=2.0):  # pylint: disable=invalid-name\n\n    return Delta + Gamma\n\n\n\n\n\nclass Annotations(object):\n\n\n\n  def double(self, count=0):\n\n    return 2 * count\n\n\n\n  def triple(self, count=0):\n\n    return 3 * count\n\n\n\n  double.__annotations__ = {'count': float}\n\n  triple.__annotations__ = {'count': float}\n\n\n\n\n\nclass TypedProperties(object):\n\n  \"\"\"Test class for testing Python Fire with properties of various types.\"\"\"\n\n\n\n  def __init__(self):\n\n    self.alpha = True\n\n    self.beta = (1, 2, 3)\n\n    self.charlie = WithDefaults()\n\n    self.delta = {\n\n        'echo': 'E',\n\n        'nest': {\n\n            0: 'a',\n\n            1: 'b',\n\n        },\n\n    }\n\n    self.echo = ['alex', 'bethany']\n\n    self.fox = ('carry', 'divide')\n\n    self.gamma = 'myexcitingstring'\n\n\n\n\n\nclass VarArgs(object):\n\n  \"\"\"Test class for testing Python Fire with a property with varargs.\"\"\"\n\n\n\n  def cumsums(self, *items):\n\n    total = None\n\n    sums = []\n\n    for item in items:\n\n      if total is None:\n\n        total = item\n\n      else:\n\n        total += item\n\n      sums.append(total)\n\n    return sums\n\n\n\n  def varchars(self, alpha=0, beta=0, *chars):  # pylint: disable=keyword-arg-before-vararg\n\n    return alpha, beta, ''.join(chars)\n\n\n\n\n\nclass Underscores(object):\n\n\n\n  def __init__(self):\n\n    self.underscore_example = 'fish fingers'\n\n\n\n  def underscore_function(self, underscore_arg):\n\n    return underscore_arg\n\n\n\n\n\nclass BoolConverter(object):\n\n\n\n  def as_bool(self, arg=False):\n\n    return bool(arg)\n\n\n\n\n\nclass ReturnsObj(object):\n\n\n\n  def get_obj(self, *items):\n\n    del items  # Unused\n\n    return BoolConverter()\n\n\n\n\n\nclass NumberDefaults(object):\n\n\n\n  def reciprocal(self, divisor=10.0):\n\n    return 1.0 / divisor\n\n\n\n  def integer_reciprocal(self, divisor=10):\n\n    return 1.0 / divisor\n\n\n\n\n\nclass InstanceVars(object):\n\n\n\n  def __init__(self, arg1, arg2):\n\n    self.arg1 = arg1\n\n    self.arg2 = arg2\n\n\n\n  def run(self, arg1, arg2):\n\n    return (self.arg1, self.arg2, arg1, arg2)\n\n\n\n\n\nclass Kwargs(object):\n\n\n\n  def props(self, **kwargs):\n\n    return kwargs\n\n\n\n  def upper(self, **kwargs):\n\n    return ' '.join(sorted(kwargs.keys())).upper()\n\n\n\n  def run(self, positional, named=None, **kwargs):\n\n    return (positional, named, kwargs)\n\n\n\n\n\nclass ErrorRaiser(object):\n\n\n\n  def fail(self):\n\n    raise ValueError('This error is part of a test.')\n\n\n\n\n\nclass NonComparable(object):\n\n\n\n  def __eq__(self, other):\n\n    raise ValueError('Instances of this class cannot be compared.')\n\n\n\n  def __ne__(self, other):\n\n    raise ValueError('Instances of this class cannot be compared.')\n\n\n\n\n\nclass EmptyDictOutput(object):\n\n\n\n  def totally_empty(self):\n\n    return {}\n\n\n\n  def nothing_printable(self):\n\n    return {'__do_not_print_me': 1}\n\n\n\n\n\nclass CircularReference(object):\n\n\n\n  def create(self):\n\n    x = {}\n\n    x['y'] = x\n\n    return x\n\n\n\n\n\nclass OrderedDictionary(object):\n\n\n\n  def empty(self):\n\n    return collections.OrderedDict()\n\n\n\n  def non_empty(self):\n\n    ordered_dict = collections.OrderedDict()\n\n    ordered_dict['A'] = 'A'\n\n    ordered_dict[2] = 2\n\n    return ordered_dict\n\n\n\n\n\nclass NamedTuple(object):\n\n  \"\"\"Functions returning named tuples used for testing.\"\"\"\n\n\n\n  def point(self):\n\n    \"\"\"Point example straight from Python docs.\"\"\"\n\n    # pylint: disable=invalid-name\n\n    Point = collections.namedtuple('Point', ['x', 'y'])\n\n    return Point(11, y=22)\n\n\n\n  def matching_names(self):\n\n    \"\"\"Field name equals value.\"\"\"\n\n    # pylint: disable=invalid-name\n\n    Point = collections.namedtuple('Point', ['x', 'y'])\n\n    return Point(x='x', y='y')\n\n\n\n\n\nclass CallableWithPositionalArgs(object):\n\n  \"\"\"Test class for supporting callable.\"\"\"\n\n\n\n  TEST = 1\n\n\n\n  def __call__(self, x, y):\n\n    return x + y\n\n\n\n  def fn(self, x):\n\n    return x + 1\n\n\n\n\n\nNamedTuplePoint = collections.namedtuple('NamedTuplePoint', ['x', 'y'])\n\n\n\n\n\nclass SubPoint(NamedTuplePoint):\n\n  \"\"\"Used for verifying subclasses of namedtuples behave as intended.\"\"\"\n\n\n\n  def coordinate_sum(self):\n\n    return self.x + self.y\n\n\n\n\n\nclass CallableWithKeywordArgument(object):\n\n  \"\"\"Test class for supporting callable.\"\"\"\n\n\n\n  def __call__(self, **kwargs):\n\n    for key, value in kwargs.items():\n\n      print('%s: %s' % (key, value))\n\n\n\n  def print_msg(self, msg):\n\n    print(msg)\n\n\n\n\n\nCALLABLE_WITH_KEYWORD_ARGUMENT = CallableWithKeywordArgument()\n\n\n\n\n\nclass ClassWithDocstring(object):\n\n  \"\"\"Test class for testing help text output.\n\n\n\n  This is some detail description of this test class.\n\n  \"\"\"\n\n\n\n  def __init__(self, message='Hello!'):\n\n    \"\"\"Constructor of the test class.\n\n\n\n    Constructs a new ClassWithDocstring object.\n\n\n\n    Args:\n\n      message: The default message to print.\n\n    \"\"\"\n\n    self.message = message\n\n\n\n  def print_msg(self, msg=None):\n\n    \"\"\"Prints a message.\"\"\"\n\n    if msg is None:\n\n      msg = self.message\n\n    print(msg)\n\n\n\n\n\nclass ClassWithMultilineDocstring(object):\n\n  \"\"\"Test class for testing help text output with multiline docstring.\n\n\n\n  This is a test class that has a long docstring description that spans across\n\n  multiple lines for testing line breaking in help text.\n\n  \"\"\"\n\n\n\n  @staticmethod\n\n  def example_generator(n):\n\n    \"\"\"Generators have a ``Yields`` section instead of a ``Returns`` section.\n\n\n\n    Args:\n\n        n (int): The upper limit of the range to generate, from 0 to `n` - 1.\n\n\n\n    Yields:\n\n        int: The next number in the range of 0 to `n` - 1.\n\n\n\n    Examples:\n\n        Examples should be written in doctest format, and should illustrate how\n\n        to use the function.\n\n\n\n        >>> print([i for i in example_generator(4)])\n\n        [0, 1, 2, 3]\n\n\n\n    \"\"\"\n\n    for i in range(n):\n\n      yield i\n\n\n\n\n\ndef simple_set():\n\n  return {1, 2, 'three'}\n\n\n\n\n\ndef simple_frozenset():\n\n  return frozenset({1, 2, 'three'})\n\n\n\n\n\nclass Subdict(dict):\n\n  \"\"\"A subclass of dict, for testing purposes.\"\"\"\n\n\n\n\n\n# An example subdict.\n\nSUBDICT = Subdict({1: 2, 'red': 'blue'})\n\n\n\n\n\nclass Color(enum.Enum):\n\n  RED = 1\n\n  GREEN = 2\n\n  BLUE = 3\n\n\n\n\n\nclass HasStaticAndClassMethods(object):\n\n  \"\"\"A class with a static method and a class method.\"\"\"\n\n\n\n  CLASS_STATE = 1\n\n\n\n  def __init__(self, instance_state):\n\n    self.instance_state = instance_state\n\n\n\n  @staticmethod\n\n  def static_fn(args):\n\n    return args\n\n\n\n  @classmethod\n\n  def class_fn(cls, args):\n\n    return args + cls.CLASS_STATE\n\n\n\n\n\ndef function_with_varargs(arg1, arg2, arg3=1, *varargs):  # pylint: disable=keyword-arg-before-vararg\n\n  \"\"\"Function with varargs.\n\n\n\n  Args:\n\n    arg1: Position arg docstring.\n\n    arg2: Position arg docstring.\n\n    arg3: Flags docstring.\n\n    *varargs: Accepts unlimited positional args.\n\n  Returns:\n\n    The unlimited positional args.\n\n  \"\"\"\n\n  del arg1, arg2, arg3  # Unused.\n\n  return varargs\n\n\n\n\n\ndef function_with_keyword_arguments(arg1, arg2=3, **kwargs):\n\n  del arg2  # Unused.\n\n  return arg1, kwargs\n\n\n\n\n\ndef fn_with_code_in_docstring():\n\n  \"\"\"This has code in the docstring.\n\n\n\n\n\n\n\n  Example:\n\n    x = fn_with_code_in_docstring()\n\n    indentation_matters = True\n\n\n\n\n\n\n\n  Returns:\n\n    True.\n\n  \"\"\"\n\n  return True\n\n\n\n\n\nclass BinaryCanvas(object):\n\n  \"\"\"A canvas with which to make binary art, one bit at a time.\"\"\"\n\n\n\n  def __init__(self, size=10):\n\n    self.pixels = [[0] * size for _ in range(size)]\n\n    self._size = size\n\n    self._row = 0  # The row of the cursor.\n\n    self._col = 0  # The column of the cursor.\n\n\n\n  def __str__(self):\n\n    return '\\n'.join(\n\n        ' '.join(str(pixel) for pixel in row) for row in self.pixels)\n\n\n\n  def show(self):\n\n    print(self)\n\n    return self\n\n\n\n  def move(self, row, col):\n\n    self._row = row % self._size\n\n    self._col = col % self._size\n\n    return self\n\n\n\n  def on(self):\n\n    return self.set(1)\n\n\n\n  def off(self):\n\n    return self.set(0)\n\n\n\n  def set(self, value):\n\n    self.pixels[self._row][self._col] = value\n\n    return self\n\n\n\n\n\nclass DefaultMethod(object):\n\n\n\n  def double(self, number):\n\n    return 2 * number\n\n\n\n  def __getattr__(self, name):\n\n    def _missing():\n\n      return 'Undefined function'\n\n    return _missing\n\n\n\n\n\nclass InvalidProperty(object):\n\n\n\n  def double(self, number):\n\n    return 2 * number\n\n\n\n  @property\n\n  def prop(self):\n\n    raise ValueError('test')\n\n\n\n\n\ndef simple_decorator(f):\n\n  @functools.wraps(f)\n\n  def wrapper(*args, **kwargs):\n\n    return f(*args, **kwargs)\n\n  return wrapper\n\n\n\n\n\n@simple_decorator\n\ndef decorated_method(name='World'):\n\n  return 'Hello %s' % name\n\n\n\n\n\n# pylint: disable=g-doc-args,g-doc-return-or-yield\n\ndef fn_with_kwarg(arg1, arg2, **kwargs):\n\n  \"\"\"Function with kwarg.\n\n\n\n  :param arg1: Description of arg1.\n\n  :param arg2: Description of arg2.\n\n  :key arg3: Description of arg3.\n\n  \"\"\"\n\n  del arg1, arg2\n\n  return kwargs.get('arg3')\n\n\n\n\n\ndef fn_with_kwarg_and_defaults(arg1, arg2, opt=True, **kwargs):\n\n  \"\"\"Function with kwarg and defaults.\n\n\n\n  :param arg1: Description of arg1.\n\n  :param arg2: Description of arg2.\n\n  :key arg3: Description of arg3.\n\n  \"\"\"\n\n  del arg1, arg2, opt\n\n  return kwargs.get('arg3')\n\n# pylint: enable=g-doc-args,g-doc-return-or-yield\n", "# Copyright (C) 2018 Google Inc.\n\n#\n\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n\n# you may not use this file except in compliance with the License.\n\n# You may obtain a copy of the License at\n\n#\n\n# http://www.apache.org/licenses/LICENSE-2.0\n\n#\n\n# Unless required by applicable law or agreed to in writing, software\n\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n\n# See the License for the specific language governing permissions and\n\n# limitations under the License.\n\n\n\n\"\"\"Tests for the core module.\"\"\"\n\n\n\nfrom __future__ import absolute_import\n\nfrom __future__ import division\n\nfrom __future__ import print_function\n\n\n\nfrom fire import core\n\nfrom fire import test_components as tc\n\nfrom fire import testutils\n\nfrom fire import trace\n\nimport mock\n\n\n\nimport six\n\n\n\n\n\nclass CoreTest(testutils.BaseTestCase):\n\n\n\n  def testOneLineResult(self):\n\n    self.assertEqual(core._OneLineResult(1), '1')  # pylint: disable=protected-access\n\n    self.assertEqual(core._OneLineResult('hello'), 'hello')  # pylint: disable=protected-access\n\n    self.assertEqual(core._OneLineResult({}), '{}')  # pylint: disable=protected-access\n\n    self.assertEqual(core._OneLineResult({'x': 'y'}), '{\"x\": \"y\"}')  # pylint: disable=protected-access\n\n\n\n  def testOneLineResultCircularRef(self):\n\n    circular_reference = tc.CircularReference()\n\n    self.assertEqual(core._OneLineResult(circular_reference.create()),  # pylint: disable=protected-access\n\n                     \"{'y': {...}}\")\n\n\n\n  @mock.patch('fire.interact.Embed')\n\n  def testInteractiveMode(self, mock_embed):\n\n    core.Fire(tc.TypedProperties, command=['alpha'])\n\n    self.assertFalse(mock_embed.called)\n\n    core.Fire(tc.TypedProperties, command=['alpha', '--', '-i'])\n\n    self.assertTrue(mock_embed.called)\n\n\n\n  @mock.patch('fire.interact.Embed')\n\n  def testInteractiveModeFullArgument(self, mock_embed):\n\n    core.Fire(tc.TypedProperties, command=['alpha', '--', '--interactive'])\n\n    self.assertTrue(mock_embed.called)\n\n\n\n  @mock.patch('fire.interact.Embed')\n\n  def testInteractiveModeVariables(self, mock_embed):\n\n    core.Fire(tc.WithDefaults, command=['double', '2', '--', '-i'])\n\n    self.assertTrue(mock_embed.called)\n\n    (variables, verbose), unused_kwargs = mock_embed.call_args\n\n    self.assertFalse(verbose)\n\n    self.assertEqual(variables['result'], 4)\n\n    self.assertIsInstance(variables['self'], tc.WithDefaults)\n\n    self.assertIsInstance(variables['trace'], trace.FireTrace)\n\n\n\n  @mock.patch('fire.interact.Embed')\n\n  def testInteractiveModeVariablesWithName(self, mock_embed):\n\n    core.Fire(tc.WithDefaults,\n\n              command=['double', '2', '--', '-i', '-v'], name='D')\n\n    self.assertTrue(mock_embed.called)\n\n    (variables, verbose), unused_kwargs = mock_embed.call_args\n\n    self.assertTrue(verbose)\n\n    self.assertEqual(variables['result'], 4)\n\n    self.assertIsInstance(variables['self'], tc.WithDefaults)\n\n    self.assertEqual(variables['D'], tc.WithDefaults)\n\n    self.assertIsInstance(variables['trace'], trace.FireTrace)\n\n\n\n  # TODO(dbieber): Use parameterized tests to break up repetitive tests.\n\n  def testHelpWithClass(self):\n\n    with self.assertRaisesFireExit(0, 'SYNOPSIS.*ARG1'):\n\n      core.Fire(tc.InstanceVars, command=['--', '--help'])\n\n    with self.assertRaisesFireExit(0, 'INFO:.*SYNOPSIS.*ARG1'):\n\n      core.Fire(tc.InstanceVars, command=['--help'])\n\n    with self.assertRaisesFireExit(0, 'INFO:.*SYNOPSIS.*ARG1'):\n\n      core.Fire(tc.InstanceVars, command=['-h'])\n\n\n\n  def testHelpWithMember(self):\n\n    with self.assertRaisesFireExit(0, 'SYNOPSIS.*capitalize'):\n\n      core.Fire(tc.TypedProperties, command=['gamma', '--', '--help'])\n\n    with self.assertRaisesFireExit(0, 'INFO:.*SYNOPSIS.*capitalize'):\n\n      core.Fire(tc.TypedProperties, command=['gamma', '--help'])\n\n    with self.assertRaisesFireExit(0, 'INFO:.*SYNOPSIS.*capitalize'):\n\n      core.Fire(tc.TypedProperties, command=['gamma', '-h'])\n\n    with self.assertRaisesFireExit(0, 'INFO:.*SYNOPSIS.*delta'):\n\n      core.Fire(tc.TypedProperties, command=['delta', '--help'])\n\n    with self.assertRaisesFireExit(0, 'INFO:.*SYNOPSIS.*echo'):\n\n      core.Fire(tc.TypedProperties, command=['echo', '--help'])\n\n\n\n  def testHelpOnErrorInConstructor(self):\n\n    with self.assertRaisesFireExit(0, 'SYNOPSIS.*VALUE'):\n\n      core.Fire(tc.ErrorInConstructor, command=['--', '--help'])\n\n    with self.assertRaisesFireExit(0, 'INFO:.*SYNOPSIS.*VALUE'):\n\n      core.Fire(tc.ErrorInConstructor, command=['--help'])\n\n\n\n  def testHelpWithNamespaceCollision(self):\n\n    # Tests cases when calling the help shortcut should not show help.\n\n    with self.assertOutputMatches(stdout='DESCRIPTION.*', stderr=None):\n\n      core.Fire(tc.WithHelpArg, command=['--help', 'False'])\n\n    with self.assertOutputMatches(stdout='help in a dict', stderr=None):\n\n      core.Fire(tc.WithHelpArg, command=['dictionary', '__help'])\n\n    with self.assertOutputMatches(stdout='{}', stderr=None):\n\n      core.Fire(tc.WithHelpArg, command=['dictionary', '--help'])\n\n    with self.assertOutputMatches(stdout='False', stderr=None):\n\n      core.Fire(tc.function_with_help, command=['False'])\n\n\n\n  def testInvalidParameterRaisesFireExit(self):\n\n    with self.assertRaisesFireExit(2, 'runmisspelled'):\n\n      core.Fire(tc.Kwargs, command=['props', '--a=1', '--b=2', 'runmisspelled'])\n\n\n\n  def testErrorRaising(self):\n\n    # Errors in user code should not be caught; they should surface as normal.\n\n    # This will lead to exit status code 1 for the client program.\n\n    with self.assertRaises(ValueError):\n\n      core.Fire(tc.ErrorRaiser, command=['fail'])\n\n\n\n  def testFireError(self):\n\n    error = core.FireError('Example error')\n\n    self.assertIsNotNone(error)\n\n\n\n  def testFireErrorMultipleValues(self):\n\n    error = core.FireError('Example error', 'value')\n\n    self.assertIsNotNone(error)\n\n\n\n  def testPrintEmptyDict(self):\n\n    with self.assertOutputMatches(stdout='{}', stderr=None):\n\n      core.Fire(tc.EmptyDictOutput, command=['totally_empty'])\n\n    with self.assertOutputMatches(stdout='{}', stderr=None):\n\n      core.Fire(tc.EmptyDictOutput, command=['nothing_printable'])\n\n\n\n  def testPrintOrderedDict(self):\n\n    with self.assertOutputMatches(stdout=r'A:\\s+A\\s+2:\\s+2\\s+', stderr=None):\n\n      core.Fire(tc.OrderedDictionary, command=['non_empty'])\n\n    with self.assertOutputMatches(stdout='{}'):\n\n      core.Fire(tc.OrderedDictionary, command=['empty'])\n\n\n\n  def testPrintNamedTupleField(self):\n\n    with self.assertOutputMatches(stdout='11', stderr=None):\n\n      core.Fire(tc.NamedTuple, command=['point', 'x'])\n\n\n\n  def testPrintNamedTupleFieldNameEqualsValue(self):\n\n    with self.assertOutputMatches(stdout='x', stderr=None):\n\n      core.Fire(tc.NamedTuple, command=['matching_names', 'x'])\n\n\n\n  def testPrintNamedTupleIndex(self):\n\n    with self.assertOutputMatches(stdout='22', stderr=None):\n\n      core.Fire(tc.NamedTuple, command=['point', '1'])\n\n\n\n  def testPrintSet(self):\n\n    with self.assertOutputMatches(stdout='.*three.*', stderr=None):\n\n      core.Fire(tc.simple_set(), command=[])\n\n\n\n  def testPrintFrozenSet(self):\n\n    with self.assertOutputMatches(stdout='.*three.*', stderr=None):\n\n      core.Fire(tc.simple_frozenset(), command=[])\n\n\n\n  def testPrintNamedTupleNegativeIndex(self):\n\n    with self.assertOutputMatches(stdout='11', stderr=None):\n\n      core.Fire(tc.NamedTuple, command=['point', '-2'])\n\n\n\n  def testCallable(self):\n\n    with self.assertOutputMatches(stdout=r'foo:\\s+foo\\s+', stderr=None):\n\n      core.Fire(tc.CallableWithKeywordArgument(), command=['--foo=foo'])\n\n    with self.assertOutputMatches(stdout=r'foo\\s+', stderr=None):\n\n      core.Fire(tc.CallableWithKeywordArgument(), command=['print_msg', 'foo'])\n\n    with self.assertOutputMatches(stdout=r'', stderr=None):\n\n      core.Fire(tc.CallableWithKeywordArgument(), command=[])\n\n\n\n  def testCallableWithPositionalArgs(self):\n\n    with self.assertRaisesFireExit(2, ''):\n\n      # This does not give 7 since positional args are disallowed for callable\n\n      # objects.\n\n      core.Fire(tc.CallableWithPositionalArgs(), command=['3', '4'])\n\n\n\n  def testStaticMethod(self):\n\n    self.assertEqual(\n\n        core.Fire(tc.HasStaticAndClassMethods,\n\n                  command=['static_fn', 'alpha']),\n\n        'alpha',\n\n    )\n\n\n\n  def testClassMethod(self):\n\n    self.assertEqual(\n\n        core.Fire(tc.HasStaticAndClassMethods,\n\n                  command=['class_fn', '6']),\n\n        7,\n\n    )\n\n\n\n  @testutils.skipIf(six.PY2, 'lru_cache is Python 3 only.')\n\n  def testLruCacheDecoratorBoundArg(self):\n\n    self.assertEqual(\n\n        core.Fire(tc.py3.LruCacheDecoratedMethod,  # pytype: disable=module-attr\n\n                  command=['lru_cache_in_class', 'foo']), 'foo')\n\n\n\n  @testutils.skipIf(six.PY2, 'lru_cache is Python 3 only.')\n\n  def testLruCacheDecorator(self):\n\n    self.assertEqual(\n\n        core.Fire(tc.py3.lru_cache_decorated,  # pytype: disable=module-attr\n\n                  command=['foo']), 'foo')\n\n\n\n\n\nif __name__ == '__main__':\n\n  testutils.main()\n", "# Copyright (C) 2018 Google Inc.\n\n#\n\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n\n# you may not use this file except in compliance with the License.\n\n# You may obtain a copy of the License at\n\n#\n\n# http://www.apache.org/licenses/LICENSE-2.0\n\n#\n\n# Unless required by applicable law or agreed to in writing, software\n\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n\n# See the License for the specific language governing permissions and\n\n# limitations under the License.\n\n\n\n\"\"\"Tests for the inspectutils module.\"\"\"\n\n\n\nfrom __future__ import absolute_import\n\nfrom __future__ import division\n\nfrom __future__ import print_function\n\n\n\nimport os\n\nimport unittest\n\n\n\nfrom fire import inspectutils\n\nfrom fire import test_components as tc\n\nfrom fire import testutils\n\n\n\nimport six\n\n\n\n\n\nclass InspectUtilsTest(testutils.BaseTestCase):\n\n\n\n  def testGetFullArgSpec(self):\n\n    spec = inspectutils.GetFullArgSpec(tc.identity)\n\n    self.assertEqual(spec.args, ['arg1', 'arg2', 'arg3', 'arg4'])\n\n    self.assertEqual(spec.defaults, (10, 20))\n\n    self.assertEqual(spec.varargs, 'arg5')\n\n    self.assertEqual(spec.varkw, 'arg6')\n\n    self.assertEqual(spec.kwonlyargs, [])\n\n    self.assertEqual(spec.kwonlydefaults, {})\n\n    self.assertEqual(spec.annotations, {'arg2': int, 'arg4': int})\n\n\n\n  @unittest.skipIf(six.PY2, 'No keyword arguments in python 2')\n\n  def testGetFullArgSpecPy3(self):\n\n    spec = inspectutils.GetFullArgSpec(tc.py3.identity)\n\n    self.assertEqual(spec.args, ['arg1', 'arg2', 'arg3', 'arg4'])\n\n    self.assertEqual(spec.defaults, (10, 20))\n\n    self.assertEqual(spec.varargs, 'arg5')\n\n    self.assertEqual(spec.varkw, 'arg10')\n\n    self.assertEqual(spec.kwonlyargs, ['arg6', 'arg7', 'arg8', 'arg9'])\n\n    self.assertEqual(spec.kwonlydefaults, {'arg8': 30, 'arg9': 40})\n\n    self.assertEqual(spec.annotations,\n\n                     {'arg2': int, 'arg4': int, 'arg7': int, 'arg9': int})\n\n\n\n  def testGetFullArgSpecFromBuiltin(self):\n\n    spec = inspectutils.GetFullArgSpec('test'.upper)\n\n    self.assertEqual(spec.args, [])\n\n    self.assertEqual(spec.defaults, ())\n\n    self.assertEqual(spec.kwonlyargs, [])\n\n    self.assertEqual(spec.kwonlydefaults, {})\n\n    self.assertEqual(spec.annotations, {})\n\n\n\n  def testGetFullArgSpecFromSlotWrapper(self):\n\n    spec = inspectutils.GetFullArgSpec(tc.NoDefaults)\n\n    self.assertEqual(spec.args, [])\n\n    self.assertEqual(spec.defaults, ())\n\n    self.assertEqual(spec.varargs, None)\n\n    self.assertEqual(spec.varkw, None)\n\n    self.assertEqual(spec.kwonlyargs, [])\n\n    self.assertEqual(spec.kwonlydefaults, {})\n\n    self.assertEqual(spec.annotations, {})\n\n\n\n  def testGetFullArgSpecFromNamedTuple(self):\n\n    spec = inspectutils.GetFullArgSpec(tc.NamedTuplePoint)\n\n    self.assertEqual(spec.args, ['x', 'y'])\n\n    self.assertEqual(spec.defaults, ())\n\n    self.assertEqual(spec.varargs, None)\n\n    self.assertEqual(spec.varkw, None)\n\n    self.assertEqual(spec.kwonlyargs, [])\n\n    self.assertEqual(spec.kwonlydefaults, {})\n\n    self.assertEqual(spec.annotations, {})\n\n\n\n  def testGetFullArgSpecFromNamedTupleSubclass(self):\n\n    spec = inspectutils.GetFullArgSpec(tc.SubPoint)\n\n    self.assertEqual(spec.args, ['x', 'y'])\n\n    self.assertEqual(spec.defaults, ())\n\n    self.assertEqual(spec.varargs, None)\n\n    self.assertEqual(spec.varkw, None)\n\n    self.assertEqual(spec.kwonlyargs, [])\n\n    self.assertEqual(spec.kwonlydefaults, {})\n\n    self.assertEqual(spec.annotations, {})\n\n\n\n  def testGetFullArgSpecFromClassNoInit(self):\n\n    spec = inspectutils.GetFullArgSpec(tc.OldStyleEmpty)\n\n    self.assertEqual(spec.args, [])\n\n    self.assertEqual(spec.defaults, ())\n\n    self.assertEqual(spec.varargs, None)\n\n    self.assertEqual(spec.varkw, None)\n\n    self.assertEqual(spec.kwonlyargs, [])\n\n    self.assertEqual(spec.kwonlydefaults, {})\n\n    self.assertEqual(spec.annotations, {})\n\n\n\n  def testGetFullArgSpecFromMethod(self):\n\n    spec = inspectutils.GetFullArgSpec(tc.NoDefaults().double)\n\n    self.assertEqual(spec.args, ['count'])\n\n    self.assertEqual(spec.defaults, ())\n\n    self.assertEqual(spec.varargs, None)\n\n    self.assertEqual(spec.varkw, None)\n\n    self.assertEqual(spec.kwonlyargs, [])\n\n    self.assertEqual(spec.kwonlydefaults, {})\n\n    self.assertEqual(spec.annotations, {})\n\n\n\n  def testInfoOne(self):\n\n    info = inspectutils.Info(1)\n\n    self.assertEqual(info.get('type_name'), 'int')\n\n    self.assertEqual(info.get('file'), None)\n\n    self.assertEqual(info.get('line'), None)\n\n    self.assertEqual(info.get('string_form'), '1')\n\n\n\n  def testInfoClass(self):\n\n    info = inspectutils.Info(tc.NoDefaults)\n\n    self.assertEqual(info.get('type_name'), 'type')\n\n    self.assertIn(os.path.join('fire', 'test_components.py'), info.get('file'))\n\n    self.assertGreater(info.get('line'), 0)\n\n\n\n  def testInfoClassNoInit(self):\n\n    info = inspectutils.Info(tc.OldStyleEmpty)\n\n    if six.PY2:\n\n      self.assertEqual(info.get('type_name'), 'classobj')\n\n    else:\n\n      self.assertEqual(info.get('type_name'), 'type')\n\n    self.assertIn(os.path.join('fire', 'test_components.py'), info.get('file'))\n\n    self.assertGreater(info.get('line'), 0)\n\n\n\n  def testInfoNoDocstring(self):\n\n    info = inspectutils.Info(tc.NoDefaults)\n\n    self.assertEqual(info['docstring'], None, 'Docstring should be None')\n\n\n\n\n\nif __name__ == '__main__':\n\n  testutils.main()\n", "# Copyright (C) 2018 Google Inc.\n\n#\n\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n\n# you may not use this file except in compliance with the License.\n\n# You may obtain a copy of the License at\n\n#\n\n# http://www.apache.org/licenses/LICENSE-2.0\n\n#\n\n# Unless required by applicable law or agreed to in writing, software\n\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n\n# See the License for the specific language governing permissions and\n\n# limitations under the License.\n\n\n\n\"\"\"Tests for the decorators module.\"\"\"\n\n\n\nfrom __future__ import absolute_import\n\nfrom __future__ import division\n\nfrom __future__ import print_function\n\n\n\nfrom fire import core\n\nfrom fire import decorators\n\nfrom fire import testutils\n\n\n\n\n\nclass NoDefaults(object):\n\n  \"\"\"A class for testing decorated functions without default values.\"\"\"\n\n\n\n  @decorators.SetParseFns(count=int)\n\n  def double(self, count):\n\n    return 2 * count\n\n\n\n  @decorators.SetParseFns(count=float)\n\n  def triple(self, count):\n\n    return 3 * count\n\n\n\n  @decorators.SetParseFns(int)\n\n  def quadruple(self, count):\n\n    return 4 * count\n\n\n\n\n\n@decorators.SetParseFns(int)\n\ndef double(count):\n\n  return 2 * count\n\n\n\n\n\nclass WithDefaults(object):\n\n\n\n  @decorators.SetParseFns(float)\n\n  def example1(self, arg1=10):\n\n    return arg1, type(arg1)\n\n\n\n  @decorators.SetParseFns(arg1=float)\n\n  def example2(self, arg1=10):\n\n    return arg1, type(arg1)\n\n\n\n\n\nclass MixedArguments(object):\n\n\n\n  @decorators.SetParseFns(float, arg2=str)\n\n  def example3(self, arg1, arg2):\n\n    return arg1, arg2\n\n\n\n\n\nclass PartialParseFn(object):\n\n\n\n  @decorators.SetParseFns(arg1=str)\n\n  def example4(self, arg1, arg2):\n\n    return arg1, arg2\n\n\n\n  @decorators.SetParseFns(arg2=str)\n\n  def example5(self, arg1, arg2):\n\n    return arg1, arg2\n\n\n\n\n\nclass WithKwargs(object):\n\n\n\n  @decorators.SetParseFns(mode=str, count=int)\n\n  def example6(self, **kwargs):\n\n    return (\n\n        kwargs.get('mode', 'default'),\n\n        kwargs.get('count', 0),\n\n    )\n\n\n\n\n\nclass WithVarArgs(object):\n\n\n\n  @decorators.SetParseFn(str)\n\n  def example7(self, arg1, arg2=None, *varargs, **kwargs):  # pylint: disable=keyword-arg-before-vararg\n\n    return arg1, arg2, varargs, kwargs\n\n\n\n\n\nclass FireDecoratorsTest(testutils.BaseTestCase):\n\n\n\n  def testSetParseFnsNamedArgs(self):\n\n    self.assertEqual(core.Fire(NoDefaults, command=['double', '2']), 4)\n\n    self.assertEqual(core.Fire(NoDefaults, command=['triple', '4']), 12.0)\n\n\n\n  def testSetParseFnsPositionalArgs(self):\n\n    self.assertEqual(core.Fire(NoDefaults, command=['quadruple', '5']), 20)\n\n\n\n  def testSetParseFnsFnWithPositionalArgs(self):\n\n    self.assertEqual(core.Fire(double, command=['5']), 10)\n\n\n\n  def testSetParseFnsDefaultsFromPython(self):\n\n    # When called from Python, function should behave normally.\n\n    self.assertTupleEqual(WithDefaults().example1(), (10, int))\n\n    self.assertEqual(WithDefaults().example1(5), (5, int))\n\n    self.assertEqual(WithDefaults().example1(12.0), (12, float))\n\n\n\n  def testSetParseFnsDefaultsFromFire(self):\n\n    # Fire should use the decorator to know how to parse string arguments.\n\n    self.assertEqual(core.Fire(WithDefaults, command=['example1']), (10, int))\n\n    self.assertEqual(core.Fire(WithDefaults, command=['example1', '10']),\n\n                     (10, float))\n\n    self.assertEqual(core.Fire(WithDefaults, command=['example1', '13']),\n\n                     (13, float))\n\n    self.assertEqual(core.Fire(WithDefaults, command=['example1', '14.0']),\n\n                     (14, float))\n\n\n\n  def testSetParseFnsNamedDefaultsFromPython(self):\n\n    # When called from Python, function should behave normally.\n\n    self.assertTupleEqual(WithDefaults().example2(), (10, int))\n\n    self.assertEqual(WithDefaults().example2(5), (5, int))\n\n    self.assertEqual(WithDefaults().example2(12.0), (12, float))\n\n\n\n  def testSetParseFnsNamedDefaultsFromFire(self):\n\n    # Fire should use the decorator to know how to parse string arguments.\n\n    self.assertEqual(core.Fire(WithDefaults, command=['example2']), (10, int))\n\n    self.assertEqual(core.Fire(WithDefaults, command=['example2', '10']),\n\n                     (10, float))\n\n    self.assertEqual(core.Fire(WithDefaults, command=['example2', '13']),\n\n                     (13, float))\n\n    self.assertEqual(core.Fire(WithDefaults, command=['example2', '14.0']),\n\n                     (14, float))\n\n\n\n  def testSetParseFnsPositionalAndNamed(self):\n\n    self.assertEqual(core.Fire(MixedArguments, ['example3', '10', '10']),\n\n                     (10, '10'))\n\n\n\n  def testSetParseFnsOnlySomeTypes(self):\n\n    self.assertEqual(\n\n        core.Fire(PartialParseFn, command=['example4', '10', '10']), ('10', 10))\n\n    self.assertEqual(\n\n        core.Fire(PartialParseFn, command=['example5', '10', '10']), (10, '10'))\n\n\n\n  def testSetParseFnsForKeywordArgs(self):\n\n    self.assertEqual(\n\n        core.Fire(WithKwargs, command=['example6']), ('default', 0))\n\n    self.assertEqual(\n\n        core.Fire(WithKwargs, command=['example6', '--herring', '\"red\"']),\n\n        ('default', 0))\n\n    self.assertEqual(\n\n        core.Fire(WithKwargs, command=['example6', '--mode', 'train']),\n\n        ('train', 0))\n\n    self.assertEqual(core.Fire(WithKwargs, command=['example6', '--mode', '3']),\n\n                     ('3', 0))\n\n    self.assertEqual(\n\n        core.Fire(WithKwargs,\n\n                  command=['example6', '--mode', '-1', '--count', '10']),\n\n        ('-1', 10))\n\n    self.assertEqual(\n\n        core.Fire(WithKwargs, command=['example6', '--count', '-2']),\n\n        ('default', -2))\n\n\n\n  def testSetParseFn(self):\n\n    self.assertEqual(\n\n        core.Fire(WithVarArgs,\n\n                  command=['example7', '1', '--arg2=2', '3', '4', '--kwarg=5']),\n\n        ('1', '2', ('3', '4'), {'kwarg': '5'}))\n\n\n\n\n\nif __name__ == '__main__':\n\n  testutils.main()\n", "# Copyright (C) 2018 Google Inc.\n\n#\n\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n\n# you may not use this file except in compliance with the License.\n\n# You may obtain a copy of the License at\n\n#\n\n# http://www.apache.org/licenses/LICENSE-2.0\n\n#\n\n# Unless required by applicable law or agreed to in writing, software\n\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n\n# See the License for the specific language governing permissions and\n\n# limitations under the License.\n\n\n\n\"\"\"Fuzz tests for the docstring parser module.\"\"\"\n\n\n\nfrom __future__ import absolute_import\n\nfrom __future__ import division\n\nfrom __future__ import print_function\n\n\n\nfrom fire import docstrings\n\nfrom fire import testutils\n\n\n\nfrom hypothesis import example\n\nfrom hypothesis import given\n\nfrom hypothesis import settings\n\nfrom hypothesis import strategies as st\n\n\n\n\n\nclass DocstringsFuzzTest(testutils.BaseTestCase):\n\n\n\n  @settings(max_examples=1000, deadline=1000)\n\n  @given(st.text(min_size=1))\n\n  @example('This is a one-line docstring.')\n\n  def test_fuzz_parse(self, value):\n\n    docstrings.parse(value)\n\n\n\n\n\nif __name__ == '__main__':\n\n  testutils.main()\n", "# Copyright (C) 2018 Google Inc.\n\n#\n\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n\n# you may not use this file except in compliance with the License.\n\n# You may obtain a copy of the License at\n\n#\n\n# http://www.apache.org/licenses/LICENSE-2.0\n\n#\n\n# Unless required by applicable law or agreed to in writing, software\n\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n\n# See the License for the specific language governing permissions and\n\n# limitations under the License.\n\n\n\n\"\"\"These decorators provide function metadata to Python Fire.\n\n\n\nSetParseFn and SetParseFns allow you to set the functions Fire uses for parsing\n\ncommand line arguments to client code.\n\n\"\"\"\n\n\n\nfrom __future__ import absolute_import\n\nfrom __future__ import division\n\nfrom __future__ import print_function\n\n\n\nimport inspect\n\n\n\nFIRE_METADATA = 'FIRE_METADATA'\n\nFIRE_PARSE_FNS = 'FIRE_PARSE_FNS'\n\nACCEPTS_POSITIONAL_ARGS = 'ACCEPTS_POSITIONAL_ARGS'\n\n\n\n\n\ndef SetParseFn(fn, *arguments):\n\n  \"\"\"Sets the fn for Fire to use to parse args when calling the decorated fn.\n\n\n\n  Args:\n\n    fn: The function to be used for parsing arguments.\n\n    *arguments: The arguments for which to use the parse fn. If none are listed,\n\n      then this will set the default parse function.\n\n  Returns:\n\n    The decorated function, which now has metadata telling Fire how to perform.\n\n  \"\"\"\n\n  def _Decorator(func):\n\n    parse_fns = GetParseFns(func)\n\n    if not arguments:\n\n      parse_fns['default'] = fn\n\n    else:\n\n      for argument in arguments:\n\n        parse_fns['named'][argument] = fn\n\n    _SetMetadata(func, FIRE_PARSE_FNS, parse_fns)\n\n    return func\n\n\n\n  return _Decorator\n\n\n\n\n\ndef SetParseFns(*positional, **named):\n\n  \"\"\"Set the fns for Fire to use to parse args when calling the decorated fn.\n\n\n\n  Returns a decorator, which when applied to a function adds metadata to the\n\n  function telling Fire how to turn string command line arguments into proper\n\n  Python arguments with which to call the function.\n\n\n\n  A parse function should accept a single string argument and return a value to\n\n  be used in its place when calling the decorated function.\n\n\n\n  Args:\n\n    *positional: The functions to be used for parsing positional arguments.\n\n    **named: The functions to be used for parsing named arguments.\n\n  Returns:\n\n    The decorated function, which now has metadata telling Fire how to perform.\n\n  \"\"\"\n\n  def _Decorator(fn):\n\n    parse_fns = GetParseFns(fn)\n\n    parse_fns['positional'] = positional\n\n    parse_fns['named'].update(named)  # pytype: disable=attribute-error\n\n    _SetMetadata(fn, FIRE_PARSE_FNS, parse_fns)\n\n    return fn\n\n\n\n  return _Decorator\n\n\n\n\n\ndef _SetMetadata(fn, attribute, value):\n\n  metadata = GetMetadata(fn)\n\n  metadata[attribute] = value\n\n  setattr(fn, FIRE_METADATA, metadata)\n\n\n\n\n\ndef GetMetadata(fn):\n\n  # type: (...) -> dict\n\n  \"\"\"Gets metadata attached to the function `fn` as an attribute.\n\n\n\n  Args:\n\n    fn: The function from which to retrieve the function metadata.\n\n  Returns:\n\n    A dictionary mapping property strings to their value.\n\n  \"\"\"\n\n  # Class __init__ functions and object __call__ functions require flag style\n\n  # arguments. Other methods and functions may accept positional args.\n\n  default = {\n\n      ACCEPTS_POSITIONAL_ARGS: inspect.isroutine(fn),\n\n  }\n\n  try:\n\n    metadata = getattr(fn, FIRE_METADATA, default)\n\n    if ACCEPTS_POSITIONAL_ARGS in metadata:\n\n      return metadata\n\n    else:\n\n      return default\n\n  except:  # pylint: disable=bare-except\n\n    return default\n\n\n\n\n\ndef GetParseFns(fn):\n\n  # type: (...) -> dict\n\n  metadata = GetMetadata(fn)\n\n  default = dict(default=None, positional=[], named={})\n\n  return metadata.get(FIRE_PARSE_FNS, default)\n", "# Copyright (C) 2018 Google Inc.\n\n#\n\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n\n# you may not use this file except in compliance with the License.\n\n# You may obtain a copy of the License at\n\n#\n\n# http://www.apache.org/licenses/LICENSE-2.0\n\n#\n\n# Unless required by applicable law or agreed to in writing, software\n\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n\n# See the License for the specific language governing permissions and\n\n# limitations under the License.\n\n\n\n\"\"\"Tests for the trace module.\"\"\"\n\n\n\nfrom __future__ import absolute_import\n\nfrom __future__ import division\n\nfrom __future__ import print_function\n\n\n\nfrom fire import testutils\n\nfrom fire import trace\n\n\n\n\n\nclass FireTraceTest(testutils.BaseTestCase):\n\n\n\n  def testFireTraceInitialization(self):\n\n    t = trace.FireTrace(10)\n\n    self.assertIsNotNone(t)\n\n    self.assertIsNotNone(t.elements)\n\n\n\n  def testFireTraceGetResult(self):\n\n    t = trace.FireTrace('start')\n\n    self.assertEqual(t.GetResult(), 'start')\n\n    t.AddAccessedProperty('t', 'final', None, 'example.py', 10)\n\n    self.assertEqual(t.GetResult(), 't')\n\n\n\n  def testFireTraceHasError(self):\n\n    t = trace.FireTrace('start')\n\n    self.assertFalse(t.HasError())\n\n    t.AddAccessedProperty('t', 'final', None, 'example.py', 10)\n\n    self.assertFalse(t.HasError())\n\n    t.AddError(ValueError('example error'), ['arg'])\n\n    self.assertTrue(t.HasError())\n\n\n\n  def testAddAccessedProperty(self):\n\n    t = trace.FireTrace('initial object')\n\n    args = ('example', 'args')\n\n    t.AddAccessedProperty('new component', 'prop', args, 'sample.py', 12)\n\n    self.assertEqual(\n\n        str(t),\n\n        '1. Initial component\\n2. Accessed property \"prop\" (sample.py:12)')\n\n\n\n  def testAddCalledCallable(self):\n\n    t = trace.FireTrace('initial object')\n\n    args = ('example', 'args')\n\n    t.AddCalledComponent('result', 'cell', args, 'sample.py', 10, False,\n\n                         action=trace.CALLED_CALLABLE)\n\n    self.assertEqual(\n\n        str(t),\n\n        '1. Initial component\\n2. Called callable \"cell\" (sample.py:10)')\n\n\n\n  def testAddCalledRoutine(self):\n\n    t = trace.FireTrace('initial object')\n\n    args = ('example', 'args')\n\n    t.AddCalledComponent('result', 'run', args, 'sample.py', 12, False,\n\n                         action=trace.CALLED_ROUTINE)\n\n    self.assertEqual(\n\n        str(t),\n\n        '1. Initial component\\n2. Called routine \"run\" (sample.py:12)')\n\n\n\n  def testAddInstantiatedClass(self):\n\n    t = trace.FireTrace('initial object')\n\n    args = ('example', 'args')\n\n    t.AddCalledComponent(\n\n        'Classname', 'classname', args, 'sample.py', 12, False,\n\n        action=trace.INSTANTIATED_CLASS)\n\n    target = \"\"\"1. Initial component\n\n2. Instantiated class \"classname\" (sample.py:12)\"\"\"\n\n    self.assertEqual(str(t), target)\n\n\n\n  def testAddCompletionScript(self):\n\n    t = trace.FireTrace('initial object')\n\n    t.AddCompletionScript('This is the completion script string.')\n\n    self.assertEqual(\n\n        str(t),\n\n        '1. Initial component\\n2. Generated completion script')\n\n\n\n  def testAddInteractiveMode(self):\n\n    t = trace.FireTrace('initial object')\n\n    t.AddInteractiveMode()\n\n    self.assertEqual(\n\n        str(t),\n\n        '1. Initial component\\n2. Entered interactive mode')\n\n\n\n  def testGetCommand(self):\n\n    t = trace.FireTrace('initial object')\n\n    args = ('example', 'args')\n\n    t.AddCalledComponent('result', 'run', args, 'sample.py', 12, False,\n\n                         action=trace.CALLED_ROUTINE)\n\n    self.assertEqual(t.GetCommand(), 'example args')\n\n\n\n  def testGetCommandWithQuotes(self):\n\n    t = trace.FireTrace('initial object')\n\n    args = ('example', 'spaced arg')\n\n    t.AddCalledComponent('result', 'run', args, 'sample.py', 12, False,\n\n                         action=trace.CALLED_ROUTINE)\n\n    self.assertEqual(t.GetCommand(), \"example 'spaced arg'\")\n\n\n\n  def testGetCommandWithFlagQuotes(self):\n\n    t = trace.FireTrace('initial object')\n\n    args = ('--example=spaced arg',)\n\n    t.AddCalledComponent('result', 'run', args, 'sample.py', 12, False,\n\n                         action=trace.CALLED_ROUTINE)\n\n    self.assertEqual(t.GetCommand(), \"--example='spaced arg'\")\n\n\n\n\n\nclass FireTraceElementTest(testutils.BaseTestCase):\n\n\n\n  def testFireTraceElementHasError(self):\n\n    el = trace.FireTraceElement()\n\n    self.assertFalse(el.HasError())\n\n\n\n    el = trace.FireTraceElement(error=ValueError('example error'))\n\n    self.assertTrue(el.HasError())\n\n\n\n  def testFireTraceElementAsStringNoMetadata(self):\n\n    el = trace.FireTraceElement(\n\n        component='Example',\n\n        action='Fake action',\n\n    )\n\n    self.assertEqual(str(el), 'Fake action')\n\n\n\n  def testFireTraceElementAsStringWithTarget(self):\n\n    el = trace.FireTraceElement(\n\n        component='Example',\n\n        action='Created toy',\n\n        target='Beaker',\n\n    )\n\n    self.assertEqual(str(el), 'Created toy \"Beaker\"')\n\n\n\n  def testFireTraceElementAsStringWithTargetAndLineNo(self):\n\n    el = trace.FireTraceElement(\n\n        component='Example',\n\n        action='Created toy',\n\n        target='Beaker',\n\n        filename='beaker.py',\n\n        lineno=10,\n\n    )\n\n    self.assertEqual(str(el), 'Created toy \"Beaker\" (beaker.py:10)')\n\n\n\n\n\nif __name__ == '__main__':\n\n  testutils.main()\n", "# Copyright (C) 2018 Google Inc.\n\n#\n\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n\n# you may not use this file except in compliance with the License.\n\n# You may obtain a copy of the License at\n\n#\n\n# http://www.apache.org/licenses/LICENSE-2.0\n\n#\n\n# Unless required by applicable law or agreed to in writing, software\n\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n\n# See the License for the specific language governing permissions and\n\n# limitations under the License.\n\n\n\n\"\"\"This module has classes for tracing the execution of a Fire execution.\n\n\n\nA FireTrace consists of a sequence of FireTraceElement objects. Each element\n\nrepresents an action taken by Fire during a single Fire execution. An action may\n\nbe instantiating a class, calling a routine, or accessing a property.\n\n\n\nEach action consumes args and results in a new component. The final component\n\nis serialized to stdout by Fire as well as returned by the Fire method. If\n\na Fire usage error occurs, such as insufficient arguments being provided to call\n\na function, then that error will be captured in the trace and the final\n\ncomponent will be None.\n\n\"\"\"\n\n\n\nfrom __future__ import absolute_import\n\nfrom __future__ import division\n\nfrom __future__ import print_function\n\n\n\nimport pipes\n\n\n\nfrom fire import inspectutils\n\n\n\nINITIAL_COMPONENT = 'Initial component'\n\nINSTANTIATED_CLASS = 'Instantiated class'\n\nCALLED_ROUTINE = 'Called routine'\n\nCALLED_CALLABLE = 'Called callable'\n\nACCESSED_PROPERTY = 'Accessed property'\n\nCOMPLETION_SCRIPT = 'Generated completion script'\n\nINTERACTIVE_MODE = 'Entered interactive mode'\n\n\n\n\n\nclass FireTrace(object):\n\n  \"\"\"A FireTrace represents the steps taken during a single Fire execution.\n\n\n\n  A FireTrace consists of a sequence of FireTraceElement objects. Each element\n\n  represents an action taken by Fire during a single Fire execution. An action\n\n  may be instantiating a class, calling a routine, or accessing a property.\n\n  \"\"\"\n\n\n\n  def __init__(self, initial_component, name=None, separator='-', verbose=False,\n\n               show_help=False, show_trace=False):\n\n    initial_trace_element = FireTraceElement(\n\n        component=initial_component,\n\n        action=INITIAL_COMPONENT,\n\n    )\n\n\n\n    self.name = name\n\n    self.separator = separator\n\n    self.elements = [initial_trace_element]\n\n    self.verbose = verbose\n\n    self.show_help = show_help\n\n    self.show_trace = show_trace\n\n\n\n  def GetResult(self):\n\n    \"\"\"Returns the component from the last element of the trace.\"\"\"\n\n    # pytype: disable=attribute-error\n\n    return self.GetLastHealthyElement().component\n\n    # pytype: enable=attribute-error\n\n\n\n  def GetLastHealthyElement(self):\n\n    \"\"\"Returns the last element of the trace that is not an error.\n\n\n\n    This element will contain the final component indicated by the trace.\n\n\n\n    Returns:\n\n      The last element of the trace that is not an error.\n\n    \"\"\"\n\n    for element in reversed(self.elements):\n\n      if not element.HasError():\n\n        return element\n\n    return None\n\n\n\n  def HasError(self):\n\n    \"\"\"Returns whether the Fire execution encountered a Fire usage error.\"\"\"\n\n    return self.elements[-1].HasError()\n\n\n\n  def AddAccessedProperty(self, component, target, args, filename, lineno):\n\n    element = FireTraceElement(\n\n        component=component,\n\n        action=ACCESSED_PROPERTY,\n\n        target=target,\n\n        args=args,\n\n        filename=filename,\n\n        lineno=lineno,\n\n    )\n\n    self.elements.append(element)\n\n\n\n  def AddCalledComponent(self, component, target, args, filename, lineno,\n\n                         capacity, action=CALLED_CALLABLE):\n\n    \"\"\"Adds an element to the trace indicating that a component was called.\n\n\n\n    Also applies to instantiating a class.\n\n\n\n    Args:\n\n      component: The result of calling the callable.\n\n      target: The name of the callable.\n\n      args: The args consumed in order to call this callable.\n\n      filename: The file in which the callable is defined, or None if N/A.\n\n      lineno: The line number on which the callable is defined, or None if N/A.\n\n      capacity: (bool) Whether the callable could have accepted additional args.\n\n      action: The value to include as the action in the FireTraceElement.\n\n    \"\"\"\n\n    element = FireTraceElement(\n\n        component=component,\n\n        action=action,\n\n        target=target,\n\n        args=args,\n\n        filename=filename,\n\n        lineno=lineno,\n\n        capacity=capacity,\n\n    )\n\n    self.elements.append(element)\n\n\n\n  def AddCompletionScript(self, script):\n\n    element = FireTraceElement(\n\n        component=script,\n\n        action=COMPLETION_SCRIPT,\n\n    )\n\n    self.elements.append(element)\n\n\n\n  def AddInteractiveMode(self):\n\n    element = FireTraceElement(action=INTERACTIVE_MODE)\n\n    self.elements.append(element)\n\n\n\n  def AddError(self, error, args):\n\n    element = FireTraceElement(error=error, args=args)\n\n    self.elements.append(element)\n\n\n\n  def AddSeparator(self):\n\n    \"\"\"Marks that the most recent element of the trace used  a separator.\n\n\n\n    A separator is an argument you can pass to a Fire CLI to separate args left\n\n    of the separator from args right of the separator.\n\n\n\n    Here's an example to demonstrate the separator. Let's say you have a\n\n    function that takes a variable number of args, and you want to call that\n\n    function, and then upper case the result. Here's how to do it:\n\n\n\n    # in Python\n\n    def display(arg1, arg2='!'):\n\n      return arg1 + arg2\n\n\n\n    # from Bash (the default separator is the hyphen -)\n\n    display hello   # hello!\n\n    display hello upper # helloupper\n\n    display hello - upper # HELLO!\n\n\n\n    Note how the separator caused the display function to be called with the\n\n    default value for arg2.\n\n    \"\"\"\n\n    self.elements[-1].AddSeparator()\n\n\n\n  def _Quote(self, arg):\n\n    if arg.startswith('--') and '=' in arg:\n\n      prefix, value = arg.split('=', 1)\n\n      return pipes.quote(prefix) + '=' + pipes.quote(value)\n\n    return pipes.quote(arg)\n\n\n\n  def GetCommand(self, include_separators=True):\n\n    \"\"\"Returns the command representing the trace up to this point.\n\n\n\n    Args:\n\n      include_separators: Whether or not to include separators in the command.\n\n\n\n    Returns:\n\n      A string representing a Fire CLI command that would produce this trace.\n\n    \"\"\"\n\n    args = []\n\n    if self.name:\n\n      args.append(self.name)\n\n\n\n    for element in self.elements:\n\n      if element.HasError():\n\n        continue\n\n      if element.args:\n\n        args.extend(element.args)\n\n      if element.HasSeparator() and include_separators:\n\n        args.append(self.separator)\n\n\n\n    if self.NeedsSeparator() and include_separators:\n\n      args.append(self.separator)\n\n\n\n    return ' '.join(self._Quote(arg) for arg in args)\n\n\n\n  def NeedsSeparator(self):\n\n    \"\"\"Returns whether a separator should be added to the command.\n\n\n\n    If the command is a function call, then adding an additional argument to the\n\n    command sometimes would add an extra arg to the function call, and sometimes\n\n    would add an arg acting on the result of the function call.\n\n\n\n    This function tells us whether we should add a separator to the command\n\n    before adding additional arguments in order to make sure the arg is applied\n\n    to the result of the function call, and not the function call itself.\n\n\n\n    Returns:\n\n      Whether a separator should be added to the command if order to keep the\n\n      component referred to by the command the same when adding additional args.\n\n    \"\"\"\n\n    element = self.GetLastHealthyElement()\n\n    return element.HasCapacity() and not element.HasSeparator()\n\n\n\n  def __str__(self):\n\n    lines = []\n\n    for index, element in enumerate(self.elements):\n\n      line = '{index}. {trace_string}'.format(\n\n          index=index + 1,\n\n          trace_string=element,\n\n      )\n\n      lines.append(line)\n\n    return '\\n'.join(lines)\n\n\n\n  def NeedsSeparatingHyphenHyphen(self, flag='help'):\n\n    \"\"\"Returns whether a the trace need '--' before '--help'.\n\n\n\n    '--' is needed when the component takes keyword arguments, when the value of\n\n    flag matches one of the argument of the component, or the component takes in\n\n    keyword-only arguments(e.g. argument with default value).\n\n\n\n    Args:\n\n      flag: the flag available for the trace\n\n\n\n    Returns:\n\n      True for needed '--', False otherwise.\n\n\n\n    \"\"\"\n\n    element = self.GetLastHealthyElement()\n\n    component = element.component\n\n    spec = inspectutils.GetFullArgSpec(component)\n\n    return (spec.varkw is not None\n\n            or flag in spec.args\n\n            or flag in spec.kwonlyargs)\n\n\n\n\n\nclass FireTraceElement(object):\n\n  \"\"\"A FireTraceElement represents a single step taken by a Fire execution.\n\n\n\n  Examples of a FireTraceElement are the instantiation of a class or the\n\n  accessing of an object member.\n\n  \"\"\"\n\n\n\n  def __init__(self,\n\n               component=None,\n\n               action=None,\n\n               target=None,\n\n               args=None,\n\n               filename=None,\n\n               lineno=None,\n\n               error=None,\n\n               capacity=None):\n\n    \"\"\"Instantiates a FireTraceElement.\n\n\n\n    Args:\n\n      component: The result of this element of the trace.\n\n      action: The type of action (eg instantiating a class) taking place.\n\n      target: (string) The name of the component being acted upon.\n\n      args: The args consumed by the represented action.\n\n      filename: The file in which the action is defined, or None if N/A.\n\n      lineno: The line number on which the action is defined, or None if N/A.\n\n      error: The error represented by the action, or None if N/A.\n\n      capacity: (bool) Whether the action could have accepted additional args.\n\n    \"\"\"\n\n    self.component = component\n\n    self._action = action\n\n    self._target = target\n\n    self.args = args\n\n    self._filename = filename\n\n    self._lineno = lineno\n\n    self._error = error\n\n    self._separator = False\n\n    self._capacity = capacity\n\n\n\n  def HasError(self):\n\n    return self._error is not None\n\n\n\n  def HasCapacity(self):\n\n    return self._capacity\n\n\n\n  def HasSeparator(self):\n\n    return self._separator\n\n\n\n  def AddSeparator(self):\n\n    self._separator = True\n\n\n\n  def ErrorAsStr(self):\n\n    return ' '.join(str(arg) for arg in self._error.args)\n\n\n\n  def __str__(self):\n\n    if self.HasError():\n\n      return self.ErrorAsStr()\n\n    else:\n\n      # Format is: {action} \"{target}\" ({filename}:{lineno})\n\n      string = self._action\n\n      if self._target is not None:\n\n        string += ' \"{target}\"'.format(target=self._target)\n\n      if self._filename is not None:\n\n        path = self._filename\n\n        if self._lineno is not None:\n\n          path += ':{lineno}'.format(lineno=self._lineno)\n\n\n\n        string += ' ({path})'.format(path=path)\n\n      return string\n", "# Copyright (C) 2018 Google Inc.\n\n#\n\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n\n# you may not use this file except in compliance with the License.\n\n# You may obtain a copy of the License at\n\n#\n\n# http://www.apache.org/licenses/LICENSE-2.0\n\n#\n\n# Unless required by applicable law or agreed to in writing, software\n\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n\n# See the License for the specific language governing permissions and\n\n# limitations under the License.\n\n\n\n# Lint as: python2, python3\n\n\"\"\"Utilities for Python Fire's tests.\"\"\"\n\n\n\nfrom __future__ import absolute_import\n\nfrom __future__ import division\n\nfrom __future__ import print_function\n\n\n\nimport contextlib\n\nimport os\n\nimport re\n\nimport sys\n\nimport unittest\n\n\n\nfrom fire import core\n\nfrom fire import trace\n\n\n\nimport mock\n\nimport six\n\n\n\n\n\nclass BaseTestCase(unittest.TestCase):\n\n  \"\"\"Shared test case for Python Fire tests.\"\"\"\n\n\n\n  @contextlib.contextmanager\n\n  def assertOutputMatches(self, stdout='.*', stderr='.*', capture=True):\n\n    \"\"\"Asserts that the context generates stdout and stderr matching regexps.\n\n\n\n    Note: If wrapped code raises an exception, stdout and stderr will not be\n\n      checked.\n\n\n\n    Args:\n\n      stdout: (str) regexp to match against stdout (None will check no stdout)\n\n      stderr: (str) regexp to match against stderr (None will check no stderr)\n\n      capture: (bool, default True) do not bubble up stdout or stderr\n\n\n\n    Yields:\n\n      Yields to the wrapped context.\n\n    \"\"\"\n\n    stdout_fp = six.StringIO()\n\n    stderr_fp = six.StringIO()\n\n    try:\n\n      with mock.patch.object(sys, 'stdout', stdout_fp):\n\n        with mock.patch.object(sys, 'stderr', stderr_fp):\n\n          yield\n\n    finally:\n\n      if not capture:\n\n        sys.stdout.write(stdout_fp.getvalue())\n\n        sys.stderr.write(stderr_fp.getvalue())\n\n\n\n    for name, regexp, fp in [('stdout', stdout, stdout_fp),\n\n                             ('stderr', stderr, stderr_fp)]:\n\n      value = fp.getvalue()\n\n      if regexp is None:\n\n        if value:\n\n          raise AssertionError('%s: Expected no output. Got: %r' %\n\n                               (name, value))\n\n      else:\n\n        if not re.search(regexp, value, re.DOTALL | re.MULTILINE):\n\n          raise AssertionError('%s: Expected %r to match %r' %\n\n                               (name, value, regexp))\n\n\n\n  def assertRaisesRegex(self, *args, **kwargs):  # pylint: disable=arguments-differ\n\n    if sys.version_info.major == 2:\n\n      return super(BaseTestCase, self).assertRaisesRegexp(*args, **kwargs)  # pylint: disable=deprecated-method\n\n    else:\n\n      return super(BaseTestCase, self).assertRaisesRegex(*args, **kwargs)  # pylint: disable=no-member\n\n\n\n  @contextlib.contextmanager\n\n  def assertRaisesFireExit(self, code, regexp='.*'):\n\n    \"\"\"Asserts that a FireExit error is raised in the context.\n\n\n\n    Allows tests to check that Fire's wrapper around SystemExit is raised\n\n    and that a regexp is matched in the output.\n\n\n\n    Args:\n\n      code: The status code that the FireExit should contain.\n\n      regexp: stdout must match this regex.\n\n\n\n    Yields:\n\n      Yields to the wrapped context.\n\n    \"\"\"\n\n    with self.assertOutputMatches(stderr=regexp):\n\n      with self.assertRaises(core.FireExit):\n\n        try:\n\n          yield\n\n        except core.FireExit as exc:\n\n          if exc.code != code:\n\n            raise AssertionError('Incorrect exit code: %r != %r' %\n\n                                 (exc.code, code))\n\n          self.assertIsInstance(exc.trace, trace.FireTrace)\n\n          raise\n\n\n\n\n\n@contextlib.contextmanager\n\ndef ChangeDirectory(directory):\n\n  \"\"\"Context manager to mock a directory change and revert on exit.\"\"\"\n\n  cwdir = os.getcwd()\n\n  os.chdir(directory)\n\n\n\n  try:\n\n    yield directory\n\n  finally:\n\n    os.chdir(cwdir)\n\n\n\n\n\n# pylint: disable=invalid-name\n\nmain = unittest.main\n\nskip = unittest.skip\n\nskipIf = unittest.skipIf\n\n# pylint: enable=invalid-name\n", "# Copyright (C) 2018 Google Inc.\n\n#\n\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n\n# you may not use this file except in compliance with the License.\n\n# You may obtain a copy of the License at\n\n#\n\n# http://www.apache.org/licenses/LICENSE-2.0\n\n#\n\n# Unless required by applicable law or agreed to in writing, software\n\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n\n# See the License for the specific language governing permissions and\n\n# limitations under the License.\n\n\n\n\"\"\"Docstring parsing module for Python Fire.\n\n\n\nThe following features of docstrings are not supported.\n\nTODO(dbieber): Support these features.\n\n- numpy docstrings may begin with the function signature.\n\n- whitespace may be important for proper structuring of a docstring\n\n- I've seen `argname` (with single backticks) as a style of documenting\n\n  arguments. The `argname` appears on one line, and the description on the next.\n\n- .. Sphinx directives such as .. note:: are not understood.\n\n- After a section ends, future contents may be included in the section. E.g.\n\n  :returns: This is what is returned.\n\n  Example: An example goes here.\n\n- @param is sometimes used.  E.g.\n\n  @param argname (type) Description\n\n  @return (type) Description\n\n- The true signature of a function is not used by the docstring parser. It could\n\n  be useful for determining whether something is a section header or an argument\n\n  for example.\n\n- This example confuses types as part of the docstrings.\n\n  Parameters\n\n  argname : argtype\n\n  Arg description\n\n- If there's no blank line after the summary, the description will be slurped\n\n  up into the summary.\n\n- \"Examples\" should be its own section type. aka \"Usage\".\n\n- \"Notes\" should be a section type.\n\n- Some people put parenthesis around their types in RST format, e.g.\n\n  :param (type) paramname:\n\n- :rtype: directive (return type)\n\n- Also \":rtype str\" with no closing \":\" has come up.\n\n- Return types are not supported.\n\n- \"# Returns\" as a section title style\n\n- \":raises ExceptionType: Description\" ignores the ExceptionType currently.\n\n- \"Defaults to X\" occurs sometimes.\n\n- \"True | False\" indicates bool type.\n\n\"\"\"\n\n\n\nfrom __future__ import absolute_import\n\nfrom __future__ import division\n\nfrom __future__ import print_function\n\n\n\nimport collections\n\nimport enum\n\nimport re\n\nimport textwrap\n\n\n\n\n\nclass DocstringInfo(\n\n    collections.namedtuple(\n\n        'DocstringInfo',\n\n        ('summary', 'description', 'args', 'returns', 'yields', 'raises'))):\n\n  pass\n\nDocstringInfo.__new__.__defaults__ = (None,) * len(DocstringInfo._fields)\n\n\n\n\n\nclass ArgInfo(\n\n    collections.namedtuple(\n\n        'ArgInfo',\n\n        ('name', 'type', 'description'))):\n\n  pass\n\nArgInfo.__new__.__defaults__ = (None,) * len(ArgInfo._fields)\n\n\n\n\n\nclass KwargInfo(ArgInfo):\n\n  pass\n\nKwargInfo.__new__.__defaults__ = (None,) * len(KwargInfo._fields)\n\n\n\n\n\nclass Namespace(dict):\n\n  \"\"\"A dict with attribute (dot-notation) access enabled.\"\"\"\n\n\n\n  def __getattr__(self, key):\n\n    if key not in self:\n\n      self[key] = Namespace()\n\n    return self[key]\n\n\n\n  def __setattr__(self, key, value):\n\n    self[key] = value\n\n\n\n  def __delattr__(self, key):\n\n    if key in self:\n\n      del self[key]\n\n\n\n\n\nclass Sections(enum.Enum):\n\n  ARGS = 0\n\n  RETURNS = 1\n\n  YIELDS = 2\n\n  RAISES = 3\n\n  TYPE = 4\n\n\n\n\n\nclass Formats(enum.Enum):\n\n  GOOGLE = 0\n\n  NUMPY = 1\n\n  RST = 2\n\n\n\n\n\nSECTION_TITLES = {\n\n    Sections.ARGS: ('argument', 'arg', 'parameter', 'param', 'key'),\n\n    Sections.RETURNS: ('return',),\n\n    Sections.YIELDS: ('yield',),\n\n    Sections.RAISES: ('raise', 'except', 'exception', 'throw', 'error', 'warn'),\n\n    Sections.TYPE: ('type',),  # rst-only\n\n}\n\n\n\n\n\ndef parse(docstring):\n\n  \"\"\"Returns DocstringInfo about the given docstring.\n\n\n\n  This parser aims to parse Google, numpy, and rst formatted docstrings. These\n\n  are the three most common docstring styles at the time of this writing.\n\n\n\n  This parser aims to be permissive, working even when the docstring deviates\n\n  from the strict recommendations of these styles.\n\n\n\n  This parser does not aim to fully extract all structured information from a\n\n  docstring, since there are simply too many ways to structure information in a\n\n  docstring. Sometimes content will remain as unstructured text and simply gets\n\n  included in the description.\n\n\n\n  The Google docstring style guide is available at:\n\n  https://github.com/google/styleguide/blob/gh-pages/pyguide.md\n\n\n\n  The numpy docstring style guide is available at:\n\n  https://numpydoc.readthedocs.io/en/latest/format.html\n\n\n\n  Information about the rST docstring format is available at:\n\n  https://www.python.org/dev/peps/pep-0287/\n\n  The full set of directives such as param and type for rST docstrings are at:\n\n  http://www.sphinx-doc.org/en/master/usage/restructuredtext/domains.html\n\n\n\n  Note: This function does not claim to handle all docstrings well. A list of\n\n  limitations is available at the top of the file. It does aim to run without\n\n  crashing in O(n) time on all strings on length n. If you find a string that\n\n  causes this to crash or run unacceptably slowly, please consider submitting\n\n  a pull request.\n\n\n\n  Args:\n\n    docstring: The docstring to parse.\n\n\n\n  Returns:\n\n    A DocstringInfo containing information about the docstring.\n\n  \"\"\"\n\n  if docstring is None:\n\n    return DocstringInfo()\n\n\n\n  lines = docstring.strip().split('\\n')\n\n  lines_len = len(lines)\n\n  state = Namespace()  # TODO(dbieber): Switch to an explicit class.\n\n\n\n  # Variables in state include:\n\n  state.section.title = None\n\n  state.section.indentation = None\n\n  state.section.line1_indentation = None\n\n  state.section.format = None\n\n  state.summary.permitted = True\n\n  state.summary.lines = []\n\n  state.description.lines = []\n\n  state.args = []\n\n  state.kwargs = []\n\n  state.current_arg = None\n\n  state.returns.lines = []\n\n  state.yields.lines = []\n\n  state.raises.lines = []\n\n\n\n  for index, line in enumerate(lines):\n\n    has_next = index + 1 < lines_len\n\n    previous_line = lines[index - 1] if index > 0 else None\n\n    next_line = lines[index + 1] if has_next else None\n\n    line_info = _create_line_info(line, next_line, previous_line)\n\n    _consume_line(line_info, state)\n\n\n\n  summary = ' '.join(state.summary.lines) if state.summary.lines else None\n\n  state.description.lines = _strip_blank_lines(state.description.lines)\n\n  description = textwrap.dedent('\\n'.join(state.description.lines))\n\n  if not description:\n\n    description = None\n\n  returns = _join_lines(state.returns.lines)\n\n  yields = _join_lines(state.yields.lines)\n\n  raises = _join_lines(state.raises.lines)\n\n\n\n  args = [ArgInfo(\n\n      name=arg.name, type=_cast_to_known_type(_join_lines(arg.type.lines)),\n\n      description=_join_lines(arg.description.lines)) for arg in state.args]\n\n\n\n  args.extend([KwargInfo(\n\n      name=arg.name, type=_cast_to_known_type(_join_lines(arg.type.lines)),\n\n      description=_join_lines(arg.description.lines)) for arg in state.kwargs])\n\n\n\n  return DocstringInfo(\n\n      summary=summary,\n\n      description=description,\n\n      args=args or None,\n\n      returns=returns,\n\n      raises=raises,\n\n      yields=yields,\n\n  )\n\n\n\n\n\ndef _strip_blank_lines(lines):\n\n  \"\"\"Removes lines containing only blank characters before and after the text.\n\n\n\n  Args:\n\n    lines: A list of lines.\n\n  Returns:\n\n    A list of lines without trailing or leading blank lines.\n\n  \"\"\"\n\n  # Find the first non-blank line.\n\n  start = 0\n\n  num_lines = len(lines)\n\n  while lines and start < num_lines and _is_blank(lines[start]):\n\n    start += 1\n\n\n\n  lines = lines[start:]\n\n\n\n  # Remove trailing blank lines.\n\n  while lines and _is_blank(lines[-1]):\n\n    lines.pop()\n\n\n\n  return lines\n\n\n\n\n\ndef _is_blank(line):\n\n  return not line or line.isspace()\n\n\n\n\n\ndef _join_lines(lines):\n\n  \"\"\"Joins lines with the appropriate connective whitespace.\n\n\n\n  This puts a single space between consecutive lines, unless there's a blank\n\n  line, in which case a full blank line is included.\n\n\n\n  Args:\n\n    lines: A list of lines to join.\n\n  Returns:\n\n    A string, the lines joined together.\n\n  \"\"\"\n\n  # TODO(dbieber): Add parameters for variations in whitespace handling.\n\n  if not lines:\n\n    return None\n\n\n\n  started = False\n\n  group_texts = []  # Full text of each section.\n\n  group_lines = []  # Lines within the current section.\n\n  for line in lines:\n\n    stripped_line = line.strip()\n\n    if stripped_line:\n\n      started = True\n\n      group_lines.append(stripped_line)\n\n    else:\n\n      if started:\n\n        group_text = ' '.join(group_lines)\n\n        group_texts.append(group_text)\n\n        group_lines = []\n\n\n\n  if group_lines:  # Process the final group.\n\n    group_text = ' '.join(group_lines)\n\n    group_texts.append(group_text)\n\n\n\n  return '\\n\\n'.join(group_texts)\n\n\n\n\n\ndef _get_or_create_arg_by_name(state, name, is_kwarg=False):\n\n  \"\"\"Gets or creates a new Arg.\n\n\n\n  These Arg objects (Namespaces) are turned into the ArgInfo namedtuples\n\n  returned by parse. Each Arg object is used to collect the name, type, and\n\n  description of a single argument to the docstring's function.\n\n\n\n  Args:\n\n    state: The state of the parser.\n\n    name: The name of the arg to create.\n\n    is_kwarg: A boolean representing whether the argument is a keyword arg.\n\n  Returns:\n\n    The new Arg.\n\n  \"\"\"\n\n  for arg in state.args + state.kwargs:\n\n    if arg.name == name:\n\n      return arg\n\n  arg = Namespace()  # TODO(dbieber): Switch to an explicit class.\n\n  arg.name = name\n\n  arg.type.lines = []\n\n  arg.description.lines = []\n\n  if is_kwarg:\n\n    state.kwargs.append(arg)\n\n  else:\n\n    state.args.append(arg)\n\n  return arg\n\n\n\n\n\ndef _is_arg_name(name):\n\n  \"\"\"Returns whether name is a valid arg name.\n\n\n\n  This is used to prevent multiple words (plaintext) from being misinterpreted\n\n  as an argument name. Any line that doesn't match the pattern for a valid\n\n  argument is treated as not being an argument.\n\n\n\n  Args:\n\n    name: The name of the potential arg.\n\n  Returns:\n\n    True if name looks like an arg name, False otherwise.\n\n  \"\"\"\n\n  name = name.strip()\n\n  # arg_pattern is a letter or underscore followed by\n\n  # zero or more letters, numbers, or underscores.\n\n  arg_pattern = r'^[a-zA-Z_]\\w*$'\n\n  re.match(arg_pattern, name)\n\n  return re.match(arg_pattern, name) is not None\n\n\n\n\n\ndef _as_arg_name_and_type(text):\n\n  \"\"\"Returns text as a name and type, if text looks like an arg name and type.\n\n\n\n  Example:\n\n    _as_arg_name_and_type(\"foo (int)\") == \"foo\", \"int\"\n\n\n\n  Args:\n\n    text: The text, which may or may not be an arg name and type.\n\n  Returns:\n\n    The arg name and type, if text looks like an arg name and type.\n\n    None otherwise.\n\n  \"\"\"\n\n  tokens = text.split()\n\n  if len(tokens) < 2:\n\n    return None\n\n  if _is_arg_name(tokens[0]):\n\n    type_token = ' '.join(tokens[1:])\n\n    type_token = type_token.lstrip('{([').rstrip('])}')\n\n    return tokens[0], type_token\n\n  else:\n\n    return None\n\n\n\n\n\ndef _as_arg_names(names_str):\n\n  \"\"\"Converts names_str to a list of arg names.\n\n\n\n  Example:\n\n    _as_arg_names(\"a, b, c\") == [\"a\", \"b\", \"c\"]\n\n\n\n  Args:\n\n    names_str: A string with multiple space or comma separated arg names.\n\n  Returns:\n\n    A list of arg names, or None if names_str doesn't look like a list of arg\n\n    names.\n\n  \"\"\"\n\n  names = re.split(',| ', names_str)\n\n  names = [name.strip() for name in names if name.strip()]\n\n  for name in names:\n\n    if not _is_arg_name(name):\n\n      return None\n\n  if not names:\n\n    return None\n\n  return names\n\n\n\n\n\ndef _cast_to_known_type(name):\n\n  \"\"\"Canonicalizes a string representing a type if possible.\n\n\n\n  # TODO(dbieber): Support additional canonicalization, such as string/str, and\n\n  # boolean/bool.\n\n\n\n  Example:\n\n    _cast_to_known_type(\"str.\") == \"str\"\n\n\n\n  Args:\n\n    name: A string representing a type, or None.\n\n  Returns:\n\n    A canonicalized version of the type string.\n\n  \"\"\"\n\n  if name is None:\n\n    return None\n\n  return name.rstrip('.')\n\n\n\n\n\ndef _consume_google_args_line(line_info, state):\n\n  \"\"\"Consume a single line from a Google args section.\"\"\"\n\n  split_line = line_info.remaining.split(':', 1)\n\n  if len(split_line) > 1:\n\n    first, second = split_line  # first is either the \"arg\" or \"arg (type)\"\n\n    if _is_arg_name(first.strip()):\n\n      arg = _get_or_create_arg_by_name(state, first.strip())\n\n      arg.description.lines.append(second.strip())\n\n      state.current_arg = arg\n\n    else:\n\n      arg_name_and_type = _as_arg_name_and_type(first)\n\n      if arg_name_and_type:\n\n        arg_name, type_str = arg_name_and_type\n\n        arg = _get_or_create_arg_by_name(state, arg_name)\n\n        arg.type.lines.append(type_str)\n\n        arg.description.lines.append(second.strip())\n\n        state.current_arg = arg\n\n      else:\n\n        if state.current_arg:\n\n          state.current_arg.description.lines.append(split_line[0])\n\n  else:\n\n    if state.current_arg:\n\n      state.current_arg.description.lines.append(split_line[0])\n\n\n\n\n\ndef _consume_line(line_info, state):\n\n  \"\"\"Consumes one line of text, updating the state accordingly.\n\n\n\n  When _consume_line is called, part of the line may already have been processed\n\n  for header information.\n\n\n\n  Args:\n\n    line_info: Information about the current and next line of the docstring.\n\n    state: The state of the docstring parser.\n\n  \"\"\"\n\n  _update_section_state(line_info, state)\n\n\n\n  if state.section.title is None:\n\n    if state.summary.permitted:\n\n      if line_info.remaining:\n\n        state.summary.lines.append(line_info.remaining)\n\n      elif state.summary.lines:\n\n        state.summary.permitted = False\n\n    else:\n\n      # We're past the end of the summary.\n\n      # Additions now contribute to the description.\n\n      state.description.lines.append(line_info.remaining_raw)\n\n  else:\n\n    state.summary.permitted = False\n\n\n\n  if state.section.new and state.section.format == Formats.RST:\n\n    # The current line starts with an RST directive, e.g. \":param arg:\".\n\n    directive = _get_directive(line_info)\n\n    directive_tokens = directive.split()  # pytype: disable=attribute-error\n\n    if state.section.title == Sections.ARGS:\n\n      name = directive_tokens[-1]\n\n      arg = _get_or_create_arg_by_name(\n\n          state,\n\n          name,\n\n          is_kwarg=directive_tokens[0] == 'key'\n\n      )\n\n      if len(directive_tokens) == 3:\n\n        # A param directive of the form \":param type arg:\".\n\n        arg.type.lines.append(directive_tokens[1])\n\n      state.current_arg = arg\n\n    elif state.section.title == Sections.TYPE:\n\n      name = directive_tokens[-1]\n\n      arg = _get_or_create_arg_by_name(state, name)\n\n      state.current_arg = arg\n\n\n\n  if (state.section.format == Formats.NUMPY and\n\n      _line_is_hyphens(line_info.remaining)):\n\n    # Skip this all-hyphens line, which is part of the numpy section header.\n\n    return\n\n\n\n  if state.section.title == Sections.ARGS:\n\n    if state.section.format == Formats.GOOGLE:\n\n      _consume_google_args_line(line_info, state)\n\n    elif state.section.format == Formats.RST:\n\n      state.current_arg.description.lines.append(line_info.remaining.strip())\n\n    elif state.section.format == Formats.NUMPY:\n\n      line_stripped = line_info.remaining.strip()\n\n      if _is_arg_name(line_stripped):\n\n        # Token on its own line can either be the last word of the description\n\n        # of the previous arg, or a new arg. TODO: Whitespace can distinguish.\n\n        arg = _get_or_create_arg_by_name(state, line_stripped)\n\n        state.current_arg = arg\n\n      elif _line_is_numpy_parameter_type(line_info):\n\n        possible_args, type_data = line_stripped.split(':', 1)\n\n        arg_names = _as_arg_names(possible_args)  # re.split(' |,', s)\n\n        if arg_names:\n\n          for arg_name in arg_names:\n\n            arg = _get_or_create_arg_by_name(state, arg_name)\n\n            arg.type.lines.append(type_data)\n\n            state.current_arg = arg  # TODO(dbieber): Multiple current args.\n\n        else:  # Just an ordinary line.\n\n          if state.current_arg:\n\n            state.current_arg.description.lines.append(\n\n                line_info.remaining.strip())\n\n          else:\n\n            # TODO(dbieber): If not a blank line, add it to the description.\n\n            pass\n\n      else:  # Just an ordinary line.\n\n        if state.current_arg:\n\n          state.current_arg.description.lines.append(\n\n              line_info.remaining.strip())\n\n        else:\n\n          # TODO(dbieber): If not a blank line, add it to the description.\n\n          pass\n\n\n\n  elif state.section.title == Sections.RETURNS:\n\n    state.returns.lines.append(line_info.remaining.strip())\n\n  elif state.section.title == Sections.YIELDS:\n\n    state.yields.lines.append(line_info.remaining.strip())\n\n  elif state.section.title == Sections.RAISES:\n\n    state.raises.lines.append(line_info.remaining.strip())\n\n  elif state.section.title == Sections.TYPE:\n\n    if state.section.format == Formats.RST:\n\n      assert state.current_arg is not None\n\n      state.current_arg.type.lines.append(line_info.remaining.strip())\n\n    else:\n\n      pass\n\n\n\n\n\ndef _create_line_info(line, next_line, previous_line):\n\n  \"\"\"Returns information about the current line and surrounding lines.\"\"\"\n\n  line_info = Namespace()  # TODO(dbieber): Switch to an explicit class.\n\n  line_info.line = line\n\n  line_info.stripped = line.strip()\n\n  line_info.remaining_raw = line_info.line\n\n  line_info.remaining = line_info.stripped\n\n  line_info.indentation = len(line) - len(line.lstrip())\n\n  # TODO(dbieber): If next_line is blank, use the next non-blank line.\n\n  line_info.next.line = next_line\n\n  next_line_exists = next_line is not None\n\n  line_info.next.stripped = next_line.strip() if next_line_exists else None\n\n  line_info.next.indentation = (\n\n      len(next_line) - len(next_line.lstrip()) if next_line_exists else None)\n\n  line_info.previous.line = previous_line\n\n  previous_line_exists = previous_line is not None\n\n  line_info.previous.indentation = (\n\n      len(previous_line) -\n\n      len(previous_line.lstrip()) if previous_line_exists else None)\n\n  # Note: This counts all whitespace equally.\n\n  return line_info\n\n\n\n\n\ndef _update_section_state(line_info, state):\n\n  \"\"\"Uses line_info to determine the current section of the docstring.\n\n\n\n  Updates state and line_info.remaining.\n\n\n\n  Args:\n\n    line_info: Information about the current line.\n\n    state: The state of the parser.\n\n  \"\"\"\n\n  section_updated = False\n\n\n\n  google_section_permitted = _google_section_permitted(line_info, state)\n\n  google_section = google_section_permitted and _google_section(line_info)\n\n  if google_section:\n\n    state.section.format = Formats.GOOGLE\n\n    state.section.title = google_section\n\n    line_info.remaining = _get_after_google_header(line_info)\n\n    line_info.remaining_raw = line_info.remaining\n\n    section_updated = True\n\n\n\n  rst_section = _rst_section(line_info)\n\n  if rst_section:\n\n    state.section.format = Formats.RST\n\n    state.section.title = rst_section\n\n    line_info.remaining = _get_after_directive(line_info)\n\n    line_info.remaining_raw = line_info.remaining\n\n    section_updated = True\n\n\n\n  numpy_section = _numpy_section(line_info)\n\n  if numpy_section:\n\n    state.section.format = Formats.NUMPY\n\n    state.section.title = numpy_section\n\n    line_info.remaining = ''\n\n    line_info.remaining_raw = line_info.remaining\n\n    section_updated = True\n\n\n\n  if section_updated:\n\n    state.section.new = True\n\n    state.section.indentation = line_info.indentation\n\n    state.section.line1_indentation = line_info.next.indentation\n\n  else:\n\n    state.section.new = False\n\n\n\n\n\ndef _google_section_permitted(line_info, state):\n\n  \"\"\"Returns whether a new google section is permitted to start here.\n\n\n\n  Q: Why might a new Google section not be allowed?\n\n  A: If we're in the middle of a Google \"Args\" section, then lines that start\n\n  \"param:\" will usually be a new arg, rather than a new section.\n\n  We use whitespace to determine when the Args section has actually ended.\n\n\n\n  A Google section ends when either:\n\n  - A new google section begins at either\n\n    - indentation less than indentation of line 1 of the previous section\n\n    - or <= indentation of the previous section\n\n  - Or the docstring terminates.\n\n\n\n  Args:\n\n    line_info: Information about the current line.\n\n    state: The state of the parser.\n\n  Returns:\n\n    True or False, indicating whether a new Google section is permitted at the\n\n    current line.\n\n  \"\"\"\n\n  if state.section.indentation is None:  # We're not in a section yet.\n\n    return True\n\n  return (line_info.indentation <= state.section.indentation\n\n          or line_info.indentation < state.section.line1_indentation)\n\n\n\n\n\ndef _matches_section_title(title, section_title):\n\n  \"\"\"Returns whether title is a match for a specific section_title.\n\n\n\n  Example:\n\n    _matches_section_title('Yields', 'yield') == True\n\n\n\n  Args:\n\n    title: The title to check for matching.\n\n    section_title: A specific known section title to check against.\n\n  \"\"\"\n\n  title = title.lower()\n\n  section_title = section_title.lower()\n\n  return section_title in (title, title[:-1])  # Supports plurals / some typos.\n\n\n\n\n\ndef _matches_section(title, section):\n\n  \"\"\"Returns whether title is a match any known title for a specific section.\n\n\n\n  Example:\n\n    _matches_section_title('Yields', Sections.YIELDS) == True\n\n    _matches_section_title('param', Sections.Args) == True\n\n\n\n  Args:\n\n    title: The title to check for matching.\n\n    section: A specific section to check all possible titles for.\n\n  Returns:\n\n    True or False, indicating whether title is a match for the specified\n\n    section.\n\n  \"\"\"\n\n  for section_title in SECTION_TITLES[section]:\n\n    if _matches_section_title(title, section_title):\n\n      return True\n\n  return False\n\n\n\n\n\ndef _section_from_possible_title(possible_title):\n\n  \"\"\"Returns a section matched by the possible title, or None if none match.\n\n\n\n  Args:\n\n    possible_title: A string that may be the title of a new section.\n\n  Returns:\n\n    A Section type if one matches, or None if no section type matches.\n\n  \"\"\"\n\n  for section in SECTION_TITLES:\n\n    if _matches_section(possible_title, section):\n\n      return section\n\n  return None\n\n\n\n\n\ndef _google_section(line_info):\n\n  \"\"\"Checks whether the current line is the start of a new Google-style section.\n\n\n\n  This docstring is a Google-style docstring. Google-style sections look like\n\n  this:\n\n\n\n    Section Name:\n\n      section body goes here\n\n\n\n  Args:\n\n    line_info: Information about the current line.\n\n  Returns:\n\n    A Section type if one matches, or None if no section type matches.\n\n  \"\"\"\n\n  colon_index = line_info.remaining.find(':')\n\n  possible_title = line_info.remaining[:colon_index]\n\n  return _section_from_possible_title(possible_title)\n\n\n\n\n\ndef _get_after_google_header(line_info):\n\n  \"\"\"Gets the remainder of the line, after a Google header.\"\"\"\n\n  colon_index = line_info.remaining.find(':')\n\n  return line_info.remaining[colon_index + 1:]\n\n\n\n\n\ndef _get_directive(line_info):\n\n  \"\"\"Gets a directive from the start of the line.\n\n\n\n  If the line is \":param str foo: Description of foo\", then\n\n  _get_directive(line_info) returns \"param str foo\".\n\n\n\n  Args:\n\n    line_info: Information about the current line.\n\n  Returns:\n\n    The contents of a directive, or None if the line doesn't start with a\n\n    directive.\n\n  \"\"\"\n\n  if line_info.stripped.startswith(':'):\n\n    return line_info.stripped.split(':', 2)[1]\n\n  else:\n\n    return None\n\n\n\n\n\ndef _get_after_directive(line_info):\n\n  \"\"\"Gets the remainder of the line, after a directive.\"\"\"\n\n  sections = line_info.stripped.split(':', 2)\n\n  if len(sections) > 2:\n\n    return sections[-1]\n\n  else:\n\n    return ''\n\n\n\n\n\ndef _rst_section(line_info):\n\n  \"\"\"Checks whether the current line is the start of a new RST-style section.\n\n\n\n  RST uses directives to specify information. An RST directive, which we refer\n\n  to as a section here, are surrounded with colons. For example, :param name:.\n\n\n\n  Args:\n\n    line_info: Information about the current line.\n\n  Returns:\n\n    A Section type if one matches, or None if no section type matches.\n\n  \"\"\"\n\n  directive = _get_directive(line_info)\n\n  if directive:\n\n    possible_title = directive.split()[0]\n\n    return _section_from_possible_title(possible_title)\n\n  else:\n\n    return None\n\n\n\n\n\ndef _line_is_hyphens(line):\n\n  \"\"\"Returns whether the line is entirely hyphens (and not blank).\"\"\"\n\n  return line and not line.strip('-')\n\n\n\n\n\ndef _numpy_section(line_info):\n\n  \"\"\"Checks whether the current line is the start of a new numpy-style section.\n\n\n\n  Numpy style sections are followed by a full line of hyphens, for example:\n\n\n\n    Section Name\n\n    ------------\n\n    Section body goes here.\n\n\n\n  Args:\n\n    line_info: Information about the current line.\n\n  Returns:\n\n    A Section type if one matches, or None if no section type matches.\n\n  \"\"\"\n\n  next_line_is_hyphens = _line_is_hyphens(line_info.next.stripped)\n\n  if next_line_is_hyphens:\n\n    possible_title = line_info.remaining\n\n    return _section_from_possible_title(possible_title)\n\n  else:\n\n    return None\n\n\n\n\n\ndef _line_is_numpy_parameter_type(line_info):\n\n  \"\"\"Returns whether the line contains a numpy style parameter type definition.\n\n\n\n  We look for a line of the form:\n\n  x : type\n\n\n\n  And we have to exclude false positives on argument descriptions containing a\n\n  colon by checking the indentation of the line above.\n\n\n\n  Args:\n\n    line_info: Information about the current line.\n\n  Returns:\n\n    True if the line is a numpy parameter type definition, False otherwise.\n\n  \"\"\"\n\n  line_stripped = line_info.remaining.strip()\n\n  if ':' in line_stripped:\n\n    previous_indent = line_info.previous.indentation\n\n    current_indent = line_info.indentation\n\n    if ':' in line_info.previous.line and current_indent > previous_indent:\n\n      # The parameter type was the previous line; this is the description.\n\n      return False\n\n    else:\n\n      return True\n\n  return False\n", "# Copyright (C) 2018 Google Inc.\n\n#\n\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n\n# you may not use this file except in compliance with the License.\n\n# You may obtain a copy of the License at\n\n#\n\n# http://www.apache.org/licenses/LICENSE-2.0\n\n#\n\n# Unless required by applicable law or agreed to in writing, software\n\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n\n# See the License for the specific language governing permissions and\n\n# limitations under the License.\n\n\n\n\"\"\"Tests for the fire module.\"\"\"\n\n\n\nfrom __future__ import absolute_import\n\nfrom __future__ import division\n\nfrom __future__ import print_function\n\n\n\nimport os\n\nimport sys\n\n\n\nimport fire\n\nfrom fire import test_components as tc\n\nfrom fire import testutils\n\n\n\nimport mock\n\nimport six\n\n\n\n\n\nclass FireTest(testutils.BaseTestCase):\n\n\n\n  def testFire(self):\n\n    with mock.patch.object(sys, 'argv', ['progname']):\n\n      fire.Fire(tc.Empty)\n\n      fire.Fire(tc.OldStyleEmpty)\n\n      fire.Fire(tc.WithInit)\n\n    # Test both passing command as a sequence and as a string.\n\n    self.assertEqual(fire.Fire(tc.NoDefaults, command='triple 4'), 12)\n\n    self.assertEqual(fire.Fire(tc.WithDefaults, command=('double', '2')), 4)\n\n    self.assertEqual(fire.Fire(tc.WithDefaults, command=['triple', '4']), 12)\n\n    self.assertEqual(fire.Fire(tc.OldStyleWithDefaults,\n\n                               command=['double', '2']), 4)\n\n    self.assertEqual(fire.Fire(tc.OldStyleWithDefaults,\n\n                               command=['triple', '4']), 12)\n\n\n\n  def testFirePositionalCommand(self):\n\n    # Test passing command as a positional argument.\n\n    self.assertEqual(fire.Fire(tc.NoDefaults, 'double 2'), 4)\n\n    self.assertEqual(fire.Fire(tc.NoDefaults, ['double', '2']), 4)\n\n\n\n  def testFireInvalidCommandArg(self):\n\n    with self.assertRaises(ValueError):\n\n      # This is not a valid command.\n\n      fire.Fire(tc.WithDefaults, command=10)\n\n\n\n  def testFireDefaultName(self):\n\n    with mock.patch.object(sys, 'argv',\n\n                           [os.path.join('python-fire', 'fire',\n\n                                         'base_filename.py')]):\n\n      with self.assertOutputMatches(stdout='SYNOPSIS.*base_filename.py',\n\n                                    stderr=None):\n\n        fire.Fire(tc.Empty)\n\n\n\n  def testFireNoArgs(self):\n\n    self.assertEqual(fire.Fire(tc.MixedDefaults, command=['ten']), 10)\n\n\n\n  def testFireExceptions(self):\n\n    # Exceptions of Fire are printed to stderr and a FireExit is raised.\n\n    with self.assertRaisesFireExit(2):\n\n      fire.Fire(tc.Empty, command=['nomethod'])  # Member doesn't exist.\n\n    with self.assertRaisesFireExit(2):\n\n      fire.Fire(tc.NoDefaults, command=['double'])  # Missing argument.\n\n    with self.assertRaisesFireExit(2):\n\n      fire.Fire(tc.TypedProperties, command=['delta', 'x'])  # Missing key.\n\n\n\n    # Exceptions of the target components are still raised.\n\n    with self.assertRaises(ZeroDivisionError):\n\n      fire.Fire(tc.NumberDefaults, command=['reciprocal', '0.0'])\n\n\n\n  def testFireNamedArgs(self):\n\n    self.assertEqual(fire.Fire(tc.WithDefaults,\n\n                               command=['double', '--count', '5']), 10)\n\n    self.assertEqual(fire.Fire(tc.WithDefaults,\n\n                               command=['triple', '--count', '5']), 15)\n\n    self.assertEqual(\n\n        fire.Fire(tc.OldStyleWithDefaults, command=['double', '--count', '5']),\n\n        10)\n\n    self.assertEqual(\n\n        fire.Fire(tc.OldStyleWithDefaults, command=['triple', '--count', '5']),\n\n        15)\n\n\n\n  def testFireNamedArgsSingleHyphen(self):\n\n    self.assertEqual(fire.Fire(tc.WithDefaults,\n\n                               command=['double', '-count', '5']), 10)\n\n    self.assertEqual(fire.Fire(tc.WithDefaults,\n\n                               command=['triple', '-count', '5']), 15)\n\n    self.assertEqual(\n\n        fire.Fire(tc.OldStyleWithDefaults, command=['double', '-count', '5']),\n\n        10)\n\n    self.assertEqual(\n\n        fire.Fire(tc.OldStyleWithDefaults, command=['triple', '-count', '5']),\n\n        15)\n\n\n\n  def testFireNamedArgsWithEquals(self):\n\n    self.assertEqual(fire.Fire(tc.WithDefaults,\n\n                               command=['double', '--count=5']), 10)\n\n    self.assertEqual(fire.Fire(tc.WithDefaults,\n\n                               command=['triple', '--count=5']), 15)\n\n\n\n  def testFireNamedArgsWithEqualsSingleHyphen(self):\n\n    self.assertEqual(fire.Fire(tc.WithDefaults,\n\n                               command=['double', '-count=5']), 10)\n\n    self.assertEqual(fire.Fire(tc.WithDefaults,\n\n                               command=['triple', '-count=5']), 15)\n\n\n\n  def testFireAllNamedArgs(self):\n\n    self.assertEqual(fire.Fire(tc.MixedDefaults, command=['sum', '1', '2']), 5)\n\n    self.assertEqual(fire.Fire(tc.MixedDefaults,\n\n                               command=['sum', '--alpha', '1', '2']), 5)\n\n    self.assertEqual(fire.Fire(tc.MixedDefaults,\n\n                               command=['sum', '--beta', '1', '2']), 4)\n\n    self.assertEqual(fire.Fire(tc.MixedDefaults,\n\n                               command=['sum', '1', '--alpha', '2']), 4)\n\n    self.assertEqual(fire.Fire(tc.MixedDefaults,\n\n                               command=['sum', '1', '--beta', '2']), 5)\n\n    self.assertEqual(\n\n        fire.Fire(tc.MixedDefaults,\n\n                  command=['sum', '--alpha', '1', '--beta', '2']), 5)\n\n    self.assertEqual(\n\n        fire.Fire(tc.MixedDefaults,\n\n                  command=['sum', '--beta', '1', '--alpha', '2']), 4)\n\n\n\n  def testFireAllNamedArgsOneMissing(self):\n\n    self.assertEqual(fire.Fire(tc.MixedDefaults, command=['sum']), 0)\n\n    self.assertEqual(fire.Fire(tc.MixedDefaults, command=['sum', '1']), 1)\n\n    self.assertEqual(fire.Fire(tc.MixedDefaults,\n\n                               command=['sum', '--alpha', '1']), 1)\n\n    self.assertEqual(fire.Fire(tc.MixedDefaults,\n\n                               command=['sum', '--beta', '2']), 4)\n\n\n\n  def testFirePartialNamedArgs(self):\n\n    self.assertEqual(\n\n        fire.Fire(tc.MixedDefaults, command=['identity', '1', '2']), (1, 2))\n\n    self.assertEqual(\n\n        fire.Fire(tc.MixedDefaults,\n\n                  command=['identity', '--alpha', '1', '2']), (1, 2))\n\n    self.assertEqual(\n\n        fire.Fire(tc.MixedDefaults,\n\n                  command=['identity', '--beta', '1', '2']), (2, 1))\n\n    self.assertEqual(\n\n        fire.Fire(tc.MixedDefaults,\n\n                  command=['identity', '1', '--alpha', '2']), (2, 1))\n\n    self.assertEqual(\n\n        fire.Fire(tc.MixedDefaults,\n\n                  command=['identity', '1', '--beta', '2']), (1, 2))\n\n    self.assertEqual(\n\n        fire.Fire(\n\n            tc.MixedDefaults,\n\n            command=['identity', '--alpha', '1', '--beta', '2']), (1, 2))\n\n    self.assertEqual(\n\n        fire.Fire(\n\n            tc.MixedDefaults,\n\n            command=['identity', '--beta', '1', '--alpha', '2']), (2, 1))\n\n\n\n  def testFirePartialNamedArgsOneMissing(self):\n\n    # Errors are written to standard out and a FireExit is raised.\n\n    with self.assertRaisesFireExit(2):\n\n      fire.Fire(tc.MixedDefaults,\n\n                command=['identity'])  # Identity needs an arg.\n\n\n\n    with self.assertRaisesFireExit(2):\n\n      # Identity needs a value for alpha.\n\n      fire.Fire(tc.MixedDefaults, command=['identity', '--beta', '2'])\n\n\n\n    self.assertEqual(\n\n        fire.Fire(tc.MixedDefaults, command=['identity', '1']), (1, '0'))\n\n    self.assertEqual(\n\n        fire.Fire(tc.MixedDefaults, command=['identity', '--alpha', '1']),\n\n        (1, '0'))\n\n\n\n  def testFireAnnotatedArgs(self):\n\n    self.assertEqual(fire.Fire(tc.Annotations, command=['double', '5']), 10)\n\n    self.assertEqual(fire.Fire(tc.Annotations, command=['triple', '5']), 15)\n\n\n\n  @testutils.skipIf(six.PY2, 'Keyword-only arguments not in Python 2.')\n\n  def testFireKeywordOnlyArgs(self):\n\n    with self.assertRaisesFireExit(2):\n\n      # Keyword arguments must be passed with flag syntax.\n\n      fire.Fire(tc.py3.KeywordOnly, command=['double', '5'])\n\n\n\n    self.assertEqual(\n\n        fire.Fire(tc.py3.KeywordOnly, command=['double', '--count', '5']), 10)\n\n    self.assertEqual(\n\n        fire.Fire(tc.py3.KeywordOnly, command=['triple', '--count', '5']), 15)\n\n\n\n  def testFireProperties(self):\n\n    self.assertEqual(fire.Fire(tc.TypedProperties, command=['alpha']), True)\n\n    self.assertEqual(fire.Fire(tc.TypedProperties, command=['beta']), (1, 2, 3))\n\n\n\n  def testFireRecursion(self):\n\n    self.assertEqual(\n\n        fire.Fire(tc.TypedProperties,\n\n                  command=['charlie', 'double', 'hello']), 'hellohello')\n\n    self.assertEqual(fire.Fire(tc.TypedProperties,\n\n                               command=['charlie', 'triple', 'w']), 'www')\n\n\n\n  def testFireVarArgs(self):\n\n    self.assertEqual(\n\n        fire.Fire(tc.VarArgs,\n\n                  command=['cumsums', 'a', 'b', 'c', 'd']),\n\n        ['a', 'ab', 'abc', 'abcd'])\n\n    self.assertEqual(\n\n        fire.Fire(tc.VarArgs, command=['cumsums', '1', '2', '3', '4']),\n\n        [1, 3, 6, 10])\n\n\n\n  def testFireVarArgsWithNamedArgs(self):\n\n    self.assertEqual(\n\n        fire.Fire(tc.VarArgs, command=['varchars', '1', '2', 'c', 'd']),\n\n        (1, 2, 'cd'))\n\n    self.assertEqual(\n\n        fire.Fire(tc.VarArgs, command=['varchars', '3', '4', 'c', 'd', 'e']),\n\n        (3, 4, 'cde'))\n\n\n\n  def testFireKeywordArgs(self):\n\n    self.assertEqual(\n\n        fire.Fire(\n\n            tc.Kwargs,\n\n            command=['props', '--name', 'David', '--age', '24']),\n\n        {'name': 'David', 'age': 24})\n\n    # Run this test both with a list command and a string command.\n\n    self.assertEqual(\n\n        fire.Fire(\n\n            tc.Kwargs,\n\n            command=['props', '--message',\n\n                     '\"This is a message it has -- in it\"']),  # Quotes stripped\n\n        {'message': 'This is a message it has -- in it'})\n\n    self.assertEqual(\n\n        fire.Fire(\n\n            tc.Kwargs,\n\n            command=['props', '--message',\n\n                     'This is a message it has -- in it']),\n\n        {'message': 'This is a message it has -- in it'})\n\n    self.assertEqual(\n\n        fire.Fire(\n\n            tc.Kwargs,\n\n            command='props --message \"This is a message it has -- in it\"'),\n\n        {'message': 'This is a message it has -- in it'})\n\n    self.assertEqual(\n\n        fire.Fire(tc.Kwargs,\n\n                  command=['upper', '--alpha', 'A', '--beta', 'B']),\n\n        'ALPHA BETA')\n\n    self.assertEqual(\n\n        fire.Fire(\n\n            tc.Kwargs,\n\n            command=['upper', '--alpha', 'A', '--beta', 'B', '-', 'lower']),\n\n        'alpha beta')\n\n\n\n  def testFireKeywordArgsWithMissingPositionalArgs(self):\n\n    self.assertEqual(\n\n        fire.Fire(tc.Kwargs, command=['run', 'Hello', 'World', '--cell', 'is']),\n\n        ('Hello', 'World', {'cell': 'is'}))\n\n    self.assertEqual(\n\n        fire.Fire(tc.Kwargs, command=['run', 'Hello', '--cell', 'ok']),\n\n        ('Hello', None, {'cell': 'ok'}))\n\n\n\n  def testFireObject(self):\n\n    self.assertEqual(\n\n        fire.Fire(tc.WithDefaults(), command=['double', '--count', '5']), 10)\n\n    self.assertEqual(\n\n        fire.Fire(tc.WithDefaults(), command=['triple', '--count', '5']), 15)\n\n\n\n  def testFireDict(self):\n\n    component = {\n\n        'double': lambda x=0: 2 * x,\n\n        'cheese': 'swiss',\n\n    }\n\n    self.assertEqual(fire.Fire(component, command=['double', '5']), 10)\n\n    self.assertEqual(fire.Fire(component, command=['cheese']), 'swiss')\n\n\n\n  def testFireObjectWithDict(self):\n\n    self.assertEqual(\n\n        fire.Fire(tc.TypedProperties, command=['delta', 'echo']), 'E')\n\n    self.assertEqual(\n\n        fire.Fire(tc.TypedProperties, command=['delta', 'echo', 'lower']), 'e')\n\n    self.assertIsInstance(\n\n        fire.Fire(tc.TypedProperties, command=['delta', 'nest']), dict)\n\n    self.assertEqual(\n\n        fire.Fire(tc.TypedProperties, command=['delta', 'nest', '0']), 'a')\n\n\n\n  def testFireSet(self):\n\n    component = tc.simple_set()\n\n    result = fire.Fire(component, command=[])\n\n    self.assertEqual(len(result), 3)\n\n\n\n  def testFireFrozenset(self):\n\n    component = tc.simple_frozenset()\n\n    result = fire.Fire(component, command=[])\n\n    self.assertEqual(len(result), 3)\n\n\n\n  def testFireList(self):\n\n    component = ['zero', 'one', 'two', 'three']\n\n    self.assertEqual(fire.Fire(component, command=['2']), 'two')\n\n    self.assertEqual(fire.Fire(component, command=['3']), 'three')\n\n    self.assertEqual(fire.Fire(component, command=['-1']), 'three')\n\n\n\n  def testFireObjectWithList(self):\n\n    self.assertEqual(fire.Fire(tc.TypedProperties, command=['echo', '0']),\n\n                     'alex')\n\n    self.assertEqual(fire.Fire(tc.TypedProperties, command=['echo', '1']),\n\n                     'bethany')\n\n\n\n  def testFireObjectWithTuple(self):\n\n    self.assertEqual(fire.Fire(tc.TypedProperties, command=['fox', '0']),\n\n                     'carry')\n\n    self.assertEqual(fire.Fire(tc.TypedProperties, command=['fox', '1']),\n\n                     'divide')\n\n\n\n  def testFireObjectWithListAsObject(self):\n\n    self.assertEqual(\n\n        fire.Fire(tc.TypedProperties, command=['echo', 'count', 'bethany']),\n\n        1)\n\n\n\n  def testFireObjectWithTupleAsObject(self):\n\n    self.assertEqual(\n\n        fire.Fire(tc.TypedProperties, command=['fox', 'count', 'divide']),\n\n        1)\n\n\n\n  def testFireNoComponent(self):\n\n    self.assertEqual(fire.Fire(command=['tc', 'WithDefaults', 'double', '10']),\n\n                     20)\n\n    last_char = lambda text: text[-1]  # pylint: disable=unused-variable\n\n    self.assertEqual(fire.Fire(command=['last_char', '\"Hello\"']), 'o')\n\n    self.assertEqual(fire.Fire(command=['last-char', '\"World\"']), 'd')\n\n    rset = lambda count=0: set(range(count))  # pylint: disable=unused-variable\n\n    self.assertEqual(fire.Fire(command=['rset', '5']), {0, 1, 2, 3, 4})\n\n\n\n  def testFireUnderscores(self):\n\n    self.assertEqual(\n\n        fire.Fire(tc.Underscores,\n\n                  command=['underscore-example']), 'fish fingers')\n\n    self.assertEqual(\n\n        fire.Fire(tc.Underscores,\n\n                  command=['underscore_example']), 'fish fingers')\n\n\n\n  def testFireUnderscoresInArg(self):\n\n    self.assertEqual(\n\n        fire.Fire(tc.Underscores,\n\n                  command=['underscore-function', 'example']), 'example')\n\n    self.assertEqual(\n\n        fire.Fire(tc.Underscores,\n\n                  command=['underscore_function', '--underscore-arg=score']),\n\n        'score')\n\n    self.assertEqual(\n\n        fire.Fire(tc.Underscores,\n\n                  command=['underscore_function', '--underscore_arg=score']),\n\n        'score')\n\n\n\n  def testBoolParsing(self):\n\n    self.assertEqual(fire.Fire(tc.BoolConverter, command=['as-bool', 'True']),\n\n                     True)\n\n    self.assertEqual(\n\n        fire.Fire(tc.BoolConverter, command=['as-bool', 'False']), False)\n\n    self.assertEqual(\n\n        fire.Fire(tc.BoolConverter, command=['as-bool', '--arg=True']), True)\n\n    self.assertEqual(\n\n        fire.Fire(tc.BoolConverter, command=['as-bool', '--arg=False']), False)\n\n    self.assertEqual(fire.Fire(tc.BoolConverter, command=['as-bool', '--arg']),\n\n                     True)\n\n    self.assertEqual(\n\n        fire.Fire(tc.BoolConverter, command=['as-bool', '--noarg']), False)\n\n\n\n  def testBoolParsingContinued(self):\n\n    self.assertEqual(\n\n        fire.Fire(tc.MixedDefaults,\n\n                  command=['identity', 'True', 'False']), (True, False))\n\n    self.assertEqual(\n\n        fire.Fire(tc.MixedDefaults,\n\n                  command=['identity', '--alpha=False', '10']), (False, 10))\n\n    self.assertEqual(\n\n        fire.Fire(tc.MixedDefaults,\n\n                  command=['identity', '--alpha', '--beta', '10']), (True, 10))\n\n    self.assertEqual(\n\n        fire.Fire(tc.MixedDefaults,\n\n                  command=['identity', '--alpha', '--beta=10']), (True, 10))\n\n    self.assertEqual(\n\n        fire.Fire(tc.MixedDefaults,\n\n                  command=['identity', '--noalpha', '--beta']), (False, True))\n\n    self.assertEqual(\n\n        fire.Fire(tc.MixedDefaults, command=['identity', '10', '--beta']),\n\n        (10, True))\n\n\n\n  def testBoolParsingSingleHyphen(self):\n\n    self.assertEqual(\n\n        fire.Fire(tc.MixedDefaults,\n\n                  command=['identity', '-alpha=False', '10']), (False, 10))\n\n    self.assertEqual(\n\n        fire.Fire(tc.MixedDefaults,\n\n                  command=['identity', '-alpha', '-beta', '10']), (True, 10))\n\n    self.assertEqual(\n\n        fire.Fire(tc.MixedDefaults,\n\n                  command=['identity', '-alpha', '-beta=10']), (True, 10))\n\n    self.assertEqual(\n\n        fire.Fire(tc.MixedDefaults,\n\n                  command=['identity', '-noalpha', '-beta']), (False, True))\n\n    self.assertEqual(\n\n        fire.Fire(tc.MixedDefaults,\n\n                  command=['identity', '-alpha', '-10', '-beta']), (-10, True))\n\n\n\n  def testBoolParsingLessExpectedCases(self):\n\n    # Note: Does not return (True, 10).\n\n    self.assertEqual(\n\n        fire.Fire(tc.MixedDefaults,\n\n                  command=['identity', '--alpha', '10']), (10, '0'))\n\n    # To get (True, 10), use one of the following:\n\n    self.assertEqual(\n\n        fire.Fire(tc.MixedDefaults,\n\n                  command=['identity', '--alpha', '--beta=10']),\n\n        (True, 10))\n\n    self.assertEqual(\n\n        fire.Fire(tc.MixedDefaults,\n\n                  command=['identity', 'True', '10']), (True, 10))\n\n\n\n    # Note: Does not return (True, '--test') or ('--test', 0).\n\n    with self.assertRaisesFireExit(2):\n\n      fire.Fire(tc.MixedDefaults, command=['identity', '--alpha', '--test'])\n\n\n\n    self.assertEqual(\n\n        fire.Fire(\n\n            tc.MixedDefaults,\n\n            command=['identity', '--alpha', 'True', '\"--test\"']),\n\n        (True, '--test'))\n\n    # To get ('--test', '0'), use one of the following:\n\n    self.assertEqual(fire.Fire(tc.MixedDefaults,\n\n                               command=['identity', '--alpha=--test']),\n\n                     ('--test', '0'))\n\n    self.assertEqual(\n\n        fire.Fire(tc.MixedDefaults, command=r'identity --alpha \\\"--test\\\"'),\n\n        ('--test', '0'))\n\n\n\n  def testSingleCharFlagParsing(self):\n\n    self.assertEqual(\n\n        fire.Fire(tc.MixedDefaults,\n\n                  command=['identity', '-a']), (True, '0'))\n\n    self.assertEqual(\n\n        fire.Fire(tc.MixedDefaults,\n\n                  command=['identity', '-a', '--beta=10']), (True, 10))\n\n    self.assertEqual(\n\n        fire.Fire(tc.MixedDefaults,\n\n                  command=['identity', '-a', '-b']), (True, True))\n\n    self.assertEqual(\n\n        fire.Fire(tc.MixedDefaults,\n\n                  command=['identity', '-a', '42', '-b']), (42, True))\n\n    self.assertEqual(\n\n        fire.Fire(tc.MixedDefaults,\n\n                  command=['identity', '-a', '42', '-b', '10']), (42, 10))\n\n    self.assertEqual(\n\n        fire.Fire(tc.MixedDefaults,\n\n                  command=['identity', '--alpha', 'True', '-b', '10']),\n\n        (True, 10))\n\n    with self.assertRaisesFireExit(2):\n\n      # This test attempts to use an ambiguous shortcut flag on a function with\n\n      # a naming conflict for the shortcut, triggering a FireError.\n\n      fire.Fire(tc.SimilarArgNames, command=['identity', '-b'])\n\n\n\n  def testSingleCharFlagParsingEqualSign(self):\n\n    self.assertEqual(\n\n        fire.Fire(tc.MixedDefaults,\n\n                  command=['identity', '-a=True']), (True, '0'))\n\n    self.assertEqual(\n\n        fire.Fire(tc.MixedDefaults,\n\n                  command=['identity', '-a=3', '--beta=10']), (3, 10))\n\n    self.assertEqual(\n\n        fire.Fire(tc.MixedDefaults,\n\n                  command=['identity', '-a=False', '-b=15']), (False, 15))\n\n    self.assertEqual(\n\n        fire.Fire(tc.MixedDefaults,\n\n                  command=['identity', '-a', '42', '-b=12']), (42, 12))\n\n    self.assertEqual(\n\n        fire.Fire(tc.MixedDefaults,\n\n                  command=['identity', '-a=42', '-b', '10']), (42, 10))\n\n\n\n  def testSingleCharFlagParsingExactMatch(self):\n\n    self.assertEqual(\n\n        fire.Fire(tc.SimilarArgNames,\n\n                  command=['identity2', '-a']), (True, None))\n\n    self.assertEqual(\n\n        fire.Fire(tc.SimilarArgNames,\n\n                  command=['identity2', '-a=10']), (10, None))\n\n    self.assertEqual(\n\n        fire.Fire(tc.SimilarArgNames,\n\n                  command=['identity2', '--a']), (True, None))\n\n    self.assertEqual(\n\n        fire.Fire(tc.SimilarArgNames,\n\n                  command=['identity2', '-alpha']), (None, True))\n\n    self.assertEqual(\n\n        fire.Fire(tc.SimilarArgNames,\n\n                  command=['identity2', '-a', '-alpha']), (True, True))\n\n\n\n  def testSingleCharFlagParsingCapitalLetter(self):\n\n    self.assertEqual(\n\n        fire.Fire(tc.CapitalizedArgNames,\n\n                  command=['sum', '-D', '5', '-G', '10']), 15)\n\n\n\n  def testBoolParsingWithNo(self):\n\n    # In these examples --nothing always refers to the nothing argument:\n\n    def fn1(thing, nothing):\n\n      return thing, nothing\n\n\n\n    self.assertEqual(fire.Fire(fn1, command=['--thing', '--nothing']),\n\n                     (True, True))\n\n    self.assertEqual(fire.Fire(fn1, command=['--thing', '--nonothing']),\n\n                     (True, False))\n\n\n\n    with self.assertRaisesFireExit(2):\n\n      # In this case nothing=False (since rightmost setting of a flag gets\n\n      # precedence), but it errors because thing has no value.\n\n      fire.Fire(fn1, command=['--nothing', '--nonothing'])\n\n\n\n    # In these examples, --nothing sets thing=False:\n\n    def fn2(thing, **kwargs):\n\n      return thing, kwargs\n\n    self.assertEqual(fire.Fire(fn2, command=['--thing']), (True, {}))\n\n    self.assertEqual(fire.Fire(fn2, command=['--nothing']), (False, {}))\n\n    with self.assertRaisesFireExit(2):\n\n      # In this case, nothing=True, but it errors because thing has no value.\n\n      fire.Fire(fn2, command=['--nothing=True'])\n\n    self.assertEqual(fire.Fire(fn2, command=['--nothing', '--nothing=True']),\n\n                     (False, {'nothing': True}))\n\n\n\n    def fn3(arg, **kwargs):\n\n      return arg, kwargs\n\n    self.assertEqual(fire.Fire(fn3, command=['--arg=value', '--thing']),\n\n                     ('value', {'thing': True}))\n\n    self.assertEqual(fire.Fire(fn3, command=['--arg=value', '--nothing']),\n\n                     ('value', {'thing': False}))\n\n    self.assertEqual(fire.Fire(fn3, command=['--arg=value', '--nonothing']),\n\n                     ('value', {'nothing': False}))\n\n\n\n  def testTraceFlag(self):\n\n    with self.assertRaisesFireExit(0, 'Fire trace:\\n'):\n\n      fire.Fire(tc.BoolConverter, command=['as-bool', 'True', '--', '--trace'])\n\n    with self.assertRaisesFireExit(0, 'Fire trace:\\n'):\n\n      fire.Fire(tc.BoolConverter, command=['as-bool', 'True', '--', '-t'])\n\n    with self.assertRaisesFireExit(0, 'Fire trace:\\n'):\n\n      fire.Fire(tc.BoolConverter, command=['--', '--trace'])\n\n\n\n  def testHelpFlag(self):\n\n    with self.assertRaisesFireExit(0):\n\n      fire.Fire(tc.BoolConverter, command=['as-bool', 'True', '--', '--help'])\n\n    with self.assertRaisesFireExit(0):\n\n      fire.Fire(tc.BoolConverter, command=['as-bool', 'True', '--', '-h'])\n\n    with self.assertRaisesFireExit(0):\n\n      fire.Fire(tc.BoolConverter, command=['--', '--help'])\n\n\n\n  def testHelpFlagAndTraceFlag(self):\n\n    with self.assertRaisesFireExit(0, 'Fire trace:\\n.*SYNOPSIS'):\n\n      fire.Fire(tc.BoolConverter,\n\n                command=['as-bool', 'True', '--', '--help', '--trace'])\n\n    with self.assertRaisesFireExit(0, 'Fire trace:\\n.*SYNOPSIS'):\n\n      fire.Fire(tc.BoolConverter, command=['as-bool', 'True', '--', '-h', '-t'])\n\n    with self.assertRaisesFireExit(0, 'Fire trace:\\n.*SYNOPSIS'):\n\n      fire.Fire(tc.BoolConverter, command=['--', '-h', '--trace'])\n\n\n\n  def testTabCompletionNoName(self):\n\n    completion_script = fire.Fire(tc.NoDefaults, command=['--', '--completion'])\n\n    self.assertIn('double', completion_script)\n\n    self.assertIn('triple', completion_script)\n\n\n\n  def testTabCompletion(self):\n\n    completion_script = fire.Fire(\n\n        tc.NoDefaults, command=['--', '--completion'], name='c')\n\n    self.assertIn('double', completion_script)\n\n    self.assertIn('triple', completion_script)\n\n\n\n  def testTabCompletionWithDict(self):\n\n    actions = {'multiply': lambda a, b: a * b}\n\n    completion_script = fire.Fire(\n\n        actions, command=['--', '--completion'], name='actCLI')\n\n    self.assertIn('actCLI', completion_script)\n\n    self.assertIn('multiply', completion_script)\n\n\n\n  def testBasicSeparator(self):\n\n    # '-' is the default separator.\n\n    self.assertEqual(\n\n        fire.Fire(tc.MixedDefaults,\n\n                  command=['identity', '+', '_']), ('+', '_'))\n\n    self.assertEqual(\n\n        fire.Fire(tc.MixedDefaults,\n\n                  command=['identity', '_', '+', '-']), ('_', '+'))\n\n\n\n    # If we change the separator we can use '-' as an argument.\n\n    self.assertEqual(\n\n        fire.Fire(tc.MixedDefaults,\n\n                  command=['identity', '-', '_', '--', '--separator', '&']),\n\n        ('-', '_'))\n\n\n\n    # The separator triggers a function call, but there aren't enough arguments.\n\n    with self.assertRaisesFireExit(2):\n\n      fire.Fire(tc.MixedDefaults, command=['identity', '-', '_', '+'])\n\n\n\n  def testNonComparable(self):\n\n    \"\"\"Fire should work with classes that disallow comparisons.\"\"\"\n\n    # Make sure this test passes both with a string command or a list command.\n\n    self.assertIsInstance(\n\n        fire.Fire(tc.NonComparable, command=''), tc.NonComparable)\n\n    self.assertIsInstance(\n\n        fire.Fire(tc.NonComparable, command=[]), tc.NonComparable)\n\n\n\n    # The first separator instantiates the NonComparable object.\n\n    # The second separator causes Fire to check if the separator was necessary.\n\n    self.assertIsInstance(\n\n        fire.Fire(tc.NonComparable, command=['-', '-']), tc.NonComparable)\n\n\n\n  def testExtraSeparators(self):\n\n    self.assertEqual(\n\n        fire.Fire(\n\n            tc.ReturnsObj,\n\n            command=['get-obj', 'arg1', 'arg2', '-', '-', 'as-bool', 'True']),\n\n        True)\n\n    self.assertEqual(\n\n        fire.Fire(\n\n            tc.ReturnsObj,\n\n            command=['get-obj', 'arg1', 'arg2', '-', '-', '-', 'as-bool',\n\n                     'True']),\n\n        True)\n\n\n\n  def testSeparatorForChaining(self):\n\n    # Without a separator all args are consumed by get_obj.\n\n    self.assertIsInstance(\n\n        fire.Fire(tc.ReturnsObj,\n\n                  command=['get-obj', 'arg1', 'arg2', 'as-bool', 'True']),\n\n        tc.BoolConverter)\n\n    # With a separator only the preceding args are consumed by get_obj.\n\n    self.assertEqual(\n\n        fire.Fire(\n\n            tc.ReturnsObj,\n\n            command=['get-obj', 'arg1', 'arg2', '-', 'as-bool', 'True']), True)\n\n    self.assertEqual(\n\n        fire.Fire(tc.ReturnsObj,\n\n                  command=['get-obj', 'arg1', 'arg2', '&', 'as-bool', 'True',\n\n                           '--', '--separator', '&']),\n\n        True)\n\n    self.assertEqual(\n\n        fire.Fire(tc.ReturnsObj,\n\n                  command=['get-obj', 'arg1', '$$', 'as-bool', 'True', '--',\n\n                           '--separator', '$$']),\n\n        True)\n\n\n\n  def testNegativeNumbers(self):\n\n    self.assertEqual(\n\n        fire.Fire(tc.MixedDefaults,\n\n                  command=['sum', '--alpha', '-3', '--beta', '-4']), -11)\n\n\n\n  def testFloatForExpectedInt(self):\n\n    self.assertEqual(\n\n        fire.Fire(tc.MixedDefaults,\n\n                  command=['sum', '--alpha', '2.2', '--beta', '3.0']), 8.2)\n\n    self.assertEqual(\n\n        fire.Fire(\n\n            tc.NumberDefaults,\n\n            command=['integer_reciprocal', '--divisor', '5.0']), 0.2)\n\n    self.assertEqual(\n\n        fire.Fire(tc.NumberDefaults, command=['integer_reciprocal', '4.0']),\n\n        0.25)\n\n\n\n  def testClassInstantiation(self):\n\n    self.assertIsInstance(fire.Fire(tc.InstanceVars,\n\n                                    command=['--arg1=a1', '--arg2=a2']),\n\n                          tc.InstanceVars)\n\n    with self.assertRaisesFireExit(2):\n\n      # Cannot instantiate a class with positional args.\n\n      fire.Fire(tc.InstanceVars, command=['a1', 'a2'])\n\n\n\n  def testTraceErrors(self):\n\n    # Class needs additional value but runs out of args.\n\n    with self.assertRaisesFireExit(2):\n\n      fire.Fire(tc.InstanceVars, command=['a1'])\n\n    with self.assertRaisesFireExit(2):\n\n      fire.Fire(tc.InstanceVars, command=['--arg1=a1'])\n\n\n\n    # Routine needs additional value but runs out of args.\n\n    with self.assertRaisesFireExit(2):\n\n      fire.Fire(tc.InstanceVars, command=['a1', 'a2', '-', 'run', 'b1'])\n\n    with self.assertRaisesFireExit(2):\n\n      fire.Fire(tc.InstanceVars,\n\n                command=['--arg1=a1', '--arg2=a2', '-', 'run b1'])\n\n\n\n    # Extra args cannot be consumed.\n\n    with self.assertRaisesFireExit(2):\n\n      fire.Fire(tc.InstanceVars,\n\n                command=['a1', 'a2', '-', 'run', 'b1', 'b2', 'b3'])\n\n    with self.assertRaisesFireExit(2):\n\n      fire.Fire(\n\n          tc.InstanceVars,\n\n          command=['--arg1=a1', '--arg2=a2', '-', 'run', 'b1', 'b2', 'b3'])\n\n\n\n    # Cannot find member to access.\n\n    with self.assertRaisesFireExit(2):\n\n      fire.Fire(tc.InstanceVars, command=['a1', 'a2', '-', 'jog'])\n\n    with self.assertRaisesFireExit(2):\n\n      fire.Fire(tc.InstanceVars, command=['--arg1=a1', '--arg2=a2', '-', 'jog'])\n\n\n\n  def testClassWithDefaultMethod(self):\n\n    self.assertEqual(\n\n        fire.Fire(tc.DefaultMethod, command=['double', '10']), 20\n\n    )\n\n\n\n  def testClassWithInvalidProperty(self):\n\n    self.assertEqual(\n\n        fire.Fire(tc.InvalidProperty, command=['double', '10']), 20\n\n    )\n\n\n\n  @testutils.skipIf(sys.version_info[0:2] <= (3, 4),\n\n                    'Cannot inspect wrapped signatures in Python 2 or 3.4.')\n\n  def testHelpKwargsDecorator(self):\n\n    # Issue #190, follow the wrapped method instead of crashing.\n\n    with self.assertRaisesFireExit(0):\n\n      fire.Fire(tc.decorated_method, command=['-h'])\n\n    with self.assertRaisesFireExit(0):\n\n      fire.Fire(tc.decorated_method, command=['--help'])\n\n\n\n  @testutils.skipIf(six.PY2, 'Asyncio not available in Python 2.')\n\n  def testFireAsyncio(self):\n\n    self.assertEqual(fire.Fire(tc.py3.WithAsyncio,\n\n                               command=['double', '--count', '10']), 20)\n\n\n\n\n\nif __name__ == '__main__':\n\n  testutils.main()\n", "", "# -*- coding: utf-8 -*- #\n\n\n\n# Copyright 2015 Google LLC. All Rights Reserved.\n\n#\n\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n\n# you may not use this file except in compliance with the License.\n\n# You may obtain a copy of the License at\n\n#\n\n#    http://www.apache.org/licenses/LICENSE-2.0\n\n#\n\n# Unless required by applicable law or agreed to in writing, software\n\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n\n# See the License for the specific language governing permissions and\n\n# limitations under the License.\n\n\n\nr\"\"\"A module for console attributes, special characters and functions.\n\n\n\nThe target architectures {linux, macos, windows} support inline encoding for\n\nall attributes except color. Windows requires win32 calls to manipulate the\n\nconsole color state.\n\n\n\nUsage:\n\n\n\n  # Get the console attribute state.\n\n  out = log.out\n\n  con = console_attr.GetConsoleAttr(out=out)\n\n\n\n  # Get the ISO 8879:1986//ENTITIES Box and Line Drawing characters.\n\n  box = con.GetBoxLineCharacters()\n\n  # Print an X inside a box.\n\n  out.write(box.dr)\n\n  out.write(box.h)\n\n  out.write(box.dl)\n\n  out.write('\\n')\n\n  out.write(box.v)\n\n  out.write('X')\n\n  out.write(box.v)\n\n  out.write('\\n')\n\n  out.write(box.ur)\n\n  out.write(box.h)\n\n  out.write(box.ul)\n\n  out.write('\\n')\n\n\n\n  # Print the bullet characters.\n\n  for c in con.GetBullets():\n\n    out.write(c)\n\n  out.write('\\n')\n\n\n\n  # Print FAIL in red.\n\n  out.write('Epic ')\n\n  con.Colorize('FAIL', 'red')\n\n  out.write(', my first.')\n\n\n\n  # Print italic and bold text.\n\n  bold = con.GetFontCode(bold=True)\n\n  italic = con.GetFontCode(italic=True)\n\n  normal = con.GetFontCode()\n\n  out.write('This is {bold}bold{normal}, this is {italic}italic{normal},'\n\n            ' and this is normal.\\n'.format(bold=bold, italic=italic,\n\n                                            normal=normal))\n\n\n\n  # Read one character from stdin with echo disabled.\n\n  c = con.GetRawKey()\n\n  if c is None:\n\n    print 'EOF\\n'\n\n\n\n  # Return the display width of a string that may contain FontCode() chars.\n\n  display_width = con.DisplayWidth(string)\n\n\n\n  # Reset the memoized state.\n\n  con = console_attr.ResetConsoleAttr()\n\n\n\n  # Print the console width and height in characters.\n\n  width, height = con.GetTermSize()\n\n  print 'width={width}, height={height}'.format(width=width, height=height)\n\n\n\n  # Colorize table data cells.\n\n  fail = console_attr.Colorizer('FAIL', 'red')\n\n  pass = console_attr.Colorizer('PASS', 'green')\n\n  cells = ['label', fail, 'more text', pass, 'end']\n\n  for cell in cells;\n\n    if isinstance(cell, console_attr.Colorizer):\n\n      cell.Render()\n\n    else:\n\n      out.write(cell)\n\n\"\"\"\n\n\n\n\n\nfrom __future__ import absolute_import\n\nfrom __future__ import division\n\nfrom __future__ import unicode_literals\n\n\n\nimport os\n\nimport sys\n\nimport unicodedata\n\n\n\n# from fire.console import properties\n\nfrom fire.console import console_attr_os\n\nfrom fire.console import encoding as encoding_util\n\nfrom fire.console import text\n\n\n\nimport six\n\n\n\n\n\n# TODO: Unify this logic with console.style.mappings\n\nclass BoxLineCharacters(object):\n\n  \"\"\"Box/line drawing characters.\n\n\n\n  The element names are from ISO 8879:1986//ENTITIES Box and Line Drawing//EN:\n\n    http://www.w3.org/2003/entities/iso8879doc/isobox.html\n\n  \"\"\"\n\n\n\n\n\nclass BoxLineCharactersUnicode(BoxLineCharacters):\n\n  \"\"\"unicode Box/line drawing characters (cp437 compatible unicode).\"\"\"\n\n  dl = '\u2510'\n\n  dr = '\u250c'\n\n  h = '\u2500'\n\n  hd = '\u252c'\n\n  hu = '\u2534'\n\n  ul = '\u2518'\n\n  ur = '\u2514'\n\n  v = '\u2502'\n\n  vh = '\u253c'\n\n  vl = '\u2524'\n\n  vr = '\u251c'\n\n  d_dl = '\u2557'\n\n  d_dr = '\u2554'\n\n  d_h = '\u2550'\n\n  d_hd = '\u2566'\n\n  d_hu = '\u2569'\n\n  d_ul = '\u255d'\n\n  d_ur = '\u255a'\n\n  d_v = '\u2551'\n\n  d_vh = '\u256c'\n\n  d_vl = '\u2563'\n\n  d_vr = '\u2560'\n\n\n\n\n\nclass BoxLineCharactersAscii(BoxLineCharacters):\n\n  \"\"\"ASCII Box/line drawing characters.\"\"\"\n\n  dl = '+'\n\n  dr = '+'\n\n  h = '-'\n\n  hd = '+'\n\n  hu = '+'\n\n  ul = '+'\n\n  ur = '+'\n\n  v = '|'\n\n  vh = '+'\n\n  vl = '+'\n\n  vr = '+'\n\n  d_dl = '#'\n\n  d_dr = '#'\n\n  d_h = '='\n\n  d_hd = '#'\n\n  d_hu = '#'\n\n  d_ul = '#'\n\n  d_ur = '#'\n\n  d_v = '#'\n\n  d_vh = '#'\n\n  d_vl = '#'\n\n  d_vr = '#'\n\n\n\n\n\nclass BoxLineCharactersScreenReader(BoxLineCharactersAscii):\n\n  dl = ' '\n\n  dr = ' '\n\n  hd = ' '\n\n  hu = ' '\n\n  ul = ' '\n\n  ur = ' '\n\n  vh = ' '\n\n  vl = ' '\n\n  vr = ' '\n\n\n\n\n\nclass ProgressTrackerSymbols(object):\n\n  \"\"\"Characters used by progress trackers.\"\"\"\n\n\n\n\n\nclass ProgressTrackerSymbolsUnicode(ProgressTrackerSymbols):\n\n  \"\"\"Characters used by progress trackers.\"\"\"\n\n\n\n  @property\n\n  def spin_marks(self):\n\n    return ['\u280f', '\u281b', '\u2839', '\u283c', '\u2836', '\u2827']\n\n\n\n  success = text.TypedText(['\u2713'], text_type=text.TextTypes.PT_SUCCESS)\n\n  failed = text.TypedText(['X'], text_type=text.TextTypes.PT_FAILURE)\n\n  interrupted = '-'\n\n  not_started = '.'\n\n  prefix_length = 2\n\n\n\n\n\nclass ProgressTrackerSymbolsAscii(ProgressTrackerSymbols):\n\n  \"\"\"Characters used by progress trackers.\"\"\"\n\n\n\n  @property\n\n  def spin_marks(self):\n\n    return ['|', '/', '-', '\\\\',]\n\n\n\n  success = 'OK'\n\n  failed = 'X'\n\n  interrupted = '-'\n\n  not_started = '.'\n\n  prefix_length = 3\n\n\n\n\n\nclass ConsoleAttr(object):\n\n  \"\"\"Console attribute and special drawing characters and functions accessor.\n\n\n\n  Use GetConsoleAttr() to get a global ConsoleAttr object shared by all callers.\n\n  Use ConsoleAttr() for abstracting multiple consoles.\n\n\n\n  If _out is not associated with a console, or if the console properties cannot\n\n  be determined, the default behavior is ASCII art with no attributes.\n\n\n\n  Attributes:\n\n    _ANSI_COLOR: The ANSI color control sequence dict.\n\n    _ANSI_COLOR_RESET: The ANSI color reset control sequence string.\n\n    _csi: The ANSI Control Sequence indicator string, '' if not supported.\n\n    _encoding: The character encoding.\n\n        ascii: ASCII art. This is the default.\n\n        utf8: UTF-8 unicode.\n\n        win: Windows code page 437.\n\n    _font_bold: The ANSI bold font embellishment code string.\n\n    _font_italic: The ANSI italic font embellishment code string.\n\n    _get_raw_key: A function that reads one keypress from stdin with no echo.\n\n    _out: The console output file stream.\n\n    _term: TERM environment variable value.\n\n    _term_size: The terminal (x, y) dimensions in characters.\n\n  \"\"\"\n\n\n\n  _CONSOLE_ATTR_STATE = None\n\n\n\n  _ANSI_COLOR = {\n\n      'red': '31;1m',\n\n      'yellow': '33;1m',\n\n      'green': '32m',\n\n      'blue': '34;1m'\n\n      }\n\n  _ANSI_COLOR_RESET = '39;0m'\n\n\n\n  _BULLETS_UNICODE = ('\u25aa', '\u25c6', '\u25b8', '\u25ab', '\u25c7', '\u25b9')\n\n  _BULLETS_WINDOWS = ('\u25a0', '\u2261', '\u221e', '\u03a6', '\u00b7')  # cp437 compatible unicode\n\n  _BULLETS_ASCII = ('o', '*', '+', '-')\n\n\n\n  def __init__(self, encoding=None, suppress_output=False):\n\n    \"\"\"Constructor.\n\n\n\n    Args:\n\n      encoding: Encoding override.\n\n        ascii -- ASCII art. This is the default.\n\n        utf8 -- UTF-8 unicode.\n\n        win -- Windows code page 437.\n\n      suppress_output: True to create a ConsoleAttr that doesn't want to output\n\n        anything.\n\n    \"\"\"\n\n    # Normalize the encoding name.\n\n    if not encoding:\n\n      encoding = self._GetConsoleEncoding()\n\n    elif encoding == 'win':\n\n      encoding = 'cp437'\n\n    self._encoding = encoding or 'ascii'\n\n    self._term = '' if suppress_output else os.getenv('TERM', '').lower()\n\n\n\n    # ANSI \"standard\" attributes.\n\n    if self.SupportsAnsi():\n\n      # Select Graphic Rendition paramaters from\n\n      # http://en.wikipedia.org/wiki/ANSI_escape_code#graphics\n\n      # Italic '3' would be nice here but its not widely supported.\n\n      self._csi = '\\x1b['\n\n      self._font_bold = '1'\n\n      self._font_italic = '4'\n\n    else:\n\n      self._csi = None\n\n      self._font_bold = ''\n\n      self._font_italic = ''\n\n\n\n    # Encoded character attributes.\n\n    is_screen_reader = False\n\n    if self._encoding == 'utf8' and not is_screen_reader:\n\n      self._box_line_characters = BoxLineCharactersUnicode()\n\n      self._bullets = self._BULLETS_UNICODE\n\n      self._progress_tracker_symbols = ProgressTrackerSymbolsUnicode()\n\n    elif self._encoding == 'cp437' and not is_screen_reader:\n\n      self._box_line_characters = BoxLineCharactersUnicode()\n\n      self._bullets = self._BULLETS_WINDOWS\n\n      # Windows does not suport the unicode characters used for the spinner.\n\n      self._progress_tracker_symbols = ProgressTrackerSymbolsAscii()\n\n    else:\n\n      self._box_line_characters = BoxLineCharactersAscii()\n\n      if is_screen_reader:\n\n        self._box_line_characters = BoxLineCharactersScreenReader()\n\n      self._bullets = self._BULLETS_ASCII\n\n      self._progress_tracker_symbols = ProgressTrackerSymbolsAscii()\n\n\n\n    # OS specific attributes.\n\n    self._get_raw_key = [console_attr_os.GetRawKeyFunction()]\n\n    self._term_size = (\n\n        (0, 0) if suppress_output else console_attr_os.GetTermSize())\n\n\n\n    self._display_width_cache = {}\n\n\n\n  def _GetConsoleEncoding(self):\n\n    \"\"\"Gets the encoding as declared by the stdout stream.\n\n\n\n    Returns:\n\n      str, The encoding name or None if it could not be determined.\n\n    \"\"\"\n\n    console_encoding = getattr(sys.stdout, 'encoding', None)\n\n    if not console_encoding:\n\n      return None\n\n    console_encoding = console_encoding.lower()\n\n    if 'utf-8' in console_encoding:\n\n      return 'utf8'\n\n    elif 'cp437' in console_encoding:\n\n      return 'cp437'\n\n    return None\n\n\n\n  def Colorize(self, string, color, justify=None):\n\n    \"\"\"Generates a colorized string, optionally justified.\n\n\n\n    Args:\n\n      string: The string to write.\n\n      color: The color name -- must be in _ANSI_COLOR.\n\n      justify: The justification function, no justification if None. For\n\n        example, justify=lambda s: s.center(10)\n\n\n\n    Returns:\n\n      str, The colorized string that can be printed to the console.\n\n    \"\"\"\n\n    if justify:\n\n      string = justify(string)\n\n    if self._csi and color in self._ANSI_COLOR:\n\n      return '{csi}{color_code}{string}{csi}{reset_code}'.format(\n\n          csi=self._csi,\n\n          color_code=self._ANSI_COLOR[color],\n\n          reset_code=self._ANSI_COLOR_RESET,\n\n          string=string)\n\n    # TODO: Add elif self._encoding == 'cp437': code here.\n\n    return string\n\n\n\n  def ConvertOutputToUnicode(self, buf):\n\n    \"\"\"Converts a console output string buf to unicode.\n\n\n\n    Mainly used for testing. Allows test comparisons in unicode while ensuring\n\n    that unicode => encoding => unicode works.\n\n\n\n    Args:\n\n      buf: The console output string to convert.\n\n\n\n    Returns:\n\n      The console output string buf converted to unicode.\n\n    \"\"\"\n\n    if isinstance(buf, six.text_type):\n\n      buf = buf.encode(self._encoding)\n\n    return six.text_type(buf, self._encoding, 'replace')\n\n\n\n  def GetBoxLineCharacters(self):\n\n    \"\"\"Returns the box/line drawing characters object.\n\n\n\n    The element names are from ISO 8879:1986//ENTITIES Box and Line Drawing//EN:\n\n      http://www.w3.org/2003/entities/iso8879doc/isobox.html\n\n\n\n    Returns:\n\n      A BoxLineCharacters object for the console output device.\n\n    \"\"\"\n\n    return self._box_line_characters\n\n\n\n  def GetBullets(self):\n\n    \"\"\"Returns the bullet characters list.\n\n\n\n    Use the list elements in order for best appearance in nested bullet lists,\n\n    wrapping back to the first element for deep nesting. The list size depends\n\n    on the console implementation.\n\n\n\n    Returns:\n\n      A tuple of bullet characters.\n\n    \"\"\"\n\n    return self._bullets\n\n\n\n  def GetProgressTrackerSymbols(self):\n\n    \"\"\"Returns the progress tracker characters object.\n\n\n\n    Returns:\n\n      A ProgressTrackerSymbols object for the console output device.\n\n    \"\"\"\n\n    return self._progress_tracker_symbols\n\n\n\n  def GetControlSequenceIndicator(self):\n\n    \"\"\"Returns the control sequence indicator string.\n\n\n\n    Returns:\n\n      The conrol sequence indicator string or None if control sequences are not\n\n      supported.\n\n    \"\"\"\n\n    return self._csi\n\n\n\n  def GetControlSequenceLen(self, buf):\n\n    \"\"\"Returns the control sequence length at the beginning of buf.\n\n\n\n    Used in display width computations. Control sequences have display width 0.\n\n\n\n    Args:\n\n      buf: The string to check for a control sequence.\n\n\n\n    Returns:\n\n      The conrol sequence length at the beginning of buf or 0 if buf does not\n\n      start with a control sequence.\n\n    \"\"\"\n\n    if not self._csi or not buf.startswith(self._csi):\n\n      return 0\n\n    n = 0\n\n    for c in buf:\n\n      n += 1\n\n      if c.isalpha():\n\n        break\n\n    return n\n\n\n\n  def GetEncoding(self):\n\n    \"\"\"Returns the current encoding.\"\"\"\n\n    return self._encoding\n\n\n\n  def GetFontCode(self, bold=False, italic=False):\n\n    \"\"\"Returns a font code string for 0 or more embellishments.\n\n\n\n    GetFontCode() with no args returns the default font code string.\n\n\n\n    Args:\n\n      bold: True for bold embellishment.\n\n      italic: True for italic embellishment.\n\n\n\n    Returns:\n\n      The font code string for the requested embellishments. Write this string\n\n        to the console output to control the font settings.\n\n    \"\"\"\n\n    if not self._csi:\n\n      return ''\n\n    codes = []\n\n    if bold:\n\n      codes.append(self._font_bold)\n\n    if italic:\n\n      codes.append(self._font_italic)\n\n    return '{csi}{codes}m'.format(csi=self._csi, codes=';'.join(codes))\n\n\n\n  def GetRawKey(self):\n\n    \"\"\"Reads one key press from stdin with no echo.\n\n\n\n    Returns:\n\n      The key name, None for EOF, <KEY-*> for function keys, otherwise a\n\n      character.\n\n    \"\"\"\n\n    return self._get_raw_key[0]()\n\n\n\n  def GetTermIdentifier(self):\n\n    \"\"\"Returns the TERM envrionment variable for the console.\n\n\n\n    Returns:\n\n      str: A str that describes the console's text capabilities\n\n    \"\"\"\n\n    return self._term\n\n\n\n  def GetTermSize(self):\n\n    \"\"\"Returns the terminal (x, y) dimensions in characters.\n\n\n\n    Returns:\n\n      (x, y): A tuple of the terminal x and y dimensions.\n\n    \"\"\"\n\n    return self._term_size\n\n\n\n  def DisplayWidth(self, buf):\n\n    \"\"\"Returns the display width of buf, handling unicode and ANSI controls.\n\n\n\n    Args:\n\n      buf: The string to count from.\n\n\n\n    Returns:\n\n      The display width of buf, handling unicode and ANSI controls.\n\n    \"\"\"\n\n    if not isinstance(buf, six.string_types):\n\n      # Handle non-string objects like Colorizer().\n\n      return len(buf)\n\n\n\n    cached = self._display_width_cache.get(buf, None)\n\n    if cached is not None:\n\n      return cached\n\n\n\n    width = 0\n\n    max_width = 0\n\n    i = 0\n\n    while i < len(buf):\n\n      if self._csi and buf[i:].startswith(self._csi):\n\n        i += self.GetControlSequenceLen(buf[i:])\n\n      elif buf[i] == '\\n':\n\n        # A newline incidates the start of a new line.\n\n        # Newline characters have 0 width.\n\n        max_width = max(width, max_width)\n\n        width = 0\n\n        i += 1\n\n      else:\n\n        width += GetCharacterDisplayWidth(buf[i])\n\n        i += 1\n\n    max_width = max(width, max_width)\n\n\n\n    self._display_width_cache[buf] = max_width\n\n    return max_width\n\n\n\n  def SplitIntoNormalAndControl(self, buf):\n\n    \"\"\"Returns a list of (normal_string, control_sequence) tuples from buf.\n\n\n\n    Args:\n\n      buf: The input string containing one or more control sequences\n\n        interspersed with normal strings.\n\n\n\n    Returns:\n\n      A list of (normal_string, control_sequence) tuples.\n\n    \"\"\"\n\n    if not self._csi or not buf:\n\n      return [(buf, '')]\n\n    seq = []\n\n    i = 0\n\n    while i < len(buf):\n\n      c = buf.find(self._csi, i)\n\n      if c < 0:\n\n        seq.append((buf[i:], ''))\n\n        break\n\n      normal = buf[i:c]\n\n      i = c + self.GetControlSequenceLen(buf[c:])\n\n      seq.append((normal, buf[c:i]))\n\n    return seq\n\n\n\n  def SplitLine(self, line, width):\n\n    \"\"\"Splits line into width length chunks.\n\n\n\n    Args:\n\n      line: The line to split.\n\n      width: The width of each chunk except the last which could be smaller than\n\n        width.\n\n\n\n    Returns:\n\n      A list of chunks, all but the last with display width == width.\n\n    \"\"\"\n\n    lines = []\n\n    chunk = ''\n\n    w = 0\n\n    keep = False\n\n    for normal, control in self.SplitIntoNormalAndControl(line):\n\n      keep = True\n\n      while True:\n\n        n = width - w\n\n        w += len(normal)\n\n        if w <= width:\n\n          break\n\n        lines.append(chunk + normal[:n])\n\n        chunk = ''\n\n        keep = False\n\n        w = 0\n\n        normal = normal[n:]\n\n      chunk += normal + control\n\n    if chunk or keep:\n\n      lines.append(chunk)\n\n    return lines\n\n\n\n  def SupportsAnsi(self):\n\n    return (self._encoding != 'ascii' and\n\n            ('screen' in self._term or 'xterm' in self._term))\n\n\n\n\n\nclass Colorizer(object):\n\n  \"\"\"Resource string colorizer.\n\n\n\n  Attributes:\n\n    _con: ConsoleAttr object.\n\n    _color: Color name.\n\n    _string: The string to colorize.\n\n    _justify: The justification function, no justification if None. For example,\n\n      justify=lambda s: s.center(10)\n\n  \"\"\"\n\n\n\n  def __init__(self, string, color, justify=None):\n\n    \"\"\"Constructor.\n\n\n\n    Args:\n\n      string: The string to colorize.\n\n      color: Color name used to index ConsoleAttr._ANSI_COLOR.\n\n      justify: The justification function, no justification if None. For\n\n        example, justify=lambda s: s.center(10)\n\n    \"\"\"\n\n    self._con = GetConsoleAttr()\n\n    self._color = color\n\n    self._string = string\n\n    self._justify = justify\n\n\n\n  def __eq__(self, other):\n\n    return self._string == six.text_type(other)\n\n\n\n  def __ne__(self, other):\n\n    return not self == other\n\n\n\n  def __gt__(self, other):\n\n    return self._string > six.text_type(other)\n\n\n\n  def __lt__(self, other):\n\n    return self._string < six.text_type(other)\n\n\n\n  def __ge__(self, other):\n\n    return not self < other\n\n\n\n  def __le__(self, other):\n\n    return not self > other\n\n\n\n  def __len__(self):\n\n    return self._con.DisplayWidth(self._string)\n\n\n\n  def __str__(self):\n\n    return self._string\n\n\n\n  def Render(self, stream, justify=None):\n\n    \"\"\"Renders the string as self._color on the console.\n\n\n\n    Args:\n\n      stream: The stream to render the string to. The stream given here *must*\n\n        have the same encoding as sys.stdout for this to work properly.\n\n      justify: The justification function, self._justify if None.\n\n    \"\"\"\n\n    stream.write(\n\n        self._con.Colorize(self._string, self._color, justify or self._justify))\n\n\n\n\n\ndef GetConsoleAttr(encoding=None, reset=False):\n\n  \"\"\"Gets the console attribute state.\n\n\n\n  If this is the first call or reset is True or encoding is not None and does\n\n  not match the current encoding or out is not None and does not match the\n\n  current out then the state is (re)initialized. Otherwise the current state\n\n  is returned.\n\n\n\n  This call associates the out file stream with the console. All console related\n\n  output should go to the same stream.\n\n\n\n  Args:\n\n    encoding: Encoding override.\n\n      ascii -- ASCII. This is the default.\n\n      utf8 -- UTF-8 unicode.\n\n      win -- Windows code page 437.\n\n    reset: Force re-initialization if True.\n\n\n\n  Returns:\n\n    The global ConsoleAttr state object.\n\n  \"\"\"\n\n  attr = ConsoleAttr._CONSOLE_ATTR_STATE  # pylint: disable=protected-access\n\n  if not reset:\n\n    if not attr:\n\n      reset = True\n\n    elif encoding and encoding != attr.GetEncoding():\n\n      reset = True\n\n  if reset:\n\n    attr = ConsoleAttr(encoding=encoding)\n\n    ConsoleAttr._CONSOLE_ATTR_STATE = attr  # pylint: disable=protected-access\n\n  return attr\n\n\n\n\n\ndef ResetConsoleAttr(encoding=None):\n\n  \"\"\"Resets the console attribute state to the console default.\n\n\n\n  Args:\n\n    encoding: Reset to this encoding instead of the default.\n\n      ascii -- ASCII. This is the default.\n\n      utf8 -- UTF-8 unicode.\n\n      win -- Windows code page 437.\n\n\n\n  Returns:\n\n    The global ConsoleAttr state object.\n\n  \"\"\"\n\n  return GetConsoleAttr(encoding=encoding, reset=True)\n\n\n\n\n\ndef GetCharacterDisplayWidth(char):\n\n  \"\"\"Returns the monospaced terminal display width of char.\n\n\n\n  Assumptions:\n\n    - monospaced display\n\n    - ambiguous or unknown chars default to width 1\n\n    - ASCII control char width is 1 => don't use this for control chars\n\n\n\n  Args:\n\n    char: The character to determine the display width of.\n\n\n\n  Returns:\n\n    The monospaced terminal display width of char: either 0, 1, or 2.\n\n  \"\"\"\n\n  if not isinstance(char, six.text_type):\n\n    # Non-unicode chars have width 1. Don't use this function on control chars.\n\n    return 1\n\n\n\n  # Normalize to avoid special cases.\n\n  char = unicodedata.normalize('NFC', char)\n\n\n\n  if unicodedata.combining(char) != 0:\n\n    # Modifies the previous character and does not move the cursor.\n\n    return 0\n\n  elif unicodedata.category(char) == 'Cf':\n\n    # Unprintable formatting char.\n\n    return 0\n\n  elif unicodedata.east_asian_width(char) in 'FW':\n\n    # Fullwidth or Wide chars take 2 character positions.\n\n    return 2\n\n  else:\n\n    # Don't use this function on control chars.\n\n    return 1\n\n\n\n\n\ndef SafeText(data, encoding=None, escape=True):\n\n  br\"\"\"Converts the data to a text string compatible with the given encoding.\n\n\n\n  This works the same way as Decode() below except it guarantees that any\n\n  characters in the resulting text string can be re-encoded using the given\n\n  encoding (or GetConsoleAttr().GetEncoding() if None is given). This means\n\n  that the string will be safe to print to sys.stdout (for example) without\n\n  getting codec exceptions if the user's terminal doesn't support the encoding\n\n  used by the source of the text.\n\n\n\n  Args:\n\n    data: Any bytes, string, or object that has str() or unicode() methods.\n\n    encoding: The encoding name to ensure compatibility with. Defaults to\n\n      GetConsoleAttr().GetEncoding().\n\n    escape: Replace unencodable characters with a \\uXXXX or \\xXX equivalent if\n\n      True. Otherwise replace unencodable characters with an appropriate unknown\n\n      character, '?' for ASCII, and the unicode unknown replacement character\n\n      \\uFFFE for unicode.\n\n\n\n  Returns:\n\n    A text string representation of the data, but modified to remove any\n\n    characters that would result in an encoding exception with the target\n\n    encoding. In the worst case, with escape=False, it will contain only ?\n\n    characters.\n\n  \"\"\"\n\n  if data is None:\n\n    return 'None'\n\n  encoding = encoding or GetConsoleAttr().GetEncoding()\n\n  string = encoding_util.Decode(data, encoding=encoding)\n\n\n\n  try:\n\n    # No change needed if the string encodes to the output encoding.\n\n    string.encode(encoding)\n\n    return string\n\n  except UnicodeError:\n\n    # The string does not encode to the output encoding. Encode it with error\n\n    # handling then convert it back into a text string (which will be\n\n    # guaranteed to only contain characters that can be encoded later.\n\n    return (string\n\n            .encode(encoding, 'backslashreplace' if escape else 'replace')\n\n            .decode(encoding))\n\n\n\n\n\ndef EncodeToBytes(data):\n\n  r\"\"\"Encode data to bytes.\n\n\n\n  The primary use case is for base64/mime style 7-bit ascii encoding where the\n\n  encoder input must be bytes. \"safe\" means that the conversion always returns\n\n  bytes and will not raise codec exceptions.\n\n\n\n  If data is text then an 8-bit ascii encoding is attempted, then the console\n\n  encoding, and finally utf-8.\n\n\n\n  Args:\n\n    data: Any bytes, string, or object that has str() or unicode() methods.\n\n\n\n  Returns:\n\n    A bytes string representation of the data.\n\n  \"\"\"\n\n  if data is None:\n\n    return b''\n\n  if isinstance(data, bytes):\n\n    # Already bytes - our work is done.\n\n    return data\n\n\n\n  # Coerce to text that will be converted to bytes.\n\n  s = six.text_type(data)\n\n\n\n  try:\n\n    # Assume the text can be directly converted to bytes (8-bit ascii).\n\n    return s.encode('iso-8859-1')\n\n  except UnicodeEncodeError:\n\n    pass\n\n\n\n  try:\n\n    # Try the output encoding.\n\n    return s.encode(GetConsoleAttr().GetEncoding())\n\n  except UnicodeEncodeError:\n\n    pass\n\n\n\n  # Punt to utf-8.\n\n  return s.encode('utf-8')\n\n\n\n\n\ndef Decode(data, encoding=None):\n\n  \"\"\"Converts the given string, bytes, or object to a text string.\n\n\n\n  Args:\n\n    data: Any bytes, string, or object that has str() or unicode() methods.\n\n    encoding: A suggesting encoding used to decode. If this encoding doesn't\n\n      work, other defaults are tried. Defaults to\n\n      GetConsoleAttr().GetEncoding().\n\n\n\n  Returns:\n\n    A text string representation of the data.\n\n  \"\"\"\n\n  encoding = encoding or GetConsoleAttr().GetEncoding()\n\n  return encoding_util.Decode(data, encoding=encoding)\n", "# -*- coding: utf-8 -*- #\n\n# Copyright 2018 Google LLC. All Rights Reserved.\n\n#\n\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n\n# you may not use this file except in compliance with the License.\n\n# You may obtain a copy of the License at\n\n#\n\n#    http://www.apache.org/licenses/LICENSE-2.0\n\n#\n\n# Unless required by applicable law or agreed to in writing, software\n\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n\n# See the License for the specific language governing permissions and\n\n# limitations under the License.\n\n\"\"\"Semantic text objects that are used for styled outputting.\"\"\"\n\n\n\nfrom __future__ import absolute_import\n\nfrom __future__ import division\n\nfrom __future__ import unicode_literals\n\n\n\nimport enum\n\n\n\n\n\nclass TextAttributes(object):\n\n  \"\"\"Attributes to use to style text with.\"\"\"\n\n\n\n  def __init__(self, format_str=None, color=None, attrs=None):\n\n    \"\"\"Defines a set of attributes for a piece of text.\n\n\n\n    Args:\n\n      format_str: (str), string that will be used to format the text\n\n        with. For example '[{}]', to enclose text in brackets.\n\n      color: (Colors), the color the text should be formatted with.\n\n      attrs: (Attrs), the attributes to apply to text.\n\n    \"\"\"\n\n    self._format_str = format_str\n\n    self._color = color\n\n    self._attrs = attrs or []\n\n\n\n  @property\n\n  def format_str(self):\n\n    return self._format_str\n\n\n\n  @property\n\n  def color(self):\n\n    return self._color\n\n\n\n  @property\n\n  def attrs(self):\n\n    return self._attrs\n\n\n\n\n\nclass TypedText(object):\n\n  \"\"\"Text with a semantic type that will be used for styling.\"\"\"\n\n\n\n  def __init__(self, texts, text_type=None):\n\n    \"\"\"String of text and a corresponding type to use to style that text.\n\n\n\n    Args:\n\n     texts: (list[str]), list of strs or TypedText objects\n\n       that should be styled using text_type.\n\n     text_type: (TextTypes), the semantic type of the text that\n\n       will be used to style text.\n\n    \"\"\"\n\n    self.texts = texts\n\n    self.text_type = text_type\n\n\n\n  def __len__(self):\n\n    length = 0\n\n    for text in self.texts:\n\n      length += len(text)\n\n    return length\n\n\n\n  def __add__(self, other):\n\n    texts = [self, other]\n\n    return TypedText(texts)\n\n\n\n  def __radd__(self, other):\n\n    texts = [other, self]\n\n    return TypedText(texts)\n\n\n\n\n\nclass _TextTypes(enum.Enum):\n\n  \"\"\"Text types base class that defines base functionality.\"\"\"\n\n\n\n  def __call__(self, *args):\n\n    \"\"\"Returns a TypedText object using this style.\"\"\"\n\n    return TypedText(list(args), self)\n\n\n\n\n\n# TODO: Add more types.\n\nclass TextTypes(_TextTypes):\n\n  \"\"\"Defines text types that can be used for styling text.\"\"\"\n\n  RESOURCE_NAME = 1\n\n  URL = 2\n\n  USER_INPUT = 3\n\n  COMMAND = 4\n\n  INFO = 5\n\n  URI = 6\n\n  OUTPUT = 7\n\n  PT_SUCCESS = 8\n\n  PT_FAILURE = 9\n\n\n", "# -*- coding: utf-8 -*- #\n\n# Copyright 2015 Google LLC. All Rights Reserved.\n\n#\n\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n\n# you may not use this file except in compliance with the License.\n\n# You may obtain a copy of the License at\n\n#\n\n#    http://www.apache.org/licenses/LICENSE-2.0\n\n#\n\n# Unless required by applicable law or agreed to in writing, software\n\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n\n# See the License for the specific language governing permissions and\n\n# limitations under the License.\n\n\n\n\"\"\"Simple console pager.\"\"\"\n\n\n\nfrom __future__ import absolute_import\n\nfrom __future__ import division\n\nfrom __future__ import unicode_literals\n\n\n\nimport re\n\nimport sys\n\n\n\nfrom fire.console import console_attr\n\n\n\n\n\nclass Pager(object):\n\n  \"\"\"A simple console text pager.\n\n\n\n  This pager requires the entire contents to be available. The contents are\n\n  written one page of lines at a time. The prompt is written after each page of\n\n  lines. A one character response is expected. See HELP_TEXT below for more\n\n  info.\n\n\n\n  The contents are written as is. For example, ANSI control codes will be in\n\n  effect. This is different from pagers like more(1) which is ANSI control code\n\n  agnostic and miscalculates line lengths, and less(1) which displays control\n\n  character names by default.\n\n\n\n  Attributes:\n\n    _attr: The current ConsoleAttr handle.\n\n    _clear: A string that clears the prompt when written to _out.\n\n    _contents: The entire contents of the text lines to page.\n\n    _height: The terminal height in characters.\n\n    _out: The output stream, log.out (effectively) if None.\n\n    _prompt: The page break prompt.\n\n    _search_direction: The search direction command, n:forward, N:reverse.\n\n    _search_pattern: The current forward/reverse search compiled RE.\n\n    _width: The termonal width in characters.\n\n  \"\"\"\n\n\n\n  HELP_TEXT = \"\"\"\n\n  Simple pager commands:\n\n\n\n    b, ^B, <PAGE-UP>, <LEFT-ARROW>\n\n      Back one page.\n\n    f, ^F, <SPACE>, <PAGE-DOWN>, <RIGHT-ARROW>\n\n      Forward one page. Does not quit if there are no more lines.\n\n    g, <HOME>\n\n      Back to the first page.\n\n    <number>g\n\n      Go to <number> lines from the top.\n\n    G, <END>\n\n      Forward to the last page.\n\n    <number>G\n\n      Go to <number> lines from the bottom.\n\n    h\n\n      Print pager command help.\n\n    j, +, <DOWN-ARROW>\n\n      Forward one line.\n\n    k, -, <UP-ARROW>\n\n      Back one line.\n\n    /pattern\n\n      Forward search for pattern.\n\n    ?pattern\n\n      Backward search for pattern.\n\n    n\n\n      Repeat current search.\n\n    N\n\n      Repeat current search in the opposite direction.\n\n    q, Q, ^C, ^D, ^Z\n\n      Quit return to the caller.\n\n    any other character\n\n      Prompt again.\n\n\n\n  Hit any key to continue:\"\"\"\n\n\n\n  PREV_POS_NXT_REPRINT = -1, -1\n\n\n\n  def __init__(self, contents, out=None, prompt=None):\n\n    \"\"\"Constructor.\n\n\n\n    Args:\n\n      contents: The entire contents of the text lines to page.\n\n      out: The output stream, log.out (effectively) if None.\n\n      prompt: The page break prompt, a defalt prompt is used if None..\n\n    \"\"\"\n\n    self._contents = contents\n\n    self._out = out or sys.stdout\n\n    self._search_pattern = None\n\n    self._search_direction = None\n\n\n\n    # prev_pos, prev_next values to force reprint\n\n    self.prev_pos, self.prev_nxt = self.PREV_POS_NXT_REPRINT\n\n    # Initialize the console attributes.\n\n    self._attr = console_attr.GetConsoleAttr()\n\n    self._width, self._height = self._attr.GetTermSize()\n\n\n\n    # Initialize the prompt and the prompt clear string.\n\n    if not prompt:\n\n      prompt = '{bold}--({{percent}}%)--{normal}'.format(\n\n          bold=self._attr.GetFontCode(bold=True),\n\n          normal=self._attr.GetFontCode())\n\n    self._clear = '\\r{0}\\r'.format(' ' * (self._attr.DisplayWidth(prompt) - 6))\n\n    self._prompt = prompt\n\n\n\n    # Initialize a list of lines with long lines split into separate display\n\n    # lines.\n\n    self._lines = []\n\n    for line in contents.splitlines():\n\n      self._lines += self._attr.SplitLine(line, self._width)\n\n\n\n  def _Write(self, s):\n\n    \"\"\"Mockable helper that writes s to self._out.\"\"\"\n\n    self._out.write(s)\n\n\n\n  def _GetSearchCommand(self, c):\n\n    \"\"\"Consumes a search command and returns the equivalent pager command.\n\n\n\n    The search pattern is an RE that is pre-compiled and cached for subsequent\n\n    /<newline>, ?<newline>, n, or N commands.\n\n\n\n    Args:\n\n      c: The search command char.\n\n\n\n    Returns:\n\n      The pager command char.\n\n    \"\"\"\n\n    self._Write(c)\n\n    buf = ''\n\n    while True:\n\n      p = self._attr.GetRawKey()\n\n      if p in (None, '\\n', '\\r') or len(p) != 1:\n\n        break\n\n      self._Write(p)\n\n      buf += p\n\n    self._Write('\\r' + ' ' * len(buf) + '\\r')\n\n    if buf:\n\n      try:\n\n        self._search_pattern = re.compile(buf)\n\n      except re.error:\n\n        # Silently ignore pattern errors.\n\n        self._search_pattern = None\n\n        return ''\n\n    self._search_direction = 'n' if c == '/' else 'N'\n\n    return 'n'\n\n\n\n  def _Help(self):\n\n    \"\"\"Print command help and wait for any character to continue.\"\"\"\n\n    clear = self._height - (len(self.HELP_TEXT) -\n\n                            len(self.HELP_TEXT.replace('\\n', '')))\n\n    if clear > 0:\n\n      self._Write('\\n' * clear)\n\n    self._Write(self.HELP_TEXT)\n\n    self._attr.GetRawKey()\n\n    self._Write('\\n')\n\n\n\n  def Run(self):\n\n    \"\"\"Run the pager.\"\"\"\n\n    # No paging if the contents are small enough.\n\n    if len(self._lines) <= self._height:\n\n      self._Write(self._contents)\n\n      return\n\n\n\n    # We will not always reset previous values.\n\n    reset_prev_values = True\n\n    # Save room for the prompt at the bottom of the page.\n\n    self._height -= 1\n\n\n\n    # Loop over all the pages.\n\n    pos = 0\n\n    while pos < len(self._lines):\n\n      # Write a page of lines.\n\n      nxt = pos + self._height\n\n      if nxt > len(self._lines):\n\n        nxt = len(self._lines)\n\n        pos = nxt - self._height\n\n      # Checks if the starting position is in between the current printed lines\n\n      # so we don't need to reprint all the lines.\n\n      if self.prev_pos < pos < self.prev_nxt:\n\n        # we start where the previous page ended.\n\n        self._Write('\\n'.join(self._lines[self.prev_nxt:nxt]) + '\\n')\n\n      elif pos != self.prev_pos and nxt != self.prev_nxt:\n\n        self._Write('\\n'.join(self._lines[pos:nxt]) + '\\n')\n\n\n\n      # Handle the prompt response.\n\n      percent = self._prompt.format(percent=100 * nxt // len(self._lines))\n\n      digits = ''\n\n      while True:\n\n        # We want to reset prev values if we just exited out of the while loop\n\n        if reset_prev_values:\n\n          self.prev_pos, self.prev_nxt = pos, nxt\n\n          reset_prev_values = False\n\n        self._Write(percent)\n\n        c = self._attr.GetRawKey()\n\n        self._Write(self._clear)\n\n\n\n        # Parse the command.\n\n        if c in (None,    # EOF.\n\n                 'q',     # Quit.\n\n                 'Q',     # Quit.\n\n                 '\\x03',  # ^C  (unix & windows terminal interrupt)\n\n                 '\\x1b',  # ESC.\n\n                ):\n\n          # Quit.\n\n          return\n\n        elif c in ('/', '?'):\n\n          c = self._GetSearchCommand(c)\n\n        elif c.isdigit():\n\n          # Collect digits for operation count.\n\n          digits += c\n\n          continue\n\n\n\n        # Set the optional command count.\n\n        if digits:\n\n          count = int(digits)\n\n          digits = ''\n\n        else:\n\n          count = 0\n\n\n\n        # Finally commit to command c.\n\n        if c in ('<PAGE-UP>', '<LEFT-ARROW>', 'b', '\\x02'):\n\n          # Previous page.\n\n          nxt = pos - self._height\n\n          if nxt < 0:\n\n            nxt = 0\n\n        elif c in ('<PAGE-DOWN>', '<RIGHT-ARROW>', 'f', '\\x06', ' '):\n\n          # Next page.\n\n          if nxt >= len(self._lines):\n\n            continue\n\n          nxt = pos + self._height\n\n          if nxt >= len(self._lines):\n\n            nxt = pos\n\n        elif c in ('<HOME>', 'g'):\n\n          # First page.\n\n          nxt = count - 1\n\n          if nxt > len(self._lines) - self._height:\n\n            nxt = len(self._lines) - self._height\n\n          if nxt < 0:\n\n            nxt = 0\n\n        elif c in ('<END>', 'G'):\n\n          # Last page.\n\n          nxt = len(self._lines) - count\n\n          if nxt > len(self._lines) - self._height:\n\n            nxt = len(self._lines) - self._height\n\n          if nxt < 0:\n\n            nxt = 0\n\n        elif c == 'h':\n\n          self._Help()\n\n          # Special case when we want to reprint the previous display.\n\n          self.prev_pos, self.prev_nxt = self.PREV_POS_NXT_REPRINT\n\n          nxt = pos\n\n          break\n\n        elif c in ('<DOWN-ARROW>', 'j', '+', '\\n', '\\r'):\n\n          # Next line.\n\n          if nxt >= len(self._lines):\n\n            continue\n\n          nxt = pos + 1\n\n          if nxt >= len(self._lines):\n\n            nxt = pos\n\n        elif c in ('<UP-ARROW>', 'k', '-'):\n\n          # Previous line.\n\n          nxt = pos - 1\n\n          if nxt < 0:\n\n            nxt = 0\n\n        elif c in ('n', 'N'):\n\n          # Next pattern match search.\n\n          if not self._search_pattern:\n\n            continue\n\n          nxt = pos\n\n          i = pos\n\n          direction = 1 if c == self._search_direction else -1\n\n          while True:\n\n            i += direction\n\n            if i < 0 or i >= len(self._lines):\n\n              break\n\n            if self._search_pattern.search(self._lines[i]):\n\n              nxt = i\n\n              break\n\n        else:\n\n          # Silently ignore everything else.\n\n          continue\n\n        if nxt != pos:\n\n          # We will exit the while loop because position changed so we can reset\n\n          # prev values.\n\n          reset_prev_values = True\n\n          break\n\n      pos = nxt\n", "# -*- coding: utf-8 -*- #\n\n\n\n# Copyright 2015 Google LLC. All Rights Reserved.\n\n#\n\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n\n# you may not use this file except in compliance with the License.\n\n# You may obtain a copy of the License at\n\n#\n\n#    http://www.apache.org/licenses/LICENSE-2.0\n\n#\n\n# Unless required by applicable law or agreed to in writing, software\n\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n\n# See the License for the specific language governing permissions and\n\n# limitations under the License.\n\n\n\n\"\"\"A module for dealing with unknown string and environment encodings.\"\"\"\n\n\n\nfrom __future__ import absolute_import\n\nfrom __future__ import division\n\nfrom __future__ import unicode_literals\n\n\n\nimport sys\n\n\n\nimport six\n\n\n\n\n\ndef Encode(string, encoding=None):\n\n  \"\"\"Encode the text string to a byte string.\n\n\n\n  Args:\n\n    string: str, The text string to encode.\n\n    encoding: The suggested encoding if known.\n\n\n\n  Returns:\n\n    str, The binary string.\n\n  \"\"\"\n\n  if string is None:\n\n    return None\n\n  if not six.PY2:\n\n    # In Python 3, the environment sets and gets accept and return text strings\n\n    # only, and it handles the encoding itself so this is not necessary.\n\n    return string\n\n  if isinstance(string, six.binary_type):\n\n    # Already an encoded byte string, we are done\n\n    return string\n\n\n\n  encoding = encoding or _GetEncoding()\n\n  return string.encode(encoding)\n\n\n\n\n\ndef Decode(data, encoding=None):\n\n  \"\"\"Returns string with non-ascii characters decoded to UNICODE.\n\n\n\n  UTF-8, the suggested encoding, and the usual suspects will be attempted in\n\n  order.\n\n\n\n  Args:\n\n    data: A string or object that has str() and unicode() methods that may\n\n      contain an encoding incompatible with the standard output encoding.\n\n    encoding: The suggested encoding if known.\n\n\n\n  Returns:\n\n    A text string representing the decoded byte string.\n\n  \"\"\"\n\n  if data is None:\n\n    return None\n\n\n\n  # First we are going to get the data object to be a text string.\n\n  # Don't use six.string_types here because on Python 3 bytes is not considered\n\n  # a string type and we want to include that.\n\n  if isinstance(data, six.text_type) or isinstance(data, six.binary_type):\n\n    string = data\n\n  else:\n\n    # Some non-string type of object.\n\n    try:\n\n      string = six.text_type(data)\n\n    except (TypeError, UnicodeError):\n\n      # The string cannot be converted to unicode -- default to str() which will\n\n      # catch objects with special __str__ methods.\n\n      string = str(data)\n\n\n\n  if isinstance(string, six.text_type):\n\n    # Our work is done here.\n\n    return string\n\n\n\n  try:\n\n    # Just return the string if its pure ASCII.\n\n    return string.decode('ascii')\n\n  except UnicodeError:\n\n    # The string is not ASCII encoded.\n\n    pass\n\n\n\n  # Try the suggested encoding if specified.\n\n  if encoding:\n\n    try:\n\n      return string.decode(encoding)\n\n    except UnicodeError:\n\n      # Bad suggestion.\n\n      pass\n\n\n\n  # Try UTF-8 because the other encodings could be extended ASCII. It would\n\n  # be exceptional if a valid extended ascii encoding with extended chars\n\n  # were also a valid UITF-8 encoding.\n\n  try:\n\n    return string.decode('utf8')\n\n  except UnicodeError:\n\n    # Not a UTF-8 encoding.\n\n    pass\n\n\n\n  # Try the filesystem encoding.\n\n  try:\n\n    return string.decode(sys.getfilesystemencoding())\n\n  except UnicodeError:\n\n    # string is not encoded for filesystem paths.\n\n    pass\n\n\n\n  # Try the system default encoding.\n\n  try:\n\n    return string.decode(sys.getdefaultencoding())\n\n  except UnicodeError:\n\n    # string is not encoded using the default encoding.\n\n    pass\n\n\n\n  # We don't know the string encoding.\n\n  # This works around a Python str.encode() \"feature\" that throws\n\n  # an ASCII *decode* exception on str strings that contain 8th bit set\n\n  # bytes. For example, this sequence throws an exception:\n\n  #   string = '\\xdc'  # iso-8859-1 '\u00dc'\n\n  #   string = string.encode('ascii', 'backslashreplace')\n\n  # even though 'backslashreplace' is documented to handle encoding\n\n  # errors. We work around the problem by first decoding the str string\n\n  # from an 8-bit encoding to unicode, selecting any 8-bit encoding that\n\n  # uses all 256 bytes (such as ISO-8559-1):\n\n  #   string = string.decode('iso-8859-1')\n\n  # Using this produces a sequence that works:\n\n  #   string = '\\xdc'\n\n  #   string = string.decode('iso-8859-1')\n\n  #   string = string.encode('ascii', 'backslashreplace')\n\n  return string.decode('iso-8859-1')\n\n\n\n\n\ndef GetEncodedValue(env, name, default=None):\n\n  \"\"\"Returns the decoded value of the env var name.\n\n\n\n  Args:\n\n    env: {str: str}, The env dict.\n\n    name: str, The env var name.\n\n    default: The value to return if name is not in env.\n\n\n\n  Returns:\n\n    The decoded value of the env var name.\n\n  \"\"\"\n\n  name = Encode(name)\n\n  value = env.get(name)\n\n  if value is None:\n\n    return default\n\n  # In Python 3, the environment sets and gets accept and return text strings\n\n  # only, and it handles the encoding itself so this is not necessary.\n\n  return Decode(value)\n\n\n\n\n\ndef SetEncodedValue(env, name, value, encoding=None):\n\n  \"\"\"Sets the value of name in env to an encoded value.\n\n\n\n  Args:\n\n    env: {str: str}, The env dict.\n\n    name: str, The env var name.\n\n    value: str or unicode, The value for name. If None then name is removed from\n\n      env.\n\n    encoding: str, The encoding to use or None to try to infer it.\n\n  \"\"\"\n\n  # Python 2 *and* 3 unicode support falls apart at filesystem/argv/environment\n\n  # boundaries. The encoding used for filesystem paths and environment variable\n\n  # names/values is under user control on most systems. With one of those values\n\n  # in hand there is no way to tell exactly how the value was encoded. We get\n\n  # some reasonable hints from sys.getfilesystemencoding() or\n\n  # sys.getdefaultencoding() and use them to encode values that the receiving\n\n  # process will have a chance at decoding. Leaving the values as unicode\n\n  # strings will cause os module Unicode exceptions. What good is a language\n\n  # unicode model when the module support could care less?\n\n  name = Encode(name, encoding=encoding)\n\n  if value is None:\n\n    env.pop(name, None)\n\n    return\n\n  env[name] = Encode(value, encoding=encoding)\n\n\n\n\n\ndef EncodeEnv(env, encoding=None):\n\n  \"\"\"Encodes all the key value pairs in env in preparation for subprocess.\n\n\n\n  Args:\n\n    env: {str: str}, The environment you are going to pass to subprocess.\n\n    encoding: str, The encoding to use or None to use the default.\n\n\n\n  Returns:\n\n    {bytes: bytes}, The environment to pass to subprocess.\n\n  \"\"\"\n\n  encoding = encoding or _GetEncoding()\n\n  return {\n\n      Encode(k, encoding=encoding): Encode(v, encoding=encoding)\n\n      for k, v in six.iteritems(env)}\n\n\n\n\n\ndef _GetEncoding():\n\n  \"\"\"Gets the default encoding to use.\"\"\"\n\n  return sys.getfilesystemencoding() or sys.getdefaultencoding()\n", "# -*- coding: utf-8 -*- #\n\n# Copyright 2013 Google LLC. All Rights Reserved.\n\n#\n\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n\n# you may not use this file except in compliance with the License.\n\n# You may obtain a copy of the License at\n\n#\n\n#    http://www.apache.org/licenses/LICENSE-2.0\n\n#\n\n# Unless required by applicable law or agreed to in writing, software\n\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n\n# See the License for the specific language governing permissions and\n\n# limitations under the License.\n\n\n\n\"\"\"Some general file utilities used that can be used by the Cloud SDK.\"\"\"\n\n\n\nfrom __future__ import absolute_import\n\nfrom __future__ import division\n\nfrom __future__ import unicode_literals\n\n\n\nimport os\n\n\n\nfrom fire.console import encoding as encoding_util\n\nfrom fire.console import platforms\n\n\n\nimport six\n\n\n\n\n\ndef _GetSystemPath():\n\n  \"\"\"Returns properly encoded system PATH variable string.\"\"\"\n\n  return encoding_util.GetEncodedValue(os.environ, 'PATH')\n\n\n\n\n\ndef _FindExecutableOnPath(executable, path, pathext):\n\n  \"\"\"Internal function to a find an executable.\n\n\n\n  Args:\n\n    executable: The name of the executable to find.\n\n    path: A list of directories to search separated by 'os.pathsep'.\n\n    pathext: An iterable of file name extensions to use.\n\n\n\n  Returns:\n\n    str, the path to a file on `path` with name `executable` + `p` for\n\n      `p` in `pathext`.\n\n\n\n  Raises:\n\n    ValueError: invalid input.\n\n  \"\"\"\n\n\n\n  if isinstance(pathext, six.string_types):\n\n    raise ValueError('_FindExecutableOnPath(..., pathext=\\'{0}\\') failed '\n\n                     'because pathext must be an iterable of strings, but got '\n\n                     'a string.'.format(pathext))\n\n\n\n  # Prioritize preferred extension over earlier in path.\n\n  for ext in pathext:\n\n    for directory in path.split(os.pathsep):\n\n      # Windows can have paths quoted.\n\n      directory = directory.strip('\"')\n\n      full = os.path.normpath(os.path.join(directory, executable) + ext)\n\n      # On Windows os.access(full, os.X_OK) is always True.\n\n      if os.path.isfile(full) and os.access(full, os.X_OK):\n\n        return full\n\n  return None\n\n\n\n\n\ndef _PlatformExecutableExtensions(platform):\n\n  if platform == platforms.OperatingSystem.WINDOWS:\n\n    return ('.exe', '.cmd', '.bat', '.com', '.ps1')\n\n  else:\n\n    return ('', '.sh')\n\n\n\n\n\ndef FindExecutableOnPath(executable, path=None, pathext=None,\n\n                         allow_extensions=False):\n\n  \"\"\"Searches for `executable` in the directories listed in `path` or $PATH.\n\n\n\n  Executable must not contain a directory or an extension.\n\n\n\n  Args:\n\n    executable: The name of the executable to find.\n\n    path: A list of directories to search separated by 'os.pathsep'.  If None\n\n      then the system PATH is used.\n\n    pathext: An iterable of file name extensions to use.  If None then\n\n      platform specific extensions are used.\n\n    allow_extensions: A boolean flag indicating whether extensions in the\n\n      executable are allowed.\n\n\n\n  Returns:\n\n    The path of 'executable' (possibly with a platform-specific extension) if\n\n    found and executable, None if not found.\n\n\n\n  Raises:\n\n    ValueError: if executable has a path or an extension, and extensions are\n\n      not allowed, or if there's an internal error.\n\n  \"\"\"\n\n\n\n  if not allow_extensions and os.path.splitext(executable)[1]:\n\n    raise ValueError('FindExecutableOnPath({0},...) failed because first '\n\n                     'argument must not have an extension.'.format(executable))\n\n\n\n  if os.path.dirname(executable):\n\n    raise ValueError('FindExecutableOnPath({0},...) failed because first '\n\n                     'argument must not have a path.'.format(executable))\n\n\n\n  if path is None:\n\n    effective_path = _GetSystemPath()\n\n  else:\n\n    effective_path = path\n\n  effective_pathext = (pathext if pathext is not None\n\n                       else _PlatformExecutableExtensions(\n\n                           platforms.OperatingSystem.Current()))\n\n\n\n  return _FindExecutableOnPath(executable, effective_path,\n\n                               effective_pathext)\n", "# -*- coding: utf-8 -*- #\n\n# Copyright 2015 Google LLC. All Rights Reserved.\n\n#\n\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n\n# you may not use this file except in compliance with the License.\n\n# You may obtain a copy of the License at\n\n#\n\n#    http://www.apache.org/licenses/LICENSE-2.0\n\n#\n\n# Unless required by applicable law or agreed to in writing, software\n\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n\n# See the License for the specific language governing permissions and\n\n# limitations under the License.\n\n\n\n\"\"\"OS specific console_attr helper functions.\"\"\"\n\n# This file contains platform specific code which is not currently handled\n\n# by pytype.\n\n# pytype: skip-file\n\n\n\nfrom __future__ import absolute_import\n\nfrom __future__ import division\n\nfrom __future__ import unicode_literals\n\n\n\nimport os\n\nimport sys\n\n\n\nfrom fire.console import encoding\n\n\n\n\n\ndef GetTermSize():\n\n  \"\"\"Gets the terminal x and y dimensions in characters.\n\n\n\n  _GetTermSize*() helper functions taken from:\n\n    http://stackoverflow.com/questions/263890/\n\n\n\n  Returns:\n\n    (columns, lines): A tuple containing the terminal x and y dimensions.\n\n  \"\"\"\n\n  xy = None\n\n  # Believe the first helper that doesn't bail.\n\n  for get_terminal_size in (_GetTermSizePosix,\n\n                            _GetTermSizeWindows,\n\n                            _GetTermSizeEnvironment,\n\n                            _GetTermSizeTput):\n\n    try:\n\n      xy = get_terminal_size()\n\n      if xy:\n\n        break\n\n    except:  # pylint: disable=bare-except\n\n      pass\n\n  return xy or (80, 24)\n\n\n\n\n\ndef _GetTermSizePosix():\n\n  \"\"\"Returns the Posix terminal x and y dimensions.\"\"\"\n\n  # pylint: disable=g-import-not-at-top\n\n  import fcntl\n\n  # pylint: disable=g-import-not-at-top\n\n  import struct\n\n  # pylint: disable=g-import-not-at-top\n\n  import termios\n\n\n\n  def _GetXY(fd):\n\n    \"\"\"Returns the terminal (x,y) size for fd.\n\n\n\n    Args:\n\n      fd: The terminal file descriptor.\n\n\n\n    Returns:\n\n      The terminal (x,y) size for fd or None on error.\n\n    \"\"\"\n\n    try:\n\n      # This magic incantation converts a struct from ioctl(2) containing two\n\n      # binary shorts to a (rows, columns) int tuple.\n\n      rc = struct.unpack(b'hh', fcntl.ioctl(fd, termios.TIOCGWINSZ, 'junk'))\n\n      return (rc[1], rc[0]) if rc else None\n\n    except:  # pylint: disable=bare-except\n\n      return None\n\n\n\n  xy = _GetXY(0) or _GetXY(1) or _GetXY(2)\n\n  if not xy:\n\n    fd = None\n\n    try:\n\n      fd = os.open(os.ctermid(), os.O_RDONLY)\n\n      xy = _GetXY(fd)\n\n    except:  # pylint: disable=bare-except\n\n      xy = None\n\n    finally:\n\n      if fd is not None:\n\n        os.close(fd)\n\n  return xy\n\n\n\n\n\ndef _GetTermSizeWindows():\n\n  \"\"\"Returns the Windows terminal x and y dimensions.\"\"\"\n\n  # pylint:disable=g-import-not-at-top\n\n  import struct\n\n  # pylint: disable=g-import-not-at-top\n\n  from ctypes import create_string_buffer\n\n  # pylint:disable=g-import-not-at-top\n\n  from ctypes import windll\n\n\n\n  # stdin handle is -10\n\n  # stdout handle is -11\n\n  # stderr handle is -12\n\n\n\n  h = windll.kernel32.GetStdHandle(-12)\n\n  csbi = create_string_buffer(22)\n\n  if not windll.kernel32.GetConsoleScreenBufferInfo(h, csbi):\n\n    return None\n\n  (unused_bufx, unused_bufy, unused_curx, unused_cury, unused_wattr,\n\n   left, top, right, bottom,\n\n   unused_maxx, unused_maxy) = struct.unpack(b'hhhhHhhhhhh', csbi.raw)\n\n  x = right - left + 1\n\n  y = bottom - top + 1\n\n  return (x, y)\n\n\n\n\n\ndef _GetTermSizeEnvironment():\n\n  \"\"\"Returns the terminal x and y dimensions from the environment.\"\"\"\n\n  return (int(os.environ['COLUMNS']), int(os.environ['LINES']))\n\n\n\n\n\ndef _GetTermSizeTput():\n\n  \"\"\"Returns the terminal x and y dimemsions from tput(1).\"\"\"\n\n  import subprocess  # pylint: disable=g-import-not-at-top\n\n  output = encoding.Decode(subprocess.check_output(['tput', 'cols'],\n\n                                                   stderr=subprocess.STDOUT))\n\n  cols = int(output)\n\n  output = encoding.Decode(subprocess.check_output(['tput', 'lines'],\n\n                                                   stderr=subprocess.STDOUT))\n\n  rows = int(output)\n\n  return (cols, rows)\n\n\n\n\n\n_ANSI_CSI = '\\x1b'  # ANSI control sequence indicator (ESC)\n\n_CONTROL_D = '\\x04'  # unix EOF (^D)\n\n_CONTROL_Z = '\\x1a'  # Windows EOF (^Z)\n\n_WINDOWS_CSI_1 = '\\x00'  # Windows control sequence indicator #1\n\n_WINDOWS_CSI_2 = '\\xe0'  # Windows control sequence indicator #2\n\n\n\n\n\ndef GetRawKeyFunction():\n\n  \"\"\"Returns a function that reads one keypress from stdin with no echo.\n\n\n\n  Returns:\n\n    A function that reads one keypress from stdin with no echo or a function\n\n    that always returns None if stdin does not support it.\n\n  \"\"\"\n\n  # Believe the first helper that doesn't bail.\n\n  for get_raw_key_function in (_GetRawKeyFunctionPosix,\n\n                               _GetRawKeyFunctionWindows):\n\n    try:\n\n      return get_raw_key_function()\n\n    except:  # pylint: disable=bare-except\n\n      pass\n\n  return lambda: None\n\n\n\n\n\ndef _GetRawKeyFunctionPosix():\n\n  \"\"\"_GetRawKeyFunction helper using Posix APIs.\"\"\"\n\n  # pylint: disable=g-import-not-at-top\n\n  import tty\n\n  # pylint: disable=g-import-not-at-top\n\n  import termios\n\n\n\n  def _GetRawKeyPosix():\n\n    \"\"\"Reads and returns one keypress from stdin, no echo, using Posix APIs.\n\n\n\n    Returns:\n\n      The key name, None for EOF, <*> for function keys, otherwise a\n\n      character.\n\n    \"\"\"\n\n    ansi_to_key = {\n\n        'A': '<UP-ARROW>',\n\n        'B': '<DOWN-ARROW>',\n\n        'D': '<LEFT-ARROW>',\n\n        'C': '<RIGHT-ARROW>',\n\n        '5': '<PAGE-UP>',\n\n        '6': '<PAGE-DOWN>',\n\n        'H': '<HOME>',\n\n        'F': '<END>',\n\n        'M': '<DOWN-ARROW>',\n\n        'S': '<PAGE-UP>',\n\n        'T': '<PAGE-DOWN>',\n\n    }\n\n\n\n    # Flush pending output. sys.stdin.read() would do this, but it's explicitly\n\n    # bypassed in _GetKeyChar().\n\n    sys.stdout.flush()\n\n\n\n    fd = sys.stdin.fileno()\n\n\n\n    def _GetKeyChar():\n\n      return encoding.Decode(os.read(fd, 1))\n\n\n\n    old_settings = termios.tcgetattr(fd)\n\n    try:\n\n      tty.setraw(fd)\n\n      c = _GetKeyChar()\n\n      if c == _ANSI_CSI:\n\n        c = _GetKeyChar()\n\n        while True:\n\n          if c == _ANSI_CSI:\n\n            return c\n\n          if c.isalpha():\n\n            break\n\n          prev_c = c\n\n          c = _GetKeyChar()\n\n          if c == '~':\n\n            c = prev_c\n\n            break\n\n        return ansi_to_key.get(c, '')\n\n    except:  # pylint:disable=bare-except\n\n      c = None\n\n    finally:\n\n      termios.tcsetattr(fd, termios.TCSADRAIN, old_settings)\n\n    return None if c in (_CONTROL_D, _CONTROL_Z) else c\n\n\n\n  return _GetRawKeyPosix\n\n\n\n\n\ndef _GetRawKeyFunctionWindows():\n\n  \"\"\"_GetRawKeyFunction helper using Windows APIs.\"\"\"\n\n  # pylint: disable=g-import-not-at-top\n\n  import msvcrt\n\n\n\n  def _GetRawKeyWindows():\n\n    \"\"\"Reads and returns one keypress from stdin, no echo, using Windows APIs.\n\n\n\n    Returns:\n\n      The key name, None for EOF, <*> for function keys, otherwise a\n\n      character.\n\n    \"\"\"\n\n    windows_to_key = {\n\n        'H': '<UP-ARROW>',\n\n        'P': '<DOWN-ARROW>',\n\n        'K': '<LEFT-ARROW>',\n\n        'M': '<RIGHT-ARROW>',\n\n        'I': '<PAGE-UP>',\n\n        'Q': '<PAGE-DOWN>',\n\n        'G': '<HOME>',\n\n        'O': '<END>',\n\n    }\n\n\n\n    # Flush pending output. sys.stdin.read() would do this it's explicitly\n\n    # bypassed in _GetKeyChar().\n\n    sys.stdout.flush()\n\n\n\n    def _GetKeyChar():\n\n      return encoding.Decode(msvcrt.getch())\n\n\n\n    c = _GetKeyChar()\n\n    # Special function key is a two character sequence; return the second char.\n\n    if c in (_WINDOWS_CSI_1, _WINDOWS_CSI_2):\n\n      return windows_to_key.get(_GetKeyChar(), '')\n\n    return None if c in (_CONTROL_D, _CONTROL_Z) else c\n\n\n\n  return _GetRawKeyWindows\n", "# -*- coding: utf-8 -*- #\n\n# Copyright 2013 Google LLC. All Rights Reserved.\n\n#\n\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n\n# you may not use this file except in compliance with the License.\n\n# You may obtain a copy of the License at\n\n#\n\n#    http://www.apache.org/licenses/LICENSE-2.0\n\n#\n\n# Unless required by applicable law or agreed to in writing, software\n\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n\n# See the License for the specific language governing permissions and\n\n# limitations under the License.\n\n\n\n\"\"\"General console printing utilities used by the Cloud SDK.\"\"\"\n\n\n\nfrom __future__ import absolute_import\n\nfrom __future__ import division\n\nfrom __future__ import print_function\n\n\n\nimport os\n\nimport signal\n\nimport subprocess\n\nimport sys\n\n\n\nfrom fire.console import console_attr\n\nfrom fire.console import console_pager\n\nfrom fire.console import encoding\n\nfrom fire.console import files\n\n\n\n\n\ndef IsInteractive(output=False, error=False, heuristic=False):\n\n  \"\"\"Determines if the current terminal session is interactive.\n\n\n\n  sys.stdin must be a terminal input stream.\n\n\n\n  Args:\n\n    output: If True then sys.stdout must also be a terminal output stream.\n\n    error: If True then sys.stderr must also be a terminal output stream.\n\n    heuristic: If True then we also do some additional heuristics to check if\n\n               we are in an interactive context. Checking home path for example.\n\n\n\n  Returns:\n\n    True if the current terminal session is interactive.\n\n  \"\"\"\n\n  if not sys.stdin.isatty():\n\n    return False\n\n  if output and not sys.stdout.isatty():\n\n    return False\n\n  if error and not sys.stderr.isatty():\n\n    return False\n\n\n\n  if heuristic:\n\n    # Check the home path. Most startup scripts for example are executed by\n\n    # users that don't have a home path set. Home is OS dependent though, so\n\n    # check everything.\n\n    # *NIX OS usually sets the HOME env variable. It is usually '/home/user',\n\n    # but can also be '/root'. If it's just '/' we are most likely in an init\n\n    # script.\n\n    # Windows usually sets HOMEDRIVE and HOMEPATH. If they don't exist we are\n\n    # probably being run from a task scheduler context. HOMEPATH can be '\\'\n\n    # when a user has a network mapped home directory.\n\n    # Cygwin has it all! Both Windows and Linux. Checking both is perfect.\n\n    home = os.getenv('HOME')\n\n    homepath = os.getenv('HOMEPATH')\n\n    if not homepath and (not home or home == '/'):\n\n      return False\n\n  return True\n\n\n\n\n\ndef More(contents, out, prompt=None, check_pager=True):\n\n  \"\"\"Run a user specified pager or fall back to the internal pager.\n\n\n\n  Args:\n\n    contents: The entire contents of the text lines to page.\n\n    out: The output stream.\n\n    prompt: The page break prompt.\n\n    check_pager: Checks the PAGER env var and uses it if True.\n\n  \"\"\"\n\n  if not IsInteractive(output=True):\n\n    out.write(contents)\n\n    return\n\n  if check_pager:\n\n    pager = encoding.GetEncodedValue(os.environ, 'PAGER', None)\n\n    if pager == '-':\n\n      # Use the fallback Pager.\n\n      pager = None\n\n    elif not pager:\n\n      # Search for a pager that handles ANSI escapes.\n\n      for command in ('less', 'pager'):\n\n        if files.FindExecutableOnPath(command):\n\n          pager = command\n\n          break\n\n    if pager:\n\n      # If the pager is less(1) then instruct it to display raw ANSI escape\n\n      # sequences to enable colors and font embellishments.\n\n      less_orig = encoding.GetEncodedValue(os.environ, 'LESS', None)\n\n      less = '-R' + (less_orig or '')\n\n      encoding.SetEncodedValue(os.environ, 'LESS', less)\n\n      # Ignore SIGINT while the pager is running.\n\n      # We don't want to terminate the parent while the child is still alive.\n\n      signal.signal(signal.SIGINT, signal.SIG_IGN)\n\n      p = subprocess.Popen(pager, stdin=subprocess.PIPE, shell=True)\n\n      enc = console_attr.GetConsoleAttr().GetEncoding()\n\n      p.communicate(input=contents.encode(enc))\n\n      p.wait()\n\n      # Start using default signal handling for SIGINT again.\n\n      signal.signal(signal.SIGINT, signal.SIG_DFL)\n\n      if less_orig is None:\n\n        encoding.SetEncodedValue(os.environ, 'LESS', None)\n\n      return\n\n  # Fall back to the internal pager.\n\n  console_pager.Pager(contents, out, prompt).Run()\n", "# -*- coding: utf-8 -*- #\n\n# Copyright 2013 Google LLC. All Rights Reserved.\n\n#\n\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n\n# you may not use this file except in compliance with the License.\n\n# You may obtain a copy of the License at\n\n#\n\n#    http://www.apache.org/licenses/LICENSE-2.0\n\n#\n\n# Unless required by applicable law or agreed to in writing, software\n\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n\n# See the License for the specific language governing permissions and\n\n# limitations under the License.\n\n\n\n\"\"\"Utilities for determining the current platform and architecture.\"\"\"\n\n\n\nfrom __future__ import absolute_import\n\nfrom __future__ import division\n\nfrom __future__ import unicode_literals\n\n\n\nimport os\n\nimport platform\n\nimport subprocess\n\nimport sys\n\n\n\n\n\nclass Error(Exception):\n\n  \"\"\"Base class for exceptions in the platforms module.\"\"\"\n\n  pass\n\n\n\n\n\nclass InvalidEnumValue(Error):  # pylint: disable=g-bad-exception-name\n\n  \"\"\"Exception for when a string could not be parsed to a valid enum value.\"\"\"\n\n\n\n  def __init__(self, given, enum_type, options):\n\n    \"\"\"Constructs a new exception.\n\n\n\n    Args:\n\n      given: str, The given string that could not be parsed.\n\n      enum_type: str, The human readable name of the enum you were trying to\n\n        parse.\n\n      options: list(str), The valid values for this enum.\n\n    \"\"\"\n\n    super(InvalidEnumValue, self).__init__(\n\n        'Could not parse [{0}] into a valid {1}.  Valid values are [{2}]'\n\n        .format(given, enum_type, ', '.join(options)))\n\n\n\n\n\nclass OperatingSystem(object):\n\n  \"\"\"An enum representing the operating system you are running on.\"\"\"\n\n\n\n  class _OS(object):\n\n    \"\"\"A single operating system.\"\"\"\n\n\n\n    # pylint: disable=redefined-builtin\n\n    def __init__(self, id, name, file_name):\n\n      self.id = id\n\n      self.name = name\n\n      self.file_name = file_name\n\n\n\n    def __str__(self):\n\n      return self.id\n\n\n\n    def __eq__(self, other):\n\n      return (isinstance(other, type(self)) and\n\n              self.id == other.id and\n\n              self.name == other.name and\n\n              self.file_name == other.file_name)\n\n\n\n    def __hash__(self):\n\n      return hash(self.id) + hash(self.name) + hash(self.file_name)\n\n\n\n    def __ne__(self, other):\n\n      return not self == other\n\n\n\n    @classmethod\n\n    def _CmpHelper(cls, x, y):\n\n      \"\"\"Just a helper equivalent to the cmp() function in Python 2.\"\"\"\n\n      return (x > y) - (x < y)\n\n\n\n    def __lt__(self, other):\n\n      return self._CmpHelper(\n\n          (self.id, self.name, self.file_name),\n\n          (other.id, other.name, other.file_name)) < 0\n\n\n\n    def __gt__(self, other):\n\n      return self._CmpHelper(\n\n          (self.id, self.name, self.file_name),\n\n          (other.id, other.name, other.file_name)) > 0\n\n\n\n    def __le__(self, other):\n\n      return not self.__gt__(other)\n\n\n\n    def __ge__(self, other):\n\n      return not self.__lt__(other)\n\n\n\n  WINDOWS = _OS('WINDOWS', 'Windows', 'windows')\n\n  MACOSX = _OS('MACOSX', 'Mac OS X', 'darwin')\n\n  LINUX = _OS('LINUX', 'Linux', 'linux')\n\n  CYGWIN = _OS('CYGWIN', 'Cygwin', 'cygwin')\n\n  MSYS = _OS('MSYS', 'Msys', 'msys')\n\n  _ALL = [WINDOWS, MACOSX, LINUX, CYGWIN, MSYS]\n\n\n\n  @staticmethod\n\n  def AllValues():\n\n    \"\"\"Gets all possible enum values.\n\n\n\n    Returns:\n\n      list, All the enum values.\n\n    \"\"\"\n\n    return list(OperatingSystem._ALL)\n\n\n\n  @staticmethod\n\n  def FromId(os_id, error_on_unknown=True):\n\n    \"\"\"Gets the enum corresponding to the given operating system id.\n\n\n\n    Args:\n\n      os_id: str, The operating system id to parse\n\n      error_on_unknown: bool, True to raise an exception if the id is unknown,\n\n        False to just return None.\n\n\n\n    Raises:\n\n      InvalidEnumValue: If the given value cannot be parsed.\n\n\n\n    Returns:\n\n      OperatingSystemTuple, One of the OperatingSystem constants or None if the\n\n      input is None.\n\n    \"\"\"\n\n    if not os_id:\n\n      return None\n\n    for operating_system in OperatingSystem._ALL:\n\n      if operating_system.id == os_id:\n\n        return operating_system\n\n    if error_on_unknown:\n\n      raise InvalidEnumValue(os_id, 'Operating System',\n\n                             [value.id for value in OperatingSystem._ALL])\n\n    return None\n\n\n\n  @staticmethod\n\n  def Current():\n\n    \"\"\"Determines the current operating system.\n\n\n\n    Returns:\n\n      OperatingSystemTuple, One of the OperatingSystem constants or None if it\n\n      cannot be determined.\n\n    \"\"\"\n\n    if os.name == 'nt':\n\n      return OperatingSystem.WINDOWS\n\n    elif 'linux' in sys.platform:\n\n      return OperatingSystem.LINUX\n\n    elif 'darwin' in sys.platform:\n\n      return OperatingSystem.MACOSX\n\n    elif 'cygwin' in sys.platform:\n\n      return OperatingSystem.CYGWIN\n\n    return None\n\n\n\n  @staticmethod\n\n  def IsWindows():\n\n    \"\"\"Returns True if the current operating system is Windows.\"\"\"\n\n    return OperatingSystem.Current() is OperatingSystem.WINDOWS\n\n\n\n\n\nclass Architecture(object):\n\n  \"\"\"An enum representing the system architecture you are running on.\"\"\"\n\n\n\n  class _ARCH(object):\n\n    \"\"\"A single architecture.\"\"\"\n\n\n\n    # pylint: disable=redefined-builtin\n\n    def __init__(self, id, name, file_name):\n\n      self.id = id\n\n      self.name = name\n\n      self.file_name = file_name\n\n\n\n    def __str__(self):\n\n      return self.id\n\n\n\n    def __eq__(self, other):\n\n      return (isinstance(other, type(self)) and\n\n              self.id == other.id and\n\n              self.name == other.name and\n\n              self.file_name == other.file_name)\n\n\n\n    def __hash__(self):\n\n      return hash(self.id) + hash(self.name) + hash(self.file_name)\n\n\n\n    def __ne__(self, other):\n\n      return not self == other\n\n\n\n    @classmethod\n\n    def _CmpHelper(cls, x, y):\n\n      \"\"\"Just a helper equivalent to the cmp() function in Python 2.\"\"\"\n\n      return (x > y) - (x < y)\n\n\n\n    def __lt__(self, other):\n\n      return self._CmpHelper(\n\n          (self.id, self.name, self.file_name),\n\n          (other.id, other.name, other.file_name)) < 0\n\n\n\n    def __gt__(self, other):\n\n      return self._CmpHelper(\n\n          (self.id, self.name, self.file_name),\n\n          (other.id, other.name, other.file_name)) > 0\n\n\n\n    def __le__(self, other):\n\n      return not self.__gt__(other)\n\n\n\n    def __ge__(self, other):\n\n      return not self.__lt__(other)\n\n\n\n  x86 = _ARCH('x86', 'x86', 'x86')\n\n  x86_64 = _ARCH('x86_64', 'x86_64', 'x86_64')\n\n  ppc = _ARCH('PPC', 'PPC', 'ppc')\n\n  arm = _ARCH('arm', 'arm', 'arm')\n\n  _ALL = [x86, x86_64, ppc, arm]\n\n\n\n  # Possible values for `uname -m` and what arch they map to.\n\n  # Examples of possible values: https://en.wikipedia.org/wiki/Uname\n\n  _MACHINE_TO_ARCHITECTURE = {\n\n      'amd64': x86_64, 'x86_64': x86_64, 'i686-64': x86_64,\n\n      'i386': x86, 'i686': x86, 'x86': x86,\n\n      'ia64': x86,  # Itanium is different x64 arch, treat it as the common x86.\n\n      'powerpc': ppc, 'power macintosh': ppc, 'ppc64': ppc,\n\n      'armv6': arm, 'armv6l': arm, 'arm64': arm, 'armv7': arm, 'armv7l': arm}\n\n\n\n  @staticmethod\n\n  def AllValues():\n\n    \"\"\"Gets all possible enum values.\n\n\n\n    Returns:\n\n      list, All the enum values.\n\n    \"\"\"\n\n    return list(Architecture._ALL)\n\n\n\n  @staticmethod\n\n  def FromId(architecture_id, error_on_unknown=True):\n\n    \"\"\"Gets the enum corresponding to the given architecture id.\n\n\n\n    Args:\n\n      architecture_id: str, The architecture id to parse\n\n      error_on_unknown: bool, True to raise an exception if the id is unknown,\n\n        False to just return None.\n\n\n\n    Raises:\n\n      InvalidEnumValue: If the given value cannot be parsed.\n\n\n\n    Returns:\n\n      ArchitectureTuple, One of the Architecture constants or None if the input\n\n      is None.\n\n    \"\"\"\n\n    if not architecture_id:\n\n      return None\n\n    for arch in Architecture._ALL:\n\n      if arch.id == architecture_id:\n\n        return arch\n\n    if error_on_unknown:\n\n      raise InvalidEnumValue(architecture_id, 'Architecture',\n\n                             [value.id for value in Architecture._ALL])\n\n    return None\n\n\n\n  @staticmethod\n\n  def Current():\n\n    \"\"\"Determines the current system architecture.\n\n\n\n    Returns:\n\n      ArchitectureTuple, One of the Architecture constants or None if it cannot\n\n      be determined.\n\n    \"\"\"\n\n    return Architecture._MACHINE_TO_ARCHITECTURE.get(platform.machine().lower())\n\n\n\n\n\nclass Platform(object):\n\n  \"\"\"Holds an operating system and architecture.\"\"\"\n\n\n\n  def __init__(self, operating_system, architecture):\n\n    \"\"\"Constructs a new platform.\n\n\n\n    Args:\n\n      operating_system: OperatingSystem, The OS\n\n      architecture: Architecture, The machine architecture.\n\n    \"\"\"\n\n    self.operating_system = operating_system\n\n    self.architecture = architecture\n\n\n\n  def __str__(self):\n\n    return '{}-{}'.format(self.operating_system, self.architecture)\n\n\n\n  @staticmethod\n\n  def Current(os_override=None, arch_override=None):\n\n    \"\"\"Determines the current platform you are running on.\n\n\n\n    Args:\n\n      os_override: OperatingSystem, A value to use instead of the current.\n\n      arch_override: Architecture, A value to use instead of the current.\n\n\n\n    Returns:\n\n      Platform, The platform tuple of operating system and architecture.  Either\n\n      can be None if it could not be determined.\n\n    \"\"\"\n\n    return Platform(\n\n        os_override if os_override else OperatingSystem.Current(),\n\n        arch_override if arch_override else Architecture.Current())\n\n\n\n  def UserAgentFragment(self):\n\n    \"\"\"Generates the fragment of the User-Agent that represents the OS.\n\n\n\n    Examples:\n\n      (Linux 3.2.5-gg1236)\n\n      (Windows NT 6.1.7601)\n\n      (Macintosh; PPC Mac OS X 12.4.0)\n\n      (Macintosh; Intel Mac OS X 12.4.0)\n\n\n\n    Returns:\n\n      str, The fragment of the User-Agent string.\n\n    \"\"\"\n\n    # Below, there are examples of the value of platform.uname() per platform.\n\n    # platform.release() is uname[2], platform.version() is uname[3].\n\n    if self.operating_system == OperatingSystem.LINUX:\n\n      # ('Linux', '<hostname goes here>', '3.2.5-gg1236',\n\n      # '#1 SMP Tue May 21 02:35:06 PDT 2013', 'x86_64', 'x86_64')\n\n      return '({name} {version})'.format(\n\n          name=self.operating_system.name, version=platform.release())\n\n    elif self.operating_system == OperatingSystem.WINDOWS:\n\n      # ('Windows', '<hostname goes here>', '7', '6.1.7601', 'AMD64',\n\n      # 'Intel64 Family 6 Model 45 Stepping 7, GenuineIntel')\n\n      return '({name} NT {version})'.format(\n\n          name=self.operating_system.name, version=platform.version())\n\n    elif self.operating_system == OperatingSystem.MACOSX:\n\n      # ('Darwin', '<hostname goes here>', '12.4.0',\n\n      # 'Darwin Kernel Version 12.4.0: Wed May  1 17:57:12 PDT 2013;\n\n      # root:xnu-2050.24.15~1/RELEASE_X86_64', 'x86_64', 'i386')\n\n      format_string = '(Macintosh; {name} Mac OS X {version})'\n\n      arch_string = (self.architecture.name\n\n                     if self.architecture == Architecture.ppc else 'Intel')\n\n      return format_string.format(\n\n          name=arch_string, version=platform.release())\n\n    else:\n\n      return '()'\n\n\n\n  def AsyncPopenArgs(self):\n\n    \"\"\"Returns the args for spawning an async process using Popen on this OS.\n\n\n\n    Make sure the main process does not wait for the new process. On windows\n\n    this means setting the 0x8 creation flag to detach the process.\n\n\n\n    Killing a group leader kills the whole group. Setting creation flag 0x200 on\n\n    Windows or running setsid on *nix makes sure the new process is in a new\n\n    session with the new process the group leader. This means it can't be killed\n\n    if the parent is killed.\n\n\n\n    Finally, all file descriptors (FD) need to be closed so that waiting for the\n\n    output of the main process does not inadvertently wait for the output of the\n\n    new process, which means waiting for the termination of the new process.\n\n    If the new process wants to write to a file, it can open new FDs.\n\n\n\n    Returns:\n\n      {str:}, The args for spawning an async process using Popen on this OS.\n\n    \"\"\"\n\n    args = {}\n\n    if self.operating_system == OperatingSystem.WINDOWS:\n\n      args['close_fds'] = True  # This is enough to close _all_ FDs on windows.\n\n      detached_process = 0x00000008\n\n      create_new_process_group = 0x00000200\n\n      # 0x008 | 0x200 == 0x208\n\n      args['creationflags'] = detached_process | create_new_process_group\n\n    else:\n\n      # Killing a group leader kills the whole group.\n\n      # Create a new session with the new process the group leader.\n\n      args['preexec_fn'] = os.setsid\n\n      args['close_fds'] = True  # This closes all FDs _except_ 0, 1, 2 on *nix.\n\n      args['stdin'] = subprocess.PIPE\n\n      args['stdout'] = subprocess.PIPE\n\n      args['stderr'] = subprocess.PIPE\n\n    return args\n\n\n\n\n\nclass PythonVersion(object):\n\n  \"\"\"Class to validate the Python version we are using.\n\n\n\n  The Cloud SDK officially supports Python 2.7.\n\n\n\n  However, many commands do work with Python 2.6, so we don't error out when\n\n  users are using this (we consider it sometimes \"compatible\" but not\n\n  \"supported\").\n\n  \"\"\"\n\n\n\n  # See class docstring for descriptions of what these mean\n\n  MIN_REQUIRED_PY2_VERSION = (2, 6)\n\n  MIN_SUPPORTED_PY2_VERSION = (2, 7)\n\n  MIN_SUPPORTED_PY3_VERSION = (3, 4)\n\n  ENV_VAR_MESSAGE = \"\"\"\\\n\n\n\nIf you have a compatible Python interpreter installed, you can use it by setting\n\nthe CLOUDSDK_PYTHON environment variable to point to it.\n\n\n\n\"\"\"\n\n\n\n  def __init__(self, version=None):\n\n    if version:\n\n      self.version = version\n\n    elif hasattr(sys, 'version_info'):\n\n      self.version = sys.version_info[:2]\n\n    else:\n\n      self.version = None\n\n\n\n  def SupportedVersionMessage(self, allow_py3):\n\n    if allow_py3:\n\n      return 'Please use Python version {0}.{1}.x or {2}.{3} and up.'.format(\n\n          PythonVersion.MIN_SUPPORTED_PY2_VERSION[0],\n\n          PythonVersion.MIN_SUPPORTED_PY2_VERSION[1],\n\n          PythonVersion.MIN_SUPPORTED_PY3_VERSION[0],\n\n          PythonVersion.MIN_SUPPORTED_PY3_VERSION[1])\n\n    else:\n\n      return 'Please use Python version {0}.{1}.x.'.format(\n\n          PythonVersion.MIN_SUPPORTED_PY2_VERSION[0],\n\n          PythonVersion.MIN_SUPPORTED_PY2_VERSION[1])\n\n\n\n  def IsCompatible(self, allow_py3=False, raise_exception=False):\n\n    \"\"\"Ensure that the Python version we are using is compatible.\n\n\n\n    This will print an error message if not compatible.\n\n\n\n    Compatible versions are 2.6 and 2.7 and > 3.4 if allow_py3 is True.\n\n    We don't guarantee support for 2.6 so we want to warn about it.\n\n\n\n    Args:\n\n      allow_py3: bool, True if we should allow a Python 3 interpreter to run\n\n        gcloud. If False, this returns an error for Python 3.\n\n      raise_exception: bool, True to raise an exception rather than printing\n\n        the error and exiting.\n\n\n\n    Raises:\n\n      Error: If not compatible and raise_exception is True.\n\n\n\n    Returns:\n\n      bool, True if the version is valid, False otherwise.\n\n    \"\"\"\n\n    error = None\n\n    if not self.version:\n\n      # We don't know the version, not a good sign.\n\n      error = ('ERROR: Your current version of Python is not compatible with '\n\n               'the Google Cloud SDK. {0}\\n'\n\n               .format(self.SupportedVersionMessage(allow_py3)))\n\n    else:\n\n      if self.version[0] < 3:\n\n        # Python 2 Mode\n\n        if self.version < PythonVersion.MIN_REQUIRED_PY2_VERSION:\n\n          error = ('ERROR: Python {0}.{1} is not compatible with the Google '\n\n                   'Cloud SDK. {2}\\n'\n\n                   .format(self.version[0], self.version[1],\n\n                           self.SupportedVersionMessage(allow_py3)))\n\n      else:\n\n        # Python 3 Mode\n\n        if not allow_py3:\n\n          error = ('ERROR: Python 3 and later is not compatible with the '\n\n                   'Google Cloud SDK. {0}\\n'\n\n                   .format(self.SupportedVersionMessage(allow_py3)))\n\n        elif self.version < PythonVersion.MIN_SUPPORTED_PY3_VERSION:\n\n          error = ('ERROR: Python {0}.{1} is not compatible with the Google '\n\n                   'Cloud SDK. {2}\\n'\n\n                   .format(self.version[0], self.version[1],\n\n                           self.SupportedVersionMessage(allow_py3)))\n\n\n\n    if error:\n\n      if raise_exception:\n\n        raise Error(error)\n\n      sys.stderr.write(error)\n\n      sys.stderr.write(PythonVersion.ENV_VAR_MESSAGE)\n\n      return False\n\n\n\n    # Warn that 2.6 might not work.\n\n    if (self.version >= self.MIN_REQUIRED_PY2_VERSION and\n\n        self.version < self.MIN_SUPPORTED_PY2_VERSION):\n\n      sys.stderr.write(\"\"\"\\\n\nWARNING:  Python 2.6.x is no longer officially supported by the Google Cloud SDK\n\nand may not function correctly.  {0}\n\n{1}\"\"\".format(self.SupportedVersionMessage(allow_py3),\n\n              PythonVersion.ENV_VAR_MESSAGE))\n\n\n\n    return True\n"]