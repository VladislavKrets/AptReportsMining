[" .MODEL small\n\n.STACK 100\n\n.DATA \n\n\n\n\t\tfilename db 'input.txt',0\t\n\n\t\thandle dw 0 \n\n\t\tbuffer db 255 DUP ?  \n\n.CODE \n\nMOV AX,@DATA \n\nMOV DS,AX \n\n\n\n\t\tmov ah,3Dh  \n\n\t\tmov al,0  \n\n\t\tmov dx,offset filename  ; make a pointer to the filename\n\n\t\tint 21h \n\n\t\tmov handle,ax \n\n\n\n\t\n\n\n\n\t\tmov ah,3Fh\n\n\t\tmov cx,255  \n\n\t\tmov dx,offset buffer \n\n\t\tmov bx,handle  \n\n\t\tint 21h  \n\n\n\n\n\n\n\n\t\tmov dx,offset buffer\n\n\t\tadd dx,ax  \n\n\t\t\t\n\n\t\tmov bx,dx\n\n\t\tmov byte [bx],'$'  \n\n            \n\n               mov cl,20\n\n               mov bl,1   \n\n               \n\n            \n\n                   call TL\n\n            return:  \n\n        \n\n            lea si,buffer \n\n            \n\n              \n\n\n\n           set:  \n\n            mov al,[si] \n\n\n\n            call moving1      \n\n            cmp al,'a'\n\n            jge changeLetter\n\n\n\n           inc si \n\n           dec cl\n\n           \n\n\n\n           \n\n           jnz set      \n\n        \n\n                jz endpro\n\n\n\n           changeLetter:\n\n           cmp bl,1\n\n           je changeMe \n\n            inc si \n\n             \n\n           dec cl \n\n          \n\n           jnz set\n\n             \n\n\t\t             \n\n\t\t   changeMe:\n\n\t\t \n\n\t\t \n\n\t\t   mov al,[si]\n\n\t\t   sub al,32d  \n\n\t\t   mov [si],al\n\n\t\t   mov bl,0\n\n\n\n\t\t    inc si \n\n         \n\n\t\t   jnz set      \n\n\t\t    \n\n\t\t     \n\n\t         \n\n\t\t  \n\nmoving1: \n\ncmp al,' '\n\n\n\nje incr\n\n ret\n\nincr:\n\nmov bl,1  \n\n\n\n   ret\n\n\t\t  \n\n\t\t\n\n\t\t\n\n\n\n   \n\nTL:\n\nlea si,buffer\n\n\n\nlower:\n\nmov al,[si]\n\ncmp al,60h\n\njg inc_di_lo\n\ncmp al,40h\n\njl inc_di_lo\n\nadd al,20h\n\nmov [si],al\n\ninc si\n\njmp lower\n\ninc_di_lo:\n\ninc si\n\ncmp al,'$'\n\nje return\n\njmp lower    \n\n  \n\n \n\n \n\n endpro:\n\n\n\n\t\tmov dx,offset buffer  ; put the pointer back in DX.\n\n\t\tmov ah,9\n\n\t\tint 21h    ; call DOS Function 9 (Print String).\n\n\t\tmov ah,4Ch\n\n\t\tint 21h      ; Function 4Ch (Exit Program)      \n\n   \n\n\t\tend", " .MODEL small\n\n.STACK 256\n\n.DATA \n\n\n\n\t\tfilename db 'input.txt',0\t\n\n\t\tfilenameresult db 'output.txt',0\t \n\n\t\tNLine db 13,10,'$'\n\n\t\thandle dw 0   ; will be the file handle. the number that DOS assigns to the open file.\n\n\t\tbuffer db 255 DUP ('$')   ; make a plain buffer (not a strange input one like before).  \n\n\t\t;result_text db 250 dup('$')      \n\n\t\t;result db \"output.txt\",0   \n\n\t\thandler dw ?    \n\n\t\thandler2 dw ?  \n\n\t\tlen dw 0  \n\n\t\tlen2 db 255   ; we need an input buffer this time.\n\n\t\t\n\n\t\t\n\n\t\n\n\t\tact db 0\n\n.CODE \n\nMOV AX,@DATA \n\nMOV DS,AX \n\n\n\n\t\tmov ah,3Dh   ; 3Dh of DOS Services opens a file.\n\n\t\tmov al,0   ; 0 - for reading. 1 - for writing. 2 - both\n\n\t\tmov dx,offset filename  ; make a pointer to the filename\n\n\t\tint 21h   ; call DOS\n\n\t\tmov handle,ax   ; Function 3Dh returns the file handle in AX, here we save it for later use.\n\n\n\n\t;'DOS Service Function number 3Fh reads from a file.\n\n\n\n\t\tmov ah,3Fh\n\n\t\tmov cx,27   ; I will assume ELMO.TXT has atleast 4 bytes in it. CX is how many bytes to read.\n\n\t\tmov dx,offset buffer  ; DOS Functions like DX having pointers for some reason.\n\n\t\tmov bx,handle    ; BX needs the file handle.\n\n\t\tint 21h   ; call DOS\n\n\n\n\t;Here we will put a $ after 4 bytes in the buffer and print the data read:\n\n\n\n\t\tmov dx,offset buffer\n\n\t\tadd dx,ax    ; Function 3Fh returns the actual amount of bytes read in AX (should be 4 if\n\n\t\t\t\t; nothing went wrong.\n\n\t\tmov bx,dx\n\n\t\tmov byte [bx],'$'   ; byte pointer so we don't mess with the whole word (a word is 16bits).\n\n            \n\n               mov cl,20\n\n               mov bl,1   \n\n               \t\t        \tmov dx,offset buffer    ; put the pointer back in DX.\n\n\t\tmov ah,9\n\n\t\tint 21h    ; call DOS Function 9 (Print String).  \n\n                   \tmov dx,offset NLine   ; put the pointer back in DX.\n\n\t\tmov ah,9\n\n\t\tint 21h    ; call DOS Function 9 (Print String).    \n\n               \n\n            \n\n                   call to_lower\n\n            return:  \n\n           ; call Print \n\n            lea si,buffer \n\n            \n\n   \n\n\t\t        \tmov dx,offset buffer    ; put the pointer back in DX.\n\n\t\tmov ah,9\n\n\t\tint 21h    ; call DOS Function 9 (Print String).  \n\n                   \tmov dx,offset NLine   ; put the pointer back in DX.\n\n\t\tmov ah,9\n\n\t\tint 21h    ; call DOS Function 9 (Print String).    \n\n;;;;;;;;;;;;;;;;;;;;;;;;++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n\n            label:  \n\n            mov al,[si] \n\n            ;mov dl,al\n\n            ;mov ah,2h\n\n           ; int 21h\n\n            call moving1      \n\n            cmp al,'a'\n\n            jge changeLetter\n\n         ;    cmp al,'A'\n\n        ; jge changeLetter1step\n\n           inc si \n\n           dec cl\n\n           \n\n\n\n          ; mov bl,0 \n\n           jnz label      \n\n;;;;;;;;;;;;;;;;;;;;;;;;++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++           \n\n                jz Print\n\n;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n\n           changeLetter: \n\n           \n\n           cmp bl,1\n\n           je changefirst  \n\n            inc si \n\n             \n\n           dec cl \n\n          \n\n           jnz label\n\n           ;;;;;;;;;;;;;;;;  \n\n                jz Print; dont go down     \n\n\t\t         \n\n\t\t          jnz label    \n\n\t\t   changefirst:\n\n\t\t   ;inc si  \n\n\t\t \n\n\t\t   mov al,[si]\n\n\t\t   sub al,32d  \n\n\t\t   mov [si],al\n\n\t\t   mov bl,0\n\n\n\n\t\t    inc si \n\n          ; dec cl\n\n\t\t   jnz label       \n\n\t\t     ;ret      \n\n\t\t     ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n\n\t\t   \n\n\t\t     \n\n\t         \n\n\t\t  \n\nmoving1: \n\ncmp al,' '\n\nje increment\n\ncmp al,'Z'\n\njle decrement\n\n ret\n\nincrement:\n\nmov bl,1\n\nret \n\n\n\ndecrement:\n\nmov bl,0\n\n   ret\n\n\t\t  \n\n\t\t\n\n\t\t\n\n\n\n   \n\n to_lower:\n\nlea si,buffer\n\n\n\nlower:\n\nmov al,[si]\n\ncmp al,60h\n\njg inc_di_lo\n\ncmp al,40h\n\njl inc_di_lo\n\nadd al,20h\n\nmov [si],al\n\ninc si\n\njmp lower\n\ninc_di_lo:\n\ninc si\n\ncmp al,'$'\n\nje return\n\njmp lower    \n\n  \n\n \n\n \n\n Print:\n\n\n\n\t\tmov dx,offset buffer  ; put the pointer back in DX.\n\n\t\tmov ah,9\n\n\t\tint 21h    ; call DOS Function 9 (Print String).   \n\n\t\t\n\n\t\t\n\n\t\t\n\n;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n\n        mov dx,offset filenameresult ; put offset of filename in dx \n\nmov cx,0 ; clear cx - make ordinary file \n\nmov ah,3Ch ; function 3Ch - create a file \n\nint 21h ; call DOS service \n\n;mov dx,offset  ; put offset of filename in dx \n\n\t\tmov ah,3Dh   ; 3Dh of DOS Services opens a file.\n\n\t\tmov al,1   ; 0 - for reading. 1 - for writing. 2 - both\n\n\t\tmov dx,offset filenameresult  ; make a pointer to the filename\n\n\t\tint 21h   ; call DOS\n\n\t\tmov handle,ax   ; Function 3Dh returns the file handle in AX, here we save it for later use.\n\n\n\n\t;Get input:\n\n\n\n\t;\tmov ah,0Ah\n\n\t\t;mov dx,offset buffer\n\n\t\t;int 21h\n\n\n\n;\tDOS Service Function number 40h writes to a file.\n\n\n\n\t\tmov ah,40h\n\n\t\tmov bx,255 ; pointer to number of bytes read from user.\n\n\t\tmov cl,27  ; get the contents of the byte at the pointer.\n\n\t\t; note that even though CX takes the length, CL physically IS the low byte of CX.\n\n\t\tmov dx,offset buffer  ; pointer to the actual data in DX.\n\n\t\tmov bx,handle    ; BX needs the file handle.\n\n\t\tint 21h   ; call DOS\n\n\t\t;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n\n\t\tmov ah,4Ch\n\n\t\tint 21h      ; Function 4Ch (Exit Program)      \n\n   \n\n\t\tend", ".model small\n\n.data\n\n\tstring1\tdb\t10\tdup(' '),13,10, '$'\n\n\n\n.code\n\n\n\n\tmov ax, @data\n\n\tmov ds, ax\n\n\t\n\n\tlea si, string1\n\n\t\n\n\tmov ah, 1\n\nREAD_NEXT:\n\n\tint 21h\n\n\tcmp al, 13\n\n\tje NEXT\n\n\tmov [si], al\n\n\tinc si\n\n\tjmp READ_NEXT\n\n\t\n\nNEXT:\n\n\tmov al, '$'\n\n\tmov [si], al\n\n\tdec si\n\n\t\n\n\tlea di, string1\n\n\tint 21h\n\nBEG:\n\n\n\n\tmov al, [di]\n\n\tmov bl, [si]\n\n\tmov [di], bl\n\n\tmov [si], al\n\n\tdec si\n\n\tinc di\n\n\tcmp di, si\n\n\tjl BEG\n\n\t\n\n\tmov ah,9h\n\n\tlea dx, string1\n\n\tint 21h\n\n\n\n\n\nmov ax,4c00h\n\nint 21h\n\n\tend", "\n\n        .MODEL SMALL\n\n        .DATA\n\n\n\n                MSG  DB 13,10, ' ENTER THE STRING :-----> :  $'\n\n                MSG2 DB 13,10, ' YOUR STRING IS  :-----> :  $'\n\n                STR1 DB  255 DUP('$')\n\n               ; ONE  DB ?\n\n               ; TWO  DB ?\n\n          .CODE\n\n\n\nBEGIN:\n\n          MOV AX,@DATA\n\n          MOV DS,AX\n\n\n\n          LEA DX,MSG\n\n          MOV AH,09H\n\n          INT 21H\n\n\n\n          LEA SI,STR1\n\n          MOV AH,01H\n\n\n\nREAD proc\n\n          INT 21H\n\n          MOV [SI],AL\n\n          INC SI\n\n          CMP AL,13;;;;;;;;;;;cariage return = 0dh\n\n        ;  JNE READ\n\n        call READ\n\n        ret\n\n      READ  endp\n\n\n\n;DISPLAY:\n\n\n\n;          MOV AL,'$'\n\n;          MOV [SI],AL\n\n\n\n          LEA DX,MSG2\n\n          MOV AH,09H\n\n          INT 21H\n\n\n\n          LEA DX,STR1\n\n          MOV AH,09H\n\n          INT 21H\n\n\n\n\n\n\n\n;          MOV AH,4CH\n\n;          INT 21h\n\n\n\n        .EXIT  \n\nEND BEGIN \n\n\n\n;*************************************OUTPUT***************************\n\n\n\n;ENTER THE STRING :-----> : SAMIR B PATEL\n\n\n\n;YOUR STRING IS  :-----> : SAMIR B PATEL", " .MODEL small\n\n.STACK 256\n\n.DATA \n\n\n\n\t\tfilename db 'elmo.txt',0\t\n\n\t\thandle dw 0   ; will be the file handle. the number that DOS assigns to the open file.\n\n\t\tbuffer db 255 DUP ?  ; make a plain buffer (not a strange input one like before).\n\n.CODE \n\nMOV AX,@DATA \n\nMOV DS,AX \n\n\n\n\t\tmov ah,3Dh   ; 3Dh of DOS Services opens a file.\n\n\t\tmov al,0   ; 0 - for reading. 1 - for writing. 2 - both\n\n\t\tmov dx,offset filename  ; make a pointer to the filename\n\n\t\tint 21h   ; call DOS\n\n\t\tmov handle,ax   ; Function 3Dh returns the file handle in AX, here we save it for later use.\n\n\n\n\t;'DOS Service Function number 3Fh reads from a file.\n\n\n\n\t\tmov ah,3Fh\n\n\t\tmov cx,255   ; I will assume ELMO.TXT has atleast 4 bytes in it. CX is how many bytes to read.\n\n\t\tmov dx,offset buffer  ; DOS Functions like DX having pointers for some reason.\n\n\t\tmov bx,handle    ; BX needs the file handle.\n\n\t\tint 21h   ; call DOS\n\n\n\n\t;Here we will put a $ after 4 bytes in the buffer and print the data read:\n\n\n\n\t\tmov dx,offset buffer\n\n\t\tadd dx,ax    ; Function 3Fh returns the actual amount of bytes read in AX (should be 4 if\n\n\t\t\t\t; nothing went wrong.\n\n\t\tmov bx,dx\n\n\t\tmov byte [bx],'$'   ; byte pointer so we don't mess with the whole word (a word is 16bits).\n\n            \n\n               mov cl,20\n\n               mov bl,1\n\n            lea si,buffer\n\n            label:  \n\n            mov al,[si] \n\n            mov dl,al\n\n            mov ah,2h\n\n            int 21h\n\n            call moving1      \n\n            cmp al,'a'\n\n            jge changeLetter\n\n           \n\n           inc si \n\n           dec cl\n\n           \n\n           \n\n           jnz label\n\n                jz Print\n\n           ;;;;;;;;;;;;;;;;;\n\n           changeLetter:\n\n           cmp bl,1\n\n           je changefirst  \n\n            inc si \n\n           dec cl\n\n           jnz label\n\n           ;;;;;;;;;;;;;;;;       \n\n\t\t             \n\n\t\t   changefirst:\n\n\t\t   inc si  \n\n\t\t \n\n\t\t   mov al,[si]\n\n\t\t   sub al,32d  \n\n\t\t   mov [si],al\n\n\t\t   mov bl,0\n\n\t\t   \n\n\t\t   dec si \n\n\t\t    inc si \n\n           dec cl\n\n\t\t   jnz label       \n\n\t\t     ;ret                \n\n\t\t     \n\n\tPrint:\n\n\n\n\t\tmov dx,offset buffer  ; put the pointer back in DX.\n\n\t\tmov ah,9\n\n\t\tint 21h    ; call DOS Function 9 (Print String).\n\n\t\tmov ah,4Ch\n\n\t\tint 21h      ; Function 4Ch (Exit Program)               \n\n\t\t  \n\nmoving1: \n\ncmp al,' '\n\n\n\nje increment\n\n ret\n\nincrement:\n\nmov bl,1  \n\n\n\n   ret\n\n\t\tend", ".model small\n\n.stack 100\n\n.data\n\n   my_arr db 4, 2, 8, 9, 1, 7, 3, 0, 4, 6\n\n    arr_idx db 1 0\n\n    size db 10\n\n   ; ----------------------------\n\n   ; | bubble_sort\n\n   ; |     sort an array whose pointer pointed by arr_idx\n\n   ; | modifies:\n\n   ; |     none\n\n   ; | algorithm outline:  (when size = 10)\n\n   ; |     for i = 0 to 8\n\n   ; |        for j = i+1 to 9\n\n   ; |            if arr_idx[i]>arr_idx[j] then swap(arr_idx[i], arr_idx[j]);\n\n   ; |\n\n   ; |  i is mapped to SI\n\n   ; |  j is mapped to DI\n\n   ; |  bx hold the base array index\n\n   ; |  ah, al is to aid processing\n\n   ; |  cx is to hold the size\n\n   ; ----------------------------    \n\n   .code\n\n   mov ax,@data\n\n   mov ds,ax\n\n         \n\n         \n\n         \n\n \n\n\n\n   mov  dx, offset my_arr   \n\n   ;mov ah,9h\n\n  ; int 21h\n\n   call bubble_sort    \n\n   \n\n ;  mov dx,offset my_arr   \n\n   \n\n\n\n   ; After this call, the array my_arr is sorted\n\n\n\n   mov  ax, 4c00h\n\n   int  21h      \n\n         \n\n   proc bubble_sort\n\n        pusha     ; save all registers\n\n        mov bx,0\n\n        mov   cx, 10\n\n        dec   cx          ; because maximum index bound is always one less than\n\n                          ; the size (i.e. when size is 10, the index is 0..9, not 1..10)\n\n        sub   si, si\n\n        sub   di, di\n\n\n\n   @@loop_i:\n\n    \n\n        mov   di, si\n\n        inc   di           ; j = i + 1  \n\n               \n\n        call printout      \n\n       \n\n        @@loop_j:\n\n             mov   ah, [bx+si]  ; AH = arr_idx[i]\n\n             mov   al, [bx+di]  ; AL = arr_idx[j]\n\n\n\n             cmp   ah, al       ; if (arr_idx[i] <= arr_idx[j]) then no swap\n\n             jle no_swap\n\n\n\n             mov   [bx+si], al  ; else swap\n\n             mov   [bx+di], ah   \n\n\n\n\n\n       no_swap: \n\n\n\n             inc   di        ; (increase j)\n\n             cmp   di, cx    ; (compare with bound)\n\n             jbe   @@loop_j  ; if below or equal, then go to @@loop_j\n\n\n\n        ; end of loop j\n\n\n\n        inc  si        ; increment i\n\n        cmp  si, cx    ; compare with bound  \n\n             \n\n        jb   @@loop_i  ; if below, then loop to @@loop_i\n\n\n\n\n\n        popa      ; restore all registers\n\n        ret\n\n   endp\n\n  \n\n  proc printout\n\n mov al,[si-1]\n\n                     add al,030h  \n\n             mov dl,al\n\n            ; sub al,48\n\nMov Ah,2\n\nINT 21h \n\nret\n\nendp\n\n   \n\nend", "mY nAme is bRo", " .MODEL small\n\n.STACK 256\n\n.DATA \n\n\n\n\t\tfilename db 'input.txt',0\t\n\n\t\tfilenameresult db 'output.txt',0\t \n\n\t\tNLine db 13,10,'$'\n\n\t\thandle dw 0   ; will be the file handle. the number that DOS assigns to the open file.\n\n\t\tbuffer db 255 DUP (' ')   ; make a plain buffer (not a strange input one like before).  \n\n\t\t;result_text db 250 dup('$')      \n\n\t\t;result db \"output.txt\",0   \n\n\t\thandler dw ?    \n\n\t\thandler2 dw ?  \n\n\t\tlen dw 0  \n\n\t\tlen2 db 255   ; we need an input buffer this time.\n\n\t\t\n\n\t\t\n\n\t\n\n\t\tact db 0\n\n.CODE \n\nMOV AX,@DATA \n\nMOV DS,AX \n\n\n\n\t\tmov ah,3Dh   ; 3Dh of DOS Services opens a file.\n\n\t\tmov al,0   ; 0 - for reading. 1 - for writing. 2 - both\n\n\t\tmov dx,offset filename  ; make a pointer to the filename\n\n\t\tint 21h   ; call DOS\n\n\t\tmov handle,ax   ; Function 3Dh returns the file handle in AX, here we save it for later use.\n\n\n\n\t;'DOS Service Function number 3Fh reads from a file.\n\n\n\n\t\tmov ah,3Fh\n\n\t\tmov cx,27   ; I will assume ELMO.TXT has atleast 4 bytes in it. CX is how many bytes to read.\n\n\t\tmov dx,offset buffer  ; DOS Functions like DX having pointers for some reason.\n\n\t\tmov bx,handle    ; BX needs the file handle.\n\n\t\tint 21h   ; call DOS\n\n\n\n\t;Here we will put a $ after 4 bytes in the buffer and print the data read:\n\n\n\n\t\tmov dx,offset buffer\n\n\t\tadd dx,ax    ; Function 3Fh returns the actual amount of bytes read in AX (should be 4 if\n\n\t\t\t\t; nothing went wrong.\n\n\t\tmov bx,dx\n\n\t\tmov byte [bx],'$'   ; byte pointer so we don't mess with the whole word (a word is 16bits).\n\n            \n\n               mov cl,20\n\n               mov bl,1   \n\n               \t\t        \tmov dx,offset buffer    ; put the pointer back in DX.\n\n\t\tmov ah,9\n\n\t\tint 21h    ; call DOS Function 9 (Print String).  \n\n                   \tmov dx,offset NLine   ; put the pointer back in DX.\n\n\t\tmov ah,9\n\n\t\tint 21h    ; call DOS Function 9 (Print String).    \n\n               \n\n            \n\n                   call to_lower\n\n            return:  \n\n           ; call Print \n\n            lea si,buffer \n\n            \n\n   \n\n\t\t        \tmov dx,offset buffer    ; put the pointer back in DX.\n\n\t\tmov ah,9\n\n\t\tint 21h    ; call DOS Function 9 (Print String).  \n\n                   \tmov dx,offset NLine   ; put the pointer back in DX.\n\n\t\tmov ah,9\n\n\t\tint 21h    ; call DOS Function 9 (Print String).    \n\n;;;;;;;;;;;;;;;;;;;;;;;;++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n\n            label:  \n\n            mov al,[si] \n\n            ;mov dl,al\n\n            ;mov ah,2h\n\n           ; int 21h\n\n            call moving1      \n\n            cmp al,'a'\n\n            jge changeLetter\n\n         ;    cmp al,'A'\n\n        ; jge changeLetter1step\n\n           inc si \n\n           dec cl\n\n           \n\n\n\n          ; mov bl,0 \n\n           jnz label      \n\n;;;;;;;;;;;;;;;;;;;;;;;;++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++           \n\n                jz Print\n\n;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n\n           changeLetter: \n\n           \n\n           cmp bl,1\n\n           je changefirst  \n\n            inc si \n\n             \n\n           dec cl \n\n          \n\n           jnz label\n\n           ;;;;;;;;;;;;;;;;  \n\n                jz Print; dont go down     \n\n\t\t         \n\n\t\t          jnz label    \n\n\t\t   changefirst:\n\n\t\t   ;inc si  \n\n\t\t \n\n\t\t   mov al,[si]\n\n\t\t   sub al,32d  \n\n\t\t   mov [si],al\n\n\t\t   mov bl,0\n\n\n\n\t\t    inc si \n\n          ; dec cl\n\n\t\t   jnz label       \n\n\t\t     ;ret      \n\n\t\t     ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n\n\t\t   \n\n\t\t     \n\n\t         \n\n\t\t  \n\nmoving1: \n\ncmp al,' '\n\nje increment\n\ncmp al,'Z'\n\njle decrement\n\n ret\n\nincrement:\n\nmov bl,1\n\nret \n\n\n\ndecrement:\n\nmov bl,0\n\n   ret\n\n\t\t  \n\n\t\t\n\n\t\t\n\n\n\n   \n\n to_lower:\n\nlea si,buffer\n\n\n\nlower:\n\nmov al,[si]\n\ncmp al,60h\n\njg inc_di_lo\n\ncmp al,40h\n\njl inc_di_lo\n\nadd al,20h\n\nmov [si],al\n\ninc si\n\njmp lower\n\ninc_di_lo:\n\ninc si\n\ncmp al,'$'\n\nje return\n\njmp lower    \n\n  \n\n \n\n \n\n Print:\n\n\n\n\t\tmov dx,offset buffer  ; put the pointer back in DX.\n\n\t\tmov ah,9\n\n\t\tint 21h    ; call DOS Function 9 (Print String).   \n\n\t\t\n\n\t\t\n\n\t\t\n\n;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n\n        mov dx,offset filenameresult ; put offset of filename in dx \n\nmov cx,0 ; clear cx - make ordinary file \n\nmov ah,3Ch ; function 3Ch - create a file \n\nint 21h ; call DOS service \n\n;mov dx,offset  ; put offset of filename in dx \n\n\t\tmov ah,3Dh   ; 3Dh of DOS Services opens a file.\n\n\t\tmov al,1   ; 0 - for reading. 1 - for writing. 2 - both\n\n\t\tmov dx,offset filenameresult  ; make a pointer to the filename\n\n\t\tint 21h   ; call DOS\n\n\t\tmov handle,ax   ; Function 3Dh returns the file handle in AX, here we save it for later use.\n\n\n\n\t;Get input:\n\n\n\n\t;\tmov ah,0Ah\n\n\t\t;mov dx,offset buffer\n\n\t\t;int 21h\n\n\n\n;\tDOS Service Function number 40h writes to a file.\n\n\n\n\t\tmov ah,40h\n\n\t\tmov bx,255 ; pointer to number of bytes read from user.\n\n\t\tmov cl,27  ; get the contents of the byte at the pointer.\n\n\t\t; note that even though CX takes the length, CL physically IS the low byte of CX.\n\n\t\tmov dx,offset buffer  ; pointer to the actual data in DX.\n\n\t\tmov bx,handle    ; BX needs the file handle.\n\n\t\tint 21h   ; call DOS\n\n\t\t;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n\n\t\tmov ah,4Ch\n\n\t\tint 21h      ; Function 4Ch (Exit Program)      \n\n   \n\n\t\tend", "; calc.asm: Read and sum two numbers. Display result.\n\n; Author: Joe Carthy\n\n; Date: March 1994\n\n\n\n\t\t.model small\n\n\t\t.stack 256\n\n\n\nCR equ 13d\n\nLF equ 10d\n\n\n\n\t\t.data\n\nprompt1 db 'Enter first number: $'\n\nprompt2 db CR, LF,'Enter second number: $'\n\nresult db CR, LF, 'The sum is $'\n\nnum1 dw ?\n\nnum2 dw ? \n\n\n\n\t\t.code\n\nstart:\n\n\t\tmov ax, @data\n\n\t\tmov ds, ax\n\n\n\n\t\tmov ax, offset prompt1\n\n\t\tcall puts ; display prompt1\n\n\n\n\t\tcall getn ; read first number\n\n\t\tmov num1, ax\n\n\t\tmov ax, offset prompt2\n\n\t\tcall puts ; display prompt2\n\n\n\n\t\tcall getn ; read second number\n\n\n\n\t\tmov num2, ax\n\n\t\tmov ax, offset result\n\n\t\tcall puts ; display result message\n\n\n\n\t\tmov ax, num1 ; ax = num1\n\n\t\tadd ax, num2 ; ax = ax + num2\n\n\t\tcall putn ; display sum\n\n\n\n\t\tmov ax, 4c00h\n\n\t\tint 21h ; finished, back to dos\n\n\n\ngetn:\t\t\t; read a number from the keyboard\n\n\t\t\t; return value in ax register\n\n;\t\t\t\t\t\t\t\t\t\tC variables\n\n\t\t\t; dx records sign of number\t\t\tsign variable\n\n\t\t\t; bl stores each digit\t\t\t\tdigit variable\n\n\t\t\t; cx stores the number read in so far\tn variable\n\n\t\t\t; al stores each character read in.\t\tc variable\n\n\t\t\t; ax is also used in the mul instruction\n\n\n\n\n\n\t\tpush bx \t\t; save registers on stack\n\n\t\tpush cx\n\n\t\tpush dx\n\n\n\n\t\tmov dx, 1\t\t; record sign, 1 for positive\n\n\t\tmov bx, 0\t\t; initialise digit to 0\n\n\t\tmov cx, 0\t\t; initialise number to 0\n\n\n\n\t\tcall getc\t\t; read first character\n\n\t\tcmp al, '-'\t\t; is it negative\n\n\t\tjne newline \t; if not goto newline\n\n\t\tmov dx, -1\t\t; else record sign \n\n\t\n\n\t\tcall getc\t\t; get next digit\n\nnewline:\n\n\t\tpush dx\t\t; save sign on stack\n\n\t\tcmp al, 13\t\t; (al == CR) ?\n\n\t\tje  fin_read\t; if yes, goto fin_read\n\n\t\t\t\t\t; otherwise\n\n\t\tsub al, '0' \t; convert to digit\n\n\t\tmov cl, al \t\t; cl = first digit \n\n\t\tcall getc \t\t; get next character\n\n\n\nread_loop:\n\n\t\tcmp al, 13  \t; if (al == CR) \n\n\t\tje fin_read \t; then goto fin_read\n\n\n\n\t\t sub al, '0' \t; otherwise, convert to digit\n\n\t\t mov bl, al\t\t; bl = digit\n\n\t\t mov ax, 10\t\t; ax = 10\n\n\t\t mul cx\t\t; ax = cx * 10   \n\n\t\t mov cx, ax\t\t; cx = ax  n = n * 10\n\n\t\t add cx, bx\t\t; cx = cx + digit  n = n + digit\n\n\t\t call getc\t\t; read next digit\n\n\t\tjmp read_loop\n\n\n\nfin_read:\n\n\t\tmov ax, cx\t\t; number returned in ax\n\n\t\tpop dx\t\t; retrieve sign from stack\n\n\t\tcmp dx, 1\t\t; ax = ax * dx\n\n\t\tje  fin_getn\n\n\t\tneg ax\t\t; ax = -ax\n\nfin_getn:\n\n\t\tpop dx\n\n\t\tpop cx\n\n\t\tpop bx\n\n\t\tret\n\n\n\nputs: \t\t; display a string terminated by $\n\n\t\t\t; dx contains address of string\n\n\n\n\t\tpush ax ; save ax\n\n\t\tpush bx ; save bx \n\n\t\tpush cx ; save cx\n\n\t\tpush dx ; save dx\n\n\n\n\t\tmov dx, ax\n\n\t\tmov ah, 9h\n\n\t\tint 21h ; call ms-dos to output string\n\n\n\n\t\tpop dx ; restore dx\n\n\t\tpop cx ; restore cx\n\n\t\tpop bx ; restore bx\n\n\t\tpop ax ; restore ax\n\n\n\n\t\tret\n\n\n\nputn:\t\t\t\t; display number in ax\n\n\t\t\t\t; ax contains number (and also div C in above)\n\n\t\t\t\t; dx contains remainder (rem in C above)\n\n\t\t\t\t; cx contains 10 for division\n\n\tpush\tbx\n\n\tpush\tcx\n\n\tpush\tdx\n\n\n\n\tmov \tdx, 0\t\t\t; dx = 0\n\n\tpush\tdx\t\t\t; push 0 as sentinel\n\n\tmov \tcx, 10\t\t; cx = 10\n\n\n\n\tcmp \tax, 0\n\n\tjge \tcalc_digits\t\t; number is negative\n\n\tneg \tax\t\t\t; ax = -ax; ax is now positive\n\n\tpush \tax\t\t\t; save ax\n\n\tmov\tal, '-'\t\t; display - sign\n\n\tcall\tputc\n\n\tpop\tax\t\t\t; restore ax\n\n\n\ncalc_digits:\n\n\tdiv\tcx\t\t\t; dx:ax = ax / cx\n\n\t\t\t\t\t; ax = result, dx = remainder\n\n\tadd\tdx, '0'\t\t; convert dx to digit\n\n\tpush \tdx\t\t\t; save digit on stack\n\n\tmov\tdx, 0 \t\t; dx = 0\n\n\tcmp\tax, 0\t\t\t; finished ?\n\n\tjne\tcalc_digits\t\t; no, repeat process\n\n\n\n; \tall digits now on stack, display them in reverse\n\n\n\ndisp_loop:\n\n\tpop\tdx\t\t\t; get last digit from stack\n\n\tcmp\tdx, 0\t\t\t; is it sentinel\n\n\tje\tend_disp_loop \t; if yes, we are finished \n\n\tmov\tal, dl\t\t; al = dl\n\n\tcall\tputc\t\t\t; otherwise display digit\n\n\tjmp\tdisp_loop\n\n\n\nend_disp_loop:\n\n\tpop dx\t\t\t; restore registers\n\n\tpop cx\n\n\tpop bx\n\n\tret\n\n\n\nputc: ; display character in al\n\n\n\n\t\tpush ax ; save ax\n\n\t\tpush bx ; save bx \n\n\t\tpush cx ; save cx\n\n\t\tpush dx ; save dx\n\n\n\n\t\tmov dl, al\n\n\t\tmov ah, 2h\n\n\t\tint 21h\n\n\n\n\t\tpop dx ; restore dx\n\n\t\tpop cx ; restore cx\n\n\t\tpop bx ; restore bx\n\n\t\tpop ax ; restore ax\n\n\t\tret\n\n\n\n\n\ngetc: \t; read character into al\n\n\n\n\t\tpush bx ; save bx \n\n\t\tpush cx ; save cx\n\n\t\tpush dx ; save dx\n\n\n\n\t\tmov ah, 1h\n\n\t\tint 21h\n\n\n\n\t\tpop dx ; restore dx\n\n\t\tpop cx ; restore cx\n\n\t\tpop bx ; restore bx\n\n\t\tret\n\n\n\n\t\tend start\n", ".model small\n\n.stack 100h\n\n.data\n\noriginal db \"elmo.txt\",0\n\nresult db \"result.txt\",0\n\nhandler dw ?\n\noriginal_text db 250 dup('$') \n\nresult_text db 250 dup('$')\n\nlowerMSG db 0dh,0ah,'PROGRAM FOR CONVERT UPPER & LOWER CASE ..$'\n\n    upperMSG db 0dh,0ah,'Do you want to LOWER(1) or UPPER(2) CASE ? : $'\n\n;lowerMSG db 10,13,' to convert the text into lower case',10,13,'$'\n\n;upperMSG db 10,13,'2: to convert the text into upper case',10,13,'$'\n\ninMSG db 10,13,'Converting data from original.text file',10,13,'$'\n\nsuccessMSG db 10,13,'Converting done succesfully',10,13,'You can see the results in \"result.txt\" file$'\n\nlen dw 0\n\n.code \n\n \n\n \n\nmov ax,@data \n\nmov ds,ax \n\n \n\nmov ah,3dh ; read a file \n\nmov al,02 \n\nlea dx,original ; the address of file name should be in dx \n\nint 21h \n\nmov handler,ax    ;file handle is returned in ax \n\n \n\nmov si,0 \n\nmov bx,handler\n\nstart:\n\nmov ah,3fh         ; the file handle \n\nmov cx,1         ; number of bytes to be read \n\nlea dx,original_text+si     ; the address of data to be read \n\nint 21h \n\ncmp ax,0 \n\nje print_option\n\ninc si \n\njmp start \n\n \n\n \n\nprint_option:\n\nmov len,si\n\nmov ah,09h\n\nlea dx,inMSG\n\nint 21h\n\n \n\nlea dx,lowerMSG\n\nint 21h\n\n \n\nlea dx,upperMSG\n\nint 21h\n\n \n\noption:\n\nmov ah,1\n\nint 21h \n\nmov bl,al\n\nmov ah,2\n\nmov dl,10\n\nint 21h\n\n \n\ncmp bl,'1'\n\nje to_lower\n\ncmp bl,'2'\n\nje to_upper\n\njmp option\n\n \n\n \n\nto_lower:\n\nlea dx,result_text\n\nmov di,0\n\nmov si,0\n\nlea bx,original_text\n\nmov ah,2\n\nlower:\n\nmov dl,[bx+di]\n\ncmp dl,'$'\n\nje write_to_file\n\ncmp dl,60h\n\njg inc_di_lo\n\ncmp dl,40h\n\njl inc_di_lo\n\nadd dl,20h\n\nmov [result_text+si],dl\n\ninc di\n\ninc si\n\njmp lower\n\ninc_di_lo:\n\nmov [result_text+si],dl\n\ninc di\n\ninc si\n\nmov dl,[bx+di]\n\ncmp dl,'$'\n\nje write_to_file\n\njmp lower  \n\n \n\n \n\nto_upper:\n\nlea dx,result_text\n\nmov di,0\n\nmov si,0\n\nlea bx,original_text\n\nupper:\n\nmov dl,[bx+di]\n\ncmp dl,60h\n\njg inc_di_up\n\nmov [result_text+si],dl\n\ninc di\n\ninc si\n\nmov al,'$'\n\ncmp al,[bx+di]\n\njne upper\n\njmp write_to_file\n\ninc_di_up:\n\nsub dl,20h\n\nmov [result_text+si],dl\n\ninc di\n\ninc si\n\nmov al,'$'\n\ncmp al,[bx+di]\n\njne upper\n\njmp write_to_file \n\n \n\nwrite_to_file:\n\nmov ah,3ch ; create a file\n\nmov cx,0 ; normal attributes\n\nlea dx,result ; the address of file name should be in dx\n\nint 21h\n\nmov handler,ax ;file handle is returned in ax , store it we need it later\n\nmov ah,40h ; write to file\n\nmov bx,handler ; the file handle\n\nmov cx,len ; number of bytes to be written\n\n \n\nlea dx,result_text ; the address of data to be written should be in dx\n\nint 21h\n\n \n\nmov ah,3eh\n\nint 21h\n\n \n\nexit:\n\nmov ah,09h\n\nlea dx,successMSG\n\nint 21h\n\nmov ah,4ch\n\nint 21h\n\nend", "# Program 4.4\n\n# Array - GAS, Clang/LLVM on Linux (32-bit)\n\n# Copyright (c) 2017 Hall & Slonka\n\n\n\n.data\n\narray: .long 1, 2, 3, 4\n\n\n\n.text\n\n.globl _main\n\n_main:\n\n\n\n# Load using byte offsets\n\nleal array, %esi\n\nmovl (%esi), %eax\n\nmovl 4(%esi), %ebx\n\n\n\n# Save using indices\n\nmovl $2, %edx\n\nmovl $10, (%esi, %edx, 4)\n\nmovl $3, %edx\n\nmovl $20, (%esi, %edx, 4)\n\n\n\nmovl $1, %eax\n\nmovl $0, %ebx\n\nint $0x80\n\n.end\n", "# Program 4.4\n\n# Array - GAS, Clang/LLVM on macOS (32-bit)\n\n# Copyright (c) 2017 Hall & Slonka\n\n\n\n.data\n\narray: .long 1, 2, 3, 4\n\n\n\n.text\n\n.globl _main\n\n_main:\n\n\n\n# Load using byte offsets\n\nleal array, %esi\n\nmovl (%esi), %eax\n\nmovl 4(%esi), %ebx\n\n\n\n# Save using indices\n\nmovl $2, %edx\n\nmovl $10, (%esi, %edx, 4)\n\nmovl $3, %edx\n\nmovl $20, (%esi, %edx, 4)\n\n\n\npushl $0\n\nsubl $4, %esp\n\nmovl $1, %eax\n\nint $0x80\n\n.end\n", "# Program 4.4\n\n# Array - GAS, Clang/LLVM on Linux (64-bit)\n\n# Copyright (c) 2019 Hall & Slonka\n\n\n\n.data\n\narray: .long 1, 2, 3, 4\n\n\n\n.text\n\n.global _main\n\n_main:\n\n\n\n# Load using byte offsets\n\nleaq array(%rip), %rsi\n\nmovl (%rsi), %eax\n\nmovl 4(%rsi), %ebx\n\n\n\n# Save using indices\n\nmovq $2, %rdx\n\nmovl $10, (%rsi, %rdx, 4)\n\nmovq $3, %rdx\n\nmovl $20, (%rsi, %rdx, 4)\n\n\n\nmovq $60, %rax\n\nxorq %rdi, %rdi\n\nsyscall\n\n.end\n", "# Program 4.4\n\n# Array - GAS, Clang/LLVM on macOS (64-bit)\n\n# Copyright (c) 2019 Hall & Slonka\n\n\n\n.data\n\narray: .long 1, 2, 3, 4\n\n\n\n.text\n\n.global _main\n\n_main:\n\n\n\n# Load using byte offsets\n\nleaq array(%rip), %rsi\n\nmovl (%rsi), %eax\n\nmovl 4(%rsi), %ebx\n\n\n\n# Save using indices\n\nmovq $2, %rdx\n\nmovl $10, (%rsi, %rdx, 4)\n\nmovq $3, %rdx\n\nmovl $20, (%rsi, %rdx, 4)\n\n\n\nmovq $0x2000001, %rax\n\nxorq %rdi, %rdi\n\nsyscall\n\n.end\n", "# Program 4.4\n\n# Array - GAS, Clang/LLVM on Linux (64-bit)\n\n# Copyright (c) 2020 Hall & Slonka\n\n\n\n.data\n\narray: .quad 1, 2, 3, 4\n\n\n\n.text\n\n.global _main\n\n_main:\n\n\n\n# Load using byte offsets\n\nleaq array(%rip), %rsi\n\nmovq (%rsi), %rax\n\nmovq 8(%rsi), %rbx\n\n\n\n# Save using indices\n\nmovq $2, %rdx\n\nmovq $10, (%rsi, %rdx, 8)\n\nmovq $3, %rdx\n\nmovq $20, (%rsi, %rdx, 8)\n\n\n\nmovq $60, %rax\n\nxorq %rdi, %rdi\n\nsyscall\n\n.end\n", "# Program 4.4\n\n# Array - GAS, Clang/LLVM on macOS (64-bit)\n\n# Copyright (c) 2020 Hall & Slonka\n\n\n\n.data\n\narray: .quad 1, 2, 3, 4\n\n\n\n.text\n\n.global _main\n\n_main:\n\n\n\n# Load using byte offsets\n\nleaq array(%rip), %rsi\n\nmovq (%rsi), %rax\n\nmovq 8(%rsi), %rbx\n\n\n\n# Save using indices\n\nmovq $2, %rdx\n\nmovq $10, (%rsi, %rdx, 8)\n\nmovq $3, %rdx\n\nmovq $20, (%rsi, %rdx, 8)\n\n\n\nmovq $0x2000001, %rax\n\nxorq %rdi, %rdi\n\nsyscall\n\n.end\n", "# Program 4.2\n\n# Multiplication and Division - GAS, Clang/LLVM on Linux (32-bit)\n\n# Copyright (c) 2017 Hall & Slonka\n\n\n\n.data\n\nmval: .long 664751\n\ndval: .long 8\n\n\n\n.text\n\n.globl _main\n\n_main:\n\n\n\n# MUL 1-op\n\nmovl mval, %eax\n\nmovl $8, %ebx\n\nmull %ebx\n\n\n\n# IMUL 1-op\n\nmovl mval, %eax\n\nmovl $8, %ebx\n\nimull %ebx\n\n\n\n# IMUL 2-op\n\nmovl $8, %eax\n\nimull mval, %eax\n\n\n\n# IMUL 3-op\n\nimull $8, mval, %eax\n\n\n\n# DIV 1-op\n\nmovl $0, %edx\n\nmovl $5318008, %eax\n\nmovl dval, %ecx\n\ndivl %ecx\n\n\n\n# IDIV 1-op\n\nmovl $0, %edx\n\nmovl $5318008, %eax\n\nmovl dval, %ecx\n\nidivl %ecx\n\n\n\nmovl $1, %eax\n\nmovl $0, %ebx\n\nint $0x80\n\n.end\n", "# Program 4.2\n\n# Multiplication and Division - GAS, Clang/LLVM on macOS (32-bit)\n\n# Copyright (c) 2017 Hall & Slonka\n\n\n\n.data\n\nmval: .long 664751\n\ndval: .long 8\n\n\n\n.text\n\n.globl _main\n\n_main:\n\n\n\n# MUL 1-op\n\nmovl mval, %eax\n\nmovl $8, %ebx\n\nmull %ebx\n\n\n\n# IMUL 1-op\n\nmovl mval, %eax\n\nmovl $8, %ebx\n\nimull %ebx\n\n\n\n# IMUL 2-op\n\nmovl $8, %eax\n\nimull mval, %eax\n\n\n\n# IMUL 3-op\n\nimull $8, mval, %eax\n\n\n\n# DIV 1-op\n\nmovl $0, %edx\n\nmovl $5318008, %eax\n\nmovl dval, %ecx\n\ndivl %ecx\n\n\n\n# IDIV 1-op\n\nmovl $0, %edx\n\nmovl $5318008, %eax\n\nmovl dval, %ecx\n\nidivl %ecx\n\n\n\npushl $0\n\nsubl $4, %esp\n\nmovl $1, %eax\n\nint $0x80\n\n.end\n", "# Program 4.2\n\n# Multiplication and Division - GAS, Clang/LLVM on Linux (64-bit)\n\n# Copyright (c) 2019 Hall & Slonka\n\n\n\n.data\n\nmval: .long 664751\n\ndval: .long 8\n\n\n\n.text\n\n.global _main\n\n_main:\n\n\n\n# MUL 1-op\n\nmovl mval(%rip), %eax\n\nmovl $8, %ebx\n\nmull %ebx\n\n\n\n# IMUL 1-op\n\nmovl mval(%rip), %eax\n\nmovl $8, %ebx\n\nimull %ebx\n\n\n\n# IMUL 2-op\n\nmovl $8, %eax\n\nimull mval(%rip), %eax\n\n\n\n# IMUL 3-op\n\nimull $8, mval(%rip), %eax\n\n\n\n# DIV 1-op\n\nmovl $0, %edx\n\nmovl $5318008, %eax\n\nmovl dval(%rip), %ecx\n\ndivl %ecx\n\n\n\n# IDIV 1-op\n\nmovl $0, %edx\n\nmovl $5318008, %eax\n\nmovl dval(%rip), %ecx\n\nidivl %ecx\n\n\n\nmovq $60, %rax\n\nxorq %rdi, %rdi\n\nsyscall\n\n.end\n", "# Program 4.2\n\n# Multiplication and Division - GAS, Clang/LLVM on macOS (64-bit)\n\n# Copyright (c) 2019 Hall & Slonka\n\n\n\n.data\n\nmval: .long 664751\n\ndval: .long 8\n\n\n\n.text\n\n.global _main\n\n_main:\n\n\n\n# MUL 1-op\n\nmovl mval(%rip), %eax\n\nmovl $8, %ebx\n\nmull %ebx\n\n\n\n# IMUL 1-op\n\nmovl mval(%rip), %eax\n\nmovl $8, %ebx\n\nimull %ebx\n\n\n\n# IMUL 2-op\n\nmovl $8, %eax\n\nimull mval(%rip), %eax\n\n\n\n# IMUL 3-op\n\nimull $8, mval(%rip), %eax\n\n\n\n# DIV 1-op\n\nmovl $0, %edx\n\nmovl $5318008, %eax\n\nmovl dval(%rip), %ecx\n\ndivl %ecx\n\n\n\n# IDIV 1-op\n\nmovl $0, %edx\n\nmovl $5318008, %eax\n\nmovl dval(%rip), %ecx\n\nidivl %ecx\n\n\n\nmovq $0x2000001, %rax\n\nxorq %rdi, %rdi\n\nsyscall\n\n.end\n", "# Program 4.2\n\n# Multiplication and Division - GAS, Clang/LLVM on Linux (64-bit)\n\n# Copyright (c) 2020 Hall & Slonka\n\n\n\n.data\n\nmval: .quad 664751\n\ndval: .quad 8\n\n\n\n.text\n\n.global _main\n\n_main:\n\n\n\n# MUL 1-op\n\nmov mval(%rip), %rax\n\nmov $8, %rbx\n\nmul %rbx\n\n\n\n# IMUL 1-op\n\nmov mval(%rip), %rax\n\nmov $8, %rbx\n\nimul %rbx\n\n\n\n# IMUL 2-op\n\nmov $8, %rax\n\nimul mval(%rip), %rax\n\n\n\n# IMUL 3-op\n\nimul $8, mval(%rip), %rax\n\n\n\n# DIV 1-op\n\nmov $0, %rdx\n\nmov $5318008, %rax\n\nmov dval(%rip), %rcx\n\ndiv %rcx\n\n\n\n# IDIV 1-op\n\nmov $0, %rdx\n\nmov $5318008, %rax\n\nmov dval(%rip), %rcx\n\nidiv %rcx\n\n\n\nmov $60, %rax\n\nxor %rdi, %rdi\n\nsyscall\n\n.end\n", "# Program 4.2\n\n# Multiplication and Division - GAS, Clang/LLVM on macOS (64-bit)\n\n# Copyright (c) 2020 Hall & Slonka\n\n\n\n.data\n\nmval: .quad 664751\n\ndval: .quad 8\n\n\n\n.text\n\n.global _main\n\n_main:\n\n\n\n# MUL 1-op\n\nmov mval(%rip), %rax\n\nmov $8, %rbx\n\nmul %rbx\n\n\n\n# IMUL 1-op\n\nmov mval(%rip), %rax\n\nmov $8, %rbx\n\nimul %rbx\n\n\n\n# IMUL 2-op\n\nmov $8, %rax\n\nimul mval(%rip), %rax\n\n\n\n# IMUL 3-op\n\nimul $8, mval(%rip), %rax\n\n\n\n# DIV 1-op\n\nmov $0, %rdx\n\nmov $5318008, %rax\n\nmov dval(%rip), %rcx\n\ndiv %rcx\n\n\n\n# IDIV 1-op\n\nmov $0, %rdx\n\nmov $5318008, %rax\n\nmov dval(%rip), %rcx\n\nidiv %rcx\n\n\n\nmov $0x2000001, %rax\n\nxor %rdi, %rdi\n\nsyscall\n\n.end\n", "# Program 4.1\n\n# Addition and Subtraction - GAS, Clang/LLVM on Linux (32-bit)\n\n# Copyright (c) 2017 Hall & Slonka\n\n\n\n.data\n\nsum: .long 0\n\nval: .long 25\n\n\n\n.text\n\n.globl _main\n\n_main:\n\n\n\nmovl $0, %eax\n\nincl %eax\n\naddl $200, %eax\n\nsubl val, %eax\n\nmovl %eax, sum\n\ndecl sum\n\nnegl sum\n\n\n\nmovl $1, %eax\n\nmovl $0, %ebx\n\nint $0x80\n\n.end\n", "# Program 4.1\n\n# Addition and Subtraction - GAS, Clang/LLVM on macOS (32-bit)\n\n# Copyright (c) 2017 Hall & Slonka\n\n\n\n.data\n\nsum: .long 0\n\nval: .long 25\n\n\n\n.text\n\n.globl _main\n\n_main:\n\n\n\nmovl $0, %eax\n\nincl %eax\n\naddl $200, %eax\n\nsubl val, %eax\n\nmovl %eax, sum\n\ndecl sum\n\nnegl sum\n\n\n\npushl $0\n\nsubl $4, %esp\n\nmovl $1, %eax\n\nint $0x80\n\n.end\n", "# Program 4.1\n\n# Addition and Subtraction - GAS, Clang/LLVM on Linux (64-bit)\n\n# Copyright (c) 2019 Hall & Slonka\n\n\n\n.data\n\nsum: .long 0\n\nval: .long 25\n\n\n\n.text\n\n.global _main\n\n_main:\n\n\n\nmovl $0, %eax\n\nincl %eax\n\naddl $200, %eax\n\nsubl val(%rip), %eax\n\nmovl %eax, sum(%rip)\n\ndecl sum(%rip)\n\nnegl sum(%rip)\n\n\n\nmovq $60, %rax\n\nxorq %rdi, %rdi\n\nsyscall\n\n.end\n", "# Program 4.1\n\n# Addition and Subtraction - GAS, Clang/LLVM on macOS (64-bit)\n\n# Copyright (c) 2019 Hall & Slonka\n\n\n\n.data\n\nsum: .long 0\n\nval: .long 25\n\n\n\n.text\n\n.global _main\n\n_main:\n\n\n\nmovl $0, %eax\n\nincl %eax\n\naddl $200, %eax\n\nsubl val(%rip), %eax\n\nmovl %eax, sum(%rip)\n\ndecl sum(%rip)\n\nnegl sum(%rip)\n\n\n\nmovq $0x2000001, %rax\n\nxorq %rdi, %rdi\n\nsyscall\n\n.end\n", "# Program 4.1\n\n# Addition and Subtraction - GAS, Clang/LLVM on Linux (64-bit)\n\n# Copyright (c) 2020 Hall & Slonka\n\n\n\n.data\n\nsum: .quad 0\n\nval: .quad 25\n\n\n\n.text\n\n.global _main\n\n_main:\n\n\n\nmov $0, %rax\n\ninc %rax\n\nadd $200, %rax\n\nsub val(%rip), %rax\n\nmov %rax, sum(%rip)\n\ndec sum(%rip)\n\nneg sum(%rip)\n\n\n\nmovq $60, %rax\n\nxorq %rdi, %rdi\n\nsyscall\n\n.end\n", "# Program 4.1\n\n# Addition and Subtraction - GAS, Clang/LLVM on macOS (64-bit)\n\n# Copyright (c) 2020 Hall & Slonka\n\n\n\n.data\n\nsum: .quad 0\n\nval: .quad 25\n\n\n\n.text\n\n.global _main\n\n_main:\n\n\n\nmov $0, %rax\n\ninc %rax\n\nadd $200, %rax\n\nsub val(%rip), %rax\n\nmov %rax, sum(%rip)\n\ndec sum(%rip)\n\nneg sum(%rip)\n\n\n\nmovq $0x2000001, %rax\n\nxorq %rdi, %rdi\n\nsyscall\n\n.end\n", "# Program 4.3\n\n# Negative Division - GAS, Clang/LLVM on macOS (32-bit)\n\n# Copyright (c) 2017 Hall & Slonka\n\n\n\n.text\n\n.globl _main\n\n_main:\n\n\n\nmovl $-534, %eax\n\ncdq\n\nmovl $15, %ebx\n\nidivl %ebx\n\n\n\npushl $0\n\nsubl $4, %esp\n\nmovl $1, %eax\n\nint $0x80\n\n.end\n", "# Program 4.3\n\n# Negative Division - GAS, Clang/LLVM on Linux (32-bit)\n\n# Copyright (c) 2017 Hall & Slonka\n\n\n\n.text\n\n.globl _main\n\n_main:\n\n\n\nmovl $-534, %eax\n\ncdq\n\nmovl $15, %ebx\n\nidivl %ebx\n\n\n\nmovl $1, %eax\n\nmovl $0, %ebx\n\nint $0x80\n\n.end\n", "# Program 4.3\n\n# Negative Division - GAS, Clang/LLVM on macOS (64-bit)\n\n# Copyright (c) 2019 Hall & Slonka\n\n\n\n.text\n\n.global _main\n\n_main:\n\n\n\nmovl $-534, %eax\n\ncdq\n\nmovl $15, %ebx\n\nidivl %ebx\n\n\n\nmovq $0x2000001, %rax\n\nxorq %rdi, %rdi\n\nsyscall\n\n.end\n", "# Program 4.3\n\n# Negative Division - GAS, Clang/LLVM on Linux (64-bit)\n\n# Copyright (c) 2019 Hall & Slonka\n\n\n\n.text\n\n.global _main\n\n_main:\n\n\n\nmovl $-534, %eax\n\ncdq\n\nmovl $15, %ebx\n\nidivl %ebx\n\n\n\nmovq $60, %rax\n\nxorq %rdi, %rdi\n\nsyscall\n\n.end\n", "# Program 4.3\n\n# Negative Division - GAS, Clang/LLVM on macOS (64-bit)\n\n# Copyright (c) 2019 Hall & Slonka\n\n\n\n.text\n\n.global _main\n\n_main:\n\n\n\nmov $-534, %rax\n\ncqo\n\nmov $15, %rbx\n\nidiv %rbx\n\n\n\nmov $0x2000001, %rax\n\nxor %rdi, %rdi\n\nsyscall\n\n.end\n", "# Program 4.3\n\n# Negative Division - GAS, Clang/LLVM on Linux (64-bit)\n\n# Copyright (c) 2020 Hall & Slonka\n\n\n\n.text\n\n.global _main\n\n_main:\n\n\n\nmov $-534, %rax\n\ncqo\n\nmov $15, %rbx\n\nidiv %rbx\n\n\n\nmov $60, %rax\n\nxor %rdi, %rdi\n\nsyscall\n\n.end\n", "# Program 5.1\n\n# Conditional Jump - GAS, Clang/LLVM on macOS (32-bit)\n\n# Copyright (c) 2017 Hall & Slonka\n\n\n\n.data\n\nwages: .long 46000\n\n\n\n.bss\n\n.lcomm taxes, 4\n\n\n\n.text\n\n.globl _main\n\n_main:\n\n\n\nmovl $50000, %eax\n\ncmpl %eax, wages\n\njae higher\n\nmovl $2000, taxes\n\njmp done\n\n\n\nhigher:\n\nmovl $4000, taxes\n\n\n\ndone:\n\npushl $0\n\nsubl $4, %esp\n\nmovl $1, %eax\n\nint $0x80\n\n.end\n", "# Program 5.1\n\n# Conditional Jump - GAS, Clang/LLVM on Linux (32-bit)\n\n# Copyright (c) 2017 Hall & Slonka\n\n\n\n.data\n\nwages: .long 46000\n\n\n\n.bss\n\n.lcomm taxes, 4\n\n\n\n.text\n\n.globl _main\n\n_main:\n\n\n\nmovl $50000, %eax\n\ncmpl %eax, wages\n\njae higher\n\nmovl $2000, taxes\n\njmp done\n\n\n\nhigher:\n\nmovl $4000, taxes\n\n\n\ndone:\n\nmovl $1, %eax\n\nmovl $0, %ebx\n\nint $0x80\n\n.end\n", "# Program 5.1\n\n# Conditional Jump - GAS, Clang/LLVM on macOS (64-bit)\n\n# Copyright (c) 2019 Hall & Slonka\n\n\n\n.data\n\nwages: .long 46000\n\n\n\n.bss\n\n.lcomm taxes, 4\n\n\n\n.text\n\n.global _main\n\n_main:\n\n\n\nmovl $50000, %eax\n\ncmpl %eax, wages(%rip)\n\njae higher\n\nmovl $2000, taxes(%rip)\n\njmp done\n\n\n\nhigher:\n\nmovl $4000, taxes(%rip)\n\n\n\ndone:\n\nmovq $0x2000001, %rax\n\nxorq %rdi, %rdi\n\nsyscall\n\n.end\n", "# Program 5.1\n\n# Conditional Jump - GAS, Clang/LLVM on Linux (64-bit)\n\n# Copyright (c) 2019 Hall & Slonka\n\n\n\n.data\n\nwages: .long 46000\n\n\n\n.bss\n\n.lcomm taxes, 4\n\n\n\n.text\n\n.global _main\n\n_main:\n\n\n\nmovl $50000, %eax\n\ncmpl %eax, wages(%rip)\n\njae higher\n\nmovl $2000, taxes(%rip)\n\njmp done\n\n\n\nhigher:\n\nmovl $4000, taxes(%rip)\n\n\n\ndone:\n\nmovq $60, %rax\n\nxorq %rdi, %rdi\n\nsyscall\n\n.end\n", "# Program 5.1\n\n# Conditional Jump - GAS, Clang/LLVM on macOS (64-bit)\n\n# Copyright (c) 2020 Hall & Slonka\n\n\n\n.data\n\nwages: .quad 46000\n\n\n\n.bss\n\n.lcomm taxes, 8\n\n\n\n.text\n\n.global _main\n\n_main:\n\n\n\nmovq $50000, %rax\n\ncmpq %rax, wages(%rip)\n\njae higher\n\nmovq $2000, taxes(%rip)\n\njmp done\n\n\n\nhigher:\n\nmovq $4000, taxes(%rip)\n\n\n\ndone:\n\nmovq $0x2000001, %rax\n\nxorq %rdi, %rdi\n\nsyscall\n\n.end\n", "# Program 5.1\n\n# Conditional Jump - GAS, Clang/LLVM on Linux (64-bit)\n\n# Copyright (c) 2020 Hall & Slonka\n\n\n\n.data\n\nwages: .quad 46000\n\n\n\n.bss\n\n.lcomm taxes, 8\n\n\n\n.text\n\n.global _main\n\n_main:\n\n\n\nmovq $50000, %rax\n\ncmpq %rax, wages(%rip)\n\njae higher\n\nmovq $2000, taxes(%rip)\n\njmp done\n\n\n\nhigher:\n\nmovq $4000, taxes(%rip)\n\n\n\ndone:\n\nmovq $60, %rax\n\nxorq %rdi, %rdi\n\nsyscall\n\n.end\n", "# Program 5.2\n\n# Looping - GAS, Clang/LLVM on macOS (32-bit)\n\n# Copyright (c) 2019 Hall & Slonka\n\n\n\n.text\n\n.globl _main\n\n_main:\n\n\n\nxorl %eax, %eax\n\nmovl $5, %ecx\n\n\n\nmyLoop:\n\n   incl %eax\n\n   loop myLoop\n\n\n\npushl $0\n\nsubl $4, %esp\n\nmovl $1, %eax\n\nint $0x80\n\n.end\n", "# Program 5.2\n\n# Looping - GAS, Clang/LLVM on Linux (32-bit)\n\n# Copyright (c) 2019 Hall & Slonka\n\n\n\n.text\n\n.globl _main\n\n_main:\n\n\n\nxorl %eax, %eax\n\nmovl $5, %ecx\n\n\n\nmyLoop:\n\n   incl %eax\n\n   loop myLoop\n\n\n\nmovl $1, %eax\n\nmovl $0, %ebx\n\nint $0x80\n\n.end\n", "# Program 5.2\n\n# Looping - GAS, Clang/LLVM on macOS (64-bit)\n\n# Copyright (c) 2017 Hall & Slonka\n\n\n\n.text\n\n.global _main\n\n_main:\n\n\n\nxorq %rax, %rax\n\nmovq $5, %rcx\n\n\n\nmyLoop:\n\n   incq %rax\n\n   loop myLoop\n\n\n\nmovq $0x2000001, %rax\n\nxorq %rdi, %rdi\n\nsyscall\n\n.end\n", "# Program 5.2\n\n# Looping - GAS, Clang/LLVM on Linux (64-bit)\n\n# Copyright (c) 2017 Hall & Slonka\n\n\n\n.text\n\n.global _main\n\n_main:\n\n\n\nxorq %rax, %rax\n\nmovq $5, %rcx\n\n\n\nmyLoop:\n\n   incq %rax\n\n   loop myLoop\n\n\n\nmovq $60, %rax\n\nxorq %rdi, %rdi\n\nsyscall\n\n.end\n", "# Program 5.2\n\n# Looping - GAS, Clang/LLVM on macOS (64-bit)\n\n# Copyright (c) 2020 Hall & Slonka\n\n\n\n.text\n\n.global _main\n\n_main:\n\n\n\nxor %rax, %rax\n\nmov $5, %rcx\n\n\n\nmyLoop:\n\n   inc %rax\n\n   loop myLoop\n\n\n\nmov $0x2000001, %rax\n\nxor %rdi, %rdi\n\nsyscall\n\n.end\n", "# Program 5.2\n\n# Looping - GAS, Clang/LLVM on Linux (64-bit)\n\n# Copyright (c) 2020 Hall & Slonka\n\n\n\n.text\n\n.global _main\n\n_main:\n\n\n\nxor %rax, %rax\n\nmov $5, %rcx\n\n\n\nmyLoop:\n\n   inc %rax\n\n   loop myLoop\n\n\n\nmov $60, %rax\n\nxor %rdi, %rdi\n\nsyscall\n\n.end\n", "# Program 5.4\n\n# while Loop - GAS, Clang/LLVM on Linux (32-bit)\n\n# Copyright (c) 2019 Hall & Slonka\n\n\n\n.text\n\n.globl _main\n\n_main:\n\n\n\nmovl $30, %eax\n\nwhile_loop:\n\n    cmpl $50, %eax\n\n    jae done\n\n    incl %eax\n\n    jmp while_loop\n\ndone:\n\n\n\nmovl $1, %eax\n\nmovl $0, %ebx\n\nint $0x80\n\n.end\n", "# Program 5.4\n\n# while Loop - GAS, Clang/LLVM on macOS (32-bit)\n\n# Copyright (c) 2019 Hall & Slonka\n\n\n\n.text\n\n.globl _main\n\n_main:\n\n\n\nmovl $30, %eax\n\nwhile_loop:\n\n    cmpl $50, %eax\n\n    jae done\n\n    incl %eax\n\n    jmp while_loop\n\ndone:\n\n\n\npushl $0\n\nsubl $4, %esp\n\nmovl $1, %eax\n\nint $0x80\n\n.end\n", "# Program 5.4\n\n# while Loop - GAS, Clang/LLVM on Linux (64-bit)\n\n# Copyright (c) 2017 Hall & Slonka\n\n\n\n.text\n\n.global _main\n\n_main:\n\n\n\nmovq $30, %rax\n\nwhile_loop:\n\n    cmpq $50, %rax\n\n    jae done\n\n    incq %rax\n\n    jmp while_loop\n\ndone:\n\n\n\nmovq $60, %rax\n\nxorq %rdi, %rdi\n\nsyscall\n\n.end\n", "# Program 5.4\n\n# while Loop - GAS, Clang/LLVM on macOS (64-bit)\n\n# Copyright (c) 2017 Hall & Slonka\n\n\n\n.text\n\n.global _main\n\n_main:\n\n\n\nmovq $30, %rax\n\nwhile_loop:\n\n    cmpq $50, %rax\n\n    jae done\n\n    incq %rax\n\n    jmp while_loop\n\ndone:\n\n\n\nmovq $0x2000001, %rax\n\nxorq %rdi, %rdi\n\nsyscall\n\n.end\n", "# Program 5.3\n\n# Nested for Loop - GAS, Clang/LLVM on macOS (32-bit)\n\n# Copyright (c) 2019 Hall & Slonka\n\n\n\n.text\n\n.globl _main\n\n_main:\n\n\n\nxorl %eax, %eax\n\nmovl $2, %ebx\n\nouter:\n\n    movl $3, %ecx\n\n    inner:\n\n        incl %eax\n\n        decl %ecx\n\n        cmpl $0, %ecx\n\n        jne inner\n\n    decl %ebx\n\n    cmpl $0, %ebx\n\n    jne outer\n\n\n\npushl $0\n\nsubl $4, %esp\n\nmovl $1, %eax\n\nint $0x80\n\n.end\n", "# Program 5.3\n\n# Nested for Loop - GAS, Clang/LLVM on Linux (32-bit)\n\n# Copyright (c) 2019 Hall & Slonka\n\n\n\n.text\n\n.globl _main\n\n_main:\n\n\n\nxorl %eax, %eax\n\nmovl $2, %ebx\n\nouter:\n\n    movl $3, %ecx\n\n    inner:\n\n        incl %eax\n\n        decl %ecx\n\n        cmpl $0, %ecx\n\n        jne inner\n\n    decl %ebx\n\n    cmpl $0, %ebx\n\n    jne outer\n\n\n\nmovl $1, %eax\n\nmovl $0, %ebx\n\nint $0x80\n\n.end\n", "# Program 5.3\n\n# Nested for Loop - GAS, Clang/LLVM on macOS (64-bit)\n\n# Copyright (c) 2017 Hall & Slonka\n\n\n\n.text\n\n.global _main\n\n_main:\n\n\n\nxorq %rax, %rax\n\nmovq $2, %rbx\n\nouter:\n\n    movq $3, %rcx\n\n    inner:\n\n        incq %rax\n\n        decq %rcx\n\n        cmpq $0, %rcx\n\n        jne inner\n\n    decq %rbx\n\n    cmpq $0, %rbx\n\n    jne outer\n\n\n\nmovq $0x2000001, %rax\n\nxorq %rdi, %rdi\n\nsyscall\n\n.end\n", "# Program 5.3\n\n# Nested for Loop - GAS, Clang/LLVM on Linux (64-bit)\n\n# Copyright (c) 2017 Hall & Slonka\n\n\n\n.text\n\n.global _main\n\n_main:\n\n\n\nxorq %rax, %rax\n\nmovq $2, %rbx\n\nouter:\n\n    movq $3, %rcx\n\n    inner:\n\n        incq %rax\n\n        decq %rcx\n\n        cmpq $0, %rcx\n\n        jne inner\n\n    decq %rbx\n\n    cmpq $0, %rbx\n\n    jne outer\n\n\n\nmovq $60, %rax\n\nxorq %rdi, %rdi\n\nsyscall\n\n.end\n", "# Program 10.3\n\n# Print Process ID with INT - GAS, Clang/LLVM on Linux (32-bit)\n\n# Copyright (c) 2017 Hall & Slonka\n\n\n\n.data\n\ndecimal: .long 10\n\n.bss\n\n.lcomm PID, 4    # Reserve 4 bytes for a process id\n\n\n\n.text\n\n.globl _main\n\n_main:                      # Print Process ID\n\n\n\nmovl $0x14, %eax            # GET_PID call\n\nint $0x80                   # syscall\n\n                            # process ID is returned in EAX\n\nmovl $(PID+4), %edi         # Pointer to end of PID string\n\nconvert:\n\n    xorl    %edx, %edx\n\n    divl    decimal         # Divide by 10\n\n    addl    $48, %edx       # Add 48 to remainder\n\n    movb    %dl, (%edi)     # Store\n\n    decl    %edi            # Next digit\n\n    cmpl    $0, %eax        # Is EAX = 0?\n\n    jg      convert         # If greater than 0, more digits\n\n\n\nmovl $1, %ebx               # File descriptor STDOUT (1)\n\nmovl $PID, %ecx             # String address\n\nmovl $6, %edx               # String length\n\nmovl $4, %eax               # system call 4 (WRITE), prints to screen\n\nint $0x80                   # system call\n\n\n\nmovl $1, %eax               # system call 1 (exit)\n\nmovl $0, %ebx               # return value\n\nint $0x80                   # system call\n\n\n\n.end\n", "# Program 10.3\n\n# Print Process ID with INT - GAS, Clang/LLVM on macOS (32-bit)\n\n# Copyright (c) 2017 Hall & Slonka\n\n\n\n.data\n\n   decimal: .long 10\n\n.bss\n\n.lcomm PID, 4    # Reserve 4 bytes for a process id\n\n\n\n.text\n\n.globl _main\n\n_main:                     # Print Process ID\n\n\n\nmovl $0x14, %eax           # GET_PID call\n\nint $0x80                  # syscall\n\n                           # process ID is returned in EAX\n\nmovl $(PID+4), %edi        # Pointer to end of PID string\n\nconvert:\n\n    xorl    %edx, %edx\n\n    divl    decimal        # Divide by 10\n\n    addl    $48, %edx      # Add 48 to remainder\n\n    movb    %dl, (%edi)    # Store\n\n    decl    %edi           # Next digit\n\n    cmpl    $0, %eax       # Is EAX = 0?\n\n    jg      convert        # If greater than 0, more digits\n\n\n\npushl $6                   # string length\n\npushl $PID                 # string address\n\npushl $1                   # file descriptor STDOUT (1)\n\npushl $0                   # align stack\n\nmovl $4, %eax              # system call 4 (write)\n\nint $0x80                  # system call\n\naddl $16, %esp             # clean stack\n\n\n\npushl $0                   # return value\n\nsubl $4, %esp              # align stack\n\nmovl $1, %eax              # system call 1 (exit)\n\nint $0x80                  # system call\n\n\n\n.end\n", "# Program 10.6\n\n# SYSCALL on macOS/BSD (GAS, Clang/LLVM 64-bit)\n\n# Copyright (c) 2017 Hall & Slonka\n\n\n\n.data\n\noutput:    .ascii \"Computer Architecture\\n\"\n\nlen: .quad (. - output)\n\nfile_name: .asciz \"output.txt\"\n\nfile_handle: .long 0\n\n\n\n.text\n\n.global _main\n\n_main:\n\n\n\nmovq $0x2000004, %rax        # system write (4)\n\nmovq $1, %rdi                # file handle STDOUT (1)\n\nleaq output(%rip), %rsi      # address\n\nmovq len(%rip), %rdx         # length\n\nsyscall\n\n\n\nmovq $0x2000005, %rax        # system open (5)\n\nleaq file_name(%rip), %rdi   # path\n\nmovq $0x0201, %rsi           # flags (02=O_CREAT, 01=O_WRONLY)\n\nmovq $0666, %rdx             # mode (permissions)\n\nsyscall\n\nmovq %rax, file_handle(%rip)\n\n\n\nmovq $0x2000004, %rax        # system write (4)\n\nmovq file_handle(%rip), %rdi # file handle\n\nleaq output(%rip), %rsi      # address\n\nmovq len(%rip), %rdx         # length\n\nsyscall\n\n\n\nmovq $0x2000006, %rax        # system close (6)\n\nmovq file_handle(%rip), %rdi # file handle\n\nsyscall\n\n\n\nmovq $0x2000001, %rax        # system exit (1)\n\nmovq $0, %rdi                # return value\n\nsyscall\n\n\n\n.end\n", "# Program 10.6\n\n# SYSCALL on Linux (GAS, Clang/LLVM 64-bit)\n\n# Copyright (c) 2017 Hall & Slonka\n\n\n\n.data\n\noutput:    .ascii \"Computer Architecture\\n\"\n\nlen: .quad (. - output)\n\nfile_name: .asciz \"output.txt\"\n\nfile_handle: .long 0\n\n\n\n.text\n\n.global _main\n\n_main:\n\n\n\nmovq $1, %rax                   # system write (1)\n\nmovq $1, %rdi                   # file handle STDOUT (1)\n\nleaq output(%rip), %rsi         # address\n\nmovq len(%rip), %rdx            # length\n\nsyscall\n\n\n\nmovq $2, %rax                   # system open (2)\n\nleaq file_name(%rip), %rdi      # path\n\nmovq $0101, %rsi                # flags (01=O_CREAT, 01=O_WRONLY)\n\nmovq $0666, %rdx                # mode (permissions)\n\nsyscall\n\nmovq %rax, file_handle(%rip)\n\n\n\nmovq $1, %rax                   # system write (1)\n\nmovq file_handle(%rip), %rdi    # file handle\n\nleaq output(%rip), %rsi         # address\n\nmovq len(%rip), %rdx            # length\n\nsyscall\n\n\n\nmovq $3, %rax                   # system close (3)\n\nmovq file_handle(%rip), %rdi    # file handle\n\nsyscall\n\n\n\nmovq $60, %rax\n\nxorq %rdi, %rdi\n\nsyscall\n\n.end\n", "# Program 10.2\n\n# Debug and System Write Interrupts - GAS, Clang/LLVM on Linux (32-bit)\n\n# Copyright (c) 2017 Hall & Slonka\n\n\n\n.data\n\noutput:    .ascii \"Computer Architecture\\n\"\n\n.equ len, (. - output)\n\n\n\n.text\n\n.globl _main\n\n_main:              # Print \"Computer Architecture\"\n\n\n\n#int $3             # Set breakpoint (remove if desired)\n\nmovl $1, %ebx       # File descriptor STDOUT (1)\n\nmovl $output, %ecx  # String address\n\nmovl $len, %edx     # String length\n\nmovl $4, %eax       # Use SYSCALL 4 (WRITE), prints to screen\n\nint  $0x80          # system call interrupt\n\n\n\nmovl $1, %eax       # call number for exit\n\nmovl $0, %ebx       # return value\n\nint $0x80           # system call interrupt\n\n\n\n.end\n", "# Program 10.2\n\n# Debug and System Write Interrupts - GAS, Clang/LLVM on macOS (32-bit)\n\n# Copyright (c) 2017 Hall & Slonka\n\n\n\n.data\n\noutput:    .ascii \"Computer Architecture\\n\"\n\n.equ len, (. - output)\n\n\n\n.text\n\n.globl _main\n\n_main:           # Print \"Computer Architecture\"\n\n\n\nint $3           # Set breakpoint (remove if desired)\n\npushl $len       # String length\n\npushl $output    # String address\n\npushl $1         # Print to STDOUT (File Descriptor 1, FD1)\n\npushl $0         # Extra push to align stack\n\nmovl $4, %eax    # Use SYSCALL 4 (WRITE), prints to screen\n\nint  $0x80       # system call interrupt\n\naddl $16, %esp   # Clean up stack\n\n\n\npushl $len       # BSD assumes that a function calls INT 80h\n\npushl $output    # as opposed to issuing INT 80h directly\n\npushl $1         # Print using kernel call\n\nmovl $4, %eax\n\ncall _kernel\n\naddl $12, %esp\n\n\n\npushl $0         # return value\n\nsubl $4, %esp    # align stack\n\nmovl $1, %eax    # call number for exit\n\nint $0x80        # system call interrupt\n\n\n\n_kernel:         # For any system call\n\n   int $0x80\n\n   ret\n\n\n\n.end\n", "# Program 10.1\n\n# Using Segment Selectors - GAS, Clang/LLVM on macOS (32-bit)\n\n# Copyright (c) 2017 Hall & Slonka\n\n\n\n.data\n\narray: .long 3, 2, 6, 4, 1\n\n\n\n.text\n\n.globl _main\n\n\n\n_main:\n\n\n\nmovl $array, %eax        # array address to eax\n\nmovl 4(%eax), %ebx       # second element to ebx\n\nmovl %ds:array, %ecx     # first element to ecx\n\nmovl %ds:array+8, %edx   # third element to edx\n\n\n\nmovl %gs, %esi           # gs to esi\n\nmovl $42, %gs:(%esi)     # 42 to gs:(offset in esi)\n\nmovl %gs:(%esi), %edi    # gs:offset to edi\n\nmovl $43, %gs:0x04       # 43 to gs:offset\n\nmovl %gs:0x04, %edi      # gs:offset to edi\n\n\n\npushl $0\n\nsubl $4, %esp\n\nmovl $1, %eax\n\nint $0x80\n\n.end\n", "# Program 10.1\n\n# Using Segment Selectors - GAS, Clang/LLVM on Linux (32-bit)\n\n# Copyright (c) 2017 Hall & Slonka\n\n\n\n.data\n\narray: .long 3, 2, 6, 4, 1\n\n\n\n.text\n\n.globl _main\n\n\n\n_main:\n\n\n\nmovl $array, %eax        # array address to eax\n\nmovl 4(%eax), %ebx       # second element to ebx\n\nmovl %ds:array, %ecx     # first element to ecx\n\nmovl %ds:array+8, %edx   # third element to edx\n\n\n\nmovl $1, %eax\n\nmovl $0, %ebx\n\nint $0x80\n\n.end\n", "# Program 10.1\n\n# Using Segment Selectors - GAS, Clang/LLVM on macOS (64-bit)\n\n# Copyright (c) 2019 Hall & Slonka\n\n\n\n.data\n\narray: .long 3, 2, 6, 4, 1\n\n\n\n.text\n\n.global _main\n\n\n\n_main:\n\n\n\nleaq array(%rip), %rsi      # array address to rsi\n\nmovl 4(%rsi), %ebx          # second element to ebx\n\nleaq %ds:array(%rip), %rdi  # array address to rdi\n\nmovl (%rdi), %ecx           # first element to ecx\n\nmovl 8(%rdi), %edx          # third element to edx\n\n\n\nmovq %gs, %rsi              # gs to rsi\n\nmovq $42, %gs:(%rsi)        # 42 to gs:(offset in rsi)\n\nmovq %gs:(%rsi), %rdi       # gs:offset to rdi\n\nmovq $43, %gs:0x04          # 43 to gs:offset\n\nmovq %gs:0x04, %rdi         # gs:offset to rdi\n\n\n\nmovq $0x2000001, %rax\n\nxorq %rdi, %rdi\n\nsyscall\n\n.end\n", "# Program 10.1\n\n# Using Segment Selectors - GAS, Clang/LLVM on Linux (64-bit)\n\n# Copyright (c) 2019 Hall & Slonka\n\n\n\n.data\n\narray: .long 3, 2, 6, 4, 1\n\n\n\n.text\n\n.global _main\n\n\n\n_main:\n\n\n\nleaq array(%rip), %rsi      # array address to rsi\n\nmovl 4(%rsi), %ebx          # second element to ebx\n\nleaq %ds:array(%rip), %rdi  # array address to rdi\n\nmovl (%rdi), %ecx           # first element to ecx\n\nmovl 8(%rdi), %edx          # third element to edx\n\n\n\nmovq $60, %rax\n\nxorq %rdi, %rdi\n\nsyscall\n\n.end\n", "# Console Output\n\n# Materials - GAS, Clang/LLVM on macOS (32-bit)\n\n# Copyright (c) 2017 Hall & Slonka\n\n\n\n# Uses system call information from Chapter 10\n\n\n\n.data\n\ns1: .ascii \"Hello Universe\\n\\0\"\n\nlenS1: .long (. - s1)\n\n\n\n.text\n\n.globl _main\n\n_main:\n\n\n\nprint:\n\npushl lenS1     # len of string\n\npushl $s1       # starting address of string\n\npushl $1        # stdout\n\npushl $0        # stack alignment\n\nmovl $4, %eax   # syswrite\n\nint $0x80\n\naddl $16, %esp\n\n\n\ndone:\n\npushl $0\n\nsubl $4, %esp\n\nmovl $1, %eax\n\nint $0x80\n\n.end\n", "# Console Output\n\n# Materials - GAS, Clang/LLVM on Linux (64-bit)\n\n# Copyright (c) 2019 Hall & Slonka\n\n\n\n# Uses system call information from Chapter 10\n\n\n\n.data\n\ns1: .ascii \"Hello Universe\\n\\0\"\n\nlenS1: .long (. - s1)\n\n\n\n.text\n\n.global _main\n\n_main:\n\n\n\nprint:\n\n    movq $0x2000004, %rax   # system write (4)\n\n    movq $1, %rdi           # file handle STDOUT (1)\n\n    leaq s1(%rip), %rsi     # address\n\n    movq lenS1(%rip), %rdx  # length\n\n    syscall\n\n\n\ndone:\n\n    movq $60, %rax\n\n    xorq %rdi, %rdi\n\n    syscall\n\n.end\n", "# Console Output\n\n# Materials - GAS, Clang/LLVM on Linux (32-bit)\n\n# Copyright (c) 2017 Hall & Slonka\n\n\n\n# Uses system call information from Chapter 10\n\n\n\n.data\n\ns1: .ascii \"Hello Universe\\n\\0\"\n\nlenS1: .long (. - s1)\n\n\n\n.text\n\n.globl _main\n\n_main:\n\n\n\nprint:\n\n    movl $4, %eax       # syswrite\n\n    movl $1, %ebx       # stdout\n\n    movl $s1, %ecx      # starting address of string\n\n    movl lenS1, %edx    # len of string\n\n    int $0x80\n\n\n\ndone:\n\nmovl $1, %eax\n\nmovl $0, %ebx\n\nint $0x80\n\n.end\n", "# Console Output\n\n# Materials - GAS, Clang/LLVM on macOS (64-bit)\n\n# Copyright (c) 2019 Hall & Slonka\n\n\n\n# Uses system call information from Chapter 10\n\n\n\n.data\n\ns1: .ascii \"Hello Universe\\n\\0\"\n\nlenS1: .long (. - s1)\n\n\n\n.text\n\n.global _main\n\n_main:\n\n\n\nprint:\n\n    movq $0x2000004, %rax   # system write (4)\n\n    movq $1, %rdi           # file handle STDOUT (1)\n\n    leaq s1(%rip), %rsi     # address\n\n    movq lenS1(%rip), %rdx  # length\n\n    syscall\n\n\n\ndone:\n\n    movq $0x2000001, %rax\n\n    xorq %rdi, %rdi\n\n    syscall\n\n.end\n", "# GDB and LLDB\n\n# Materials - GAS, Clang/LLVM on Linux (64-bit)\n\n# Copyright (c) 2019 Hall & Slonka\n\n\n\n.data\n\ns1: .ascii \"Hello Universe\\n\\0\"\n\nlenS1: .long (. - s1)\n\nnums: .long 2, 4, 6, 8, 10, 12\n\nlenNums: .long (. - nums)\n\nfloats: .float 1.2, 3.4, 5.6, 7.8\n\nlenFloats: .long (. - floats)\n\nvalue: .long 22\n\n\n\n.text\n\n.global _main\n\n_main:\n\n\n\nleaq s1(%rip), %rax\n\nleaq nums(%rip), %rax\n\nleaq floats(%rip), %rax\n\nmovups floats(%rip), %xmm0\n\n\n\ndone:\n\nmovq $60, %rax\n\nxorq %rdi, %rdi\n\nsyscall\n\n.end\n", "# GDB and LLDB\n\n# Materials - GAS, Clang/LLVM on Linux (32-bit)\n\n# Copyright (c) 2017 Hall & Slonka\n\n\n\n.data\n\ns1: .ascii \"Hello Universe\\n\\0\"\n\nlenS1: .long (. - s1)\n\nnums: .long 2, 4, 6, 8, 10, 12\n\nlenNums: .long (. - nums)\n\nfloats: .float 1.2, 3.4, 5.6, 7.8\n\nlenFloats: .long (. - floats)\n\nvalue: .long 22\n\n\n\n.text\n\n.globl _main\n\n_main:\n\n\n\nmovl $s1, %eax\n\nmovl $nums, %eax\n\nmovl $floats, %eax\n\nmovups floats, %xmm0\n\n\n\ndone:\n\nmovl $1, %eax\n\nmovl $0, %ebx\n\nint $0x80\n\n.end\n", "# GDB and LLDB\n\n# Materials - GAS, Clang/LLVM on macOS (64-bit)\n\n# Copyright (c) 2019 Hall & Slonka\n\n\n\n.data\n\ns1: .ascii \"Hello Universe\\n\\0\"\n\nlenS1: .long (. - s1)\n\nnums: .long 2, 4, 6, 8, 10, 12\n\nlenNums: .long (. - nums)\n\nfloats: .float 1.2, 3.4, 5.6, 7.8\n\nlenFloats: .long (. - floats)\n\nvalue: .long 22\n\n\n\n.text\n\n.global _main\n\n_main:\n\n\n\nleaq s1(%rip), %rax\n\nleaq nums(%rip), %rax\n\nleaq floats(%rip), %rax\n\nmovups floats(%rip), %xmm0\n\n\n\ndone:\n\nmovq $0x2000001, %rax\n\nxorq %rdi, %rdi\n\nsyscall\n\n.end\n", "# GDB and LLDB\n\n# Materials - GAS, Clang/LLVM on macOS (32-bit)\n\n# Copyright (c) 2017 Hall & Slonka\n\n\n\n.data\n\ns1: .ascii \"Hello Universe\\n\\0\"\n\nlenS1: .long (. - s1)\n\nnums: .long 2, 4, 6, 8, 10, 12\n\nlenNums: .long (. - nums)\n\nfloats: .float 1.2, 3.4, 5.6, 7.8\n\nlenFloats: .long (. - floats)\n\nvalue: .long 22\n\n\n\n.text\n\n.globl _main\n\n_main:\n\n\n\nmovl $s1, %eax\n\nmovl $nums, %eax\n\nmovl $floats, %eax\n\nmovups floats, %xmm0\n\n\n\ndone:\n\npushl $0\n\nsubl $4, %esp\n\nmovl $1, %eax\n\nint $0x80\n\n.end\n", "# Program 8.6\n\n# SSE3 - GAS, Clang/LLVM on Linux (32-bit)\n\n# Copyright (c) 2017 Hall & Slonka\n\n\n\n.data\n\n.balign 16\n\nvectorA: .float 1.2, 3.4, 5.6, 7.8\n\nvectorB: .float 7.8, 5.6, 3.4, 1.2\n\n\n\n.text\n\n.globl _main\n\n_main:\n\n\n\nmovaps vectorA, %xmm0   # move vectorA to XMM0\n\nmovaps vectorB, %xmm1   # move vectorB to XMM1\n\nhaddps %xmm1, %xmm0     # horizontal add packed SP vectorB to vectorA\n\n\n\nmovl $1, %eax\n\nmovl $0, %ebx\n\nint $0x80\n\n.end\n", "# Program 8.6\n\n# SSE3 - GAS, Clang/LLVM on macOS (32-bit)\n\n# Copyright (c) 2017 Hall & Slonka\n\n\n\n.data\n\n.balign 16\n\nvectorA: .float 1.2, 3.4, 5.6, 7.8\n\nvectorB: .float 7.8, 5.6, 3.4, 1.2\n\n\n\n.text\n\n.globl _main\n\n_main:\n\n\n\nmovaps vectorA, %xmm0   # move vectorA to XMM0\n\nmovaps vectorB, %xmm1   # move vectorB to XMM1\n\nhaddps %xmm1, %xmm0     # horizontal add packed SP vectorB to vectorA\n\n\n\npushl $0\n\nsubl $4, %esp\n\nmovl $1, %eax\n\nint $0x80\n\n.end\n", "# Program 8.6\n\n# SSE3 - GAS, Clang/LLVM on Linux (64-bit)\n\n# Copyright (c) 2019 Hall & Slonka\n\n\n\n.data\n\n.balign 16\n\nvectorA: .float 1.2, 3.4, 5.6, 7.8\n\nvectorB: .float 7.8, 5.6, 3.4, 1.2\n\n\n\n.text\n\n.global _main\n\n_main:\n\n\n\nmovaps vectorA(%rip), %xmm0 # move vectorA to XMM0\n\nmovaps vectorB(%rip), %xmm1 # move vectorB to XMM1\n\nhaddps %xmm1, %xmm0         # horizontal add packed SP vectorB to vectorA\n\n\n\nmovq $60, %rax\n\nxorq %rdi, %rdi\n\nsyscall\n\n.end\n", "# Program 8.6\n\n# SSE3 - GAS, Clang/LLVM on macOS (64-bit)\n\n# Copyright (c) 2019 Hall & Slonka\n\n\n\n.data\n\n.balign 16\n\nvectorA: .float 1.2, 3.4, 5.6, 7.8\n\nvectorB: .float 7.8, 5.6, 3.4, 1.2\n\n\n\n.text\n\n.global _main\n\n_main:\n\n\n\nmovaps vectorA(%rip), %xmm0 # move vectorA to XMM0\n\nmovaps vectorB(%rip), %xmm1 # move vectorB to XMM1\n\nhaddps %xmm1, %xmm0         # horizontal add packed SP vectorB to vectorA\n\n\n\nmovq $0x2000001, %rax\n\nxorq %rdi, %rdi\n\nsyscall\n\n.end\n", "# Program 8.1\n\n# x87 FPU - GAS, g++, Clang/LLVM on Linux (32-bit)\n\n# Copyright (c) 2017 Hall & Slonka\n\n\n\n.extern _printFloat\n\n.extern _printDouble\n\n\n\n.data\n\nvalue: .float 1.2\n\n\n\n.bss\n\n.lcomm r_value, 4   # Reserve 4 bytes for holding a 32-bit value\n\n.lcomm f_result, 4\n\n.lcomm d_result, 8  # Reserve 8 bytes for holding a 64-bit value\n\n\n\n.text\n\n.globl _asmMain\n\n_asmMain:\n\npush %ebp\n\nmovl %esp, %ebp\n\n\n\nfinit               # initialize FPU\n\nfldpi               # load PI on FPU stack\n\nflds value          # load single precision value on FPU stack\n\nfadd %st(1), %st    # st same as st(0), st(1) = PI, st(0) = 1.2\n\nfists r_value       # copies st(0), rounds to nearest, stores in memory, r_value = 4\n\n\n\nfstps f_result      # float store single precision (32 bits) from top of FPU stack\n\npush f_result\n\ncall _printFloat\n\nadd $4, %esp\n\n\n\nfstpl d_result      # float store double precision (64 bits) from top of FPU stack\n\npush d_result + 4\n\npush d_result\n\ncall _printDouble\n\nadd $8, %esp\n\n\n\npop %ebp\n\nret\n\n.end\n", "# Program 8.1\n\n# x87 FPU - GAS, g++, Clang/LLVM on Linux (64-bit)\n\n# Copyright (c) 2019 Hall & Slonka\n\n\n\n.extern _printDouble\n\n\n\n.data\n\nvalue: .float 1.2\n\n\n\n.bss\n\n.lcomm r_value, 4   # Reserve 4 bytes for holding a 32-bit value\n\n.lcomm f_result, 4\n\n.lcomm d_result, 8  # Reserve 8 bytes for holding a 64-bit value\n\n\n\n.text\n\n.global _asmMain\n\n_asmMain:\n\npushq %rbp\n\nmovq %rsp, %rbp\n\n\n\nfinit                       # initialize FPU\n\nfldpi                       # load PI on FPU stack\n\nflds value(%rip)            # load single precision value on FPU stack\n\nfadd %st(1), %st            # st same as st(0), st(1) = PI, st(0) = 1.2\n\nfists r_value(%rip)         # copies st(0), rounds to nearest, stores in memory, r_value = 4\n\n\n\nfstps f_result(%rip)        # float store single precision (32 bits) from top of FPU stack\n\nmovss f_result(%rip), %xmm0\n\ncall _printFloat\n\n\n\nfstpl d_result(%rip)        # float store double precision (64 bits) from top of FPU stack\n\nmovsd d_result(%rip), %xmm0\n\ncall _printDouble\n\n\n\npopq %rbp\n\nretq\n\n.end\n", "# Program 8.1\n\n# x87 FPU - GAS, Clang/LLVM on macOS (32-bit)\n\n# Copyright (c) 2017 Hall & Slonka\n\n\n\n.extern _printFloat\n\n.extern _printDouble\n\n\n\n.data\n\nvalue: .float 1.2\n\n\n\n.bss\n\n.lcomm r_value, 4   # Reserve 4 bytes for holding a 32-bit value\n\n.lcomm f_result, 4\n\n.lcomm d_result, 8  # Reserve 8 bytes for holding a 64-bit value\n\n\n\n.text\n\n.globl _asmMain\n\n_asmMain:\n\npush %ebp\n\nmovl %esp, %ebp\n\n\n\nfinit               # initialize FPU\n\nfldpi               # load PI on FPU stack\n\nflds value          # load single precision value on FPU stack\n\nfadd %st(1), %st    # st same as st(0), st(1) = PI, st(0) = 1.2\n\nfists r_value       # copies st(0), rounds to nearest, stores in memory, r_value = 4\n\n\n\nfstps f_result      # float store single precision (32 bits) from top of FPU stack\n\npush f_result\n\ncall _printFloat\n\nadd $4, %esp\n\n\n\nfstpl d_result      # float store double precision (64 bits) from top of FPU stack\n\npush d_result + 4\n\npush d_result\n\ncall _printDouble\n\nadd $8, %esp\n\n\n\npop %ebp\n\nret\n\n.end\n", "# Program 8.1\n\n# x87 FPU - GAS, Clang/LLVM on macOS (64-bit)\n\n# Copyright (c) 2019 Hall & Slonka\n\n\n\n.extern _printFloat\n\n.extern _printDouble\n\n\n\n.data\n\nvalue: .float 1.2\n\n\n\n.bss\n\n.lcomm r_value, 4   # Reserve 4 bytes for holding a 32-bit value\n\n.lcomm f_result, 4\n\n.lcomm d_result, 8  # Reserve 8 bytes for holding a 64-bit value\n\n\n\n.text\n\n.global _asmMain\n\n_asmMain:\n\npushq %rbp\n\nmovq %rsp, %rbp\n\n\n\nfinit                       # initialize FPU\n\nfldpi                       # load PI on FPU stack\n\nflds value(%rip)            # load single precision value on FPU stack\n\nfadd %st(1), %st            # st same as st(0), st(1) = PI, st(0) = 1.2\n\nfists r_value(%rip)         # copies st(0), rounds to nearest, stores in memory, r_value = 4\n\n\n\nfstps f_result(%rip)        # float store single precision (32 bits) from top of FPU stack\n\nmovss f_result(%rip), %xmm0\n\ncall _printFloat\n\n\n\nfstpl d_result(%rip)        # float store double precision (64 bits) from top of FPU stack\n\nmovsd d_result(%rip), %xmm0\n\ncall _printDouble\n\n\n\npopq %rbp\n\nretq\n\n.end\n", "# Program 8.2\n\n# x87 FPU Rounding Control - GAS, Clang/LLVM on macOS (32-bit)\n\n# Copyright (c) 2017 Hall & Slonka\n\n\n\n.data\n\ndefault_cw:  .word 0x0000\n\nnearest:     .word 0x0000\n\ndown:        .word 0x0400\n\nup:          .word 0x0800\n\nzero:        .word 0x0C00\n\n\n\n.bss\n\n.lcomm result, 4\n\n\n\n.text\n\n.globl _main\n\n_main:\n\n\n\nfinit                   # initialize FPU\n\nfstcw default_cw        # store initialized control word in default\n\nmovw default_cw, %ax    # move default control word to AX register\n\nandb $0b11110011, %ah   # clear RC field (bits 10 and 11)\n\norw %ax, nearest        # set RC bits to 00 and store in nearest\n\norw %ax, down           # set RC bits to 01 and store in down\n\norw %ax, up             # set RC bits to 10 and store in up\n\norw %ax, zero           # set RC bits to 11 and store in zero\n\n\n\nxor %ax, %ax            # sequence to verify bits\n\nmovw default_cw, %ax\n\nmovw nearest, %ax\n\nmovw down, %ax\n\nmovw up, %ax\n\nmovw zero, %ax\n\n\n\nfldcw nearest           # set desired rounding mode\n\n\n\nfldpi                   # load pi on the stack\n\nfrndint                 # round to integer (uses rounding mode)\n\nfists result            # store from FPU stack to memory\n\nmovl result, %eax       # mov rounded result to EAX\n\n\n\npushl $0\n\nsubl $4, %esp\n\nmovl $1, %eax\n\nint $0x80\n\n.end\n", "# Program 8.2\n\n# x87 FPU Rounding Control - GAS, Clang/LLVM on Linux (32-bit)\n\n# Copyright (c) 2017 Hall & Slonka\n\n\n\n.data\n\ndefault_cw:  .word 0x0000\n\nnearest:     .word 0x0000\n\ndown:        .word 0x0400\n\nup:          .word 0x0800\n\nzero:        .word 0x0C00\n\n\n\n.bss\n\n.lcomm result, 4\n\n\n\n.text\n\n.globl _main\n\n_main:\n\n\n\nfinit                   # initialize FPU\n\nfstcw default_cw        # store initialized control word in default\n\nmovw default_cw, %ax    # move default control word to AX register\n\nandb $0b11110011, %ah   # clear RC field (bits 10 and 11)\n\norw %ax, nearest        # set RC bits to 00 and store in nearest\n\norw %ax, down           # set RC bits to 01 and store in down\n\norw %ax, up             # set RC bits to 10 and store in up\n\norw %ax, zero           # set RC bits to 11 and store in zero\n\n\n\nxor %ax, %ax            # sequence to verify bits\n\nmovw default_cw, %ax\n\nmovw nearest, %ax\n\nmovw down, %ax\n\nmovw up, %ax\n\nmovw zero, %ax\n\n\n\nfldcw nearest           # set desired rounding mode\n\n\n\nfldpi                   # load pi on the stack\n\nfrndint                 # round to integer (uses rounding mode)\n\nfists result            # store from FPU stack to memory\n\nmovl result, %eax       # mov rounded result to EAX\n\n\n\nmovl $1, %eax\n\nmovl $0, %ebx\n\nint $0x80\n\n.end\n", "# Program 8.2\n\n# x87 FPU Rounding Control - GAS, Clang/LLVM on macOS (64-bit)\n\n# Copyright (c) 2019 Hall & Slonka\n\n\n\n.data\n\ndefault_cw:  .word 0x0000\n\nnearest:     .word 0x0000\n\ndown:        .word 0x0400\n\nup:          .word 0x0800\n\nzero:        .word 0x0C00\n\n\n\n.bss\n\n.lcomm result, 8\n\n\n\n.text\n\n.global _main\n\n_main:\n\n\n\nfinit                           # initialize FPU\n\nfstcw default_cw(%rip)          # store initialized control word in default\n\nmovw default_cw(%rip), %ax      # move default control word to AX register\n\nandb $0b11110011, %ah           # clear RC field (bits 10 and 11)\n\norw %ax, nearest(%rip)          # set RC bits to 00 and store in nearest\n\norw %ax, down(%rip)             # set RC bits to 01 and store in down\n\norw %ax, up(%rip)               # set RC bits to 10 and store in up\n\norw %ax, zero(%rip)             # set RC bits to 11 and store in zero\n\n\n\nxor %ax, %ax                    # sequence to verify bits\n\nmovw default_cw(%rip), %ax\n\nmovw nearest(%rip), %ax\n\nmovw down(%rip), %ax\n\nmovw up(%rip), %ax\n\nmovw zero(%rip), %ax\n\n\n\nfldcw nearest(%rip)             # set desired rounding mode\n\n\n\nfldpi                           # load pi on the stack\n\nfrndint                         # round to integer (uses rounding mode)\n\nfistpq result(%rip)             # store from FPU stack to memory\n\nmovq result(%rip), %rax         # mov rounded result to RAX\n\n\n\nmovq $0x2000001, %rax\n\nxorq %rdi, %rdi\n\nsyscall\n\n.end\n", "# Program 8.2\n\n# x87 FPU Rounding Control - GAS, Clang/LLVM on Linux (64-bit)\n\n# Copyright (c) 2019 Hall & Slonka\n\n\n\ndefault_cw:  .word 0x0000\n\nnearest:     .word 0x0000\n\ndown:        .word 0x0400\n\nup:          .word 0x0800\n\nzero:        .word 0x0C00\n\n\n\n.bss\n\n.lcomm result, 8\n\n\n\n.text\n\n.global _main\n\n_main:\n\n\n\nfinit                           # initialize FPU\n\nfstcw default_cw(%rip)          # store initialized control word in default\n\nmovw default_cw(%rip), %ax      # move default control word to AX register\n\nandb $0b11110011, %ah           # clear RC field (bits 10 and 11)\n\norw %ax, nearest(%rip)          # set RC bits to 00 and store in nearest\n\norw %ax, down(%rip)             # set RC bits to 01 and store in down\n\norw %ax, up(%rip)               # set RC bits to 10 and store in up\n\norw %ax, zero(%rip)             # set RC bits to 11 and store in zero\n\n\n\nxor %ax, %ax                    # sequence to verify bits\n\nmovw default_cw(%rip), %ax\n\nmovw nearest(%rip), %ax\n\nmovw down(%rip), %ax\n\nmovw up(%rip), %ax\n\nmovw zero(%rip), %ax\n\n\n\nfldcw nearest(%rip)             # set desired rounding mode\n\n\n\nfldpi                           # load pi on the stack\n\nfrndint                         # round to integer (uses rounding mode)\n\nfistpq result(%rip)             # store from FPU stack to memory\n\nmovq result(%rip), %rax         # mov rounded result to RAX\n\n\n\nmovq $60, %rax\n\nxorq %rdi, %rdi\n\nsyscall\n\n.end\n", "# Program 8.4\n\n# SSE Packed Operations - GAS, Clang/LLVM on macOS (32-bit)\n\n# Copyright (c) 2017 Hall & Slonka\n\n\n\n.data\n\n.balign 16              # 16-byte alignment\n\nvectorA: .float 1.2, 3.4, 5.6, 7.8\n\nvectorB: .float 7.8, 5.6, 3.4, 1.2\n\n\n\n.bss\n\n.lcomm result, 128      # space for storing results\n\n\n\n.text\n\n.globl _main\n\n_main:\n\n\n\nmovaps vectorA, %xmm0   # move aligned packed SP vectorA to XMM0\n\naddps  vectorB, %xmm0   # add vectorB to XMM0\n\nmovaps %xmm0, result    # move data to result\n\n\n\npushl $0\n\nsubl $4, %esp\n\nmovl $1, %eax\n\nint $0x80\n\n.end\n", "# Program 8.4\n\n# SSE Packed Operations - GAS, Clang/LLVM on Linux (32-bit)\n\n# Copyright (c) 2017 Hall & Slonka\n\n\n\n.data\n\n.balign 16              # 16-byte alignment\n\nvectorA: .float 1.2, 3.4, 5.6, 7.8\n\nvectorB: .float 7.8, 5.6, 3.4, 1.2\n\n\n\n.bss\n\n.lcomm result, 128      # space for storing results\n\n\n\n.text\n\n.globl _main\n\n_main:\n\n\n\nmovaps vectorA, %xmm0   # move aligned packed SP vectorA to XMM0\n\naddps  vectorB, %xmm0   # add vectorB to XMM0\n\nmovaps %xmm0, result    # move data to result\n\n\n\nmovl $1, %eax\n\nmovl $0, %ebx\n\nint $0x80\n\n.end\n", "# Program 8.4\n\n# SSE Packed Operations - GAS, Clang/LLVM on macOS (64-bit)\n\n# Copyright (c) 2019 Hall & Slonka\n\n\n\n.data\n\n.balign 16                      # 16-byte alignment\n\nvectorA: .float 1.2, 3.4, 5.6, 7.8\n\nvectorB: .float 7.8, 5.6, 3.4, 1.2\n\n\n\n.bss\n\n.lcomm result, 128              # space for storing results\n\n\n\n.text\n\n.global _main\n\n_main:\n\n\n\nmovaps vectorA(%rip), %xmm0     # move aligned packed SP vectorA to XMM0\n\naddps  vectorB(%rip), %xmm0     # add vectorB to XMM0\n\nmovaps %xmm0, result(%rip)      # move data to result\n\n\n\nmovq $0x2000001, %rax\n\nxorq %rdi, %rdi\n\nsyscall\n\n.end\n", "# Program 8.4\n\n# SSE Packed Operations - GAS, Clang/LLVM on Linux (64-bit)\n\n# Copyright (c) 2019 Hall & Slonka\n\n\n\n.data\n\n.balign 16                      # 16-byte alignment\n\nvectorA: .float 1.2, 3.4, 5.6, 7.8\n\nvectorB: .float 7.8, 5.6, 3.4, 1.2\n\n\n\n.bss\n\n.lcomm result, 128              # space for storing results\n\n\n\n.text\n\n.global _main\n\n_main:\n\n\n\nmovaps vectorA(%rip), %xmm0     # move aligned packed SP vectorA to XMM0\n\naddps  vectorB(%rip), %xmm0     # add vectorB to XMM0\n\nmovaps %xmm0, result(%rip)      # move data to result\n\n\n\nmovq $60, %rax\n\nxorq %rdi, %rdi\n\nsyscall\n\n.end\n", "# Program 8.3\n\n# MMX - GAS, Clang/LLVM on macOS (32-bit)\n\n# Copyright (c) 2017 Hall & Slonka\n\n\n\n.data\n\nw1: .word 1, 2, 3, 4\n\nw5: .word 5, 6, 7, 8\n\nresult: .quad 0\n\n\n\n.text\n\n.globl _main\n\n_main:\n\n\n\nmovq w1, %mm0        # move quadword w1-w4 to MM0\n\nmovq w5, %mm1        # move quadword w5-w8 to MM1\n\n\n\npaddsw %mm1, %mm0    # add packed signed words\n\nmovq %mm0, result    # move data to result\n\n\n\npushl $0\n\nsubl $4, %esp\n\nmovl $1, %eax\n\nint $0x80\n\n.end\n", "# Program 8.3\n\n# MMX - GAS, Clang/LLVM on Linux (32-bit)\n\n# Copyright (c) 2017 Hall & Slonka\n\n\n\n.data\n\nw1: .word 1, 2, 3, 4\n\nw5: .word 5, 6, 7, 8\n\nresult: .quad 0\n\n\n\n.text\n\n.globl _main\n\n_main:\n\n\n\nmovq w1, %mm0        # move quadword w1-w4 to MM0\n\nmovq w5, %mm1        # move quadword w5-w8 to MM1\n\n\n\npaddsw %mm1, %mm0    # add packed signed words\n\nmovq %mm0, result    # move data to result\n\n\n\nmovl $1, %eax\n\nmovl $0, %ebx\n\nint $0x80\n\n.end\n", "# Program 8.3\n\n# MMX - GAS, Clang/LLVM on macOS (64-bit)\n\n# Copyright (c) 2019 Hall & Slonka\n\n\n\n.data\n\nw1: .word 1, 2, 3, 4\n\nw5: .word 5, 6, 7, 8\n\nresult: .quad 0\n\n\n\n.text\n\n.global _main\n\n_main:\n\n\n\nmovq w1(%rip), %mm0     # move quadword w1-w4 to MM0\n\nmovq w5(%rip), %mm1     # move quadword w5-w8 to MM1\n\n\n\npaddsw %mm1, %mm0       # add packed signed words\n\nmovq %mm0, result(%rip) # move data to result\n\n\n\nmovq $0x2000001, %rax\n\nxorq %rdi, %rdi\n\nsyscall\n\n.end\n", "# Program 8.3\n\n# MMX - GAS, Clang/LLVM on Linux (64-bit)\n\n# Copyright (c) 2019 Hall & Slonka\n\n\n\n.data\n\nw1: .word 1, 2, 3, 4\n\nw5: .word 5, 6, 7, 8\n\nresult: .quad 0\n\n\n\n.text\n\n.global _main\n\n_main:\n\n\n\nmovq w1(%rip), %mm0     # move quadword w1-w4 to MM0\n\nmovq w5(%rip), %mm1     # move quadword w5-w8 to MM1\n\n\n\npaddsw %mm1, %mm0       # add packed signed words\n\nmovq %mm0, result(%rip) # move data to result\n\n\n\nmovq $60, %rax\n\nxorq %rdi, %rdi\n\nsyscall\n\n.end\n", "# Program 8.5\n\n# SSE Scalar Operations - GAS, Clang/LLVM on macOS (32-bit)\n\n# Copyright (c) 2017 Hall & Slonka\n\n\n\n.data\n\n.balign 16\n\nvalueA: .float 1.2\n\npi: .double 3.14159265358979\n\n\n\n.bss\n\n.lcomm result, 4        # space for storing result\n\n\n\n.text\n\n.globl _main\n\n_main:                  # scalar examples\n\n\n\nmovss  valueA, %xmm0    # move valueA to XMM0\n\naddss  valueA, %xmm0    # add valueA to XMM0\n\nmovss  %xmm0, result    # store result\n\nmovl   result, %eax     # move result to EAX\n\n\n\nmovsd  pi, %xmm0        # move pi to XMM0\n\n\n\npushl $0\n\nsubl $4, %esp\n\nmovl $1, %eax\n\nint $0x80\n\n.end\n", "# Program 8.5\n\n# SSE Scalar Operations - GAS, Clang/LLVM on Linux (32-bit)\n\n# Copyright (c) 2017 Hall & Slonka\n\n\n\n.data\n\n.balign 16\n\nvalueA: .float 1.2\n\npi: .double 3.14159265358979\n\n\n\n.bss\n\n.lcomm result, 4        # space for storing result\n\n\n\n.text\n\n.globl _main\n\n_main:                  # scalar examples\n\n\n\nmovss  valueA, %xmm0    # move valueA to XMM0\n\naddss  valueA, %xmm0    # add valueA to XMM0\n\nmovss  %xmm0, result    # store result\n\nmovl   result, %eax     # move result to EAX\n\n\n\nmovsd  pi, %xmm0        # move pi to XMM0\n\n\n\nmovl $1, %eax\n\nmovl $0, %ebx\n\nint $0x80\n\n.end\n", "# Program 8.5\n\n# SSE Scalar Operations - GAS, Clang/LLVM on macOS (64-bit)\n\n# Copyright (c) 2019 Hall & Slonka\n\n\n\n.data\n\n.balign 16\n\nvalueA: .float 1.2\n\npi: .double 3.14159265358979\n\n\n\n.bss\n\n.lcomm result, 4            # space for storing result\n\n\n\n.text\n\n.global _main\n\n_main:                      # scalar examples\n\n\n\nmovss  valueA(%rip), %xmm0  # move valueA to XMM0\n\naddss  valueA(%rip), %xmm0  # add valueA to XMM0\n\nmovss  %xmm0, result(%rip)  # store result\n\nmovl   result(%rip), %eax   # move result to EAX\n\n\n\nmovsd  pi(%rip), %xmm0      # move pi to XMM0\n\n\n\nmovq $0x2000001, %rax\n\nxorq %rdi, %rdi\n\nsyscall\n\n.end\n", "# Program 8.5\n\n# SSE Scalar Operations - GAS, Clang/LLVM on Linux (64-bit)\n\n# Copyright (c) 2019 Hall & Slonka\n\n\n\n.data\n\n.balign 16\n\nvalueA: .float 1.2\n\npi: .double 3.14159265358979\n\n\n\n.bss\n\n.lcomm result, 4            # space for storing result\n\n\n\n.text\n\n.global _main\n\n_main:                      # scalar examples\n\n\n\nmovss  valueA(%rip), %xmm0  # move valueA to XMM0\n\naddss  valueA(%rip), %xmm0  # add valueA to XMM0\n\nmovss  %xmm0, result(%rip)  # store result\n\nmovl   result(%rip), %eax   # move result to EAX\n\n\n\nmovsd  pi(%rip), %xmm0      # move pi to XMM0\n\n\n\nmovq $60, %rax\n\nxorq %rdi, %rdi\n\nsyscall\n\n.end\n", "# Program 8.8\n\n# AVX - GAS, Clang/LLVM on macOS (32-bit)\n\n# Copyright (c) 2017 Hall & Slonka\n\n\n\n.data\n\n.balign 16\n\nvectorA: .float 1.2, 3.4, 5.6, 7.8, 8.9, 9.0, 0.9, 9.8\n\nvectorB: .float 7.8, 5.6, 3.4, 1.2, 0.1, 0.0, 8.1, -0.8\n\nvectorC: .long 1, 1, 1, 1\n\nvectorD: .long -2, -2, -2, -2\n\n\n\n.text\n\n.globl _main\n\n_main:                          # AVX/AVX2 example\n\n\n\nvmovaps  vectorA, %ymm0         # move vectorA to YMM0\n\nvmovaps  vectorB, %ymm1         # move vectorA to YMM1\n\nvaddps   %ymm0, %ymm1, %ymm2    # add vectorA and B, store in YMM2\n\n\n\nvmovdqa  vectorC, %xmm3         # move vectorC to XMM3\n\nvmovdqa  vectorC, %xmm4         # move vectorC to XMM4\n\nvpsignd  vectorD, %xmm3, %xmm4  # negate sign of XMM3 values if vectorD\n\n                                #   values are < 0, store in XMM4\n\n                                # vpsign AVX support\n\n                                #   (CPUID for 128 or 256-bit capability)\n\n\n\npushl $0\n\nsubl $4, %esp\n\nmovl $1, %eax\n\nint $0x80\n\n.end\n", "# Program 8.8\n\n# AVX - GAS, Clang/LLVM on Linux (32-bit)\n\n# Copyright (c) 2017 Hall & Slonka\n\n\n\n.data\n\n.balign 16\n\nvectorA: .float 1.2, 3.4, 5.6, 7.8, 8.9, 9.0, 0.9, 9.8\n\nvectorB: .float 7.8, 5.6, 3.4, 1.2, 0.1, 0.0, 8.1, -0.8\n\nvectorC: .long 1, 1, 1, 1\n\nvectorD: .long -2, -2, -2, -2\n\n\n\n.text\n\n.globl _main\n\n_main:                          # AVX/AVX2 example\n\n\n\nvmovaps  vectorA, %ymm0         # move vectorA to YMM0\n\nvmovaps  vectorB, %ymm1         # move vectorA to YMM1\n\nvaddps   %ymm0, %ymm1, %ymm2    # add vectorA and B, store in YMM2\n\n\n\nvmovdqa  vectorC, %xmm3         # move vectorC to XMM3\n\nvmovdqa  vectorC, %xmm4         # move vectorC to XMM4\n\nvpsignd  vectorD, %xmm3, %xmm4  # negate sign of XMM3 values if vectorD\n\n                                #   values are < 0, store in XMM4\n\n                                # vpsign AVX support\n\n                                #   (CPUID for 128 or 256-bit capability)\n\n\n\nmovl $1, %eax\n\nmovl $0, %ebx\n\nint $0x80\n\n.end\n", "# Program 8.8\n\n# AVX - GAS, Clang/LLVM on macOS (64-bit)\n\n# Copyright (c) 2019 Hall & Slonka\n\n\n\n.data\n\n.balign 16\n\nvectorA: .float 1.2, 3.4, 5.6, 7.8, 8.9, 9.0, 0.9, 9.8\n\nvectorB: .float 7.8, 5.6, 3.4, 1.2, 0.1, 0.0, 8.1, -0.8\n\nvectorC: .long 1, 1, 1, 1\n\nvectorD: .long -2, -2, -2, -2\n\n\n\n.text\n\n.global _main\n\n_main:                                  # AVX/AVX2 example\n\n\n\nvmovaps  vectorA(%rip), %ymm0           # move vectorA to YMM0\n\nvmovaps  vectorB(%rip), %ymm1           # move vectorA to YMM1\n\nvaddps   %ymm0, %ymm1, %ymm2            # add vectorA and B, store in YMM2\n\n\n\nvmovdqa  vectorC(%rip), %xmm3           # move vectorC to XMM3\n\nvmovdqa  vectorC(%rip), %xmm4           # move vectorC to XMM4\n\nvpsignd  vectorD(%rip), %xmm3, %xmm4    # negate sign of XMM3 values if vectorD\n\n                                        #   values are < 0, store in XMM4\n\n                                        # vpsign AVX support\n\n                                        #   (CPUID for 128 or 256-bit capability)\n\n\n\nmovq $0x2000001, %rax\n\nxorq %rdi, %rdi\n\nsyscall\n\n.end\n", "# Program 8.8\n\n# AVX - GAS, Clang/LLVM on Linux (64-bit)\n\n# Copyright (c) 2019 Hall & Slonka\n\n\n\n.data\n\n.balign 16\n\nvectorA: .float 1.2, 3.4, 5.6, 7.8, 8.9, 9.0, 0.9, 9.8\n\nvectorB: .float 7.8, 5.6, 3.4, 1.2, 0.1, 0.0, 8.1, -0.8\n\nvectorC: .long 1, 1, 1, 1\n\nvectorD: .long -2, -2, -2, -2\n\n\n\n.text\n\n.global _main\n\n_main:                                  # AVX/AVX2 example\n\n\n\nvmovaps  vectorA(%rip), %ymm0           # move vectorA to YMM0\n\nvmovaps  vectorB(%rip), %ymm1           # move vectorA to YMM1\n\nvaddps   %ymm0, %ymm1, %ymm2            # add vectorA and B, store in YMM2\n\n\n\nvmovdqa  vectorC(%rip), %xmm3           # move vectorC to XMM3\n\nvmovdqa  vectorC(%rip), %xmm4           # move vectorC to XMM4\n\nvpsignd  vectorD(%rip), %xmm3, %xmm4    # negate sign of XMM3 values if vectorD\n\n                                        #   values are < 0, store in XMM4\n\n                                        # vpsign AVX support\n\n                                        #   (CPUID for 128 or 256-bit capability)\n\n\n\nmovq $60, %rax\n\nxorq %rdi, %rdi\n\nsyscall\n\n.end\n", "# Program 8.9\n\n# x86_64 Investment Calculator - GAS, Clang/LLVM (64-bit)\n\n# Copyright (c) 2017 Hall & Slonka\n\n\n\n# This program calculates a monthly deposit needed to reach an investment\n\n# value, given the future value, interest rate (%), and duration (months)\n\n\n\n.extern _printString               # declare external functions\n\n.extern _printDouble\n\n.extern _getDouble\n\n.extern _getInt\n\n\n\n.data\n\n.balign 16                         # align data on 16-byte boundary\n\namountNeeded:   .double 0.0\n\ninterestRate:   .double 0.0\n\ninterest:       .double 0.0\n\nmonthlyPayment: .double 0.0\n\nduration:       .quad   0          # integer data\n\nconst100:       .double 100.0\n\nconst12:        .double 12.0\n\nconst1:         .double 1.0\n\n\n\namountMessage:   .asciz  \"       Enter Amount Needed:  $\"\n\ninterestMessage: .asciz  \"       Enter Interest Rate:  \"\n\ndurationMessage: .asciz  \"Enter Duration (in months):  \"\n\npaymentMessage:  .asciz  \"    Monthly Payment Amount:  $\"\n\n\n\n.text\n\n.global _asmMain\n\n_asmMain:\n\n\n\npushq\t%rbp\n\nmovq\t%rsp, %rbp                 # align stack pointer\n\n\n\nleaq amountMessage(%rip), %rdi     # pass char* to print\n\ncallq\t_printString\n\ncallq _getDouble                   # get and store amountNeeded\n\nmovsd %xmm0, amountNeeded(%rip)\n\n\n\nleaq interestMessage(%rip), %rdi   # pass char* to print\n\ncallq\t_printString\n\ncallq _getDouble                   # get interestRate as a %\n\n\n\nmovsd const100(%rip), %xmm1        # divide rate by 100\n\ndivsd %xmm1, %xmm0\n\nmovsd %xmm0, interestRate(%rip)    # store rate as decimal value\n\n\n\nleaq durationMessage(%rip), %rdi   # pass char* to print\n\ncallq\t_printString\n\ncallq _getInt                      # get and store duration\n\nmovq %rax, duration(%rip)\n\n\n\nmovsd const12(%rip), %xmm0         # interest = interestRate / const12\n\nmovsd interestRate(%rip), %xmm1\n\ndivsd %xmm0, %xmm1\n\nmovsd %xmm1, interest(%rip)\n\n\n\nmovsd interest(%rip), %xmm0        # investment formula (see Ch8 Supplement)\n\nmovsd amountNeeded(%rip), %xmm1\n\nmulsd %xmm0, %xmm1                 # interest * amount needed, then store\n\nmovsd %xmm1, %xmm2\n\n\n\naddsd const1(%rip), %xmm0          # add 1 to interest\n\nmovq duration(%rip), %rdi\n\ncallq _pow                         # pow(interest, duration)\n\nsubsd const1(%rip), %xmm0          # subtract 1 from result\n\nvdivsd %xmm0, %xmm2, %xmm1         # complete formula with division\n\nmovsd %xmm1, monthlyPayment(%rip)\n\n\n\nleaq paymentMessage(%rip), %rdi    # pass char* to print\n\ncallq\t_printString\n\nmovsd monthlyPayment(%rip), %xmm0\n\ncallq\t_printDouble               # print monthlyPayment\n\n\n\npopq\t%rbp\n\nretq                               # end _asmMain\n\n\n\n_pow:                              # pow function\n\npushq\t%rbp\n\nmovq %rsp, %rbp\n\nmovq %rdi, %rcx                    # use rcx for loop countdown\n\ndecq %rcx\n\nmovsd %xmm0, %xmm1\n\n\n\nexp:                               # multiply by value duration times\n\nmulsd %xmm1, %xmm0\n\nloop exp\n\n\n\npopq\t%rbp\n\nretq                               # end _pow\n\n\n\n.end\n", "# Program 8.9\n\n# x86_64 Investment Calculator - GAS, g++, Clang/LLVM on Linux (64-bit)\n\n# Copyright (c) 2017 Hall & Slonka\n\n\n\n# This program calculates a monthly deposit needed to reach an investment\n\n# value, given the future value, interest rate (%), and duration (months)\n\n\n\n.extern _printString               # declare external functions\n\n.extern _printDouble\n\n.extern _getDouble\n\n.extern _getInt\n\n\n\n.data\n\n.balign 16                         # align data on 16-byte boundary\n\namountNeeded:   .double 0.0\n\ninterestRate:   .double 0.0\n\ninterest:       .double 0.0\n\nmonthlyPayment: .double 0.0\n\nduration:       .quad   0          # integer data\n\nconst100:       .double 100.0\n\nconst12:        .double 12.0\n\nconst1:         .double 1.0\n\n\n\namountMessage:   .asciz  \"       Enter Amount Needed:  $\"\n\ninterestMessage: .asciz  \"       Enter Interest Rate:  \"\n\ndurationMessage: .asciz  \"Enter Duration (in months):  \"\n\npaymentMessage:  .asciz  \"    Monthly Payment Amount:  $\"\n\n\n\n.text\n\n.globl _asmMain\n\n_asmMain:\n\n\n\npushq\t%rbp\n\nmovq\t%rsp, %rbp                 # align stack pointer\n\n\n\nleaq amountMessage(%rip), %rdi     # pass char* to print\n\ncallq\t_printString\n\ncallq _getDouble                   # get and store amountNeeded\n\nmovsd %xmm0, amountNeeded(%rip)\n\n\n\nleaq interestMessage(%rip), %rdi   # pass char* to print\n\ncallq\t_printString\n\ncallq _getDouble                   # get interestRate as a %\n\n\n\nmovsd const100(%rip), %xmm1        # divide rate by 100\n\ndivsd %xmm1, %xmm0\n\nmovsd %xmm0, interestRate(%rip)    # store rate as decimal value\n\n\n\nleaq durationMessage(%rip), %rdi   # pass char* to print\n\ncallq\t_printString\n\ncallq _getInt                      # get and store duration\n\nmovq %rax, duration(%rip)\n\n\n\nmovsd const12(%rip), %xmm0         # interest = interestRate / const12\n\nmovsd interestRate(%rip), %xmm1\n\ndivsd %xmm0, %xmm1\n\nmovsd %xmm1, interest(%rip)\n\n\n\nmovsd interest(%rip), %xmm0        # investment formula (see Ch8 Supplement)\n\nmovsd amountNeeded(%rip), %xmm1\n\nmulsd %xmm0, %xmm1                 # interest * amount needed, then store\n\nmovsd %xmm1, %xmm2\n\n\n\naddsd const1(%rip), %xmm0          # add 1 to interest\n\nmovq duration(%rip), %rdi\n\ncallq _pow                         # pow(interest, duration)\n\nsubsd const1(%rip), %xmm0          # subtract 1 from result\n\nvdivsd %xmm0, %xmm2, %xmm1         # complete formula with division\n\nmovsd %xmm1, monthlyPayment(%rip)\n\n\n\nleaq paymentMessage(%rip), %rdi    # pass char* to print\n\ncallq\t_printString\n\nmovsd monthlyPayment(%rip), %xmm0\n\ncallq\t_printDouble               # print monthlyPayment\n\n\n\npopq\t%rbp\n\nretq                               # end _asmMain\n\n\n\n_pow:                              # pow function\n\npushq\t%rbp\n\nmovq %rsp, %rbp\n\nmovq %rdi, %rcx                    # use rcx for loop countdown\n\ndecq %rcx\n\nmovsd %xmm0, %xmm1\n\n\n\nexp:                               # multiply by value duration times\n\nmulsd %xmm1, %xmm0\n\nloop exp\n\n\n\npopq\t%rbp\n\nretq                               # end _pow\n\n\n\n.end\n", "# Program 8.7\n\n# SSE4 - GAS, Clang/LLVM on macOS (32-bit)\n\n# Copyright (c) 2017 Hall & Slonka\n\n\n\n.data\n\n.balign 16\n\nvectorA: .float 1.2, 3.4, 5.6, 7.8\n\nvectorB: .float 7.8, 5.6, 3.4, 1.2\n\n\n\n.text\n\n.globl _main\n\n_main:\n\n\n\nmovaps  vectorA, %xmm0     # move aligned packed vectorA to XMM0\n\nroundps $1, %xmm0, %xmm1   # round down(1) values in XMM0 and store in XMM1\n\ncvtps2dq %xmm1, %xmm2      # convert SPF to int and store in XMM2\n\n\n\nmovaps  vectorB, %xmm3     # move aligned packed vectorB to XMM3\n\nroundps $2, %xmm3, %xmm4   # round up(2) values in XMM3 and store in XMM4\n\ncvtps2dq %xmm4, %xmm5      # convert SPF to int and store in XMM5\n\n\n\npmulld  %xmm2, %xmm5       # multiply doublewords and store in XMM5\n\n\n\npushl $0\n\nsubl $4, %esp\n\nmovl $1, %eax\n\nint $0x80\n\n.end\n", "# Program 8.7\n\n# SSE4 - GAS, Clang/LLVM on Linux (32-bit)\n\n# Copyright (c) 2017 Hall & Slonka\n\n\n\n.data\n\n.balign 16\n\nvectorA: .float 1.2, 3.4, 5.6, 7.8\n\nvectorB: .float 7.8, 5.6, 3.4, 1.2\n\n\n\n.text\n\n.globl _main\n\n_main:\n\n\n\nmovaps  vectorA, %xmm0     # move aligned packed vectorA to XMM0\n\nroundps $1, %xmm0, %xmm1   # round down(1) values in XMM0 and store in XMM1\n\ncvtps2dq %xmm1, %xmm2      # convert SPF to int and store in XMM2\n\n\n\nmovaps  vectorB, %xmm3     # move aligned packed vectorB to XMM3\n\nroundps $2, %xmm3, %xmm4   # round up(2) values in XMM3 and store in XMM4\n\ncvtps2dq %xmm4, %xmm5      # convert SPF to int and store in XMM5\n\n\n\npmulld  %xmm2, %xmm5       # multiply doublewords and store in XMM5\n\n\n\nmovl $1, %eax\n\nmovl $0, %ebx\n\nint $0x80\n\n.end\n", "# Program 8.7\n\n# SSE4 - GAS, Clang/LLVM on macOS (64-bit)\n\n# Copyright (c) 2019 Hall & Slonka\n\n\n\n.data\n\n.balign 16\n\nvectorA: .float 1.2, 3.4, 5.6, 7.8\n\nvectorB: .float 7.8, 5.6, 3.4, 1.2\n\n\n\n.text\n\n.global _main\n\n_main:\n\n\n\nmovaps  vectorA(%rip), %xmm0    # move aligned packed vectorA to XMM0\n\nroundps $1, %xmm0, %xmm1        # round down(1) values in XMM0 and store in XMM1\n\ncvtps2dq %xmm1, %xmm2           # convert SPF to int and store in XMM2\n\n\n\nmovaps  vectorB(%rip), %xmm3    # move aligned packed vectorB to XMM3\n\nroundps $2, %xmm3, %xmm4        # round up(2) values in XMM3 and store in XMM4\n\ncvtps2dq %xmm4, %xmm5           # convert SPF to int and store in XMM5\n\n\n\npmulld  %xmm2, %xmm5            # multiply doublewords and store in XMM5\n\n\n\nmovq $0x2000001, %rax\n\nxorq %rdi, %rdi\n\nsyscall\n\n.end\n", "# Program 8.7\n\n# SSE4 - GAS, Clang/LLVM on Linux (64-bit)\n\n# Copyright (c) 2019 Hall & Slonka\n\n\n\n.data\n\n.balign 16\n\nvectorA: .float 1.2, 3.4, 5.6, 7.8\n\nvectorB: .float 7.8, 5.6, 3.4, 1.2\n\n\n\n.text\n\n.global _main\n\n_main:\n\n\n\nmovaps  vectorA(%rip), %xmm0    # move aligned packed vectorA to XMM0\n\nroundps $1, %xmm0, %xmm1        # round down(1) values in XMM0 and store in XMM1\n\ncvtps2dq %xmm1, %xmm2           # convert SPF to int and store in XMM2\n\n\n\nmovaps  vectorB(%rip), %xmm3    # move aligned packed vectorB to XMM3\n\nroundps $2, %xmm3, %xmm4        # round up(2) values in XMM3 and store in XMM4\n\ncvtps2dq %xmm4, %xmm5           # convert SPF to int and store in XMM5\n\n\n\npmulld  %xmm2, %xmm5            # multiply doublewords and store in XMM5\n\n\n\nmovq $60, %rax\n\nxorq %rdi, %rdi\n\nsyscall\n\n.end\n", "# Modified from https://github.com/riscv/riscv-tests\n\n.include \"riscv_test.h\"       # defines the macros (in all-caps)\n\n\n\nRVTEST_RV64U                  # define TVM used by program\n\n\n\n# Test code\n\nRVTEST_CODE_BEGIN             # Start of test code\n\n        lw      x2, testdata  # load word into x2 (41)\n\n        addi    x2, 1         # add 1 to x2 (our result)\n\n        sw      x2, result    # store word into memory overwriting -1s.\n\n        li      x3, 42        # load immediate into x3 (desired result)\n\n        bne     x2, x3, fail  # branch if not equal: Fail if no match\n\n        RVTEST_PASS           # else success\n\nfail:\n\n        RVTEST_FAIL\n\nRVTEST_CODE_END               # End of test code\n\n\n\n# Input data section\n\n# This section is optional, the data is NOT saved in the output\n\n.data\n\n        .align 3\n\ntestdata:\n\n        .dword 41\n\n\n\n# Output data section\n\nRVTEST_DATA_BEGIN   # Start of test output data region\n\n        .align 3\n\nresult:\n\n        .dword -1\n\nRVTEST_DATA_END     # End of test output data region\n", "# Chapter 1\n\n# Assembly Bubble Sort - GAS, Clang/LLVM on Linux (32-bit)\n\n# Copyright (c) 2017 Hall & Slonka\n\n\n\n.data\n\narray: .long 3, 2, 6, 4, 1\n\ncount: .long 5\n\n\n\n.text\n\n.globl _main\n\n_main:\n\n\n\nmov count, %ecx\n\ndec %ecx\n\n\n\nouterLoop:\n\npush %ecx\n\nlea array, %esi\n\n\n\ninnerLoop:\n\nmov (%esi), %eax\n\ncmp %eax, 4(%esi)\n\njg nextStep\n\nxchg 4(%esi), %eax\n\nmov %eax, (%esi)\n\n\n\nnextStep:\n\nadd $4, %esi\n\nloop innerLoop\n\npop %ecx\n\nloop outerLoop\n\n\n\nmovl $1, %eax\n\nmovl $0, %ebx\n\nint $0x80\n\n.end\n", "# Chapter 1\n\n# Assembly Bubble Sort - GAS, Clang/LLVM on macOS (32-bit)\n\n# Copyright (c) 2017 Hall & Slonka\n\n\n\n.data\n\narray: .long 3, 2, 6, 4, 1\n\ncount: .long 5\n\n\n\n.text\n\n.globl _main\n\n_main:\n\n\n\nmov count, %ecx\n\ndec %ecx\n\n\n\nouterLoop:\n\npush %ecx\n\nlea array, %esi\n\n\n\ninnerLoop:\n\nmov (%esi), %eax\n\ncmp %eax, 4(%esi)\n\njg nextStep\n\nxchg 4(%esi), %eax\n\nmov %eax, (%esi)\n\n\n\nnextStep:\n\nadd $4, %esi\n\nloop innerLoop\n\npop %ecx\n\nloop outerLoop\n\n\n\npush $0\n\nsub $4, %esp\n\nmov $1, %eax\n\nint $0x80\n\n.end\n", "# Chapter 1\n\n# Assembly Bubble Sort - GAS, Clang/LLVM on Linux (64-bit)\n\n# Copyright (c) 2019 Hall & Slonka\n\n\n\n.data\n\narray: .long 3, 2, 6, 4, 1\n\ncount: .long 5\n\n\n\n.text\n\n.global _main\n\n_main:\n\n\n\nmovslq count(%rip), %rcx\n\ndec %rcx\n\n\n\nouterLoop:\n\npush %rcx\n\nleaq array(%rip), %rsi\n\n\n\ninnerLoop:\n\nmovl (%rsi), %eax\n\ncmpl %eax, 4(%rsi)\n\njg nextStep\n\nxchgl 4(%rsi), %eax\n\nmovl %eax, (%rsi)\n\n\n\nnextStep:\n\naddq $4, %rsi\n\nloop innerLoop\n\npopq %rcx\n\nloop outerLoop\n\n\n\nmovq $60, %rax\n\nxorq %rdi, %rdi\n\nsyscall\n\n.end\n", "# Chapter 1\n\n# Assembly Bubble Sort - GAS, Clang/LLVM on macOS (64-bit)\n\n# Copyright (c) 2019 Hall & Slonka\n\n\n\n.data\n\narray: .long 3, 2, 6, 4, 1\n\ncount: .long 5\n\n\n\n.text\n\n.global _main\n\n_main:\n\n\n\nmovslq count(%rip), %rcx\n\ndec %rcx\n\n\n\nouterLoop:\n\npush %rcx\n\nleaq array(%rip), %rsi\n\n\n\ninnerLoop:\n\nmovl (%rsi), %eax\n\ncmpl %eax, 4(%rsi)\n\njg nextStep\n\nxchgl 4(%rsi), %eax\n\nmovl %eax, (%rsi)\n\n\n\nnextStep:\n\naddq $4, %rsi\n\nloop innerLoop\n\npopq %rcx\n\nloop outerLoop\n\n\n\nmovq $0x2000001, %rax\n\nxorq %rdi, %rdi\n\nsyscall\n\n.end\n", "# Program 7.1\n\n# CMPS - GAS, Clang/LLVM on macOS (32-bit)\n\n# Copyright (c) 2017 Hall & Slonka\n\n\n\n.data\n\nsrc: .ascii \"Test sentence!\\n\\0\"\n\n.equ lenSrc, (. - src)\n\ndst: .ascii \"Test sentence!\\n\\0\"\n\n.equ lenDst, (. - dst)\n\n\n\n.text\n\n.globl _main\n\n_main:\n\n\n\n# compare string lengths\n\nmovl $lenSrc, %eax\n\ncmpl $lenDst, %eax\n\njne notequal\n\n\n\n# when lengths are equal execute CMPS\n\nleal src, %esi\n\nleal dst, %edi\n\nmovl $lenSrc, %ecx\n\ncld\n\nrepe cmpsb\n\n\n\n# after CMPS, see if it ended successfully\n\njnz notequal\n\n\n\n# equality things\n\njmp done\n\n\n\nnotequal:\n\n# non-equality things\n\n\n\ndone:\n\npushl $0\n\nsubl $4, %esp\n\nmovl $1, %eax\n\nint $0x80\n\n.end\n", "# Program 7.1\n\n# CMPS - GAS, Clang/LLVM on Linux (32-bit)\n\n# Copyright (c) 2017 Hall & Slonka\n\n\n\n.data\n\nsrc: .ascii \"Test sentence!\\n\\0\"\n\n.equ lenSrc, (. - src)\n\ndst: .ascii \"Test sentence!\\n\\0\"\n\n.equ lenDst, (. - dst)\n\n\n\n.text\n\n.globl _main\n\n_main:\n\n\n\n# compare string lengths\n\nmovl $lenSrc, %eax\n\ncmpl $lenDst, %eax\n\njne notequal\n\n\n\n# when lengths are equal execute CMPS\n\nleal src, %esi\n\nleal dst, %edi\n\nmovl $lenSrc, %ecx\n\ncld\n\nrepe cmpsb\n\n\n\n# after CMPS, see if it ended successfully\n\njnz notequal\n\n\n\n# equality things\n\njmp done\n\n\n\nnotequal:\n\n# non-equality things\n\n\n\ndone:\n\nmovl $1, %eax\n\nmovl $0, %ebx\n\nint $0x80\n\n.end\n", "# Program 7.1\n\n# CMPS - GAS, Clang/LLVM on macOS (64-bit)\n\n# Copyright (c) 2019 Hall & Slonka\n\n\n\n.data\n\nsrc: .ascii \"Test sentence!\\n\\0\"\n\n.equ lenSrc, (. - src)\n\ndst: .ascii \"Test sentence!\\n\\0\"\n\n.equ lenDst, (. - dst)\n\n\n\n.text\n\n.global _main\n\n_main:\n\n\n\n# compare string lengths\n\nmovq $lenSrc, %rax\n\ncmpq $lenDst, %rax\n\njne notequal\n\n\n\n# when lengths are equal execute CMPS\n\nleaq src(%rip), %rsi\n\nleaq dst(%rip), %rdi\n\nmovq $lenSrc, %rcx\n\ncld\n\nrepe cmpsb\n\n\n\n# after CMPS, see if it ended successfully\n\njnz notequal\n\n\n\n# equality things\n\njmp done\n\n\n\nnotequal:\n\n# non-equality things\n\n\n\ndone:\n\nmovq $0x2000001, %rax\n\nxorq %rdi, %rdi\n\nsyscall\n\n.end\n", "# Program 7.1\n\n# CMPS - GAS, Clang/LLVM on Linux (64-bit)\n\n# Copyright (c) 2019 Hall & Slonka\n\n\n\n.data\n\nsrc: .ascii \"Test sentence!\\n\\0\"\n\n.equ lenSrc, (. - src)\n\ndst: .ascii \"Test sentence!\\n\\0\"\n\n.equ lenDst, (. - dst)\n\n\n\n.text\n\n.global _main\n\n_main:\n\n\n\n# compare string lengths\n\nmovq $lenSrc, %rax\n\ncmpq $lenDst, %rax\n\njne notequal\n\n\n\n# when lengths are equal execute CMPS\n\nleaq src(%rip), %rsi\n\nleaq dst(%rip), %rdi\n\nmovq $lenSrc, %rcx\n\ncld\n\nrepe cmpsb\n\n\n\n# after CMPS, see if it ended successfully\n\njnz notequal\n\n\n\n# equality things\n\njmp done\n\n\n\nnotequal:\n\n# non-equality things\n\n\n\ndone:\n\nmovq $60, %rax\n\nxorq %rdi, %rdi\n\nsyscall\n\n.end\n", "# Program 7.2\n\n# SCAS - GAS, Clang/LLVM on macOS (32-bit)\n\n# Copyright (c) 2017 Hall & Slonka\n\n\n\n.data\n\nsrc: .ascii \"Test sentence\\0\"\n\n.equ lenSrc, (. - src)\n\nsearch: .ascii \"s\"\n\n\n\n.text\n\n.globl _main\n\n_main:\n\n\n\nxor %eax, %eax\n\nmovb search, %al\n\nleal src, %edi\n\nmovl $lenSrc, %ecx\n\ncld\n\nrepne scasb\n\n\n\n# after SCAS, test for success\n\njnz notfound\n\n\n\n# found things\n\njmp done\n\n\n\nnotfound:\n\n# non-found things\n\n\n\ndone:\n\npushl $0\n\nsubl $4, %esp\n\nmovl $1, %eax\n\nint $0x80\n\n.end\n", "# Program 7.2\n\n# SCAS - GAS, Clang/LLVM on Linux (32-bit)\n\n# Copyright (c) 2017 Hall & Slonka\n\n\n\n.data\n\nsrc: .ascii \"Test sentence\\0\"\n\n.equ lenSrc, (. - src)\n\nsearch: .ascii \"s\"\n\n\n\n.text\n\n.globl _main\n\n_main:\n\n\n\nxor %eax, %eax\n\nmovb search, %al\n\nleal src, %edi\n\nmovl $lenSrc, %ecx\n\ncld\n\nrepne scasb\n\n\n\n# after SCAS, test for success\n\njnz notfound\n\n\n\n# found things\n\njmp done\n\n\n\nnotfound:\n\n# non-found things\n\n\n\ndone:\n\nmovl $1, %eax\n\nmovl $0, %ebx\n\nint $0x80\n\n.end\n", "# Program 7.2\n\n# SCAS - GAS, Clang/LLVM on macOS (64-bit)\n\n# Copyright (c) 2019 Hall & Slonka\n\n\n\n.data\n\nsrc: .ascii \"Test sentence\\0\"\n\n.equ lenSrc, (. - src)\n\nsearch: .ascii \"s\"\n\n\n\n.text\n\n.global _main\n\n_main:\n\n\n\nxorq %rax, %rax\n\nmovb search(%rip), %al\n\nleaq src(%rip), %rdi\n\nmovq $lenSrc, %rcx\n\ncld\n\nrepne scasb\n\n\n\n# after SCAS, test for success\n\njnz notfound\n\n\n\n# found things\n\njmp done\n\n\n\nnotfound:\n\n# non-found things\n\n\n\ndone:\n\nmovq $0x2000001, %rax\n\nxorq %rdi, %rdi\n\nsyscall\n\n.end\n", "# Program 7.2\n\n# SCAS - GAS, Clang/LLVM on Linux (64-bit)\n\n# Copyright (c) 2019 Hall & Slonka\n\n\n\n.data\n\nsrc: .ascii \"Test sentence\\0\"\n\n.equ lenSrc, (. - src)\n\nsearch: .ascii \"s\"\n\n\n\n.text\n\n.global _main\n\n_main:\n\n\n\nxorq %rax, %rax\n\nmovb search(%rip), %al\n\nleaq src(%rip), %rdi\n\nmovq $lenSrc, %rcx\n\ncld\n\nrepne scasb\n\n\n\n# after SCAS, test for success\n\njnz notfound\n\n\n\n# found things\n\njmp done\n\n\n\nnotfound:\n\n# non-found things\n\n\n\ndone:\n\nmovq $60, %rax\n\nxorq %rdi, %rdi\n\nsyscall\n\n.end\n", "# Program 9.3\n\n# Addition Macro - GAS, Clang/LLVM on Linux (32-bit)\n\n# Copyright (c) 2017 Hall & Slonka\n\n\n\n.macro intAdd dest, source1, source2\n\n    movl \\source1, %eax\n\n    addl \\source2, %eax\n\n    movl %eax, \\dest\n\n.endm\n\n\n\n.data\n\nintA: .long 2\n\nintB: .long 4\n\nintC: .long 3\n\nintD: .long 7\n\nresult: .long 0\n\n\n\n.text\n\n.globl _main\n\n_main:\n\n\n\n    intAdd result, intA, intB\n\n    intAdd result, intC, intD\n\n\n\nmovl $1, %eax\n\nmovl $0, %ebx\n\nint $0x80\n\n.end\n", "# Program 9.3\n\n# Addition Macro - GAS, Clang/LLVM on macOS (32-bit)\n\n# Copyright (c) 2017 Hall & Slonka\n\n\n\n.macro intAdd dest, source1, source2\n\n    movl \\source1, %eax\n\n    addl \\source2, %eax\n\n    movl %eax, \\dest\n\n.endm\n\n\n\n.data\n\nintA: .long 2\n\nintB: .long 4\n\nintC: .long 3\n\nintD: .long 7\n\nresult: .long 0\n\n\n\n.text\n\n.globl _main\n\n_main:\n\n\n\n    intAdd result, intA, intB\n\n    intAdd result, intC, intD\n\n\n\npushl $0\n\nsubl $4, %esp\n\nmovl $1, %eax\n\nint $0x80\n\n.end\n", "# Program 9.3\n\n# Addition Macro - GAS, Clang/LLVM on Linux (64-bit)\n\n# Copyright (c) 2019 Hall & Slonka\n\n\n\n.macro intAdd dest, source1, source2\n\n    movl \\source1, %eax\n\n    addl \\source2, %eax\n\n    movl %eax, \\dest\n\n.endm\n\n\n\n.data\n\nintA: .long 2\n\nintB: .long 4\n\nintC: .long 3\n\nintD: .long 7\n\nresult: .long 0\n\n\n\n.text\n\n.global _main\n\n_main:\n\n\n\n    intAdd result(%rip), intA(%rip), intB(%rip)\n\n    intAdd result(%rip), intC(%rip), intD(%rip)\n\n\n\nmovq $60, %rax\n\nxorq %rdi, %rdi\n\nsyscall\n\n.end\n", "# Program 9.3\n\n# Addition Macro - GAS, Clang/LLVM on macOS (64-bit)\n\n# Copyright (c) 2019 Hall & Slonka\n\n\n\n.macro intAdd dest, source1, source2\n\n    movl \\source1, %eax\n\n    addl \\source2, %eax\n\n    movl %eax, \\dest\n\n.endm\n\n\n\n.data\n\nintA: .long 2\n\nintB: .long 4\n\nintC: .long 3\n\nintD: .long 7\n\nresult: .long 0\n\n\n\n.text\n\n.global _main\n\n_main:\n\n\n\n    intAdd result(%rip), intA(%rip), intB(%rip)\n\n    intAdd result(%rip), intC(%rip), intD(%rip)\n\n\n\nmovq $0x2000001, %rax\n\nxorq %rdi, %rdi\n\nsyscall\n\n.end\n", "# Program 3.2\n\n# Working Example - GAS, Clang/LLVM on macOS (32-bit)\n\n# Copyright (c) 2017 Hall & Slonka\n\n\n\n.data                             # Section for variable definitions\n\n\n\ndecimalLiteral:    .byte 31       # Variable storing 31\n\nhexLiteral:        .long 0xF      # Variable storing F (15 in decimal)\n\ncharLiteral:       .byte 'A'      # Variable storing 65 in decimal\n\n\n\n# Variable containing a string that has a line break and is null-terminated\n\nstringLiteral:     .ascii \"This string has\\na line break in it.\\0\"\n\n\n\n# Variable that calculates the value of an expression to determine the\n\n# length, in bytes, of the variable \"stringLiteral\" by subtracting the\n\n# starting memory address of the variable from the current memory address\n\n.equ lenString, (. - stringLiteral)\n\n\n\n.bss                              # Section for uninitialized variables\n\n.lcomm unInitVariable, 4          # Uninitialized, 4-byte variable\n\n\n\n.text                             # Section for instructions\n\n.globl _main                      # Make the label \"_main\"\n\n                                  # available to the linker as an\n\n                                  # entry point for the program\n\n_main:                            # Label for program entry\n\n\n\n# Label and instruction on\n\n# the same line below\n\npartOne: movl $10, %eax           # Assign 10 to the eax register\n\naddl hexLiteral, %eax             # Add the value in hexLiteral to\n\n                                  # the contents of the eax register\n\n                                  # and store the result in eax\n\n\n\npartTwo:                          # Label on its own line\n\ninc %eax                          # Increment the value in eax\n\n\n\npushl $0                          # Push the return value on the stack\n\nsubl $4, %esp                     # Pad the stack for INT requirement\n\nmovl $1, %eax                     # Set the system call to 1 for exit\n\nint $0x80                         # Issue the kernel interrupt\n\n.end                              # End assembling\n", "# Program 3.2\n\n# Working Example - GAS, Clang/LLVM on Linux (32-bit)\n\n# Copyright (c) 2017 Hall & Slonka\n\n\n\n.data                             # Section for variable definitions\n\n\n\ndecimalLiteral:    .byte 31       # Variable storing 31\n\nhexLiteral:        .long 0xF      # Variable storing F (15 in decimal)\n\ncharLiteral:       .byte 'A'      # Variable storing 65 in decimal\n\n\n\n# Variable containing a string that has a line break and is null-terminated\n\nstringLiteral:     .ascii \"This string has\\na line break in it.\\0\"\n\n\n\n# Variable that calculates the value of an expression to determine the\n\n# length, in bytes, of the variable \"stringLiteral\" by subtracting the\n\n# starting memory address of the variable from the current memory address\n\n.equ lenString, (. - stringLiteral)\n\n\n\n.bss                              # Section for uninitialized variables\n\n.lcomm unInitVariable, 4          # Uninitialized, 4-byte variable\n\n\n\n.text                             # Section for instructions\n\n.globl _main                      # Make the label \"_main\"\n\n                                  # available to the linker as an\n\n                                  # entry point for the program\n\n_main:                            # Label for program entry\n\n\n\n# Label and instruction on\n\n# the same line below\n\npartOne: movl $10, %eax           # Assign 10 to the eax register\n\naddl hexLiteral, %eax             # Add the value in hexLiteral to\n\n                                  # the contents of the eax register\n\n                                  # and store the result in eax\n\n\n\npartTwo:                          # Label on its own line\n\ninc %eax                          # Increment the value in eax\n\n\n\nmovl $1, %eax                     # Indicate exit system call code (1)\n\nmovl $0, %ebx                     # Return value of the program (0)\n\nint $0x80                         # Issue the kernel interrupt\n\n.end                              # End assembling\n", "# Program 3.2\n\n# Working Example - GAS, Clang/LLVM on macOS (64-bit)\n\n# Copyright (c) 2019 Hall & Slonka\n\n\n\n.data                             # Section for variable definitions\n\n\n\ndecimalLiteral:    .byte 31       # Variable storing 31\n\nhexLiteral:        .long 0xF      # Variable storing F (15 in decimal)\n\ncharLiteral:       .byte 'A'      # Variable storing 65 in decimal\n\n\n\n# Variable containing a string that has a line break and is null-terminated\n\nstringLiteral:     .ascii \"This string has\\na line break in it.\\0\"\n\n\n\n# Variable that calculates the value of an expression to determine the\n\n# length, in bytes, of the variable \"stringLiteral\" by subtracting the\n\n# starting memory address of the variable from the current memory address\n\n.equ lenString, (. - stringLiteral)\n\n\n\n.bss                              # Section for uninitialized variables\n\n.lcomm unInitVariable, 4          # Uninitialized, 4-byte variable\n\n\n\n.text                             # Section for instructions\n\n.global _main                     # Make the label \"_main\"\n\n                                  # available to the linker as an\n\n                                  # entry point for the program\n\n_main:                            # Label for program entry\n\n\n\n# Label and instruction on\n\n# the same line below\n\npartOne: movl $10, %eax           # Assign 10 to the eax register\n\naddl hexLiteral(%rip), %eax       # Add the value in hexLiteral to\n\n                                  # the contents of the eax register\n\n                                  # and store the result in eax\n\n\n\npartTwo:                          # Label on its own line\n\ninc %eax                          # Increment the value in eax\n\n\n\nmovq $0x2000001, %rax             # Set the system call for exit\n\nxorq %rdi, %rdi                   # Set the return value in rdi (0)\n\nsyscall                           # Issue the kernel interrupt\n\n.end                              # End assembling\n", "# Program 3.2\n\n# Working Example - GAS, Clang/LLVM on Linux (64-bit)\n\n# Copyright (c) 2019 Hall & Slonka\n\n\n\n.data                             # Section for variable definitions\n\n\n\ndecimalLiteral:    .byte 31       # Variable storing 31\n\nhexLiteral:        .long 0xF      # Variable storing F (15 in decimal)\n\ncharLiteral:       .byte 'A'      # Variable storing 65 in decimal\n\n\n\n# Variable containing a string that has a line break and is null-terminated\n\nstringLiteral:     .ascii \"This string has\\na line break in it.\\0\"\n\n\n\n# Variable that calculates the value of an expression to determine the\n\n# length, in bytes, of the variable \"stringLiteral\" by subtracting the\n\n# starting memory address of the variable from the current memory address\n\n.equ lenString, (. - stringLiteral)\n\n\n\n.bss                              # Section for uninitialized variables\n\n.lcomm unInitVariable, 4          # Uninitialized, 4-byte variable\n\n\n\n.text                             # Section for instructions\n\n.global _main                     # Make the label \"_main\"\n\n                                  # available to the linker as an\n\n                                  # entry point for the program\n\n_main:                            # Label for program entry\n\n\n\n# Label and instruction on\n\n# the same line below\n\npartOne: movl $10, %eax           # Assign 10 to the eax register\n\naddl hexLiteral(%rip), %eax       # Add the value in hexLiteral to\n\n                                  # the contents of the eax register\n\n                                  # and store the result in eax\n\n\n\npartTwo:                          # Label on its own line\n\ninc %eax                          # Increment the value in eax\n\n\n\nmovq $60, %rax                    # Set the system call for exit\n\nxorq %rdi, %rdi                   # Set the return value in rdi (0)\n\nsyscall                           # Issue the kernel interrupt\n\n.end                              # End assembling\n", "# Program 3.2\n\n# Working Example - GAS, Clang/LLVM on macOS (64-bit)\n\n# Copyright (c) 2020 Hall & Slonka\n\n\n\n.data                             # Section for variable definitions\n\n\n\ndecimalLiteral:    .byte 31       # Variable storing 31\n\nhexLiteral:        .quad 0xF      # Variable storing F (15 in decimal)\n\ncharLiteral:       .byte 'A'      # Variable storing 65 in decimal\n\n\n\n# Variable containing a string that has a line break and is null-terminated\n\nstringLiteral:     .ascii \"This string has\\na line break in it.\\0\"\n\n\n\n# Variable that calculates the value of an expression to determine the\n\n# length, in bytes, of the variable \"stringLiteral\" by subtracting the\n\n# starting memory address of the variable from the current memory address\n\n.equ lenString, (. - stringLiteral)\n\n\n\n.bss                              # Section for uninitialized variables\n\n.lcomm unInitVariable, 8          # Uninitialized, 8-byte variable\n\n\n\n.text                             # Section for instructions\n\n.global _main                     # Make the label \"_main\"\n\n                                  # available to the linker as an\n\n                                  # entry point for the program\n\n_main:                            # Label for program entry\n\n\n\n# Label and instruction on\n\n# the same line below\n\npartOne: mov $10, %rax            # Assign 10 to the rax register\n\nadd hexLiteral(%rip), %rax        # Add the value in hexLiteral to\n\n                                  # the contents of the rax register\n\n                                  # and store the result in rax\n\n\n\npartTwo:                          # Label on its own line\n\ninc %rax                          # Increment the value in rax\n\n\n\nmov $0x2000001, %rax              # Set the system call for exit\n\nxor %rdi, %rdi                    # Set the return value in rdi (0)\n\nsyscall                           # Issue the kernel interrupt\n\n.end                              # End assembling\n", "# Program 3.2\n\n# Working Example - GAS, Clang/LLVM on Linux (64-bit)\n\n# Copyright (c) 2020 Hall & Slonka\n\n\n\n.data                             # Section for variable definitions\n\n\n\ndecimalLiteral:    .byte 31       # Variable storing 31\n\nhexLiteral:        .quad 0xF      # Variable storing F (15 in decimal)\n\ncharLiteral:       .byte 'A'      # Variable storing 65 in decimal\n\n\n\n# Variable containing a string that has a line break and is null-terminated\n\nstringLiteral:     .ascii \"This string has\\na line break in it.\\0\"\n\n\n\n# Variable that calculates the value of an expression to determine the\n\n# length, in bytes, of the variable \"stringLiteral\" by subtracting the\n\n# starting memory address of the variable from the current memory address\n\n.equ lenString, (. - stringLiteral)\n\n\n\n.bss                              # Section for uninitialized variables\n\n.lcomm unInitVariable, 8          # Uninitialized, 8-byte variable\n\n\n\n.text                             # Section for instructions\n\n.global _main                     # Make the label \"_main\"\n\n                                  # available to the linker as an\n\n                                  # entry point for the program\n\n_main:                            # Label for program entry\n\n\n\n# Label and instruction on\n\n# the same line below\n\npartOne: mov $10, %rax            # Assign 10 to the rax register\n\nadd hexLiteral(%rip), %rax        # Add the value in hexLiteral to\n\n                                  # the contents of the rax register\n\n                                  # and store the result in rax\n\n\n\npartTwo:                          # Label on its own line\n\ninc %rax                          # Increment the value in rax\n\n\n\nmov $60, %rax                     # Set the system call for exit\n\nxor %rdi, %rdi                    # Set the return value in rdi (0)\n\nsyscall                           # Issue the kernel interrupt\n\n.end                              # End assembling\n", "# Assignment 3.3\n\n# Syntax Translation - GAS, Clang/LLVM on Linux (32-bit)\n\n# Copyright (c) 2017 Hall & Slonka\n\n\n\n.data\n\n\n\n.bss\n\n.lcomm letter, 1\n\n.lcomm r, 4\n\n.lcomm s, 4\n\n.lcomm t, 4\n\n.lcomm x, 2\n\n.lcomm y, 2\n\n.lcomm z, 2\n\n\n\n.text\n\n.globl _main\n\n_main:\n\n\n\nmovb $0x77, letter\n\nmovl $0x5, r\n\nmovl $0x2, s\n\nmovw $0xa, x\n\nmovw $0x4, y\n\n\n\nmovw x, %ax\n\naddw y, %ax\n\nmovw %ax, z\n\n\n\nmovw x, %ax\n\nsubw y, %ax\n\nmovw %ax, z\n\n\n\nmovl $0x0, %edx\n\nmovl r, %eax\n\nmovl s, %ecx\n\ndivl %ecx\n\nmovl %eax, t\n\n\n\nmovl $0x0, %edx\n\nmovl r, %eax\n\nmovl s, %ecx\n\ndivl %ecx\n\nmovl %edx, t\n\n\n\nmovl $1, %eax\n\nmovl $0, %ebx\n\nint $0x80\n\n\n\n.end\n", "# Assignment 3.3\n\n# Syntax Translation - GAS, Clang/LLVM on macOS (32-bit)\n\n# Copyright (c) 2017 Hall & Slonka\n\n\n\n.data\n\n\n\n.bss\n\n.lcomm letter, 1\n\n.lcomm r, 4\n\n.lcomm s, 4\n\n.lcomm t, 4\n\n.lcomm x, 2\n\n.lcomm y, 2\n\n.lcomm z, 2\n\n\n\n.text\n\n.globl _main\n\n_main:\n\n\n\nmovb $0x77, letter\n\nmovl $0x5, r\n\nmovl $0x2, s\n\nmovw $0xa, x\n\nmovw $0x4, y\n\n\n\nmovw x, %ax\n\naddw y, %ax\n\nmovw %ax, z\n\n\n\nmovw x, %ax\n\nsubw y, %ax\n\nmovw %ax, z\n\n\n\nmovl $0x0, %edx\n\nmovl r, %eax\n\nmovl s, %ecx\n\ndivl %ecx\n\nmovl %eax, t\n\n\n\nmovl $0x0, %edx\n\nmovl r, %eax\n\nmovl s, %ecx\n\ndivl %ecx\n\nmovl %edx, t\n\n\n\npushl $0\n\nsubl $4, %esp\n\nmovl $1, %eax\n\nint $0x80\n\n\n\n.end\n", "# Assignment 3.3\n\n# Syntax Translation - GAS, Clang/LLVM on Linux (64-bit)\n\n# Copyright (c) 2019 Hall & Slonka\n\n\n\n.data\n\n\n\n.bss\n\n.lcomm letter, 1\n\n.lcomm r, 4\n\n.lcomm s, 4\n\n.lcomm t, 4\n\n.lcomm x, 2\n\n.lcomm y, 2\n\n.lcomm z, 2\n\n\n\n.text\n\n.global _main\n\n_main:\n\n\n\nmovb $0x77, letter(%rip)\n\nmovl $0x5, r(%rip)\n\nmovl $0x2, s(%rip)\n\nmovw $0xa, x(%rip)\n\nmovw $0x4, y(%rip)\n\n\n\nmovw x(%rip), %ax\n\naddw y(%rip), %ax\n\nmovw %ax, z(%rip)\n\n\n\nmovw x(%rip), %ax\n\nsubw y(%rip), %ax\n\nmovw %ax, z(%rip)\n\n\n\nmovl $0x0, %edx\n\nmovl r(%rip), %eax\n\nmovl s(%rip), %ecx\n\ndivl %ecx\n\nmovl %eax, t(%rip)\n\n\n\nmovl $0x0, %edx\n\nmovl r(%rip), %eax\n\nmovl s(%rip), %ecx\n\ndivl %ecx\n\nmovl %edx, t(%rip)\n\n\n\nmovq $60, %rax\n\nxorq %rdi, %rdi\n\nsyscall\n\n.end\n", "# Assignment 3.3\n\n# Syntax Translation - GAS, Clang/LLVM on macOS (64-bit)\n\n# Copyright (c) 2019 Hall & Slonka\n\n\n\n.data\n\n\n\n.bss\n\n.lcomm letter, 1\n\n.lcomm r, 4\n\n.lcomm s, 4\n\n.lcomm t, 4\n\n.lcomm x, 2\n\n.lcomm y, 2\n\n.lcomm z, 2\n\n\n\n.text\n\n.global _main\n\n_main:\n\n\n\nmovb $0x77, letter(%rip)\n\nmovl $0x5, r(%rip)\n\nmovl $0x2, s(%rip)\n\nmovw $0xa, x(%rip)\n\nmovw $0x4, y(%rip)\n\n\n\nmovw x(%rip), %ax\n\naddw y(%rip), %ax\n\nmovw %ax, z(%rip)\n\n\n\nmovw x(%rip), %ax\n\nsubw y(%rip), %ax\n\nmovw %ax, z(%rip)\n\n\n\nmovl $0x0, %edx\n\nmovl r(%rip), %eax\n\nmovl s(%rip), %ecx\n\ndivl %ecx\n\nmovl %eax, t(%rip)\n\n\n\nmovl $0x0, %edx\n\nmovl r(%rip), %eax\n\nmovl s(%rip), %ecx\n\ndivl %ecx\n\nmovl %edx, t(%rip)\n\n\n\nmovq $0x2000001, %rax\n\nxorq %rdi, %rdi\n\nsyscall\n\n.end\n", "# Program 3.1\n\n# Sample Assembly Program - GAS, Clang/LLVM on Linux (32-bit)\n\n# Copyright (c) 2017 Hall & Slonka\n\n\n\n.data\n\nsum: .long 0\n\n\n\n.text\n\n.globl _main\n\n_main:\n\nmovl $25, %eax\n\nmovl $50, %ebx\n\naddl %ebx, %eax\n\nmovl %eax, sum\n\n\n\nmovl $1, %eax\n\nmovl $0, %ebx\n\nint $0x80\n\n.end\n", "# Program 3.1\n\n# Sample Assembly Program - GAS, Clang/LLVM on macOS (32-bit)\n\n# Copyright (c) 2017 Hall & Slonka\n\n\n\n.data\n\nsum: .long 0\n\n\n\n.text\n\n.globl _main\n\n_main:\n\nmovl $25, %eax\n\nmovl $50, %ebx\n\naddl %ebx, %eax\n\nmovl %eax, sum\n\n\n\npushl $0\n\nsubl $4, %esp\n\nmovl $1, %eax\n\nint $0x80\n\n.end\n", "# Program 3.1\n\n# Sample Assembly Program - GAS, Clang/LLVM on Linux (64-bit)\n\n# Copyright (c) 2019 Hall & Slonka\n\n\n\n.data\n\nsum: .long 0\n\n\n\n.text\n\n.global _main\n\n_main:\n\nmovl $25, %eax\n\nmovl $50, %ebx\n\naddl %ebx, %eax\n\nmovl %eax, sum(%rip)\n\n\n\nmovq $60, %rax\n\nxorq %rdi, %rdi\n\nsyscall\n\n.end\n", "# Program 3.1\n\n# Sample Assembly Program - GAS, Clang/LLVM on macOS (64-bit)\n\n# Copyright (c) 2019 Hall & Slonka\n\n\n\n.data\n\nsum: .long 0\n\n\n\n.text\n\n.global _main\n\n_main:\n\nmovl $25, %eax\n\nmovl $50, %ebx\n\naddl %ebx, %eax\n\nmovl %eax, sum(%rip)\n\n\n\nmovq $0x2000001, %rax\n\nxorq %rdi, %rdi\n\nsyscall\n\n.end\n", "# Program 3.1\n\n# Sample Assembly Program - GAS, Clang/LLVM on Linux (64-bit)\n\n# Copyright (c) 2020 Hall & Slonka\n\n\n\n.data\n\nsum: .quad 0\n\n\n\n.text\n\n.global _main\n\n_main:\n\nmov $25, %rax\n\nmov $50, %rbx\n\nadd %rbx, %rax\n\nmov %rax, sum(%rip)\n\n\n\nmov $60, %rax\n\nxor %rdi, %rdi\n\nsyscall\n\n.end\n", "# Program 3.1\n\n# Sample Assembly Program - GAS, Clang/LLVM on macOS (64-bit)\n\n# Copyright (c) 2020 Hall & Slonka\n\n\n\n.data\n\nsum: .quad 0\n\n\n\n.text\n\n.global _main\n\n_main:\n\nmov $25, %rax\n\nmov $50, %rbx\n\nadd %rbx, %rax\n\nmov %rax, sum(%rip)\n\n\n\nmov $0x2000001, %rax\n\nxor %rdi, %rdi\n\nsyscall\n\n.end\n", "# Program 6.1\n\n# Sum Program - GAS, Clang/LLVM on macOS (32-bit)\n\n# Copyright (c) 2017 Hall & Slonka\n\n\n\n.data\n\nnum1: .long 2\n\nnum2: .long 4\n\n\n\n.text\n\n.globl _main, _sum\n\n_main:\n\n\n\nmov $10, %eax\n\ndec %eax\n\nmov $5, %ebx\n\n\n\npush num2\n\npush num1\n\ncall _sum\n\nadd $8, %esp\n\n\n\nadd %ebx, %eax\n\ndec %eax\n\n\n\npushl $0\n\nsubl $4, %esp\n\nmovl $1, %eax\n\nint $0x80\n\n\n\n_sum:\n\npush %ebp\n\nmov %esp, %ebp\n\npush %ebx\n\n\n\nmov 8(%ebp), %ebx\n\nmov 12(%ebp), %eax\n\nadd %ebx, %eax\n\npop %ebx\n\npop %ebp\n\nret\n\n\n\n.end\n", "# Program 6.1\n\n# Sum Program - GAS, Clang/LLVM on Linux (32-bit)\n\n# Copyright (c) 2017 Hall & Slonka\n\n\n\n.data\n\nnum1: .long 2\n\nnum2: .long 4\n\n\n\n.text\n\n.globl _main, _sum\n\n_main:\n\n\n\nmov $10, %eax\n\ndec %eax\n\nmov $5, %ebx\n\n\n\npush num2\n\npush num1\n\ncall _sum\n\nadd $8, %esp\n\n\n\nadd %ebx, %eax\n\ndec %eax\n\n\n\nmovl $1, %eax\n\nmovl $0, %ebx\n\nint $0x80\n\n\n\n_sum:\n\npush %ebp\n\nmov %esp, %ebp\n\npush %ebx\n\n\n\nmov 8(%ebp), %ebx\n\nmov 12(%ebp), %eax\n\nadd %ebx, %eax\n\npop %ebx\n\npop %ebp\n\nret\n\n\n\n.end\n", "# Program 6.1\n\n# Sum Program - GAS, Clang/LLVM on macOS (64-bit)\n\n# Copyright (c) 2020 Hall & Slonka\n\n\n\n.data\n\nnum1: .long 2\n\nnum2: .long 4\n\n\n\n.text\n\n.global _main, _sum\n\n_main:\n\n\n\nmovq $10, %rax\n\ndecq %rax\n\nmovq $5, %rbx\n\n\n\nmovslq num1(%rip), %rdi\n\nmovslq num2(%rip), %rsi\n\ncallq _sum\n\n\n\naddq %rbx, %rax\n\ndecq %rax\n\n\n\nmovq $0x2000001, %rax\n\nxorq %rdi, %rdi\n\nsyscall\n\n\n\n_sum:\n\npushq %rbp\n\nmovq %rsp, %rbp\n\npushq %rbx\n\nmovq %rdi, %rax\n\naddq %rsi, %rax\n\npopq %rbx\n\npopq %rbp\n\nretq\n\n\n\n.end\n", "# Program 6.1\n\n# Sum Program - GAS, Clang/LLVM on Linux (64-bit)\n\n# Copyright (c) 2020 Hall & Slonka\n\n\n\n.data\n\nnum1: .long 2\n\nnum2: .long 4\n\n\n\n.text\n\n.global _main, _sum\n\n_main:\n\n\n\nmovq $10, %rax\n\ndecq %rax\n\nmovq $5, %rbx\n\n\n\nmovslq num1(%rip), %rdi\n\nmovslq num2(%rip), %rsi\n\ncallq _sum\n\n\n\naddq %rbx, %rax\n\ndecq %rax\n\n\n\nmovq $60, %rax\n\nxorq %rdi, %rdi\n\nsyscall\n\n\n\n_sum:\n\npushq %rbp\n\nmovq %rsp, %rbp\n\npushq %rbx\n\nmovq %rdi, %rax\n\naddq %rsi, %rax\n\npopq %rbx\n\npopq %rbp\n\nretq\n\n\n\n.end\n", "# Program 6.3\n\n# Sum Program - GAS, Clang/LLVM on macOS (64-bit)\n\n# Copyright (c) 2017 Hall & Slonka\n\n\n\n.data\n\nnum1: .quad 2\n\nnum2: .quad 4\n\n\n\n.text\n\n.global _main, _sum\n\n_main:\n\n\n\nmovq $10, %rax\n\ndecq %rax\n\nmovq $5, %rbx\n\n\n\nleaq num1(%rip), %rdi\n\nleaq num2(%rip), %rsi\n\ncallq _sum\n\n\n\naddq %rbx, %rax\n\ndecq %rax\n\n\n\nmovq $0x2000001, %rax\n\nxorq %rdi, %rdi\n\nsyscall\n\n\n\n_sum:\n\npushq %rbp\n\nmovq %rsp, %rbp\n\npushq %rbx\n\nmovq (%rdi), %rax\n\naddq (%rsi), %rax\n\npopq %rbx\n\npopq %rbp\n\nretq\n\n\n\n.end\n", "# Program 6.3\n\n# Sum Program - GAS, Clang/LLVM on Linux (64-bit)\n\n# Copyright (c) 2017 Hall & Slonka\n\n\n\n.data\n\nnum1: .quad 2\n\nnum2: .quad 4\n\n\n\n.text\n\n.global _main, _sum\n\n_main:\n\n\n\nmovq $10, %rax\n\ndecq %rax\n\nmovq $5, %rbx\n\n\n\nleaq num1(%rip), %rdi\n\nleaq num2(%rip), %rsi\n\ncallq _sum\n\n\n\naddq %rbx, %rax\n\ndecq %rax\n\n\n\nmovq $60, %rax\n\nxorq %rdi, %rdi\n\nsyscall\n\n\n\n_sum:\n\npushq %rbp\n\nmovq %rsp, %rbp\n\npushq %rbx\n\nmovq (%rdi), %rax\n\naddq (%rsi), %rax\n\npopq %rbx\n\npopq %rbp\n\nretq\n\n\n\n.end\n", "# Program C.1\n\n# Template - GAS, Clang/LLVM on macOS (32-bit)\n\n# Copyright (c) 2017 Hall & Slonka\n\n\n\n.data\n\nnum: .long 80\n\n\n\n.bss\n\n.lcomm sum, 4\n\n\n\n.text\n\n.globl _main\n\n\n\n_main:\n\nmovl num, %eax\n\naddl $20, %eax\n\nmovl %eax, sum\n\n\n\npushl $0\n\nsubl $4, %esp\n\nmovl $1, %eax\n\nint $0x80\n\n.end\n", "# Program C.1\n\n# Template - GAS, Clang/LLVM on Linux (32-bit)\n\n# Copyright (c) 2017 Hall & Slonka\n\n\n\n.data\n\nnum: .long 80\n\n\n\n.bss\n\n.lcomm sum, 4\n\n\n\n.text\n\n.globl _main\n\n\n\n_main:\n\nmovl num, %eax\n\naddl $20, %eax\n\nmovl %eax, sum\n\n\n\nmovl $1, %eax\n\nmovl $0, %ebx\n\nint $0x80\n\n.end\n", "# Program C.1\n\n# Template - GAS, Clang/LLVM on macOS (64-bit)\n\n# Copyright (c) 2018 Hall & Slonka\n\n\n\n.data\n\nnum: .quad 80\n\n\n\n.bss\n\n.lcomm sum, 8\n\n\n\n.text\n\n.global _main\n\n\n\n_main:\n\nmovq num(%rip), %rax\n\naddq $20, %rax\n\nmovq %rax, sum(%rip)\n\n\n\nmovq $0x2000001, %rax\n\nxorq %rdi, %rdi\n\nsyscall\n\n.end\n", "# Program C.1\n\n# Template - GAS, Clang/LLVM on Linux (64-bit)\n\n# Copyright (c) 2018 Hall & Slonka\n\n\n\n.data\n\nnum: .quad 80\n\n\n\n.bss\n\n.lcomm sum, 8\n\n\n\n.text\n\n.global _main\n\n\n\n_main:\n\nmovq num(%rip), %rax\n\naddq $20, %rax\n\nmovq %rax, sum(%rip)\n\n\n\nmovq $60, %rax\n\nxorq %rdi, %rdi\n\nsyscall\n\n.end\n", "# Program B.1\n\n# Template - GAS, Clang/LLVM on Linux (32-bit)\n\n# Copyright (c) 2017 Hall & Slonka\n\n\n\n.data\n\nnum: .long 80\n\n\n\n.bss\n\n.lcomm sum, 4\n\n\n\n.text\n\n.globl _main\n\n\n\n_main:\n\nmovl num, %eax\n\naddl $20, %eax\n\nmovl %eax, sum\n\n\n\nmovl $1, %eax\n\nmovl $0, %ebx\n\nint $0x80\n\n.end\n", "# Program B.1\n\n# Template - GAS, Clang/LLVM on macOS (32-bit)\n\n# Copyright (c) 2017 Hall & Slonka\n\n\n\n.data\n\nnum: .long 80\n\n\n\n.bss\n\n.lcomm sum, 4\n\n\n\n.text\n\n.globl _main\n\n\n\n_main:\n\nmovl num, %eax\n\naddl $20, %eax\n\nmovl %eax, sum\n\n\n\npushl $0\n\nsubl $4, %esp\n\nmovl $1, %eax\n\nint $0x80\n\n.end\n", "# Program B.1\n\n# Template - GAS, Clang/LLVM on Linux (64-bit)\n\n# Copyright (c) 2019 Hall & Slonka\n\n\n\n.data\n\nnum: .quad 80\n\n\n\n.bss\n\n.lcomm sum, 8\n\n\n\n.text\n\n.global _main\n\n\n\n_main:\n\nmovq num(%rip), %rax\n\naddq $20, %rax\n\nmovq %rax, sum(%rip)\n\n\n\nmovq $60, %rax\n\nxorq %rdi, %rdi\n\nsyscall\n\n.end\n", "# Program B.1\n\n# Template - GAS, Clang/LLVM on macOS (64-bit)\n\n# Copyright (c) 2019 Hall & Slonka\n\n\n\n.data\n\nnum: .quad 80\n\n\n\n.bss\n\n.lcomm sum, 8\n\n\n\n.text\n\n.global _main\n\n\n\n_main:\n\nmovq num(%rip), %rax\n\naddq $20, %rax\n\nmovq %rax, sum(%rip)\n\n\n\nmovq $0x2000001, %rax\n\nxorq %rdi, %rdi\n\nsyscall\n\n.end\n", "# Program H.1\n\n# ASCII Adjust after Addition - GAS, Clang/LLVM on macOS (32-bit)\n\n# Copyright (c) 2017 Hall & Slonka\n\n\n\n.data\n\nnum1: .byte '8'\n\nnum2: .byte '2'\n\n\n\n.text\n\n.globl _main\n\n_main:\n\n\n\nxorw %ax, %ax     # must clear so it doesn\u2019t influence the adjust\n\nmovb num1, %al\n\naddb num2, %al\n\naaa               # ascii adjust\n\norw $0x3030, %ax  # convert to ascii\n\n\n\npushl $0\n\nsubl $4, %esp\n\nmovl $1, %eax\n\nint $0x80\n\n\n\n.end\n", "# Program H.1\n\n# ASCII Adjust after Addition - GAS, Clang/LLVM on Linux (32-bit)\n\n# Copyright (c) 2017 Hall & Slonka\n\n\n\n.data\n\nnum1: .byte '8'\n\nnum2: .byte '2'\n\n\n\n.text\n\n.globl _main\n\n_main:\n\n\n\nxorw %ax, %ax     # must clear so it doesn\u2019t influence the adjust\n\nmovb num1, %al\n\naddb num2, %al\n\naaa               # ascii adjust\n\norw $0x3030, %ax  # convert to ascii\n\n\n\nmovl $1, %eax\n\nmovl $0, %ebx\n\nint $0x80\n\n\n\n.end\n", "# Program H.2\n\n# Decimal Adjust after Addition - GAS, Clang/LLVM on macOS (32-bit)\n\n# Copyright (c) 2017 Hall & Slonka\n\n\n\n.data\n\n.text\n\n.globl _main\n\n_main:\n\n\n\nxor %ax, %ax    # clear AX\n\nxor %bx, %bx    # clear BX\n\nmov $0x42, %al  # 42 decimal = 2A hex\n\nadd $0x68, %al  # 68 decimal = 44 hex\n\ndaa             # 110 decimal = 6E hex\n\n                # CF = 1, AL = 10\n\nadc $0, %bx     # BX = 0 + BX(0) + CF\n\ncmp $0, %bx     # if CF set(1)\n\njz done\n\ncarry:\n\nadd $1, %ah     # set next byte to 1\n\n\n\ndone:\n\npushl $0\n\nsubl $4, %esp\n\nmovl $1, %eax\n\nint $0x80\n\n\n\n.end\n", "# Program H.2\n\n# Decimal Adjust after Addition - GAS, Clang/LLVM on Linux (32-bit)\n\n# Copyright (c) 2017 Hall & Slonka\n\n\n\n.data\n\n.text\n\n.globl _main\n\n_main:\n\n\n\nxor %ax, %ax    # clear AX\n\nxor %bx, %bx    # clear BX\n\nmov $0x42, %al  # 42 decimal = 2A hex\n\nadd $0x68, %al  # 68 decimal = 44 hex\n\ndaa             # 110 decimal = 6E hex\n\n                # CF = 1, AL = 10\n\nadc $0, %bx     # BX = 0 + BX(0) + CF\n\ncmp $0, %bx     # if CF set(1)\n\njz done\n\ncarry:\n\nadd $1, %ah     # set next byte to 1\n\n\n\ndone:\n\nmovl $1, %eax\n\nmovl $0, %ebx\n\nint $0x80\n\n\n\n.end\n", "; Program D.1\n\n; sum - NASM (32-bit) on macOS\n\n; Copyright (c) 2017 Hall & Slonka\n\n\n\n; nasm -f macho -o sum.o -l sum.lst sum.s\n\n; clang -o sum -m32 sum.o\n\n\n\nsection .data\n\nnum1: dd 2\n\nnum2: dd 4\n\n\n\nsection .text\n\nglobal _main, _sum\n\n_main:\n\n\n\nmov eax, 10\n\ndec eax\n\nmov ebx, 5\n\n\n\npush DWORD[num2]\n\npush DWORD[num1]\n\ncall _sum\n\nadd esp, 8\n\n\n\npush DWORD 0\n\nsub esp, 4\n\nmov eax, 1\n\nint 80h\n\n\n\n_sum:\n\npush ebp\n\nmov ebp, esp\n\npush ebx\n\nmov ebx, [ebp + 8]\n\nmov eax, [ebp + 12]\n\nadd eax, ebx\n\npop ebx\n\npop ebp\n\nret\n", "; Program D.1\n\n; sum - NASM (64-bit) on macOS\n\n; Copyright (c) 2019 Hall & Slonka\n\n\n\n; nasm -f macho64 -o sum.o -l sum.lst sum.s\n\n; clang -o sum -m64 sum.o\n\n\n\nsection .data\n\nnum1: dq 2\n\nnum2: dq 4\n\n\n\nsection .text\n\nglobal _main, _sum\n\n_main:\n\n\n\nmov rax, 10\n\ndec rax\n\nmov rbx, 5\n\n\n\nlea rdi, [rel num1]\n\nlea rsi, [rel num2]\n\ncall _sum\n\n\n\nadd rax, rbx\n\ndec rax\n\n\n\nmov rax, 2000001h\n\nmov rdi, 0\n\nsyscall\n\n\n\n_sum:\n\npush rbp\n\nmov rbp, rsp\n\npush rbx\n\nmov rax, [rdi]\n\nadd rax, [rsi]\n\npop rbx\n\npop rbp\n\nret\n", "; Hello World Program (Print with line feed)\n\n; Compile with: nasm -f elf helloworld-lf.asm\n\n; Link with (64 bit systems require elf_i386 option): ld -m elf_i386 helloworld-lf.o -o helloworld-lf\n\n; Run with: ./helloworld-lf\n\n\n\n%include        'functions.asm'\n\n\n\nSECTION .data\n\nmsg1    db      'Hello, brave new world!', 0h          ; NOTE we have removed the line feed character 0AH\n\nmsg2    db      'This is how we recycle in NASM.', 0h  ; NOTE we have removed the line feed character 0AH\n\n\n\nSECTION .text\n\nglobal  _start\n\n    \n\n_start: \n\n\n\n    mov     eax, msg1        \n\n    call    sprintLF    ; NOTE we are calling our new print with linefeed function\n\n\n\n    mov     eax, msg2\n\n    call    sprintLF    ; NOTE we are calling our new print with linefeed function\n\n\n\n    call    quit", ";------------------------------------------\n\n; int slen(String message)\n\n; String length calculation function\n\nslen:                     \n\n    push    ebx             \n\n    mov     ebx, eax        \n\n    \n\nnextchar:                   \n\n    cmp     byte [eax], 0   \n\n    jz      finished        \n\n    inc     eax             \n\n    jmp     nextchar        \n\n    \n\nfinished:\n\n    sub     eax, ebx\n\n    pop     ebx             \n\n    ret                     \n\n\n\n\n\n;------------------------------------------\n\n; void sprint(String message)\n\n; String printing function\n\nsprint:\n\n    push    edx\n\n    push    ecx\n\n    push    ebx\n\n    push    eax\n\n    call    slen\n\n    \n\n    mov     edx, eax\n\n    pop     eax\n\n    \n\n    mov     ecx, eax\n\n    mov     ebx, 1\n\n    mov     eax, 4\n\n    int     80h\n\n    \n\n    pop     ebx\n\n    pop     ecx\n\n    pop     edx\n\n    ret\n\n\n\n\n\n;------------------------------------------\n\n; void sprintLF(String message)\n\n; String printing with line feed function\n\nsprintLF:\n\n    call    sprint\n\n\n\n    push    eax         ; push eax onto the stack to preserve it while we use the eax register in this function\n\n    mov     eax, 0Ah    ; move 0AH into eax - 0AH is the ascii character for a linefeed\n\n    push    eax         ; push the linefeed onto the stack so we can get the address\n\n    mov     eax, esp    ; move the address of the current stack pointer into eax for sprint\n\n    call    sprint      ; call our sprint function\n\n    pop     eax         ; remove our linefeed character from the stack\n\n    pop     eax         ; restore the original value of eax before our function was called\n\n    ret                 ; return to our program\n\n\n\n    \n\n;------------------------------------------\n\n; void exit()\n\n; Exit program and restore resources\n\nquit:\n\n    mov     ebx, 0      \n\n    mov     eax, 1      \n\n    int     80h\n\n    ret\n\n\n", "; Socket\n\n; Compile with: nasm -f elf socket.asm\n\n; Link with (64 bit systems require elf_i386 option): ld -m elf_i386 socket.o -o socket\n\n; Run with: ./socket\n\n\n\n%include    'functions.asm'\n\n\n\nSECTION .data\n\n; our response string\n\nresponse db 'HTTP/1.1 200 OK', 0Dh, 0Ah, 'Content-Type: text/html', 0Dh, 0Ah, 'Content-Length: 14', 0Dh, 0Ah, 0Dh, 0Ah, 'Hello World!', 0Dh, 0Ah, 0h\n\n\n\nSECTION .bss\n\nbuffer resb 255,                ; variable to store request headers\n\n\n\nSECTION .text\n\nglobal  _start\n\n\n\n_start:\n\n\n\n    xor     eax, eax            ; initialize some registers\n\n    xor     ebx, ebx\n\n    xor     edi, edi\n\n    xor     esi, esi\n\n\n\n_socket:\n\n\n\n    push    byte 6              ; create socket from lesson 29\n\n    push    byte 1\n\n    push    byte 2\n\n    mov     ecx, esp\n\n    mov     ebx, 1\n\n    mov     eax, 102\n\n    int     80h\n\n\n\n_bind:\n\n\n\n    mov     edi, eax            ; bind socket from lesson 30\n\n    push    dword 0x00000000\n\n    push    word 0x2923\n\n    push    word 2\n\n    mov     ecx, esp\n\n    push    byte 16\n\n    push    ecx\n\n    push    edi\n\n    mov     ecx, esp\n\n    mov     ebx, 2\n\n    mov     eax, 102\n\n    int     80h\n\n\n\n_listen:\n\n\n\n    push    byte 1              ; listen socket from lesson 31\n\n    push    edi\n\n    mov     ecx, esp\n\n    mov     ebx, 4\n\n    mov     eax, 102\n\n    int     80h\n\n\n\n_accept:\n\n\n\n    push    byte 0              ; accept socket from lesson 32\n\n    push    byte 0\n\n    push    edi\n\n    mov     ecx, esp\n\n    mov     ebx, 5\n\n    mov     eax, 102\n\n    int     80h\n\n\n\n_fork:\n\n\n\n    mov     esi, eax            ; fork socket from lesson 33\n\n    mov     eax, 2\n\n    int     80h\n\n\n\n    cmp     eax, 0\n\n    jz      _read\n\n\n\n    jmp     _accept\n\n\n\n_read:\n\n\n\n    mov     edx, 255            ; read socket from lesson 33\n\n    mov     ecx, buffer\n\n    mov     ebx, esi\n\n    mov     eax, 3\n\n    int     80h\n\n\n\n    mov     eax, buffer\n\n    call    sprintLF\n\n\n\n_write:\n\n\n\n    mov     edx, 78             ; move 78 dec into edx (length in bytes to write)\n\n    mov     ecx, response       ; move address of our response variable into ecx\n\n    mov     ebx, esi            ; move file descriptor into ebx (accepted socket id)\n\n    mov     eax, 4              ; invoke SYS_WRITE (kernel opcode 4)\n\n    int     80h                 ; call the kernel\n\n\n\n_exit:\n\n\n\n    call    quit                ; call our quit function\n", ";------------------------------------------\n\n; int atoi(Integer number)\n\n; Ascii to integer function (atoi)\n\natoi:\n\n    push    ebx             ; preserve ebx on the stack to be restored after function runs\n\n    push    ecx             ; preserve ecx on the stack to be restored after function runs\n\n    push    edx             ; preserve edx on the stack to be restored after function runs\n\n    push    esi             ; preserve esi on the stack to be restored after function runs\n\n    mov     esi, eax        ; move pointer in eax into esi (our number to convert)\n\n    mov     eax, 0          ; initialise eax with decimal value 0\n\n    mov     ecx, 0          ; initialise ecx with decimal value 0\n\n\n\n.multiplyLoop:\n\n    xor     ebx, ebx        ; resets both lower and uppper bytes of ebx to be 0\n\n    mov     bl, [esi+ecx]   ; move a single byte into ebx register's lower half\n\n    cmp     bl, 48          ; compare ebx register's lower half value against ascii value 48 (char value 0)\n\n    jl      .finished       ; jump if less than to label finished\n\n    cmp     bl, 57          ; compare ebx register's lower half value against ascii value 57 (char value 9)\n\n    jg      .finished       ; jump if greater than to label finished\n\n\n\n    sub     bl, 48          ; convert ebx register's lower half to decimal representation of ascii value\n\n    add     eax, ebx        ; add ebx to our interger value in eax\n\n    mov     ebx, 10         ; move decimal value 10 into ebx\n\n    mul     ebx             ; multiply eax by ebx to get place value\n\n    inc     ecx             ; increment ecx (our counter register)\n\n    jmp     .multiplyLoop   ; continue multiply loop\n\n\n\n.finished:\n\n    cmp     ecx, 0          ; compare ecx register's value against decimal 0 (our counter register)\n\n    je      .restore        ; jump if equal to 0 (no integer arguments were passed to atoi)\n\n    mov     ebx, 10         ; move decimal value 10 into ebx\n\n    div     ebx             ; divide eax by value in ebx (in this case 10)\n\n\n\n.restore:\n\n    pop     esi             ; restore esi from the value we pushed onto the stack at the start\n\n    pop     edx             ; restore edx from the value we pushed onto the stack at the start\n\n    pop     ecx             ; restore ecx from the value we pushed onto the stack at the start\n\n    pop     ebx             ; restore ebx from the value we pushed onto the stack at the start\n\n    ret\n\n\n\n\n\n;------------------------------------------\n\n; void iprint(Integer number)\n\n; Integer printing function (itoa)\n\niprint:\n\n    push    eax             ; preserve eax on the stack to be restored after function runs\n\n    push    ecx             ; preserve ecx on the stack to be restored after function runs\n\n    push    edx             ; preserve edx on the stack to be restored after function runs\n\n    push    esi             ; preserve esi on the stack to be restored after function runs\n\n    mov     ecx, 0          ; counter of how many bytes we need to print in the end\n\n\n\n.divideLoop:\n\n    inc     ecx             ; count each byte to print - number of characters\n\n    mov     edx, 0          ; empty edx\n\n    mov     esi, 10         ; mov 10 into esi\n\n    idiv    esi             ; divide eax by esi\n\n    add     edx, 48         ; convert edx to it's ascii representation - edx holds the remainder after a divide instruction\n\n    push    edx             ; push edx (string representation of an intger) onto the stack\n\n    cmp     eax, 0          ; can the integer be divided anymore?\n\n    jnz     .divideLoop     ; jump if not zero to the label divideLoop\n\n\n\n.printLoop:\n\n    dec     ecx             ; count down each byte that we put on the stack\n\n    mov     eax, esp        ; mov the stack pointer into eax for printing\n\n    call    sprint          ; call our string print function\n\n    pop     eax             ; remove last character from the stack to move esp forward\n\n    cmp     ecx, 0          ; have we printed all bytes we pushed onto the stack?\n\n    jnz     .printLoop      ; jump is not zero to the label printLoop\n\n\n\n    pop     esi             ; restore esi from the value we pushed onto the stack at the start\n\n    pop     edx             ; restore edx from the value we pushed onto the stack at the start\n\n    pop     ecx             ; restore ecx from the value we pushed onto the stack at the start\n\n    pop     eax             ; restore eax from the value we pushed onto the stack at the start\n\n    ret\n\n\n\n\n\n;------------------------------------------\n\n; void iprintLF(Integer number)\n\n; Integer printing function with linefeed (itoa)\n\niprintLF:\n\n    call    iprint          ; call our integer printing function\n\n\n\n    push    eax             ; push eax onto the stack to preserve it while we use the eax register in this function\n\n    mov     eax, 0Ah        ; move 0Ah into eax - 0Ah is the ascii character for a linefeed\n\n    push    eax             ; push the linefeed onto the stack so we can get the address\n\n    mov     eax, esp        ; move the address of the current stack pointer into eax for sprint\n\n    call    sprint          ; call our sprint function\n\n    pop     eax             ; remove our linefeed character from the stack\n\n    pop     eax             ; restore the original value of eax before our function was called\n\n    ret\n\n\n\n\n\n;------------------------------------------\n\n; int slen(String message)\n\n; String length calculation function\n\nslen:\n\n    push    ebx\n\n    mov     ebx, eax\n\n\n\n.nextchar:\n\n    cmp     byte [eax], 0\n\n    jz      .finished\n\n    inc     eax\n\n    jmp     .nextchar\n\n\n\n.finished:\n\n    sub     eax, ebx\n\n    pop     ebx\n\n    ret\n\n\n\n\n\n;------------------------------------------\n\n; void sprint(String message)\n\n; String printing function\n\nsprint:\n\n    push    edx\n\n    push    ecx\n\n    push    ebx\n\n    push    eax\n\n    call    slen\n\n\n\n    mov     edx, eax\n\n    pop     eax\n\n\n\n    mov     ecx, eax\n\n    mov     ebx, 1\n\n    mov     eax, 4\n\n    int     80h\n\n\n\n    pop     ebx\n\n    pop     ecx\n\n    pop     edx\n\n    ret\n\n\n\n\n\n;------------------------------------------\n\n; void sprintLF(String message)\n\n; String printing with line feed function\n\nsprintLF:\n\n    call    sprint\n\n\n\n    push    eax\n\n    mov     eax, 0AH\n\n    push    eax\n\n    mov     eax, esp\n\n    call    sprint\n\n    pop     eax\n\n    pop     eax\n\n    ret\n\n\n\n\n\n;------------------------------------------\n\n; void exit()\n\n; Exit program and restore resources\n\nquit:\n\n    mov     ebx, 0\n\n    mov     eax, 1\n\n    int     80h\n\n    ret\n\n\n", "; Seek\n\n; Compile with: nasm -f elf seek.asm\n\n; Link with (64 bit systems require elf_i386 option): ld -m elf_i386 seek.o -o seek\n\n; Run with: ./seek\n\n\n\n%include    'functions.asm'\n\n\n\nSECTION .data\n\nfilename db 'readme.txt', 0h    ; the filename to create\n\ncontents  db '-updated-', 0h     ; the contents to write at the start of the file\n\n\n\nSECTION .text\n\nglobal  _start\n\n\n\n_start:\n\n\n\n    mov     ecx, 1              ; flag for writeonly access mode (O_WRONLY)\n\n    mov     ebx, filename       ; filename of the file to open\n\n    mov     eax, 5              ; invoke SYS_OPEN (kernel opcode 5)\n\n    int     80h                 ; call the kernel\n\n\n\n    mov     edx, 2              ; whence argument (SEEK_END)\n\n    mov     ecx, 0              ; move the cursor 0 bytes\n\n    mov     ebx, eax            ; move the opened file descriptor into EBX\n\n    mov     eax, 19             ; invoke SYS_LSEEK (kernel opcode 19)\n\n    int     80h                 ; call the kernel\n\n\n\n    mov     edx, 9              ; number of bytes to write - one for each letter of our contents string\n\n    mov     ecx, contents       ; move the memory address of our contents string into ecx\n\n    mov     ebx, ebx            ; move the opened file descriptor into EBX (not required as EBX already has the FD)\n\n    mov     eax, 4              ; invoke SYS_WRITE (kernel opcode 4)\n\n    int     80h                 ; call the kernel\n\n\n\n    call    quit                ; call our quit function\n", ";------------------------------------------\n\n; int atoi(Integer number)\n\n; Ascii to integer function (atoi)\n\natoi:\n\n    push    ebx             ; preserve ebx on the stack to be restored after function runs\n\n    push    ecx             ; preserve ecx on the stack to be restored after function runs\n\n    push    edx             ; preserve edx on the stack to be restored after function runs\n\n    push    esi             ; preserve esi on the stack to be restored after function runs\n\n    mov     esi, eax        ; move pointer in eax into esi (our number to convert)\n\n    mov     eax, 0          ; initialise eax with decimal value 0\n\n    mov     ecx, 0          ; initialise ecx with decimal value 0\n\n\n\n.multiplyLoop:\n\n    xor     ebx, ebx        ; resets both lower and uppper bytes of ebx to be 0\n\n    mov     bl, [esi+ecx]   ; move a single byte into ebx register's lower half\n\n    cmp     bl, 48          ; compare ebx register's lower half value against ascii value 48 (char value 0)\n\n    jl      .finished       ; jump if less than to label finished\n\n    cmp     bl, 57          ; compare ebx register's lower half value against ascii value 57 (char value 9)\n\n    jg      .finished       ; jump if greater than to label finished\n\n\n\n    sub     bl, 48          ; convert ebx register's lower half to decimal representation of ascii value\n\n    add     eax, ebx        ; add ebx to our interger value in eax\n\n    mov     ebx, 10         ; move decimal value 10 into ebx\n\n    mul     ebx             ; multiply eax by ebx to get place value\n\n    inc     ecx             ; increment ecx (our counter register)\n\n    jmp     .multiplyLoop   ; continue multiply loop\n\n\n\n.finished:\n\n    cmp     ecx, 0          ; compare ecx register's value against decimal 0 (our counter register)\n\n    je      .restore        ; jump if equal to 0 (no integer arguments were passed to atoi)\n\n    mov     ebx, 10         ; move decimal value 10 into ebx\n\n    div     ebx             ; divide eax by value in ebx (in this case 10)\n\n\n\n.restore:\n\n    pop     esi             ; restore esi from the value we pushed onto the stack at the start\n\n    pop     edx             ; restore edx from the value we pushed onto the stack at the start\n\n    pop     ecx             ; restore ecx from the value we pushed onto the stack at the start\n\n    pop     ebx             ; restore ebx from the value we pushed onto the stack at the start\n\n    ret\n\n\n\n\n\n;------------------------------------------\n\n; void iprint(Integer number)\n\n; Integer printing function (itoa)\n\niprint:\n\n    push    eax             ; preserve eax on the stack to be restored after function runs\n\n    push    ecx             ; preserve ecx on the stack to be restored after function runs\n\n    push    edx             ; preserve edx on the stack to be restored after function runs\n\n    push    esi             ; preserve esi on the stack to be restored after function runs\n\n    mov     ecx, 0          ; counter of how many bytes we need to print in the end\n\n\n\n.divideLoop:\n\n    inc     ecx             ; count each byte to print - number of characters\n\n    mov     edx, 0          ; empty edx\n\n    mov     esi, 10         ; mov 10 into esi\n\n    idiv    esi             ; divide eax by esi\n\n    add     edx, 48         ; convert edx to it's ascii representation - edx holds the remainder after a divide instruction\n\n    push    edx             ; push edx (string representation of an intger) onto the stack\n\n    cmp     eax, 0          ; can the integer be divided anymore?\n\n    jnz     .divideLoop     ; jump if not zero to the label divideLoop\n\n\n\n.printLoop:\n\n    dec     ecx             ; count down each byte that we put on the stack\n\n    mov     eax, esp        ; mov the stack pointer into eax for printing\n\n    call    sprint          ; call our string print function\n\n    pop     eax             ; remove last character from the stack to move esp forward\n\n    cmp     ecx, 0          ; have we printed all bytes we pushed onto the stack?\n\n    jnz     .printLoop      ; jump is not zero to the label printLoop\n\n\n\n    pop     esi             ; restore esi from the value we pushed onto the stack at the start\n\n    pop     edx             ; restore edx from the value we pushed onto the stack at the start\n\n    pop     ecx             ; restore ecx from the value we pushed onto the stack at the start\n\n    pop     eax             ; restore eax from the value we pushed onto the stack at the start\n\n    ret\n\n\n\n\n\n;------------------------------------------\n\n; void iprintLF(Integer number)\n\n; Integer printing function with linefeed (itoa)\n\niprintLF:\n\n    call    iprint          ; call our integer printing function\n\n\n\n    push    eax             ; push eax onto the stack to preserve it while we use the eax register in this function\n\n    mov     eax, 0Ah        ; move 0Ah into eax - 0Ah is the ascii character for a linefeed\n\n    push    eax             ; push the linefeed onto the stack so we can get the address\n\n    mov     eax, esp        ; move the address of the current stack pointer into eax for sprint\n\n    call    sprint          ; call our sprint function\n\n    pop     eax             ; remove our linefeed character from the stack\n\n    pop     eax             ; restore the original value of eax before our function was called\n\n    ret\n\n\n\n\n\n;------------------------------------------\n\n; int slen(String message)\n\n; String length calculation function\n\nslen:\n\n    push    ebx\n\n    mov     ebx, eax\n\n\n\n.nextchar:\n\n    cmp     byte [eax], 0\n\n    jz      .finished\n\n    inc     eax\n\n    jmp     .nextchar\n\n\n\n.finished:\n\n    sub     eax, ebx\n\n    pop     ebx\n\n    ret\n\n\n\n\n\n;------------------------------------------\n\n; void sprint(String message)\n\n; String printing function\n\nsprint:\n\n    push    edx\n\n    push    ecx\n\n    push    ebx\n\n    push    eax\n\n    call    slen\n\n\n\n    mov     edx, eax\n\n    pop     eax\n\n\n\n    mov     ecx, eax\n\n    mov     ebx, 1\n\n    mov     eax, 4\n\n    int     80h\n\n\n\n    pop     ebx\n\n    pop     ecx\n\n    pop     edx\n\n    ret\n\n\n\n\n\n;------------------------------------------\n\n; void sprintLF(String message)\n\n; String printing with line feed function\n\nsprintLF:\n\n    call    sprint\n\n\n\n    push    eax\n\n    mov     eax, 0AH\n\n    push    eax\n\n    mov     eax, esp\n\n    call    sprint\n\n    pop     eax\n\n    pop     eax\n\n    ret\n\n\n\n\n\n;------------------------------------------\n\n; void exit()\n\n; Exit program and restore resources\n\nquit:\n\n    mov     ebx, 0\n\n    mov     eax, 1\n\n    int     80h\n\n    ret\n\n\n", ";------------------------------------------\n\n; int slen(String message)\n\n; String length calculation function\n\nslen:                     \n\n    push    ebx             \n\n    mov     ebx, eax        \n\n    \n\nnextchar:                   \n\n    cmp     byte [eax], 0   \n\n    jz      finished        \n\n    inc     eax             \n\n    jmp     nextchar        \n\n    \n\nfinished:\n\n    sub     eax, ebx\n\n    pop     ebx             \n\n    ret                     \n\n\n\n\n\n;------------------------------------------\n\n; void sprint(String message)\n\n; String printing function\n\nsprint:\n\n    push    edx         \n\n    push    ecx\n\n    push    ebx\n\n    push    eax\n\n    call    slen\n\n    \n\n    mov     edx, eax\n\n    pop     eax\n\n    \n\n    mov     ecx, eax\n\n    mov     ebx, 1\n\n    mov     eax, 4\n\n    int     80h\n\n    \n\n    pop     ebx\n\n    pop     ecx\n\n    pop     edx\n\n    ret\n\n\n\n\n\n;------------------------------------------\n\n; void exit()\n\n; Exit program and restore resources\n\nquit:\n\n    mov     ebx, 0      \n\n    mov     eax, 1      \n\n    int     80h\n\n    ret\n\n\n", "; Hello World Program (External file include)\n\n; Compile with: nasm -f elf helloworld-inc.asm\n\n; Link with (64 bit systems require elf_i386 option): ld -m elf_i386 helloworld-inc.o -o helloworld-inc\n\n; Run with: ./helloworld-inc\n\n\n\n%include        'functions.asm'                             ; include our external file\n\n\n\nSECTION .data\n\nmsg1    db      'Hello, brave new world!', 0Ah              ; our first message string\n\nmsg2    db      'This is how we recycle in NASM.', 0Ah      ; our second message string\n\n\n\nSECTION .text\n\nglobal  _start\n\n    \n\n_start: \n\n\n\n    mov     eax, msg1       ; move the address of our first message string into EAX\n\n    call    sprint          ; call our string printing function\n\n    \n\n    mov     eax, msg2       ; move the address of our second message string into EAX\n\n    call    sprint          ; call our string printing function\n\n    \n\n    call    quit            ; call our quit function", "; Socket\n\n; Compile with: nasm -f elf socket.asm\n\n; Link with (64 bit systems require elf_i386 option): ld -m elf_i386 socket.o -o socket\n\n; Run with: ./socket\n\n\n\n%include    'functions.asm'\n\n\n\nSECTION .text\n\nglobal  _start\n\n\n\n_start:\n\n\n\n    xor     eax, eax            ; initialize some registers\n\n    xor     ebx, ebx\n\n    xor     edi, edi\n\n    xor     esi, esi\n\n\n\n_socket:\n\n\n\n    push    byte 6              ; create socket from lesson 29\n\n    push    byte 1\n\n    push    byte 2\n\n    mov     ecx, esp\n\n    mov     ebx, 1\n\n    mov     eax, 102\n\n    int     80h\n\n\n\n_bind:\n\n\n\n    mov     edi, eax            ; bind socket from lesson 30\n\n    push    dword 0x00000000\n\n    push    word 0x2923\n\n    push    word 2\n\n    mov     ecx, esp\n\n    push    byte 16\n\n    push    ecx\n\n    push    edi\n\n    mov     ecx, esp\n\n    mov     ebx, 2\n\n    mov     eax, 102\n\n    int     80h\n\n\n\n_listen:\n\n\n\n    push    byte 1              ; move 1 onto stack (max queue length argument)\n\n    push    edi                 ; push the file descriptor onto stack\n\n    mov     ecx, esp            ; move address of arguments into ecx\n\n    mov     ebx, 4              ; invoke subroutine LISTEN (4)\n\n    mov     eax, 102            ; invoke SYS_SOCKETCALL (kernel opcode 102)\n\n    int     80h                 ; call the kernel\n\n\n\n_exit:\n\n\n\n    call    quit                ; call our quit function\n", ";------------------------------------------\n\n; int atoi(Integer number)\n\n; Ascii to integer function (atoi)\n\natoi:\n\n    push    ebx             ; preserve ebx on the stack to be restored after function runs\n\n    push    ecx             ; preserve ecx on the stack to be restored after function runs\n\n    push    edx             ; preserve edx on the stack to be restored after function runs\n\n    push    esi             ; preserve esi on the stack to be restored after function runs\n\n    mov     esi, eax        ; move pointer in eax into esi (our number to convert)\n\n    mov     eax, 0          ; initialise eax with decimal value 0\n\n    mov     ecx, 0          ; initialise ecx with decimal value 0\n\n\n\n.multiplyLoop:\n\n    xor     ebx, ebx        ; resets both lower and uppper bytes of ebx to be 0\n\n    mov     bl, [esi+ecx]   ; move a single byte into ebx register's lower half\n\n    cmp     bl, 48          ; compare ebx register's lower half value against ascii value 48 (char value 0)\n\n    jl      .finished       ; jump if less than to label finished\n\n    cmp     bl, 57          ; compare ebx register's lower half value against ascii value 57 (char value 9)\n\n    jg      .finished       ; jump if greater than to label finished\n\n\n\n    sub     bl, 48          ; convert ebx register's lower half to decimal representation of ascii value\n\n    add     eax, ebx        ; add ebx to our interger value in eax\n\n    mov     ebx, 10         ; move decimal value 10 into ebx\n\n    mul     ebx             ; multiply eax by ebx to get place value\n\n    inc     ecx             ; increment ecx (our counter register)\n\n    jmp     .multiplyLoop   ; continue multiply loop\n\n\n\n.finished:\n\n    cmp     ecx, 0          ; compare ecx register's value against decimal 0 (our counter register)\n\n    je      .restore        ; jump if equal to 0 (no integer arguments were passed to atoi)\n\n    mov     ebx, 10         ; move decimal value 10 into ebx\n\n    div     ebx             ; divide eax by value in ebx (in this case 10)\n\n\n\n.restore:\n\n    pop     esi             ; restore esi from the value we pushed onto the stack at the start\n\n    pop     edx             ; restore edx from the value we pushed onto the stack at the start\n\n    pop     ecx             ; restore ecx from the value we pushed onto the stack at the start\n\n    pop     ebx             ; restore ebx from the value we pushed onto the stack at the start\n\n    ret\n\n\n\n\n\n;------------------------------------------\n\n; void iprint(Integer number)\n\n; Integer printing function (itoa)\n\niprint:\n\n    push    eax             ; preserve eax on the stack to be restored after function runs\n\n    push    ecx             ; preserve ecx on the stack to be restored after function runs\n\n    push    edx             ; preserve edx on the stack to be restored after function runs\n\n    push    esi             ; preserve esi on the stack to be restored after function runs\n\n    mov     ecx, 0          ; counter of how many bytes we need to print in the end\n\n\n\n.divideLoop:\n\n    inc     ecx             ; count each byte to print - number of characters\n\n    mov     edx, 0          ; empty edx\n\n    mov     esi, 10         ; mov 10 into esi\n\n    idiv    esi             ; divide eax by esi\n\n    add     edx, 48         ; convert edx to it's ascii representation - edx holds the remainder after a divide instruction\n\n    push    edx             ; push edx (string representation of an intger) onto the stack\n\n    cmp     eax, 0          ; can the integer be divided anymore?\n\n    jnz     .divideLoop     ; jump if not zero to the label divideLoop\n\n\n\n.printLoop:\n\n    dec     ecx             ; count down each byte that we put on the stack\n\n    mov     eax, esp        ; mov the stack pointer into eax for printing\n\n    call    sprint          ; call our string print function\n\n    pop     eax             ; remove last character from the stack to move esp forward\n\n    cmp     ecx, 0          ; have we printed all bytes we pushed onto the stack?\n\n    jnz     .printLoop      ; jump is not zero to the label printLoop\n\n\n\n    pop     esi             ; restore esi from the value we pushed onto the stack at the start\n\n    pop     edx             ; restore edx from the value we pushed onto the stack at the start\n\n    pop     ecx             ; restore ecx from the value we pushed onto the stack at the start\n\n    pop     eax             ; restore eax from the value we pushed onto the stack at the start\n\n    ret\n\n\n\n\n\n;------------------------------------------\n\n; void iprintLF(Integer number)\n\n; Integer printing function with linefeed (itoa)\n\niprintLF:\n\n    call    iprint          ; call our integer printing function\n\n\n\n    push    eax             ; push eax onto the stack to preserve it while we use the eax register in this function\n\n    mov     eax, 0Ah        ; move 0Ah into eax - 0Ah is the ascii character for a linefeed\n\n    push    eax             ; push the linefeed onto the stack so we can get the address\n\n    mov     eax, esp        ; move the address of the current stack pointer into eax for sprint\n\n    call    sprint          ; call our sprint function\n\n    pop     eax             ; remove our linefeed character from the stack\n\n    pop     eax             ; restore the original value of eax before our function was called\n\n    ret\n\n\n\n\n\n;------------------------------------------\n\n; int slen(String message)\n\n; String length calculation function\n\nslen:\n\n    push    ebx\n\n    mov     ebx, eax\n\n\n\n.nextchar:\n\n    cmp     byte [eax], 0\n\n    jz      .finished\n\n    inc     eax\n\n    jmp     .nextchar\n\n\n\n.finished:\n\n    sub     eax, ebx\n\n    pop     ebx\n\n    ret\n\n\n\n\n\n;------------------------------------------\n\n; void sprint(String message)\n\n; String printing function\n\nsprint:\n\n    push    edx\n\n    push    ecx\n\n    push    ebx\n\n    push    eax\n\n    call    slen\n\n\n\n    mov     edx, eax\n\n    pop     eax\n\n\n\n    mov     ecx, eax\n\n    mov     ebx, 1\n\n    mov     eax, 4\n\n    int     80h\n\n\n\n    pop     ebx\n\n    pop     ecx\n\n    pop     edx\n\n    ret\n\n\n\n\n\n;------------------------------------------\n\n; void sprintLF(String message)\n\n; String printing with line feed function\n\nsprintLF:\n\n    call    sprint\n\n\n\n    push    eax\n\n    mov     eax, 0AH\n\n    push    eax\n\n    mov     eax, esp\n\n    call    sprint\n\n    pop     eax\n\n    pop     eax\n\n    ret\n\n\n\n\n\n;------------------------------------------\n\n; void exit()\n\n; Exit program and restore resources\n\nquit:\n\n    mov     ebx, 0\n\n    mov     eax, 1\n\n    int     80h\n\n    ret\n\n\n", "; Hello World Program (Passing arguments from the command line)\n\n; Compile with: nasm -f elf helloworld-args.asm\n\n; Link with (64 bit systems require elf_i386 option): ld -m elf_i386 helloworld-args.o -o helloworld-args\n\n; Run with: ./helloworld-args\n\n\n\n%include        'functions.asm'\n\n\n\nSECTION .text\n\nglobal  _start\n\n\n\n_start:\n\n\n\n    pop     ecx             ; first value on the stack is the number of arguments\n\n\n\nnextArg:\n\n    cmp     ecx, 0H         ; check to see if we have any arguments left\n\n    jz      noMoreArgs      ; if zero flag is set jump to noMoreArgs label (by jumping over the end of the loop)\n\n    pop     eax             ; pop the next argument off the stack\n\n    call    sprintLF        ; call our print with linefeed function\n\n    dec     ecx             ; decrease edi (number of arguments left) by 1\n\n    jmp     nextArg         ; jump to nextArg label\n\n\n\nnoMoreArgs:\n\n    call    quit", ";------------------------------------------\n\n; int slen(String message)\n\n; String length calculation function\n\nslen:                     \n\n    push    ebx             \n\n    mov     ebx, eax        \n\n    \n\nnextchar:                   \n\n    cmp     byte [eax], 0   \n\n    jz      finished        \n\n    inc     eax             \n\n    jmp     nextchar        \n\n    \n\nfinished:\n\n    sub     eax, ebx\n\n    pop     ebx             \n\n    ret                     \n\n\n\n\n\n;------------------------------------------\n\n; void sprint(String message)\n\n; String printing function\n\nsprint:\n\n    push    edx\n\n    push    ecx\n\n    push    ebx\n\n    push    eax\n\n    call    slen\n\n    \n\n    mov     edx, eax\n\n    pop     eax\n\n    \n\n    mov     ecx, eax\n\n    mov     ebx, 1\n\n    mov     eax, 4\n\n    int     80h\n\n    \n\n    pop     ebx\n\n    pop     ecx\n\n    pop     edx\n\n    ret\n\n\n\n\n\n;------------------------------------------\n\n; void sprintLF(String message)\n\n; String printing with line feed function\n\nsprintLF:\n\n    call    sprint\n\n\n\n    push    eax\n\n    mov     eax, 0AH\n\n    push    eax\n\n    mov     eax, esp\n\n    call    sprint\n\n    pop     eax\n\n    pop     eax\n\n    ret\n\n\n\n    \n\n;------------------------------------------\n\n; void exit()\n\n; Exit program and restore resources\n\nquit:\n\n    mov     ebx, 0      \n\n    mov     eax, 1      \n\n    int     80h\n\n    ret\n\n\n", "; Calculator (Subtraction)\n\n; Compile with: nasm -f elf calculator-subtraction.asm\n\n; Link with (64 bit systems require elf_i386 option): ld -m elf_i386 calculator-subtraction.o -o calculator-subtraction\n\n; Run with: ./calculator-subtraction\n\n\n\n%include        'functions.asm'\n\n\n\nSECTION .text\n\nglobal  _start\n\n\n\n_start:\n\n\n\n    mov     eax, 90     ; move our first number into eax\n\n    mov     ebx, 9      ; move our second number into ebx\n\n    sub     eax, ebx    ; subtract ebx from eax\n\n    call    iprintLF    ; call our integer print with linefeed function\n\n\n\n    call    quit", ";------------------------------------------\n\n; void iprint(Integer number)\n\n; Integer printing function (itoa)\n\niprint:\n\n    push    eax             ; preserve eax on the stack to be restored after function runs\n\n    push    ecx             ; preserve ecx on the stack to be restored after function runs\n\n    push    edx             ; preserve edx on the stack to be restored after function runs\n\n    push    esi             ; preserve esi on the stack to be restored after function runs\n\n    mov     ecx, 0          ; counter of how many bytes we need to print in the end\n\n    \n\ndivideLoop:\n\n    inc     ecx             ; count each byte to print - number of characters\n\n    mov     edx, 0          ; empty edx\n\n    mov     esi, 10         ; mov 10 into esi\n\n    idiv    esi             ; divide eax by esi\n\n    add     edx, 48         ; convert edx to it's ascii representation - edx holds the remainder after a divide instruction\n\n    push    edx             ; push edx (string representation of an intger) onto the stack\n\n    cmp     eax, 0          ; can the integer be divided anymore?\n\n    jnz     divideLoop      ; jump if not zero to the label divideLoop\n\n\n\nprintLoop:\n\n    dec     ecx             ; count down each byte that we put on the stack\n\n    mov     eax, esp        ; mov the stack pointer into eax for printing\n\n    call    sprint          ; call our string print function\n\n    pop     eax             ; remove last character from the stack to move esp forward\n\n    cmp     ecx, 0          ; have we printed all bytes we pushed onto the stack?\n\n    jnz     printLoop       ; jump is not zero to the label printLoop\n\n\n\n    pop     esi             ; restore esi from the value we pushed onto the stack at the start\n\n    pop     edx             ; restore edx from the value we pushed onto the stack at the start\n\n    pop     ecx             ; restore ecx from the value we pushed onto the stack at the start\n\n    pop     eax             ; restore eax from the value we pushed onto the stack at the start\n\n    ret\n\n\n\n\n\n;------------------------------------------\n\n; void iprintLF(Integer number)\n\n; Integer printing function with linefeed (itoa)\n\niprintLF:\n\n    call    iprint          ; call our integer printing function\n\n\n\n    push    eax             ; push eax onto the stack to preserve it while we use the eax register in this function\n\n    mov     eax, 0Ah        ; move 0Ah into eax - 0Ah is the ascii character for a linefeed\n\n    push    eax             ; push the linefeed onto the stack so we can get the address\n\n    mov     eax, esp        ; move the address of the current stack pointer into eax for sprint\n\n    call    sprint          ; call our sprint function\n\n    pop     eax             ; remove our linefeed character from the stack\n\n    pop     eax             ; restore the original value of eax before our function was called\n\n    ret\n\n\n\n    \n\n;------------------------------------------\n\n; int slen(String message)\n\n; String length calculation function\n\nslen:                     \n\n    push    ebx             \n\n    mov     ebx, eax        \n\n    \n\nnextchar:                   \n\n    cmp     byte [eax], 0   \n\n    jz      finished        \n\n    inc     eax             \n\n    jmp     nextchar        \n\n    \n\nfinished:\n\n    sub     eax, ebx\n\n    pop     ebx             \n\n    ret                     \n\n\n\n\n\n;------------------------------------------\n\n; void sprint(String message)\n\n; String printing function\n\nsprint:\n\n    push    edx\n\n    push    ecx\n\n    push    ebx\n\n    push    eax\n\n    call    slen\n\n    \n\n    mov     edx, eax\n\n    pop     eax\n\n    \n\n    mov     ecx, eax\n\n    mov     ebx, 1\n\n    mov     eax, 4\n\n    int     80h\n\n\n\n    pop     ebx\n\n    pop     ecx\n\n    pop     edx\n\n    ret\n\n\n\n\n\n;------------------------------------------\n\n; void sprintLF(String message)\n\n; String printing with line feed function\n\nsprintLF:\n\n    call    sprint\n\n\n\n    push    eax\n\n    mov     eax, 0AH\n\n    push    eax\n\n    mov     eax, esp\n\n    call    sprint\n\n    pop     eax\n\n    pop     eax\n\n    ret\n\n\n\n    \n\n;------------------------------------------\n\n; void exit()\n\n; Exit program and restore resources\n\nquit:\n\n    mov     ebx, 0      \n\n    mov     eax, 1      \n\n    int     80h\n\n    ret\n\n\n", ";------------------------------------------\n\n; void iprint(Integer number)\n\n; Integer printing function (itoa)\n\niprint:\n\n    push    eax             ; preserve eax on the stack to be restored after function runs\n\n    push    ecx             ; preserve ecx on the stack to be restored after function runs\n\n    push    edx             ; preserve edx on the stack to be restored after function runs\n\n    push    esi             ; preserve esi on the stack to be restored after function runs\n\n    mov     ecx, 0          ; counter of how many bytes we need to print in the end\n\n    \n\ndivideLoop:\n\n    inc     ecx             ; count each byte to print - number of characters\n\n    mov     edx, 0          ; empty edx\n\n    mov     esi, 10         ; mov 10 into esi\n\n    idiv    esi             ; divide eax by esi\n\n    add     edx, 48         ; convert edx to it's ascii representation - edx holds the remainder after a divide instruction\n\n    push    edx             ; push edx (string representation of an intger) onto the stack\n\n    cmp     eax, 0          ; can the integer be divided anymore?\n\n    jnz     divideLoop      ; jump if not zero to the label divideLoop\n\n\n\nprintLoop:\n\n    dec     ecx             ; count down each byte that we put on the stack\n\n    mov     eax, esp        ; mov the stack pointer into eax for printing\n\n    call    sprint          ; call our string print function\n\n    pop     eax             ; remove last character from the stack to move esp forward\n\n    cmp     ecx, 0          ; have we printed all bytes we pushed onto the stack?\n\n    jnz     printLoop       ; jump is not zero to the label printLoop\n\n\n\n    pop     esi             ; restore esi from the value we pushed onto the stack at the start\n\n    pop     edx             ; restore edx from the value we pushed onto the stack at the start\n\n    pop     ecx             ; restore ecx from the value we pushed onto the stack at the start\n\n    pop     eax             ; restore eax from the value we pushed onto the stack at the start\n\n    ret\n\n\n\n\n\n;------------------------------------------\n\n; void iprintLF(Integer number)\n\n; Integer printing function with linefeed (itoa)\n\niprintLF:\n\n    call    iprint          ; call our integer printing function\n\n\n\n    push    eax             ; push eax onto the stack to preserve it while we use the eax register in this function\n\n    mov     eax, 0Ah        ; move 0Ah into eax - 0Ah is the ascii character for a linefeed\n\n    push    eax             ; push the linefeed onto the stack so we can get the address\n\n    mov     eax, esp        ; move the address of the current stack pointer into eax for sprint\n\n    call    sprint          ; call our sprint function\n\n    pop     eax             ; remove our linefeed character from the stack\n\n    pop     eax             ; restore the original value of eax before our function was called\n\n    ret\n\n\n\n    \n\n;------------------------------------------\n\n; int slen(String message)\n\n; String length calculation function\n\nslen:                     \n\n    push    ebx             \n\n    mov     ebx, eax        \n\n    \n\nnextchar:                   \n\n    cmp     byte [eax], 0   \n\n    jz      finished        \n\n    inc     eax             \n\n    jmp     nextchar        \n\n    \n\nfinished:\n\n    sub     eax, ebx\n\n    pop     ebx             \n\n    ret                     \n\n\n\n\n\n;------------------------------------------\n\n; void sprint(String message)\n\n; String printing function\n\nsprint:\n\n    push    edx\n\n    push    ecx\n\n    push    ebx\n\n    push    eax\n\n    call    slen\n\n    \n\n    mov     edx, eax\n\n    pop     eax\n\n    \n\n    mov     ecx, eax\n\n    mov     ebx, 1\n\n    mov     eax, 4\n\n    int     80h\n\n\n\n    pop     ebx\n\n    pop     ecx\n\n    pop     edx\n\n    ret\n\n\n\n\n\n;------------------------------------------\n\n; void sprintLF(String message)\n\n; String printing with line feed function\n\nsprintLF:\n\n    call    sprint\n\n\n\n    push    eax\n\n    mov     eax, 0AH\n\n    push    eax\n\n    mov     eax, esp\n\n    call    sprint\n\n    pop     eax\n\n    pop     eax\n\n    ret\n\n\n\n    \n\n;------------------------------------------\n\n; void exit()\n\n; Exit program and restore resources\n\nquit:\n\n    mov     ebx, 0      \n\n    mov     eax, 1      \n\n    int     80h\n\n    ret\n\n\n", "; Calculator (Multiplication)\n\n; Compile with: nasm -f elf calculator-multiplication.asm\n\n; Link with (64 bit systems require elf_i386 option): ld -m elf_i386 calculator-multiplication.o -o calculator-multiplication\n\n; Run with: ./calculator-multiplication\n\n\n\n%include        'functions.asm'\n\n\n\nSECTION .text\n\nglobal  _start\n\n\n\n_start:\n\n\n\n    mov     eax, 90     ; move our first number into eax\n\n    mov     ebx, 9      ; move our second number into ebx\n\n    mul     ebx         ; multiply eax by ebx\n\n    call    iprintLF    ; call our integer print with linefeed function\n\n\n\n    call    quit", "; Calculator (ATOI)\n\n; Compile with: nasm -f elf calculator-atoi.asm\n\n; Link with (64 bit systems require elf_i386 option): ld -m elf_i386 calculator-atoi.o -o calculator-atoi\n\n; Run with: ./calculator-atoi 20 1000 317\n\n\n\n%include        'functions.asm'\n\n\n\nSECTION .text\n\nglobal  _start\n\n\n\n_start:\n\n\n\n    pop     ecx             ; first value on the stack is the number of arguments\n\n    pop     edx             ; second value on the stack is the program name (discarded when we initialise edx)\n\n    sub     ecx, 1          ; decrease ecx by 1 (number of arguments without program name)\n\n    mov     edx, 0          ; initialise our data register to store additions\n\n\n\nnextArg:\n\n    cmp     ecx, 0h         ; check to see if we have any arguments left\n\n    jz      noMoreArgs      ; if zero flag is set jump to noMoreArgs label (jumping over the end of the loop)\n\n    pop     eax             ; pop the next argument off the stack\n\n    call    atoi            ; convert our ascii string to decimal integer\n\n    add     edx, eax        ; perform our addition logic\n\n    dec     ecx             ; decrease ecx (number of arguments left) by 1\n\n    jmp     nextArg         ; jump to nextArg label\n\n\n\nnoMoreArgs:\n\n    mov     eax, edx        ; move our data result into eax for printing\n\n    call    iprintLF        ; call our integer printing with linefeed function\n\n    call    quit            ; call our quit function\n", ";------------------------------------------\n\n; int atoi(Integer number)\n\n; Ascii to integer function (atoi)\n\natoi:\n\n    push    ebx             ; preserve ebx on the stack to be restored after function runs\n\n    push    ecx             ; preserve ecx on the stack to be restored after function runs\n\n    push    edx             ; preserve edx on the stack to be restored after function runs\n\n    push    esi             ; preserve esi on the stack to be restored after function runs\n\n    mov     esi, eax        ; move pointer in eax into esi (our number to convert)\n\n    mov     eax, 0          ; initialise eax with decimal value 0\n\n    mov     ecx, 0          ; initialise ecx with decimal value 0\n\n\n\n.multiplyLoop:\n\n    xor     ebx, ebx        ; resets both lower and uppper bytes of ebx to be 0\n\n    mov     bl, [esi+ecx]   ; move a single byte into ebx register's lower half\n\n    cmp     bl, 48          ; compare ebx register's lower half value against ascii value 48 (char value 0)\n\n    jl      .finished       ; jump if less than to label finished\n\n    cmp     bl, 57          ; compare ebx register's lower half value against ascii value 57 (char value 9)\n\n    jg      .finished       ; jump if greater than to label finished\n\n\n\n    sub     bl, 48          ; convert ebx register's lower half to decimal representation of ascii value\n\n    add     eax, ebx        ; add ebx to our interger value in eax\n\n    mov     ebx, 10         ; move decimal value 10 into ebx\n\n    mul     ebx             ; multiply eax by ebx to get place value\n\n    inc     ecx             ; increment ecx (our counter register)\n\n    jmp     .multiplyLoop   ; continue multiply loop\n\n\n\n.finished:\n\n    cmp     ecx, 0          ; compare ecx register's value against decimal 0 (our counter register)\n\n    je      .restore        ; jump if equal to 0 (no integer arguments were passed to atoi)\n\n    mov     ebx, 10         ; move decimal value 10 into ebx\n\n    div     ebx             ; divide eax by value in ebx (in this case 10)\n\n\n\n.restore:\n\n    pop     esi             ; restore esi from the value we pushed onto the stack at the start\n\n    pop     edx             ; restore edx from the value we pushed onto the stack at the start\n\n    pop     ecx             ; restore ecx from the value we pushed onto the stack at the start\n\n    pop     ebx             ; restore ebx from the value we pushed onto the stack at the start\n\n    ret\n\n\n\n\n\n;------------------------------------------\n\n; void iprint(Integer number)\n\n; Integer printing function (itoa)\n\niprint:\n\n    push    eax             ; preserve eax on the stack to be restored after function runs\n\n    push    ecx             ; preserve ecx on the stack to be restored after function runs\n\n    push    edx             ; preserve edx on the stack to be restored after function runs\n\n    push    esi             ; preserve esi on the stack to be restored after function runs\n\n    mov     ecx, 0          ; counter of how many bytes we need to print in the end\n\n\n\n.divideLoop:\n\n    inc     ecx             ; count each byte to print - number of characters\n\n    mov     edx, 0          ; empty edx\n\n    mov     esi, 10         ; mov 10 into esi\n\n    idiv    esi             ; divide eax by esi\n\n    add     edx, 48         ; convert edx to it's ascii representation - edx holds the remainder after a divide instruction\n\n    push    edx             ; push edx (string representation of an intger) onto the stack\n\n    cmp     eax, 0          ; can the integer be divided anymore?\n\n    jnz     .divideLoop      ; jump if not zero to the label divideLoop\n\n\n\n.printLoop:\n\n    dec     ecx             ; count down each byte that we put on the stack\n\n    mov     eax, esp        ; mov the stack pointer into eax for printing\n\n    call    sprint          ; call our string print function\n\n    pop     eax             ; remove last character from the stack to move esp forward\n\n    cmp     ecx, 0          ; have we printed all bytes we pushed onto the stack?\n\n    jnz     .printLoop       ; jump is not zero to the label printLoop\n\n\n\n    pop     esi             ; restore esi from the value we pushed onto the stack at the start\n\n    pop     edx             ; restore edx from the value we pushed onto the stack at the start\n\n    pop     ecx             ; restore ecx from the value we pushed onto the stack at the start\n\n    pop     eax             ; restore eax from the value we pushed onto the stack at the start\n\n    ret\n\n\n\n\n\n;------------------------------------------\n\n; void iprintLF(Integer number)\n\n; Integer printing function with linefeed (itoa)\n\niprintLF:\n\n    call    iprint          ; call our integer printing function\n\n\n\n    push    eax             ; push eax onto the stack to preserve it while we use the eax register in this function\n\n    mov     eax, 0Ah        ; move 0Ah into eax - 0Ah is the ascii character for a linefeed\n\n    push    eax             ; push the linefeed onto the stack so we can get the address\n\n    mov     eax, esp        ; move the address of the current stack pointer into eax for sprint\n\n    call    sprint          ; call our sprint function\n\n    pop     eax             ; remove our linefeed character from the stack\n\n    pop     eax             ; restore the original value of eax before our function was called\n\n    ret\n\n\n\n\n\n;------------------------------------------\n\n; int slen(String message)\n\n; String length calculation function\n\nslen:\n\n    push    ebx\n\n    mov     ebx, eax\n\n\n\n.nextchar:\n\n    cmp     byte [eax], 0\n\n    jz      .finished\n\n    inc     eax\n\n    jmp     .nextchar\n\n\n\n.finished:\n\n    sub     eax, ebx\n\n    pop     ebx\n\n    ret\n\n\n\n\n\n;------------------------------------------\n\n; void sprint(String message)\n\n; String printing function\n\nsprint:\n\n    push    edx\n\n    push    ecx\n\n    push    ebx\n\n    push    eax\n\n    call    slen\n\n\n\n    mov     edx, eax\n\n    pop     eax\n\n\n\n    mov     ecx, eax\n\n    mov     ebx, 1\n\n    mov     eax, 4\n\n    int     80h\n\n\n\n    pop     ebx\n\n    pop     ecx\n\n    pop     edx\n\n    ret\n\n\n\n\n\n;------------------------------------------\n\n; void sprintLF(String message)\n\n; String printing with line feed function\n\nsprintLF:\n\n    call    sprint\n\n\n\n    push    eax\n\n    mov     eax, 0AH\n\n    push    eax\n\n    mov     eax, esp\n\n    call    sprint\n\n    pop     eax\n\n    pop     eax\n\n    ret\n\n\n\n\n\n;------------------------------------------\n\n; void exit()\n\n; Exit program and restore resources\n\nquit:\n\n    mov     ebx, 0\n\n    mov     eax, 1\n\n    int     80h\n\n    ret\n\n\n", "; Hello World Program (Count to 10 itoa)\n\n; Compile with: nasm -f elf helloworld-itoa.asm\n\n; Link with (64 bit systems require elf_i386 option): ld -m elf_i386 helloworld-itoa.o -o helloworld-itoa\n\n; Run with: ./helloworld-itoa\n\n\n\n%include        'functions.asm'\n\n\n\nSECTION .text\n\nglobal  _start\n\n    \n\n_start: \n\n\n\n    mov     ecx, 0\n\n    \n\nnextNumber:\n\n    inc     ecx\n\n    mov     eax, ecx\n\n    call    iprintLF        ; NOTE call our new integer printing function (itoa)\n\n    cmp     ecx, 10\n\n    jne     nextNumber\n\n      \n\n    call    quit", ";------------------------------------------\n\n; void iprint(Integer number)\n\n; Integer printing function (itoa)\n\niprint:\n\n    push    eax             ; preserve eax on the stack to be restored after function runs\n\n    push    ecx             ; preserve ecx on the stack to be restored after function runs\n\n    push    edx             ; preserve edx on the stack to be restored after function runs\n\n    push    esi             ; preserve esi on the stack to be restored after function runs\n\n    mov     ecx, 0          ; counter of how many bytes we need to print in the end\n\n    \n\ndivideLoop:\n\n    inc     ecx             ; count each byte to print - number of characters\n\n    mov     edx, 0          ; empty edx\n\n    mov     esi, 10         ; mov 10 into esi\n\n    idiv    esi             ; divide eax by esi\n\n    add     edx, 48         ; convert edx to it's ascii representation - edx holds the remainder after a divide instruction\n\n    push    edx             ; push edx (string representation of an intger) onto the stack\n\n    cmp     eax, 0          ; can the integer be divided anymore?\n\n    jnz     divideLoop      ; jump if not zero to the label divideLoop\n\n\n\nprintLoop:\n\n    dec     ecx             ; count down each byte that we put on the stack\n\n    mov     eax, esp        ; mov the stack pointer into eax for printing\n\n    call    sprint          ; call our string print function\n\n    pop     eax             ; remove last character from the stack to move esp forward\n\n    cmp     ecx, 0          ; have we printed all bytes we pushed onto the stack?\n\n    jnz     printLoop       ; jump is not zero to the label printLoop\n\n\n\n    pop     esi             ; restore esi from the value we pushed onto the stack at the start\n\n    pop     edx             ; restore edx from the value we pushed onto the stack at the start\n\n    pop     ecx             ; restore ecx from the value we pushed onto the stack at the start\n\n    pop     eax             ; restore eax from the value we pushed onto the stack at the start\n\n    ret\n\n\n\n\n\n;------------------------------------------\n\n; void iprintLF(Integer number)\n\n; Integer printing function with linefeed (itoa)\n\niprintLF:\n\n    call    iprint          ; call our integer printing function\n\n\n\n    push    eax             ; push eax onto the stack to preserve it while we use the eax register in this function\n\n    mov     eax, 0Ah        ; move 0Ah into eax - 0Ah is the ascii character for a linefeed\n\n    push    eax             ; push the linefeed onto the stack so we can get the address\n\n    mov     eax, esp        ; move the address of the current stack pointer into eax for sprint\n\n    call    sprint          ; call our sprint function\n\n    pop     eax             ; remove our linefeed character from the stack\n\n    pop     eax             ; restore the original value of eax before our function was called\n\n    ret\n\n\n\n    \n\n;------------------------------------------\n\n; int slen(String message)\n\n; String length calculation function\n\nslen:                     \n\n    push    ebx             \n\n    mov     ebx, eax        \n\n    \n\nnextchar:                   \n\n    cmp     byte [eax], 0   \n\n    jz      finished        \n\n    inc     eax             \n\n    jmp     nextchar        \n\n    \n\nfinished:\n\n    sub     eax, ebx\n\n    pop     ebx             \n\n    ret                     \n\n\n\n\n\n;------------------------------------------\n\n; void sprint(String message)\n\n; String printing function\n\nsprint:\n\n    push    edx\n\n    push    ecx\n\n    push    ebx\n\n    push    eax\n\n    call    slen\n\n    \n\n    mov     edx, eax\n\n    pop     eax\n\n    \n\n    mov     ecx, eax\n\n    mov     ebx, 1\n\n    mov     eax, 4\n\n    int     80h\n\n\n\n    pop     ebx\n\n    pop     ecx\n\n    pop     edx\n\n    ret\n\n\n\n\n\n;------------------------------------------\n\n; void sprintLF(String message)\n\n; String printing with line feed function\n\nsprintLF:\n\n    call    sprint\n\n\n\n    push    eax\n\n    mov     eax, 0AH\n\n    push    eax\n\n    mov     eax, esp\n\n    call    sprint\n\n    pop     eax\n\n    pop     eax\n\n    ret\n\n\n\n    \n\n;------------------------------------------\n\n; void exit()\n\n; Exit program and restore resources\n\nquit:\n\n    mov     ebx, 0      \n\n    mov     eax, 1      \n\n    int     80h\n\n    ret\n\n\n", "; Create\n\n; Compile with: nasm -f elf create.asm\n\n; Link with (64 bit systems require elf_i386 option): ld -m elf_i386 create.o -o create\n\n; Run with: ./create\n\n\n\n%include    'functions.asm'\n\n\n\nSECTION .data\n\nfilename db 'readme.txt',       ; the filename to create\n\n\n\nSECTION .text\n\nglobal  _start\n\n\n\n_start:\n\n\n\n    mov     ecx, 0777           ; set all permissions to read, write, execute\n\n    mov     ebx, filename       ; filename we will create\n\n    mov     eax, 8              ; invoke SYS_CREAT (kernel opcode 8)\n\n    int     80h                 ; call the kernel\n\n\n\n    call    quit                ; call our quit function\n", ";------------------------------------------\n\n; int atoi(Integer number)\n\n; Ascii to integer function (atoi)\n\natoi:\n\n    push    ebx             ; preserve ebx on the stack to be restored after function runs\n\n    push    ecx             ; preserve ecx on the stack to be restored after function runs\n\n    push    edx             ; preserve edx on the stack to be restored after function runs\n\n    push    esi             ; preserve esi on the stack to be restored after function runs\n\n    mov     esi, eax        ; move pointer in eax into esi (our number to convert)\n\n    mov     eax, 0          ; initialise eax with decimal value 0\n\n    mov     ecx, 0          ; initialise ecx with decimal value 0\n\n\n\n.multiplyLoop:\n\n    xor     ebx, ebx        ; resets both lower and uppper bytes of ebx to be 0\n\n    mov     bl, [esi+ecx]   ; move a single byte into ebx register's lower half\n\n    cmp     bl, 48          ; compare ebx register's lower half value against ascii value 48 (char value 0)\n\n    jl      .finished       ; jump if less than to label finished\n\n    cmp     bl, 57          ; compare ebx register's lower half value against ascii value 57 (char value 9)\n\n    jg      .finished       ; jump if greater than to label finished\n\n\n\n    sub     bl, 48          ; convert ebx register's lower half to decimal representation of ascii value\n\n    add     eax, ebx        ; add ebx to our interger value in eax\n\n    mov     ebx, 10         ; move decimal value 10 into ebx\n\n    mul     ebx             ; multiply eax by ebx to get place value\n\n    inc     ecx             ; increment ecx (our counter register)\n\n    jmp     .multiplyLoop   ; continue multiply loop\n\n\n\n.finished:\n\n    cmp     ecx, 0          ; compare ecx register's value against decimal 0 (our counter register)\n\n    je      .restore        ; jump if equal to 0 (no integer arguments were passed to atoi)\n\n    mov     ebx, 10         ; move decimal value 10 into ebx\n\n    div     ebx             ; divide eax by value in ebx (in this case 10)\n\n\n\n.restore:\n\n    pop     esi             ; restore esi from the value we pushed onto the stack at the start\n\n    pop     edx             ; restore edx from the value we pushed onto the stack at the start\n\n    pop     ecx             ; restore ecx from the value we pushed onto the stack at the start\n\n    pop     ebx             ; restore ebx from the value we pushed onto the stack at the start\n\n    ret\n\n\n\n\n\n;------------------------------------------\n\n; void iprint(Integer number)\n\n; Integer printing function (itoa)\n\niprint:\n\n    push    eax             ; preserve eax on the stack to be restored after function runs\n\n    push    ecx             ; preserve ecx on the stack to be restored after function runs\n\n    push    edx             ; preserve edx on the stack to be restored after function runs\n\n    push    esi             ; preserve esi on the stack to be restored after function runs\n\n    mov     ecx, 0          ; counter of how many bytes we need to print in the end\n\n\n\n.divideLoop:\n\n    inc     ecx             ; count each byte to print - number of characters\n\n    mov     edx, 0          ; empty edx\n\n    mov     esi, 10         ; mov 10 into esi\n\n    idiv    esi             ; divide eax by esi\n\n    add     edx, 48         ; convert edx to it's ascii representation - edx holds the remainder after a divide instruction\n\n    push    edx             ; push edx (string representation of an intger) onto the stack\n\n    cmp     eax, 0          ; can the integer be divided anymore?\n\n    jnz     .divideLoop     ; jump if not zero to the label divideLoop\n\n\n\n.printLoop:\n\n    dec     ecx             ; count down each byte that we put on the stack\n\n    mov     eax, esp        ; mov the stack pointer into eax for printing\n\n    call    sprint          ; call our string print function\n\n    pop     eax             ; remove last character from the stack to move esp forward\n\n    cmp     ecx, 0          ; have we printed all bytes we pushed onto the stack?\n\n    jnz     .printLoop      ; jump is not zero to the label printLoop\n\n\n\n    pop     esi             ; restore esi from the value we pushed onto the stack at the start\n\n    pop     edx             ; restore edx from the value we pushed onto the stack at the start\n\n    pop     ecx             ; restore ecx from the value we pushed onto the stack at the start\n\n    pop     eax             ; restore eax from the value we pushed onto the stack at the start\n\n    ret\n\n\n\n\n\n;------------------------------------------\n\n; void iprintLF(Integer number)\n\n; Integer printing function with linefeed (itoa)\n\niprintLF:\n\n    call    iprint          ; call our integer printing function\n\n\n\n    push    eax             ; push eax onto the stack to preserve it while we use the eax register in this function\n\n    mov     eax, 0Ah        ; move 0Ah into eax - 0Ah is the ascii character for a linefeed\n\n    push    eax             ; push the linefeed onto the stack so we can get the address\n\n    mov     eax, esp        ; move the address of the current stack pointer into eax for sprint\n\n    call    sprint          ; call our sprint function\n\n    pop     eax             ; remove our linefeed character from the stack\n\n    pop     eax             ; restore the original value of eax before our function was called\n\n    ret\n\n\n\n\n\n;------------------------------------------\n\n; int slen(String message)\n\n; String length calculation function\n\nslen:\n\n    push    ebx\n\n    mov     ebx, eax\n\n\n\n.nextchar:\n\n    cmp     byte [eax], 0\n\n    jz      .finished\n\n    inc     eax\n\n    jmp     .nextchar\n\n\n\n.finished:\n\n    sub     eax, ebx\n\n    pop     ebx\n\n    ret\n\n\n\n\n\n;------------------------------------------\n\n; void sprint(String message)\n\n; String printing function\n\nsprint:\n\n    push    edx\n\n    push    ecx\n\n    push    ebx\n\n    push    eax\n\n    call    slen\n\n\n\n    mov     edx, eax\n\n    pop     eax\n\n\n\n    mov     ecx, eax\n\n    mov     ebx, 1\n\n    mov     eax, 4\n\n    int     80h\n\n\n\n    pop     ebx\n\n    pop     ecx\n\n    pop     edx\n\n    ret\n\n\n\n\n\n;------------------------------------------\n\n; void sprintLF(String message)\n\n; String printing with line feed function\n\nsprintLF:\n\n    call    sprint\n\n\n\n    push    eax\n\n    mov     eax, 0AH\n\n    push    eax\n\n    mov     eax, esp\n\n    call    sprint\n\n    pop     eax\n\n    pop     eax\n\n    ret\n\n\n\n\n\n;------------------------------------------\n\n; void exit()\n\n; Exit program and restore resources\n\nquit:\n\n    mov     ebx, 0\n\n    mov     eax, 1\n\n    int     80h\n\n    ret\n\n\n", "; Socket\n\n; Compile with: nasm -f elf socket.asm\n\n; Link with (64 bit systems require elf_i386 option): ld -m elf_i386 socket.o -o socket\n\n; Run with: ./socket\n\n\n\n%include    'functions.asm'\n\n\n\nSECTION .text\n\nglobal  _start\n\n\n\n_start:\n\n\n\n    xor     eax, eax            ; init eax 0\n\n    xor     ebx, ebx            ; init ebx 0\n\n    xor     edi, edi            ; init edi 0\n\n    xor     esi, esi            ; init esi 0\n\n\n\n_socket:\n\n\n\n    push    byte 6              ; push 6 onto the stack (IPPROTO_TCP)\n\n    push    byte 1              ; push 1 onto the stack (SOCK_STREAM)\n\n    push    byte 2              ; push 2 onto the stack (PF_INET)\n\n    mov     ecx, esp            ; move address of arguments into ecx\n\n    mov     ebx, 1              ; invoke subroutine SOCKET (1)\n\n    mov     eax, 102            ; invoke SYS_SOCKETCALL (kernel opcode 102)\n\n    int     80h                 ; call the kernel\n\n\n\n    call    iprintLF            ; call our integer printing function (print the file descriptor in EAX or -1 on error)\n\n\n\n_exit:\n\n\n\n    call    quit                ; call our quit function\n", ";------------------------------------------\n\n; int atoi(Integer number)\n\n; Ascii to integer function (atoi)\n\natoi:\n\n    push    ebx             ; preserve ebx on the stack to be restored after function runs\n\n    push    ecx             ; preserve ecx on the stack to be restored after function runs\n\n    push    edx             ; preserve edx on the stack to be restored after function runs\n\n    push    esi             ; preserve esi on the stack to be restored after function runs\n\n    mov     esi, eax        ; move pointer in eax into esi (our number to convert)\n\n    mov     eax, 0          ; initialise eax with decimal value 0\n\n    mov     ecx, 0          ; initialise ecx with decimal value 0\n\n\n\n.multiplyLoop:\n\n    xor     ebx, ebx        ; resets both lower and uppper bytes of ebx to be 0\n\n    mov     bl, [esi+ecx]   ; move a single byte into ebx register's lower half\n\n    cmp     bl, 48          ; compare ebx register's lower half value against ascii value 48 (char value 0)\n\n    jl      .finished       ; jump if less than to label finished\n\n    cmp     bl, 57          ; compare ebx register's lower half value against ascii value 57 (char value 9)\n\n    jg      .finished       ; jump if greater than to label finished\n\n\n\n    sub     bl, 48          ; convert ebx register's lower half to decimal representation of ascii value\n\n    add     eax, ebx        ; add ebx to our interger value in eax\n\n    mov     ebx, 10         ; move decimal value 10 into ebx\n\n    mul     ebx             ; multiply eax by ebx to get place value\n\n    inc     ecx             ; increment ecx (our counter register)\n\n    jmp     .multiplyLoop   ; continue multiply loop\n\n\n\n.finished:\n\n    cmp     ecx, 0          ; compare ecx register's value against decimal 0 (our counter register)\n\n    je      .restore        ; jump if equal to 0 (no integer arguments were passed to atoi)\n\n    mov     ebx, 10         ; move decimal value 10 into ebx\n\n    div     ebx             ; divide eax by value in ebx (in this case 10)\n\n\n\n.restore:\n\n    pop     esi             ; restore esi from the value we pushed onto the stack at the start\n\n    pop     edx             ; restore edx from the value we pushed onto the stack at the start\n\n    pop     ecx             ; restore ecx from the value we pushed onto the stack at the start\n\n    pop     ebx             ; restore ebx from the value we pushed onto the stack at the start\n\n    ret\n\n\n\n\n\n;------------------------------------------\n\n; void iprint(Integer number)\n\n; Integer printing function (itoa)\n\niprint:\n\n    push    eax             ; preserve eax on the stack to be restored after function runs\n\n    push    ecx             ; preserve ecx on the stack to be restored after function runs\n\n    push    edx             ; preserve edx on the stack to be restored after function runs\n\n    push    esi             ; preserve esi on the stack to be restored after function runs\n\n    mov     ecx, 0          ; counter of how many bytes we need to print in the end\n\n\n\n.divideLoop:\n\n    inc     ecx             ; count each byte to print - number of characters\n\n    mov     edx, 0          ; empty edx\n\n    mov     esi, 10         ; mov 10 into esi\n\n    idiv    esi             ; divide eax by esi\n\n    add     edx, 48         ; convert edx to it's ascii representation - edx holds the remainder after a divide instruction\n\n    push    edx             ; push edx (string representation of an intger) onto the stack\n\n    cmp     eax, 0          ; can the integer be divided anymore?\n\n    jnz     .divideLoop     ; jump if not zero to the label divideLoop\n\n\n\n.printLoop:\n\n    dec     ecx             ; count down each byte that we put on the stack\n\n    mov     eax, esp        ; mov the stack pointer into eax for printing\n\n    call    sprint          ; call our string print function\n\n    pop     eax             ; remove last character from the stack to move esp forward\n\n    cmp     ecx, 0          ; have we printed all bytes we pushed onto the stack?\n\n    jnz     .printLoop      ; jump is not zero to the label printLoop\n\n\n\n    pop     esi             ; restore esi from the value we pushed onto the stack at the start\n\n    pop     edx             ; restore edx from the value we pushed onto the stack at the start\n\n    pop     ecx             ; restore ecx from the value we pushed onto the stack at the start\n\n    pop     eax             ; restore eax from the value we pushed onto the stack at the start\n\n    ret\n\n\n\n\n\n;------------------------------------------\n\n; void iprintLF(Integer number)\n\n; Integer printing function with linefeed (itoa)\n\niprintLF:\n\n    call    iprint          ; call our integer printing function\n\n\n\n    push    eax             ; push eax onto the stack to preserve it while we use the eax register in this function\n\n    mov     eax, 0Ah        ; move 0Ah into eax - 0Ah is the ascii character for a linefeed\n\n    push    eax             ; push the linefeed onto the stack so we can get the address\n\n    mov     eax, esp        ; move the address of the current stack pointer into eax for sprint\n\n    call    sprint          ; call our sprint function\n\n    pop     eax             ; remove our linefeed character from the stack\n\n    pop     eax             ; restore the original value of eax before our function was called\n\n    ret\n\n\n\n\n\n;------------------------------------------\n\n; int slen(String message)\n\n; String length calculation function\n\nslen:\n\n    push    ebx\n\n    mov     ebx, eax\n\n\n\n.nextchar:\n\n    cmp     byte [eax], 0\n\n    jz      .finished\n\n    inc     eax\n\n    jmp     .nextchar\n\n\n\n.finished:\n\n    sub     eax, ebx\n\n    pop     ebx\n\n    ret\n\n\n\n\n\n;------------------------------------------\n\n; void sprint(String message)\n\n; String printing function\n\nsprint:\n\n    push    edx\n\n    push    ecx\n\n    push    ebx\n\n    push    eax\n\n    call    slen\n\n\n\n    mov     edx, eax\n\n    pop     eax\n\n\n\n    mov     ecx, eax\n\n    mov     ebx, 1\n\n    mov     eax, 4\n\n    int     80h\n\n\n\n    pop     ebx\n\n    pop     ecx\n\n    pop     edx\n\n    ret\n\n\n\n\n\n;------------------------------------------\n\n; void sprintLF(String message)\n\n; String printing with line feed function\n\nsprintLF:\n\n    call    sprint\n\n\n\n    push    eax\n\n    mov     eax, 0AH\n\n    push    eax\n\n    mov     eax, esp\n\n    call    sprint\n\n    pop     eax\n\n    pop     eax\n\n    ret\n\n\n\n\n\n;------------------------------------------\n\n; void exit()\n\n; Exit program and restore resources\n\nquit:\n\n    mov     ebx, 0\n\n    mov     eax, 1\n\n    int     80h\n\n    ret\n\n\n", "; Close\n\n; Compile with: nasm -f elf close.asm\n\n; Link with (64 bit systems require elf_i386 option): ld -m elf_i386 close.o -o close\n\n; Run with: ./close\n\n\n\n%include    'functions.asm'\n\n\n\nSECTION .data\n\nfilename db 'readme.txt', 0h    ; the filename to create\n\ncontents db 'Hello world!', 0h  ; the contents to write\n\n\n\nSECTION .bss\n\nfileContents resb 255,          ; variable to store file contents\n\n\n\nSECTION .text\n\nglobal  _start\n\n\n\n_start:\n\n\n\n    mov     ecx, 0777           ; Create file from lesson 22\n\n    mov     ebx, filename\n\n    mov     eax, 8\n\n    int     80h\n\n\n\n    mov     edx, 12             ; Write contents to file from lesson 23\n\n    mov     ecx, contents\n\n    mov     ebx, eax\n\n    mov     eax, 4\n\n    int     80h\n\n\n\n    mov     ecx, 0              ; Open file from lesson 24\n\n    mov     ebx, filename\n\n    mov     eax, 5\n\n    int     80h\n\n\n\n    mov     edx, 12             ; Read file from lesson 25\n\n    mov     ecx, fileContents\n\n    mov     ebx, eax\n\n    mov     eax, 3\n\n    int     80h\n\n\n\n    mov     eax, fileContents\n\n    call    sprintLF\n\n\n\n    mov     ebx, ebx            ; not needed but used to demonstrate that SYS_CLOSE takes a file descriptor from EBX\n\n    mov     eax, 6              ; invoke SYS_CLOSE (kernel opcode 6)\n\n    int     80h                 ; call the kernel\n\n\n\n    call    quit                ; call our quit function\n", ";------------------------------------------\n\n; int atoi(Integer number)\n\n; Ascii to integer function (atoi)\n\natoi:\n\n    push    ebx             ; preserve ebx on the stack to be restored after function runs\n\n    push    ecx             ; preserve ecx on the stack to be restored after function runs\n\n    push    edx             ; preserve edx on the stack to be restored after function runs\n\n    push    esi             ; preserve esi on the stack to be restored after function runs\n\n    mov     esi, eax        ; move pointer in eax into esi (our number to convert)\n\n    mov     eax, 0          ; initialise eax with decimal value 0\n\n    mov     ecx, 0          ; initialise ecx with decimal value 0\n\n\n\n.multiplyLoop:\n\n    xor     ebx, ebx        ; resets both lower and uppper bytes of ebx to be 0\n\n    mov     bl, [esi+ecx]   ; move a single byte into ebx register's lower half\n\n    cmp     bl, 48          ; compare ebx register's lower half value against ascii value 48 (char value 0)\n\n    jl      .finished       ; jump if less than to label finished\n\n    cmp     bl, 57          ; compare ebx register's lower half value against ascii value 57 (char value 9)\n\n    jg      .finished       ; jump if greater than to label finished\n\n\n\n    sub     bl, 48          ; convert ebx register's lower half to decimal representation of ascii value\n\n    add     eax, ebx        ; add ebx to our interger value in eax\n\n    mov     ebx, 10         ; move decimal value 10 into ebx\n\n    mul     ebx             ; multiply eax by ebx to get place value\n\n    inc     ecx             ; increment ecx (our counter register)\n\n    jmp     .multiplyLoop   ; continue multiply loop\n\n\n\n.finished:\n\n    cmp     ecx, 0          ; compare ecx register's value against decimal 0 (our counter register)\n\n    je      .restore        ; jump if equal to 0 (no integer arguments were passed to atoi)\n\n    mov     ebx, 10         ; move decimal value 10 into ebx\n\n    div     ebx             ; divide eax by value in ebx (in this case 10)\n\n\n\n.restore:\n\n    pop     esi             ; restore esi from the value we pushed onto the stack at the start\n\n    pop     edx             ; restore edx from the value we pushed onto the stack at the start\n\n    pop     ecx             ; restore ecx from the value we pushed onto the stack at the start\n\n    pop     ebx             ; restore ebx from the value we pushed onto the stack at the start\n\n    ret\n\n\n\n\n\n;------------------------------------------\n\n; void iprint(Integer number)\n\n; Integer printing function (itoa)\n\niprint:\n\n    push    eax             ; preserve eax on the stack to be restored after function runs\n\n    push    ecx             ; preserve ecx on the stack to be restored after function runs\n\n    push    edx             ; preserve edx on the stack to be restored after function runs\n\n    push    esi             ; preserve esi on the stack to be restored after function runs\n\n    mov     ecx, 0          ; counter of how many bytes we need to print in the end\n\n\n\n.divideLoop:\n\n    inc     ecx             ; count each byte to print - number of characters\n\n    mov     edx, 0          ; empty edx\n\n    mov     esi, 10         ; mov 10 into esi\n\n    idiv    esi             ; divide eax by esi\n\n    add     edx, 48         ; convert edx to it's ascii representation - edx holds the remainder after a divide instruction\n\n    push    edx             ; push edx (string representation of an intger) onto the stack\n\n    cmp     eax, 0          ; can the integer be divided anymore?\n\n    jnz     .divideLoop     ; jump if not zero to the label divideLoop\n\n\n\n.printLoop:\n\n    dec     ecx             ; count down each byte that we put on the stack\n\n    mov     eax, esp        ; mov the stack pointer into eax for printing\n\n    call    sprint          ; call our string print function\n\n    pop     eax             ; remove last character from the stack to move esp forward\n\n    cmp     ecx, 0          ; have we printed all bytes we pushed onto the stack?\n\n    jnz     .printLoop      ; jump is not zero to the label printLoop\n\n\n\n    pop     esi             ; restore esi from the value we pushed onto the stack at the start\n\n    pop     edx             ; restore edx from the value we pushed onto the stack at the start\n\n    pop     ecx             ; restore ecx from the value we pushed onto the stack at the start\n\n    pop     eax             ; restore eax from the value we pushed onto the stack at the start\n\n    ret\n\n\n\n\n\n;------------------------------------------\n\n; void iprintLF(Integer number)\n\n; Integer printing function with linefeed (itoa)\n\niprintLF:\n\n    call    iprint          ; call our integer printing function\n\n\n\n    push    eax             ; push eax onto the stack to preserve it while we use the eax register in this function\n\n    mov     eax, 0Ah        ; move 0Ah into eax - 0Ah is the ascii character for a linefeed\n\n    push    eax             ; push the linefeed onto the stack so we can get the address\n\n    mov     eax, esp        ; move the address of the current stack pointer into eax for sprint\n\n    call    sprint          ; call our sprint function\n\n    pop     eax             ; remove our linefeed character from the stack\n\n    pop     eax             ; restore the original value of eax before our function was called\n\n    ret\n\n\n\n\n\n;------------------------------------------\n\n; int slen(String message)\n\n; String length calculation function\n\nslen:\n\n    push    ebx\n\n    mov     ebx, eax\n\n\n\n.nextchar:\n\n    cmp     byte [eax], 0\n\n    jz      .finished\n\n    inc     eax\n\n    jmp     .nextchar\n\n\n\n.finished:\n\n    sub     eax, ebx\n\n    pop     ebx\n\n    ret\n\n\n\n\n\n;------------------------------------------\n\n; void sprint(String message)\n\n; String printing function\n\nsprint:\n\n    push    edx\n\n    push    ecx\n\n    push    ebx\n\n    push    eax\n\n    call    slen\n\n\n\n    mov     edx, eax\n\n    pop     eax\n\n\n\n    mov     ecx, eax\n\n    mov     ebx, 1\n\n    mov     eax, 4\n\n    int     80h\n\n\n\n    pop     ebx\n\n    pop     ecx\n\n    pop     edx\n\n    ret\n\n\n\n\n\n;------------------------------------------\n\n; void sprintLF(String message)\n\n; String printing with line feed function\n\nsprintLF:\n\n    call    sprint\n\n\n\n    push    eax\n\n    mov     eax, 0AH\n\n    push    eax\n\n    mov     eax, esp\n\n    call    sprint\n\n    pop     eax\n\n    pop     eax\n\n    ret\n\n\n\n\n\n;------------------------------------------\n\n; void exit()\n\n; Exit program and restore resources\n\nquit:\n\n    mov     ebx, 0\n\n    mov     eax, 1\n\n    int     80h\n\n    ret\n\n\n", "; Fork\n\n; Compile with: nasm -f elf fork.asm\n\n; Link with (64 bit systems require elf_i386 option): ld -m elf_i386 fork.o -o fork\n\n; Run with: ./fork\n\n\n\n%include        'functions.asm'\n\n\n\nSECTION .data\n\nchildMsg        db      'This is the child process', 0h     ; a message string\n\nparentMsg       db      'This is the parent process', 0h    ; a message string\n\n\n\nSECTION .text\n\nglobal  _start\n\n\n\n_start:\n\n\n\n    mov     eax, 2              ; invoke SYS_FORK (kernel opcode 2)\n\n    int     80h\n\n\n\n    cmp     eax, 0              ; if eax is zero we are in the child process\n\n    jz      child               ; jump if eax is zero to child label\n\n\n\nparent:\n\n    mov     eax, parentMsg      ; inside our parent process move parentMsg into eax\n\n    call    sprintLF            ; call our string printing with linefeed function\n\n\n\n    call    quit                ; quit the parent process\n\n\n\nchild:\n\n    mov     eax, childMsg       ; inside our child process move childMsg into eax\n\n    call    sprintLF            ; call our string printing with linefeed function\n\n\n\n    call    quit                ; quit the child process", ";------------------------------------------\n\n; int atoi(Integer number)\n\n; Ascii to integer function (atoi)\n\natoi:\n\n    push    ebx             ; preserve ebx on the stack to be restored after function runs\n\n    push    ecx             ; preserve ecx on the stack to be restored after function runs\n\n    push    edx             ; preserve edx on the stack to be restored after function runs\n\n    push    esi             ; preserve esi on the stack to be restored after function runs\n\n    mov     esi, eax        ; move pointer in eax into esi (our number to convert)\n\n    mov     eax, 0          ; initialise eax with decimal value 0\n\n    mov     ecx, 0          ; initialise ecx with decimal value 0\n\n\n\n.multiplyLoop:\n\n    xor     ebx, ebx        ; resets both lower and uppper bytes of ebx to be 0\n\n    mov     bl, [esi+ecx]   ; move a single byte into ebx register's lower half\n\n    cmp     bl, 48          ; compare ebx register's lower half value against ascii value 48 (char value 0)\n\n    jl      .finished       ; jump if less than to label finished\n\n    cmp     bl, 57          ; compare ebx register's lower half value against ascii value 57 (char value 9)\n\n    jg      .finished       ; jump if greater than to label finished\n\n\n\n    sub     bl, 48          ; convert ebx register's lower half to decimal representation of ascii value\n\n    add     eax, ebx        ; add ebx to our interger value in eax\n\n    mov     ebx, 10         ; move decimal value 10 into ebx\n\n    mul     ebx             ; multiply eax by ebx to get place value\n\n    inc     ecx             ; increment ecx (our counter register)\n\n    jmp     .multiplyLoop   ; continue multiply loop\n\n\n\n.finished:\n\n    cmp     ecx, 0          ; compare ecx register's value against decimal 0 (our counter register)\n\n    je      .restore        ; jump if equal to 0 (no integer arguments were passed to atoi)\n\n    mov     ebx, 10         ; move decimal value 10 into ebx\n\n    div     ebx             ; divide eax by value in ebx (in this case 10)\n\n\n\n.restore:\n\n    pop     esi             ; restore esi from the value we pushed onto the stack at the start\n\n    pop     edx             ; restore edx from the value we pushed onto the stack at the start\n\n    pop     ecx             ; restore ecx from the value we pushed onto the stack at the start\n\n    pop     ebx             ; restore ebx from the value we pushed onto the stack at the start\n\n    ret\n\n\n\n\n\n;------------------------------------------\n\n; void iprint(Integer number)\n\n; Integer printing function (itoa)\n\niprint:\n\n    push    eax             ; preserve eax on the stack to be restored after function runs\n\n    push    ecx             ; preserve ecx on the stack to be restored after function runs\n\n    push    edx             ; preserve edx on the stack to be restored after function runs\n\n    push    esi             ; preserve esi on the stack to be restored after function runs\n\n    mov     ecx, 0          ; counter of how many bytes we need to print in the end\n\n\n\n.divideLoop:\n\n    inc     ecx             ; count each byte to print - number of characters\n\n    mov     edx, 0          ; empty edx\n\n    mov     esi, 10         ; mov 10 into esi\n\n    idiv    esi             ; divide eax by esi\n\n    add     edx, 48         ; convert edx to it's ascii representation - edx holds the remainder after a divide instruction\n\n    push    edx             ; push edx (string representation of an intger) onto the stack\n\n    cmp     eax, 0          ; can the integer be divided anymore?\n\n    jnz     .divideLoop     ; jump if not zero to the label divideLoop\n\n\n\n.printLoop:\n\n    dec     ecx             ; count down each byte that we put on the stack\n\n    mov     eax, esp        ; mov the stack pointer into eax for printing\n\n    call    sprint          ; call our string print function\n\n    pop     eax             ; remove last character from the stack to move esp forward\n\n    cmp     ecx, 0          ; have we printed all bytes we pushed onto the stack?\n\n    jnz     .printLoop      ; jump is not zero to the label printLoop\n\n\n\n    pop     esi             ; restore esi from the value we pushed onto the stack at the start\n\n    pop     edx             ; restore edx from the value we pushed onto the stack at the start\n\n    pop     ecx             ; restore ecx from the value we pushed onto the stack at the start\n\n    pop     eax             ; restore eax from the value we pushed onto the stack at the start\n\n    ret\n\n\n\n\n\n;------------------------------------------\n\n; void iprintLF(Integer number)\n\n; Integer printing function with linefeed (itoa)\n\niprintLF:\n\n    call    iprint          ; call our integer printing function\n\n\n\n    push    eax             ; push eax onto the stack to preserve it while we use the eax register in this function\n\n    mov     eax, 0Ah        ; move 0Ah into eax - 0Ah is the ascii character for a linefeed\n\n    push    eax             ; push the linefeed onto the stack so we can get the address\n\n    mov     eax, esp        ; move the address of the current stack pointer into eax for sprint\n\n    call    sprint          ; call our sprint function\n\n    pop     eax             ; remove our linefeed character from the stack\n\n    pop     eax             ; restore the original value of eax before our function was called\n\n    ret\n\n\n\n\n\n;------------------------------------------\n\n; int slen(String message)\n\n; String length calculation function\n\nslen:\n\n    push    ebx\n\n    mov     ebx, eax\n\n\n\n.nextchar:\n\n    cmp     byte [eax], 0\n\n    jz      .finished\n\n    inc     eax\n\n    jmp     .nextchar\n\n\n\n.finished:\n\n    sub     eax, ebx\n\n    pop     ebx\n\n    ret\n\n\n\n\n\n;------------------------------------------\n\n; void sprint(String message)\n\n; String printing function\n\nsprint:\n\n    push    edx\n\n    push    ecx\n\n    push    ebx\n\n    push    eax\n\n    call    slen\n\n\n\n    mov     edx, eax\n\n    pop     eax\n\n\n\n    mov     ecx, eax\n\n    mov     ebx, 1\n\n    mov     eax, 4\n\n    int     80h\n\n\n\n    pop     ebx\n\n    pop     ecx\n\n    pop     edx\n\n    ret\n\n\n\n\n\n;------------------------------------------\n\n; void sprintLF(String message)\n\n; String printing with line feed function\n\nsprintLF:\n\n    call    sprint\n\n\n\n    push    eax\n\n    mov     eax, 0AH\n\n    push    eax\n\n    mov     eax, esp\n\n    call    sprint\n\n    pop     eax\n\n    pop     eax\n\n    ret\n\n\n\n\n\n;------------------------------------------\n\n; void exit()\n\n; Exit program and restore resources\n\nquit:\n\n    mov     ebx, 0\n\n    mov     eax, 1\n\n    int     80h\n\n    ret\n\n\n", ";------------------------------------------\n\n; int slen(String message)\n\n; String length calculation function\n\nslen:                     \n\n    push    ebx             \n\n    mov     ebx, eax        \n\n    \n\nnextchar:                   \n\n    cmp     byte [eax], 0   \n\n    jz      finished        \n\n    inc     eax             \n\n    jmp     nextchar        \n\n    \n\nfinished:\n\n    sub     eax, ebx\n\n    pop     ebx             \n\n    ret                     \n\n\n\n\n\n;------------------------------------------\n\n; void sprint(String message)\n\n; String printing function\n\nsprint:\n\n    push    edx\n\n    push    ecx\n\n    push    ebx\n\n    push    eax\n\n    call    slen\n\n    \n\n    mov     edx, eax\n\n    pop     eax\n\n    \n\n    mov     ecx, eax\n\n    mov     ebx, 1\n\n    mov     eax, 4\n\n    int     80h\n\n    \n\n    pop     ebx\n\n    pop     ecx\n\n    pop     edx\n\n    ret\n\n\n\n\n\n;------------------------------------------\n\n; void exit()\n\n; Exit program and restore resources\n\nquit:\n\n    mov     ebx, 0      \n\n    mov     eax, 1      \n\n    int     80h\n\n    ret\n\n\n", "; Hello World Program (NULL terminating bytes)\n\n; Compile with: nasm -f elf helloworld-inc.asm\n\n; Link with (64 bit systems require elf_i386 option): ld -m elf_i386 helloworld-inc.o -o helloworld-inc\n\n; Run with: ./helloworld-inc\n\n\n\n%include        'functions.asm'\n\n\n\nSECTION .data\n\nmsg1    db      'Hello, brave new world!', 0Ah, 0h          ; NOTE the null terminating byte\n\nmsg2    db      'This is how we recycle in NASM.', 0Ah, 0h  ; NOTE the null terminating byte\n\n\n\nSECTION .text\n\nglobal  _start\n\n    \n\n_start: \n\n\n\n    mov     eax, msg1        \n\n    call    sprint          \n\n\n\n    mov     eax, msg2\n\n    call    sprint\n\n\n\n    call    quit", ";------------------------------------------\n\n; int atoi(Integer number)\n\n; Ascii to integer function (atoi)\n\natoi:\n\n    push    ebx             ; preserve ebx on the stack to be restored after function runs\n\n    push    ecx             ; preserve ecx on the stack to be restored after function runs\n\n    push    edx             ; preserve edx on the stack to be restored after function runs\n\n    push    esi             ; preserve esi on the stack to be restored after function runs\n\n    mov     esi, eax        ; move pointer in eax into esi (our number to convert)\n\n    mov     eax, 0          ; initialise eax with decimal value 0\n\n    mov     ecx, 0          ; initialise ecx with decimal value 0\n\n\n\n.multiplyLoop:\n\n    xor     ebx, ebx        ; resets both lower and uppper bytes of ebx to be 0\n\n    mov     bl, [esi+ecx]   ; move a single byte into ebx register's lower half\n\n    cmp     bl, 48          ; compare ebx register's lower half value against ascii value 48 (char value 0)\n\n    jl      .finished       ; jump if less than to label finished\n\n    cmp     bl, 57          ; compare ebx register's lower half value against ascii value 57 (char value 9)\n\n    jg      .finished       ; jump if greater than to label finished\n\n\n\n    sub     bl, 48          ; convert ebx register's lower half to decimal representation of ascii value\n\n    add     eax, ebx        ; add ebx to our interger value in eax\n\n    mov     ebx, 10         ; move decimal value 10 into ebx\n\n    mul     ebx             ; multiply eax by ebx to get place value\n\n    inc     ecx             ; increment ecx (our counter register)\n\n    jmp     .multiplyLoop   ; continue multiply loop\n\n\n\n.finished:\n\n    cmp     ecx, 0          ; compare ecx register's value against decimal 0 (our counter register)\n\n    je      .restore        ; jump if equal to 0 (no integer arguments were passed to atoi)\n\n    mov     ebx, 10         ; move decimal value 10 into ebx\n\n    div     ebx             ; divide eax by value in ebx (in this case 10)\n\n\n\n.restore:\n\n    pop     esi             ; restore esi from the value we pushed onto the stack at the start\n\n    pop     edx             ; restore edx from the value we pushed onto the stack at the start\n\n    pop     ecx             ; restore ecx from the value we pushed onto the stack at the start\n\n    pop     ebx             ; restore ebx from the value we pushed onto the stack at the start\n\n    ret\n\n\n\n\n\n;------------------------------------------\n\n; void iprint(Integer number)\n\n; Integer printing function (itoa)\n\niprint:\n\n    push    eax             ; preserve eax on the stack to be restored after function runs\n\n    push    ecx             ; preserve ecx on the stack to be restored after function runs\n\n    push    edx             ; preserve edx on the stack to be restored after function runs\n\n    push    esi             ; preserve esi on the stack to be restored after function runs\n\n    mov     ecx, 0          ; counter of how many bytes we need to print in the end\n\n\n\n.divideLoop:\n\n    inc     ecx             ; count each byte to print - number of characters\n\n    mov     edx, 0          ; empty edx\n\n    mov     esi, 10         ; mov 10 into esi\n\n    idiv    esi             ; divide eax by esi\n\n    add     edx, 48         ; convert edx to it's ascii representation - edx holds the remainder after a divide instruction\n\n    push    edx             ; push edx (string representation of an intger) onto the stack\n\n    cmp     eax, 0          ; can the integer be divided anymore?\n\n    jnz     .divideLoop     ; jump if not zero to the label divideLoop\n\n\n\n.printLoop:\n\n    dec     ecx             ; count down each byte that we put on the stack\n\n    mov     eax, esp        ; mov the stack pointer into eax for printing\n\n    call    sprint          ; call our string print function\n\n    pop     eax             ; remove last character from the stack to move esp forward\n\n    cmp     ecx, 0          ; have we printed all bytes we pushed onto the stack?\n\n    jnz     .printLoop      ; jump is not zero to the label printLoop\n\n\n\n    pop     esi             ; restore esi from the value we pushed onto the stack at the start\n\n    pop     edx             ; restore edx from the value we pushed onto the stack at the start\n\n    pop     ecx             ; restore ecx from the value we pushed onto the stack at the start\n\n    pop     eax             ; restore eax from the value we pushed onto the stack at the start\n\n    ret\n\n\n\n\n\n;------------------------------------------\n\n; void iprintLF(Integer number)\n\n; Integer printing function with linefeed (itoa)\n\niprintLF:\n\n    call    iprint          ; call our integer printing function\n\n\n\n    push    eax             ; push eax onto the stack to preserve it while we use the eax register in this function\n\n    mov     eax, 0Ah        ; move 0Ah into eax - 0Ah is the ascii character for a linefeed\n\n    push    eax             ; push the linefeed onto the stack so we can get the address\n\n    mov     eax, esp        ; move the address of the current stack pointer into eax for sprint\n\n    call    sprint          ; call our sprint function\n\n    pop     eax             ; remove our linefeed character from the stack\n\n    pop     eax             ; restore the original value of eax before our function was called\n\n    ret\n\n\n\n\n\n;------------------------------------------\n\n; int slen(String message)\n\n; String length calculation function\n\nslen:\n\n    push    ebx\n\n    mov     ebx, eax\n\n\n\n.nextchar:\n\n    cmp     byte [eax], 0\n\n    jz      .finished\n\n    inc     eax\n\n    jmp     .nextchar\n\n\n\n.finished:\n\n    sub     eax, ebx\n\n    pop     ebx\n\n    ret\n\n\n\n\n\n;------------------------------------------\n\n; void sprint(String message)\n\n; String printing function\n\nsprint:\n\n    push    edx\n\n    push    ecx\n\n    push    ebx\n\n    push    eax\n\n    call    slen\n\n\n\n    mov     edx, eax\n\n    pop     eax\n\n\n\n    mov     ecx, eax\n\n    mov     ebx, 1\n\n    mov     eax, 4\n\n    int     80h\n\n\n\n    pop     ebx\n\n    pop     ecx\n\n    pop     edx\n\n    ret\n\n\n\n\n\n;------------------------------------------\n\n; void sprintLF(String message)\n\n; String printing with line feed function\n\nsprintLF:\n\n    call    sprint\n\n\n\n    push    eax\n\n    mov     eax, 0AH\n\n    push    eax\n\n    mov     eax, esp\n\n    call    sprint\n\n    pop     eax\n\n    pop     eax\n\n    ret\n\n\n\n\n\n;------------------------------------------\n\n; void exit()\n\n; Exit program and restore resources\n\nquit:\n\n    mov     ebx, 0\n\n    mov     eax, 1\n\n    int     80h\n\n    ret\n\n\n", "; Read\n\n; Compile with: nasm -f elf read.asm\n\n; Link with (64 bit systems require elf_i386 option): ld -m elf_i386 read.o -o read\n\n; Run with: ./read\n\n\n\n%include    'functions.asm'\n\n\n\nSECTION .data\n\nfilename db 'readme.txt', 0h    ; the filename to create\n\ncontents db 'Hello world!', 0h  ; the contents to write\n\n\n\nSECTION .bss\n\nfileContents resb 255,          ; variable to store file contents\n\n\n\nSECTION .text\n\nglobal  _start\n\n\n\n_start:\n\n\n\n    mov     ecx, 0777           ; Create file from lesson 22\n\n    mov     ebx, filename\n\n    mov     eax, 8\n\n    int     80h\n\n\n\n    mov     edx, 12             ; Write contents to file from lesson 23\n\n    mov     ecx, contents\n\n    mov     ebx, eax\n\n    mov     eax, 4\n\n    int     80h\n\n\n\n    mov     ecx, 0              ; Open file from lesson 24\n\n    mov     ebx, filename\n\n    mov     eax, 5\n\n    int     80h\n\n\n\n    mov     edx, 12             ; number of bytes to read - one for each letter of the file contents\n\n    mov     ecx, fileContents   ; move the memory address of our file contents variable into ecx\n\n    mov     ebx, eax            ; move the opened file descriptor into EBX\n\n    mov     eax, 3              ; invoke SYS_READ (kernel opcode 3)\n\n    int     80h                 ; call the kernel\n\n\n\n    mov     eax, fileContents   ; move the memory address of our file contents variable into eax for printing\n\n    call    sprintLF            ; call our string printing function\n\n\n\n    call    quit                ; call our quit function\n", ";------------------------------------------\n\n; int slen(String message)\n\n; String length calculation function\n\nslen:                     \n\n    push    ebx             \n\n    mov     ebx, eax        \n\n    \n\nnextchar:                   \n\n    cmp     byte [eax], 0   \n\n    jz      finished        \n\n    inc     eax             \n\n    jmp     nextchar        \n\n    \n\nfinished:\n\n    sub     eax, ebx\n\n    pop     ebx             \n\n    ret                     \n\n\n\n\n\n;------------------------------------------\n\n; void sprint(String message)\n\n; String printing function\n\nsprint:\n\n    push    edx\n\n    push    ecx\n\n    push    ebx\n\n    push    eax\n\n    call    slen\n\n    \n\n    mov     edx, eax\n\n    pop     eax\n\n    \n\n    mov     ecx, eax\n\n    mov     ebx, 1\n\n    mov     eax, 4\n\n    int     80h\n\n    \n\n    pop     ebx\n\n    pop     ecx\n\n    pop     edx\n\n    ret\n\n\n\n\n\n;------------------------------------------\n\n; void sprintLF(String message)\n\n; String printing with line feed function\n\nsprintLF:\n\n    call    sprint\n\n\n\n    push    eax\n\n    mov     eax, 0AH\n\n    push    eax\n\n    mov     eax, esp\n\n    call    sprint\n\n    pop     eax\n\n    pop     eax\n\n    ret\n\n\n\n    \n\n;------------------------------------------\n\n; void exit()\n\n; Exit program and restore resources\n\nquit:\n\n    mov     ebx, 0      \n\n    mov     eax, 1      \n\n    int     80h\n\n    ret\n\n\n", "; Hello World Program (Count to 10)\n\n; Compile with: nasm -f elf helloworld-10.asm\n\n; Link with (64 bit systems require elf_i386 option): ld -m elf_i386 helloworld-10.o -o helloworld-10\n\n; Run with: ./helloworld-10\n\n\n\n%include        'functions.asm'\n\n\n\nSECTION .text\n\nglobal  _start\n\n    \n\n_start: \n\n\n\n    mov     ecx, 0          ; ecx is initalised to zero.\n\n    \n\nnextNumber:\n\n    inc     ecx             ; increment ecx\n\n    \n\n    mov     eax, ecx        ; move the address of our integer into eax\n\n    add     eax, 48         ; add 48 to our number to convert from integer to ascii for printing\n\n    push    eax             ; push eax to the stack\n\n    mov     eax, esp        ; get the address of the character on the stack\n\n    call    sprintLF        ; call our print function\n\n    \n\n    pop     eax             ; clean up the stack so we don't have unneeded bytes taking up space\n\n    cmp     ecx, 10         ; have we reached 10 yet? compare our counter with decimal 10\n\n    jne     nextNumber      ; jump if not equal and keep counting\n\n      \n\n    call    quit", "; Socket\n\n; Compile with: nasm -f elf socket.asm\n\n; Link with (64 bit systems require elf_i386 option): ld -m elf_i386 socket.o -o socket\n\n; Run with: ./socket\n\n\n\n%include    'functions.asm'\n\n\n\nSECTION .text\n\nglobal  _start\n\n\n\n_start:\n\n\n\n    xor     eax, eax            ; initialize some registers\n\n    xor     ebx, ebx\n\n    xor     edi, edi\n\n    xor     esi, esi\n\n\n\n_socket:\n\n\n\n    push    byte 6              ; create socket from lesson 29\n\n    push    byte 1\n\n    push    byte 2\n\n    mov     ecx, esp\n\n    mov     ebx, 1\n\n    mov     eax, 102\n\n    int     80h\n\n\n\n_bind:\n\n\n\n    mov     edi, eax            ; move return value of SYS_SOCKETCALL into edi (file descriptor for new socket, or -1 on error)\n\n    push    dword 0x00000000    ; push 0 dec onto the stack IP ADDRESS (0.0.0.0)\n\n    push    word 0x2923         ; push 9001 dec onto stack PORT (reverse byte order)\n\n    push    word 2              ; push 2 dec onto stack AF_INET\n\n    mov     ecx, esp            ; move address of stack pointer into ecx\n\n    push    byte 16             ; push 16 dec onto stack (arguments length)\n\n    push    ecx                 ; push the address of arguments onto stack\n\n    push    edi                 ; push the file descriptor onto stack\n\n    mov     ecx, esp            ; move address of arguments into ecx\n\n    mov     ebx, 2              ; invoke subroutine BIND (2)\n\n    mov     eax, 102            ; invoke SYS_SOCKETCALL (kernel opcode 102)\n\n    int     80h                 ; call the kernel\n\n\n\n_exit:\n\n\n\n    call    quit                ; call our quit function\n", ";------------------------------------------\n\n; int atoi(Integer number)\n\n; Ascii to integer function (atoi)\n\natoi:\n\n    push    ebx             ; preserve ebx on the stack to be restored after function runs\n\n    push    ecx             ; preserve ecx on the stack to be restored after function runs\n\n    push    edx             ; preserve edx on the stack to be restored after function runs\n\n    push    esi             ; preserve esi on the stack to be restored after function runs\n\n    mov     esi, eax        ; move pointer in eax into esi (our number to convert)\n\n    mov     eax, 0          ; initialise eax with decimal value 0\n\n    mov     ecx, 0          ; initialise ecx with decimal value 0\n\n\n\n.multiplyLoop:\n\n    xor     ebx, ebx        ; resets both lower and uppper bytes of ebx to be 0\n\n    mov     bl, [esi+ecx]   ; move a single byte into ebx register's lower half\n\n    cmp     bl, 48          ; compare ebx register's lower half value against ascii value 48 (char value 0)\n\n    jl      .finished       ; jump if less than to label finished\n\n    cmp     bl, 57          ; compare ebx register's lower half value against ascii value 57 (char value 9)\n\n    jg      .finished       ; jump if greater than to label finished\n\n\n\n    sub     bl, 48          ; convert ebx register's lower half to decimal representation of ascii value\n\n    add     eax, ebx        ; add ebx to our interger value in eax\n\n    mov     ebx, 10         ; move decimal value 10 into ebx\n\n    mul     ebx             ; multiply eax by ebx to get place value\n\n    inc     ecx             ; increment ecx (our counter register)\n\n    jmp     .multiplyLoop   ; continue multiply loop\n\n\n\n.finished:\n\n    cmp     ecx, 0          ; compare ecx register's value against decimal 0 (our counter register)\n\n    je      .restore        ; jump if equal to 0 (no integer arguments were passed to atoi)\n\n    mov     ebx, 10         ; move decimal value 10 into ebx\n\n    div     ebx             ; divide eax by value in ebx (in this case 10)\n\n\n\n.restore:\n\n    pop     esi             ; restore esi from the value we pushed onto the stack at the start\n\n    pop     edx             ; restore edx from the value we pushed onto the stack at the start\n\n    pop     ecx             ; restore ecx from the value we pushed onto the stack at the start\n\n    pop     ebx             ; restore ebx from the value we pushed onto the stack at the start\n\n    ret\n\n\n\n\n\n;------------------------------------------\n\n; void iprint(Integer number)\n\n; Integer printing function (itoa)\n\niprint:\n\n    push    eax             ; preserve eax on the stack to be restored after function runs\n\n    push    ecx             ; preserve ecx on the stack to be restored after function runs\n\n    push    edx             ; preserve edx on the stack to be restored after function runs\n\n    push    esi             ; preserve esi on the stack to be restored after function runs\n\n    mov     ecx, 0          ; counter of how many bytes we need to print in the end\n\n\n\n.divideLoop:\n\n    inc     ecx             ; count each byte to print - number of characters\n\n    mov     edx, 0          ; empty edx\n\n    mov     esi, 10         ; mov 10 into esi\n\n    idiv    esi             ; divide eax by esi\n\n    add     edx, 48         ; convert edx to it's ascii representation - edx holds the remainder after a divide instruction\n\n    push    edx             ; push edx (string representation of an intger) onto the stack\n\n    cmp     eax, 0          ; can the integer be divided anymore?\n\n    jnz     .divideLoop     ; jump if not zero to the label divideLoop\n\n\n\n.printLoop:\n\n    dec     ecx             ; count down each byte that we put on the stack\n\n    mov     eax, esp        ; mov the stack pointer into eax for printing\n\n    call    sprint          ; call our string print function\n\n    pop     eax             ; remove last character from the stack to move esp forward\n\n    cmp     ecx, 0          ; have we printed all bytes we pushed onto the stack?\n\n    jnz     .printLoop      ; jump is not zero to the label printLoop\n\n\n\n    pop     esi             ; restore esi from the value we pushed onto the stack at the start\n\n    pop     edx             ; restore edx from the value we pushed onto the stack at the start\n\n    pop     ecx             ; restore ecx from the value we pushed onto the stack at the start\n\n    pop     eax             ; restore eax from the value we pushed onto the stack at the start\n\n    ret\n\n\n\n\n\n;------------------------------------------\n\n; void iprintLF(Integer number)\n\n; Integer printing function with linefeed (itoa)\n\niprintLF:\n\n    call    iprint          ; call our integer printing function\n\n\n\n    push    eax             ; push eax onto the stack to preserve it while we use the eax register in this function\n\n    mov     eax, 0Ah        ; move 0Ah into eax - 0Ah is the ascii character for a linefeed\n\n    push    eax             ; push the linefeed onto the stack so we can get the address\n\n    mov     eax, esp        ; move the address of the current stack pointer into eax for sprint\n\n    call    sprint          ; call our sprint function\n\n    pop     eax             ; remove our linefeed character from the stack\n\n    pop     eax             ; restore the original value of eax before our function was called\n\n    ret\n\n\n\n\n\n;------------------------------------------\n\n; int slen(String message)\n\n; String length calculation function\n\nslen:\n\n    push    ebx\n\n    mov     ebx, eax\n\n\n\n.nextchar:\n\n    cmp     byte [eax], 0\n\n    jz      .finished\n\n    inc     eax\n\n    jmp     .nextchar\n\n\n\n.finished:\n\n    sub     eax, ebx\n\n    pop     ebx\n\n    ret\n\n\n\n\n\n;------------------------------------------\n\n; void sprint(String message)\n\n; String printing function\n\nsprint:\n\n    push    edx\n\n    push    ecx\n\n    push    ebx\n\n    push    eax\n\n    call    slen\n\n\n\n    mov     edx, eax\n\n    pop     eax\n\n\n\n    mov     ecx, eax\n\n    mov     ebx, 1\n\n    mov     eax, 4\n\n    int     80h\n\n\n\n    pop     ebx\n\n    pop     ecx\n\n    pop     edx\n\n    ret\n\n\n\n\n\n;------------------------------------------\n\n; void sprintLF(String message)\n\n; String printing with line feed function\n\nsprintLF:\n\n    call    sprint\n\n\n\n    push    eax\n\n    mov     eax, 0AH\n\n    push    eax\n\n    mov     eax, esp\n\n    call    sprint\n\n    pop     eax\n\n    pop     eax\n\n    ret\n\n\n\n\n\n;------------------------------------------\n\n; void exit()\n\n; Exit program and restore resources\n\nquit:\n\n    mov     ebx, 0\n\n    mov     eax, 1\n\n    int     80h\n\n    ret\n\n\n", "; Fizzbuzz\n\n; Compile with: nasm -f elf fizzbuzz.asm\n\n; Link with (64 bit systems require elf_i386 option): ld -m elf_i386 fizzbuzz.o -o fizzbuzz\n\n; Run with: ./fizzbuzz\n\n\n\n%include        'functions.asm'\n\n\n\nSECTION .data\n\nfizz        db      'Fizz', 0h     ; a message string\n\nbuzz        db      'Buzz', 0h     ; a message string\n\n\n\nSECTION .text\n\nglobal  _start\n\n\n\n_start:\n\n\n\n    mov     esi, 0          ; initialise our checkFizz boolean variable\n\n    mov     edi, 0          ; initialise our checkBuzz boolean variable\n\n    mov     ecx, 0          ; initialise our counter variable\n\n\n\nnextNumber:\n\n    inc     ecx             ; increment our counter variable\n\n\n\n.checkFizz\n\n    mov     edx, 0          ; clear the edx register - this will hold our remainder after division\n\n    mov     eax, ecx        ; move the value of our counter into eax for division\n\n    mov     ebx, 3          ; move our number to divide by into ebx (in this case the value is 3)\n\n    div     ebx             ; divide eax by ebx\n\n    mov     edi, edx        ; move our remainder into edi (our checkFizz boolean variable)\n\n    cmp     edi, 0          ; compare if the remainder is zero (meaning the counter divides by 3)\n\n    jne     .checkBuzz      ; if the remainder is not equal to zero jump to local label checkBuzz\n\n    mov     eax, fizz       ; else move the address of our fizz string into eax for printing\n\n    call    sprint          ; call our string printing function\n\n\n\n.checkBuzz:\n\n    mov     edx, 0          ; clear the edx register - this will hold our remainder after division\n\n    mov     eax, ecx        ; move the value of our counter into eax for division\n\n    mov     ebx, 5          ; move our number to divide by into ebx (in this case the value is 5)\n\n    div     ebx             ; divide eax by ebx\n\n    mov     esi, edx        ; move our remainder into edi (our checkBuzz boolean variable)\n\n    cmp     esi, 0          ; compare if the remainder is zero (meaning the counter divides by 5)\n\n    jne     .checkInt       ; if the remainder is not equal to zero jump to local label checkInt\n\n    mov     eax, buzz       ; else move the address of our buzz string into eax for printing\n\n    call    sprint          ; call our string printing function\n\n\n\n.checkInt:\n\n    cmp     edi, 0          ; edi contains the remainder after the division in checkFizz\n\n    je     .continue        ; if equal (counter divides by 3) skip printing the integer\n\n    cmp     esi, 0          ; esi contains the remainder after the division in checkBuzz\n\n    je     .continue        ; if equal (counter divides by 5) skip printing the integer\n\n    mov     eax, ecx        ; else move the value in ecx (our counter) into eax for printing\n\n    call    iprint          ; call our integer printing function\n\n\n\n.continue:\n\n    mov     eax, 0Ah        ; move an ascii linefeed character into eax\n\n    push    eax             ; push the address of eax onto the stack for printing\n\n    mov     eax, esp        ; get the stack pointer (address on the stack of our linefeed char)\n\n    call    sprint          ; call our string printing function to print a line feed\n\n    pop     eax             ; pop the stack so we don't waste resources\n\n    cmp     ecx, 100        ; compare if our counter is equal to 100\n\n    jne     nextNumber      ; if not equal jump to the start of the loop\n\n\n\n    call    quit            ; else call our quit function", ";------------------------------------------\n\n; int atoi(Integer number)\n\n; Ascii to integer function (atoi)\n\natoi:\n\n    push    ebx             ; preserve ebx on the stack to be restored after function runs\n\n    push    ecx             ; preserve ecx on the stack to be restored after function runs\n\n    push    edx             ; preserve edx on the stack to be restored after function runs\n\n    push    esi             ; preserve esi on the stack to be restored after function runs\n\n    mov     esi, eax        ; move pointer in eax into esi (our number to convert)\n\n    mov     eax, 0          ; initialise eax with decimal value 0\n\n    mov     ecx, 0          ; initialise ecx with decimal value 0\n\n\n\n.multiplyLoop:\n\n    xor     ebx, ebx        ; resets both lower and uppper bytes of ebx to be 0\n\n    mov     bl, [esi+ecx]   ; move a single byte into ebx register's lower half\n\n    cmp     bl, 48          ; compare ebx register's lower half value against ascii value 48 (char value 0)\n\n    jl      .finished       ; jump if less than to label finished\n\n    cmp     bl, 57          ; compare ebx register's lower half value against ascii value 57 (char value 9)\n\n    jg      .finished       ; jump if greater than to label finished\n\n\n\n    sub     bl, 48          ; convert ebx register's lower half to decimal representation of ascii value\n\n    add     eax, ebx        ; add ebx to our interger value in eax\n\n    mov     ebx, 10         ; move decimal value 10 into ebx\n\n    mul     ebx             ; multiply eax by ebx to get place value\n\n    inc     ecx             ; increment ecx (our counter register)\n\n    jmp     .multiplyLoop   ; continue multiply loop\n\n\n\n.finished:\n\n    cmp     ecx, 0          ; compare ecx register's value against decimal 0 (our counter register)\n\n    je      .restore        ; jump if equal to 0 (no integer arguments were passed to atoi)\n\n    mov     ebx, 10         ; move decimal value 10 into ebx\n\n    div     ebx             ; divide eax by value in ebx (in this case 10)\n\n\n\n.restore:\n\n    pop     esi             ; restore esi from the value we pushed onto the stack at the start\n\n    pop     edx             ; restore edx from the value we pushed onto the stack at the start\n\n    pop     ecx             ; restore ecx from the value we pushed onto the stack at the start\n\n    pop     ebx             ; restore ebx from the value we pushed onto the stack at the start\n\n    ret\n\n\n\n\n\n;------------------------------------------\n\n; void iprint(Integer number)\n\n; Integer printing function (itoa)\n\niprint:\n\n    push    eax             ; preserve eax on the stack to be restored after function runs\n\n    push    ecx             ; preserve ecx on the stack to be restored after function runs\n\n    push    edx             ; preserve edx on the stack to be restored after function runs\n\n    push    esi             ; preserve esi on the stack to be restored after function runs\n\n    mov     ecx, 0          ; counter of how many bytes we need to print in the end\n\n\n\n.divideLoop:\n\n    inc     ecx             ; count each byte to print - number of characters\n\n    mov     edx, 0          ; empty edx\n\n    mov     esi, 10         ; mov 10 into esi\n\n    idiv    esi             ; divide eax by esi\n\n    add     edx, 48         ; convert edx to it's ascii representation - edx holds the remainder after a divide instruction\n\n    push    edx             ; push edx (string representation of an intger) onto the stack\n\n    cmp     eax, 0          ; can the integer be divided anymore?\n\n    jnz     .divideLoop      ; jump if not zero to the label divideLoop\n\n\n\n.printLoop:\n\n    dec     ecx             ; count down each byte that we put on the stack\n\n    mov     eax, esp        ; mov the stack pointer into eax for printing\n\n    call    sprint          ; call our string print function\n\n    pop     eax             ; remove last character from the stack to move esp forward\n\n    cmp     ecx, 0          ; have we printed all bytes we pushed onto the stack?\n\n    jnz     .printLoop       ; jump is not zero to the label printLoop\n\n\n\n    pop     esi             ; restore esi from the value we pushed onto the stack at the start\n\n    pop     edx             ; restore edx from the value we pushed onto the stack at the start\n\n    pop     ecx             ; restore ecx from the value we pushed onto the stack at the start\n\n    pop     eax             ; restore eax from the value we pushed onto the stack at the start\n\n    ret\n\n\n\n\n\n;------------------------------------------\n\n; void iprintLF(Integer number)\n\n; Integer printing function with linefeed (itoa)\n\niprintLF:\n\n    call    iprint          ; call our integer printing function\n\n\n\n    push    eax             ; push eax onto the stack to preserve it while we use the eax register in this function\n\n    mov     eax, 0Ah        ; move 0Ah into eax - 0Ah is the ascii character for a linefeed\n\n    push    eax             ; push the linefeed onto the stack so we can get the address\n\n    mov     eax, esp        ; move the address of the current stack pointer into eax for sprint\n\n    call    sprint          ; call our sprint function\n\n    pop     eax             ; remove our linefeed character from the stack\n\n    pop     eax             ; restore the original value of eax before our function was called\n\n    ret\n\n\n\n\n\n;------------------------------------------\n\n; int slen(String message)\n\n; String length calculation function\n\nslen:\n\n    push    ebx\n\n    mov     ebx, eax\n\n\n\n.nextchar:\n\n    cmp     byte [eax], 0\n\n    jz      .finished\n\n    inc     eax\n\n    jmp     .nextchar\n\n\n\n.finished:\n\n    sub     eax, ebx\n\n    pop     ebx\n\n    ret\n\n\n\n\n\n;------------------------------------------\n\n; void sprint(String message)\n\n; String printing function\n\nsprint:\n\n    push    edx\n\n    push    ecx\n\n    push    ebx\n\n    push    eax\n\n    call    slen\n\n\n\n    mov     edx, eax\n\n    pop     eax\n\n\n\n    mov     ecx, eax\n\n    mov     ebx, 1\n\n    mov     eax, 4\n\n    int     80h\n\n\n\n    pop     ebx\n\n    pop     ecx\n\n    pop     edx\n\n    ret\n\n\n\n\n\n;------------------------------------------\n\n; void sprintLF(String message)\n\n; String printing with line feed function\n\nsprintLF:\n\n    call    sprint\n\n\n\n    push    eax\n\n    mov     eax, 0AH\n\n    push    eax\n\n    mov     eax, esp\n\n    call    sprint\n\n    pop     eax\n\n    pop     eax\n\n    ret\n\n\n\n\n\n;------------------------------------------\n\n; void exit()\n\n; Exit program and restore resources\n\nquit:\n\n    mov     ebx, 0\n\n    mov     eax, 1\n\n    int     80h\n\n    ret\n\n\n", "; Hello World Program - asmtutor.com\n\n; Compile with: nasm -f elf helloworld.asm\n\n; Link with (64 bit systems require elf_i386 option): ld -m elf_i386 helloworld.o -o helloworld\n\n; Run with: ./helloworld\n\n\n\nSECTION .data\n\nmsg     db      'Hello World!', 0Ah\n\n\n\nSECTION .text\n\nglobal  _start\n\n\n\n_start: \n\n\n\n    mov     edx, 13\n\n    mov     ecx, msg\n\n    mov     ebx, 1\n\n    mov     eax, 4\n\n    int     80h\n\n\n\n    mov     ebx, 0      ; return 0 status on exit - 'No Errors'\n\n    mov     eax, 1      ; invoke SYS_EXIT (kernel opcode 1)\n\n    int     80h", ";------------------------------------------\n\n; int atoi(Integer number)\n\n; Ascii to integer function (atoi)\n\natoi:\n\n    push    ebx             ; preserve ebx on the stack to be restored after function runs\n\n    push    ecx             ; preserve ecx on the stack to be restored after function runs\n\n    push    edx             ; preserve edx on the stack to be restored after function runs\n\n    push    esi             ; preserve esi on the stack to be restored after function runs\n\n    mov     esi, eax        ; move pointer in eax into esi (our number to convert)\n\n    mov     eax, 0          ; initialise eax with decimal value 0\n\n    mov     ecx, 0          ; initialise ecx with decimal value 0\n\n\n\n.multiplyLoop:\n\n    xor     ebx, ebx        ; resets both lower and uppper bytes of ebx to be 0\n\n    mov     bl, [esi+ecx]   ; move a single byte into ebx register's lower half\n\n    cmp     bl, 48          ; compare ebx register's lower half value against ascii value 48 (char value 0)\n\n    jl      .finished       ; jump if less than to label finished\n\n    cmp     bl, 57          ; compare ebx register's lower half value against ascii value 57 (char value 9)\n\n    jg      .finished       ; jump if greater than to label finished\n\n\n\n    sub     bl, 48          ; convert ebx register's lower half to decimal representation of ascii value\n\n    add     eax, ebx        ; add ebx to our interger value in eax\n\n    mov     ebx, 10         ; move decimal value 10 into ebx\n\n    mul     ebx             ; multiply eax by ebx to get place value\n\n    inc     ecx             ; increment ecx (our counter register)\n\n    jmp     .multiplyLoop   ; continue multiply loop\n\n\n\n.finished:\n\n    cmp     ecx, 0          ; compare ecx register's value against decimal 0 (our counter register)\n\n    je      .restore        ; jump if equal to 0 (no integer arguments were passed to atoi)\n\n    mov     ebx, 10         ; move decimal value 10 into ebx\n\n    div     ebx             ; divide eax by value in ebx (in this case 10)\n\n\n\n.restore:\n\n    pop     esi             ; restore esi from the value we pushed onto the stack at the start\n\n    pop     edx             ; restore edx from the value we pushed onto the stack at the start\n\n    pop     ecx             ; restore ecx from the value we pushed onto the stack at the start\n\n    pop     ebx             ; restore ebx from the value we pushed onto the stack at the start\n\n    ret\n\n\n\n\n\n;------------------------------------------\n\n; void iprint(Integer number)\n\n; Integer printing function (itoa)\n\niprint:\n\n    push    eax             ; preserve eax on the stack to be restored after function runs\n\n    push    ecx             ; preserve ecx on the stack to be restored after function runs\n\n    push    edx             ; preserve edx on the stack to be restored after function runs\n\n    push    esi             ; preserve esi on the stack to be restored after function runs\n\n    mov     ecx, 0          ; counter of how many bytes we need to print in the end\n\n\n\n.divideLoop:\n\n    inc     ecx             ; count each byte to print - number of characters\n\n    mov     edx, 0          ; empty edx\n\n    mov     esi, 10         ; mov 10 into esi\n\n    idiv    esi             ; divide eax by esi\n\n    add     edx, 48         ; convert edx to it's ascii representation - edx holds the remainder after a divide instruction\n\n    push    edx             ; push edx (string representation of an intger) onto the stack\n\n    cmp     eax, 0          ; can the integer be divided anymore?\n\n    jnz     .divideLoop      ; jump if not zero to the label divideLoop\n\n\n\n.printLoop:\n\n    dec     ecx             ; count down each byte that we put on the stack\n\n    mov     eax, esp        ; mov the stack pointer into eax for printing\n\n    call    sprint          ; call our string print function\n\n    pop     eax             ; remove last character from the stack to move esp forward\n\n    cmp     ecx, 0          ; have we printed all bytes we pushed onto the stack?\n\n    jnz     .printLoop       ; jump is not zero to the label printLoop\n\n\n\n    pop     esi             ; restore esi from the value we pushed onto the stack at the start\n\n    pop     edx             ; restore edx from the value we pushed onto the stack at the start\n\n    pop     ecx             ; restore ecx from the value we pushed onto the stack at the start\n\n    pop     eax             ; restore eax from the value we pushed onto the stack at the start\n\n    ret\n\n\n\n\n\n;------------------------------------------\n\n; void iprintLF(Integer number)\n\n; Integer printing function with linefeed (itoa)\n\niprintLF:\n\n    call    iprint          ; call our integer printing function\n\n\n\n    push    eax             ; push eax onto the stack to preserve it while we use the eax register in this function\n\n    mov     eax, 0Ah        ; move 0Ah into eax - 0Ah is the ascii character for a linefeed\n\n    push    eax             ; push the linefeed onto the stack so we can get the address\n\n    mov     eax, esp        ; move the address of the current stack pointer into eax for sprint\n\n    call    sprint          ; call our sprint function\n\n    pop     eax             ; remove our linefeed character from the stack\n\n    pop     eax             ; restore the original value of eax before our function was called\n\n    ret\n\n\n\n\n\n;------------------------------------------\n\n; int slen(String message)\n\n; String length calculation function\n\nslen:\n\n    push    ebx\n\n    mov     ebx, eax\n\n\n\n.nextchar:\n\n    cmp     byte [eax], 0\n\n    jz      .finished\n\n    inc     eax\n\n    jmp     .nextchar\n\n\n\n.finished:\n\n    sub     eax, ebx\n\n    pop     ebx\n\n    ret\n\n\n\n\n\n;------------------------------------------\n\n; void sprint(String message)\n\n; String printing function\n\nsprint:\n\n    push    edx\n\n    push    ecx\n\n    push    ebx\n\n    push    eax\n\n    call    slen\n\n\n\n    mov     edx, eax\n\n    pop     eax\n\n\n\n    mov     ecx, eax\n\n    mov     ebx, 1\n\n    mov     eax, 4\n\n    int     80h\n\n\n\n    pop     ebx\n\n    pop     ecx\n\n    pop     edx\n\n    ret\n\n\n\n\n\n;------------------------------------------\n\n; void sprintLF(String message)\n\n; String printing with line feed function\n\nsprintLF:\n\n    call    sprint\n\n\n\n    push    eax\n\n    mov     eax, 0AH\n\n    push    eax\n\n    mov     eax, esp\n\n    call    sprint\n\n    pop     eax\n\n    pop     eax\n\n    ret\n\n\n\n\n\n;------------------------------------------\n\n; void exit()\n\n; Exit program and restore resources\n\nquit:\n\n    mov     ebx, 0\n\n    mov     eax, 1\n\n    int     80h\n\n    ret\n\n\n", "; Execute\n\n; Compile with: nasm -f elf execute.asm\n\n; Link with (64 bit systems require elf_i386 option): ld -m elf_i386 execute.o -o execute\n\n; Run with: ./execute\n\n\n\n%include        'functions.asm'\n\n\n\nSECTION .data\n\ncommand         db      '/bin/echo', 0h     ; command to execute\n\narg1            db      'Hello World!', 0h\n\narguments       dd      command\n\n                dd      arg1                ; arguments to pass to commandline (in this case just one)\n\n                dd      0h                  ; end the struct\n\nenvironment     dd      0h                  ; arguments to pass as environment variables (inthis case none) end the struct\n\n\n\nSECTION .text\n\nglobal  _start\n\n\n\n_start:\n\n\n\n    mov     edx, environment    ; address of environment variables\n\n    mov     ecx, arguments      ; address of the arguments to pass to the commandline\n\n    mov     ebx, command        ; address of the file to execute\n\n    mov     eax, 11             ; invoke SYS_EXECVE (kernel opcode 11)\n\n    int     80h\n\n\n\n    call    quit                ; call our quit function", "; Socket\n\n; Compile with: nasm -f elf socket.asm\n\n; Link with (64 bit systems require elf_i386 option): ld -m elf_i386 socket.o -o socket\n\n; Run with: ./socket\n\n\n\n%include    'functions.asm'\n\n\n\nSECTION .data\n\n; our response string\n\nresponse db 'HTTP/1.1 200 OK', 0Dh, 0Ah, 'Content-Type: text/html', 0Dh, 0Ah, 'Content-Length: 14', 0Dh, 0Ah, 0Dh, 0Ah, 'Hello World!', 0Dh, 0Ah, 0h\n\n\n\nSECTION .bss\n\nbuffer resb 255,                ; variable to store request headers\n\n\n\nSECTION .text\n\nglobal  _start\n\n\n\n_start:\n\n\n\n    xor     eax, eax            ; initialize some registers\n\n    xor     ebx, ebx\n\n    xor     edi, edi\n\n    xor     esi, esi\n\n\n\n_socket:\n\n\n\n    push    byte 6              ; create socket from lesson 29\n\n    push    byte 1\n\n    push    byte 2\n\n    mov     ecx, esp\n\n    mov     ebx, 1\n\n    mov     eax, 102\n\n    int     80h\n\n\n\n_bind:\n\n\n\n    mov     edi, eax            ; bind socket from lesson 30\n\n    push    dword 0x00000000\n\n    push    word 0x2923\n\n    push    word 2\n\n    mov     ecx, esp\n\n    push    byte 16\n\n    push    ecx\n\n    push    edi\n\n    mov     ecx, esp\n\n    mov     ebx, 2\n\n    mov     eax, 102\n\n    int     80h\n\n\n\n_listen:\n\n\n\n    push    byte 1              ; listen socket from lesson 31\n\n    push    edi\n\n    mov     ecx, esp\n\n    mov     ebx, 4\n\n    mov     eax, 102\n\n    int     80h\n\n\n\n_accept:\n\n\n\n    push    byte 0              ; accept socket from lesson 32\n\n    push    byte 0\n\n    push    edi\n\n    mov     ecx, esp\n\n    mov     ebx, 5\n\n    mov     eax, 102\n\n    int     80h\n\n\n\n_fork:\n\n\n\n    mov     esi, eax            ; fork socket from lesson 33\n\n    mov     eax, 2\n\n    int     80h\n\n\n\n    cmp     eax, 0\n\n    jz      _read\n\n\n\n    jmp     _accept\n\n\n\n_read:\n\n\n\n    mov     edx, 255            ; read socket from lesson 33\n\n    mov     ecx, buffer\n\n    mov     ebx, esi\n\n    mov     eax, 3\n\n    int     80h\n\n\n\n    mov     eax, buffer\n\n    call    sprintLF\n\n\n\n_write:\n\n\n\n    mov     edx, 78             ; write socket from lesson 34\n\n    mov     ecx, response\n\n    mov     ebx, esi\n\n    mov     eax, 4\n\n    int     80h\n\n\n\n_close:\n\n\n\n    mov     ebx, esi            ; move esi into ebx (accepted socket file descriptor)\n\n    mov     eax, 6              ; invoke SYS_CLOSE (kernel opcode 6)\n\n    int     80h                 ; call the kernel\n\n\n\n_exit:\n\n\n\n    call    quit                ; call our quit function\n", ";------------------------------------------\n\n; int atoi(Integer number)\n\n; Ascii to integer function (atoi)\n\natoi:\n\n    push    ebx             ; preserve ebx on the stack to be restored after function runs\n\n    push    ecx             ; preserve ecx on the stack to be restored after function runs\n\n    push    edx             ; preserve edx on the stack to be restored after function runs\n\n    push    esi             ; preserve esi on the stack to be restored after function runs\n\n    mov     esi, eax        ; move pointer in eax into esi (our number to convert)\n\n    mov     eax, 0          ; initialise eax with decimal value 0\n\n    mov     ecx, 0          ; initialise ecx with decimal value 0\n\n\n\n.multiplyLoop:\n\n    xor     ebx, ebx        ; resets both lower and uppper bytes of ebx to be 0\n\n    mov     bl, [esi+ecx]   ; move a single byte into ebx register's lower half\n\n    cmp     bl, 48          ; compare ebx register's lower half value against ascii value 48 (char value 0)\n\n    jl      .finished       ; jump if less than to label finished\n\n    cmp     bl, 57          ; compare ebx register's lower half value against ascii value 57 (char value 9)\n\n    jg      .finished       ; jump if greater than to label finished\n\n\n\n    sub     bl, 48          ; convert ebx register's lower half to decimal representation of ascii value\n\n    add     eax, ebx        ; add ebx to our interger value in eax\n\n    mov     ebx, 10         ; move decimal value 10 into ebx\n\n    mul     ebx             ; multiply eax by ebx to get place value\n\n    inc     ecx             ; increment ecx (our counter register)\n\n    jmp     .multiplyLoop   ; continue multiply loop\n\n\n\n.finished:\n\n    cmp     ecx, 0          ; compare ecx register's value against decimal 0 (our counter register)\n\n    je      .restore        ; jump if equal to 0 (no integer arguments were passed to atoi)\n\n    mov     ebx, 10         ; move decimal value 10 into ebx\n\n    div     ebx             ; divide eax by value in ebx (in this case 10)\n\n\n\n.restore:\n\n    pop     esi             ; restore esi from the value we pushed onto the stack at the start\n\n    pop     edx             ; restore edx from the value we pushed onto the stack at the start\n\n    pop     ecx             ; restore ecx from the value we pushed onto the stack at the start\n\n    pop     ebx             ; restore ebx from the value we pushed onto the stack at the start\n\n    ret\n\n\n\n\n\n;------------------------------------------\n\n; void iprint(Integer number)\n\n; Integer printing function (itoa)\n\niprint:\n\n    push    eax             ; preserve eax on the stack to be restored after function runs\n\n    push    ecx             ; preserve ecx on the stack to be restored after function runs\n\n    push    edx             ; preserve edx on the stack to be restored after function runs\n\n    push    esi             ; preserve esi on the stack to be restored after function runs\n\n    mov     ecx, 0          ; counter of how many bytes we need to print in the end\n\n\n\n.divideLoop:\n\n    inc     ecx             ; count each byte to print - number of characters\n\n    mov     edx, 0          ; empty edx\n\n    mov     esi, 10         ; mov 10 into esi\n\n    idiv    esi             ; divide eax by esi\n\n    add     edx, 48         ; convert edx to it's ascii representation - edx holds the remainder after a divide instruction\n\n    push    edx             ; push edx (string representation of an intger) onto the stack\n\n    cmp     eax, 0          ; can the integer be divided anymore?\n\n    jnz     .divideLoop     ; jump if not zero to the label divideLoop\n\n\n\n.printLoop:\n\n    dec     ecx             ; count down each byte that we put on the stack\n\n    mov     eax, esp        ; mov the stack pointer into eax for printing\n\n    call    sprint          ; call our string print function\n\n    pop     eax             ; remove last character from the stack to move esp forward\n\n    cmp     ecx, 0          ; have we printed all bytes we pushed onto the stack?\n\n    jnz     .printLoop      ; jump is not zero to the label printLoop\n\n\n\n    pop     esi             ; restore esi from the value we pushed onto the stack at the start\n\n    pop     edx             ; restore edx from the value we pushed onto the stack at the start\n\n    pop     ecx             ; restore ecx from the value we pushed onto the stack at the start\n\n    pop     eax             ; restore eax from the value we pushed onto the stack at the start\n\n    ret\n\n\n\n\n\n;------------------------------------------\n\n; void iprintLF(Integer number)\n\n; Integer printing function with linefeed (itoa)\n\niprintLF:\n\n    call    iprint          ; call our integer printing function\n\n\n\n    push    eax             ; push eax onto the stack to preserve it while we use the eax register in this function\n\n    mov     eax, 0Ah        ; move 0Ah into eax - 0Ah is the ascii character for a linefeed\n\n    push    eax             ; push the linefeed onto the stack so we can get the address\n\n    mov     eax, esp        ; move the address of the current stack pointer into eax for sprint\n\n    call    sprint          ; call our sprint function\n\n    pop     eax             ; remove our linefeed character from the stack\n\n    pop     eax             ; restore the original value of eax before our function was called\n\n    ret\n\n\n\n\n\n;------------------------------------------\n\n; int slen(String message)\n\n; String length calculation function\n\nslen:\n\n    push    ebx\n\n    mov     ebx, eax\n\n\n\n.nextchar:\n\n    cmp     byte [eax], 0\n\n    jz      .finished\n\n    inc     eax\n\n    jmp     .nextchar\n\n\n\n.finished:\n\n    sub     eax, ebx\n\n    pop     ebx\n\n    ret\n\n\n\n\n\n;------------------------------------------\n\n; void sprint(String message)\n\n; String printing function\n\nsprint:\n\n    push    edx\n\n    push    ecx\n\n    push    ebx\n\n    push    eax\n\n    call    slen\n\n\n\n    mov     edx, eax\n\n    pop     eax\n\n\n\n    mov     ecx, eax\n\n    mov     ebx, 1\n\n    mov     eax, 4\n\n    int     80h\n\n\n\n    pop     ebx\n\n    pop     ecx\n\n    pop     edx\n\n    ret\n\n\n\n\n\n;------------------------------------------\n\n; void sprintLF(String message)\n\n; String printing with line feed function\n\nsprintLF:\n\n    call    sprint\n\n\n\n    push    eax\n\n    mov     eax, 0AH\n\n    push    eax\n\n    mov     eax, esp\n\n    call    sprint\n\n    pop     eax\n\n    pop     eax\n\n    ret\n\n\n\n\n\n;------------------------------------------\n\n; void exit()\n\n; Exit program and restore resources\n\nquit:\n\n    mov     ebx, 0\n\n    mov     eax, 1\n\n    int     80h\n\n    ret\n\n\n", "; Calculator (Division)\n\n; Compile with: nasm -f elf calculator-division.asm\n\n; Link with (64 bit systems require elf_i386 option): ld -m elf_i386 calculator-division.o -o calculator-division\n\n; Run with: ./calculator-division\n\n\n\n%include        'functions.asm'\n\n\n\nSECTION .data\n\nmsg1        db      ' remainder '      ; a message string to correctly output result\n\n\n\nSECTION .text\n\nglobal  _start\n\n\n\n_start:\n\n\n\n    mov     eax, 90     ; move our first number into eax\n\n    mov     ebx, 9      ; move our second number into ebx\n\n    div     ebx         ; divide eax by ebx\n\n    call    iprint      ; call our integer print function on the quotient\n\n    mov     eax, msg1   ; move our message string into eax\n\n    call    sprint      ; call our string print function\n\n    mov     eax, edx    ; move our remainder into eax\n\n    call    iprintLF    ; call our integer printing with linefeed function\n\n\n\n    call    quit", ";------------------------------------------\n\n; void iprint(Integer number)\n\n; Integer printing function (itoa)\n\niprint:\n\n    push    eax             ; preserve eax on the stack to be restored after function runs\n\n    push    ecx             ; preserve ecx on the stack to be restored after function runs\n\n    push    edx             ; preserve edx on the stack to be restored after function runs\n\n    push    esi             ; preserve esi on the stack to be restored after function runs\n\n    mov     ecx, 0          ; counter of how many bytes we need to print in the end\n\n    \n\ndivideLoop:\n\n    inc     ecx             ; count each byte to print - number of characters\n\n    mov     edx, 0          ; empty edx\n\n    mov     esi, 10         ; mov 10 into esi\n\n    idiv    esi             ; divide eax by esi\n\n    add     edx, 48         ; convert edx to it's ascii representation - edx holds the remainder after a divide instruction\n\n    push    edx             ; push edx (string representation of an intger) onto the stack\n\n    cmp     eax, 0          ; can the integer be divided anymore?\n\n    jnz     divideLoop      ; jump if not zero to the label divideLoop\n\n\n\nprintLoop:\n\n    dec     ecx             ; count down each byte that we put on the stack\n\n    mov     eax, esp        ; mov the stack pointer into eax for printing\n\n    call    sprint          ; call our string print function\n\n    pop     eax             ; remove last character from the stack to move esp forward\n\n    cmp     ecx, 0          ; have we printed all bytes we pushed onto the stack?\n\n    jnz     printLoop       ; jump is not zero to the label printLoop\n\n\n\n    pop     esi             ; restore esi from the value we pushed onto the stack at the start\n\n    pop     edx             ; restore edx from the value we pushed onto the stack at the start\n\n    pop     ecx             ; restore ecx from the value we pushed onto the stack at the start\n\n    pop     eax             ; restore eax from the value we pushed onto the stack at the start\n\n    ret\n\n\n\n\n\n;------------------------------------------\n\n; void iprintLF(Integer number)\n\n; Integer printing function with linefeed (itoa)\n\niprintLF:\n\n    call    iprint          ; call our integer printing function\n\n\n\n    push    eax             ; push eax onto the stack to preserve it while we use the eax register in this function\n\n    mov     eax, 0Ah        ; move 0Ah into eax - 0Ah is the ascii character for a linefeed\n\n    push    eax             ; push the linefeed onto the stack so we can get the address\n\n    mov     eax, esp        ; move the address of the current stack pointer into eax for sprint\n\n    call    sprint          ; call our sprint function\n\n    pop     eax             ; remove our linefeed character from the stack\n\n    pop     eax             ; restore the original value of eax before our function was called\n\n    ret\n\n\n\n    \n\n;------------------------------------------\n\n; int slen(String message)\n\n; String length calculation function\n\nslen:                     \n\n    push    ebx             \n\n    mov     ebx, eax        \n\n    \n\nnextchar:                   \n\n    cmp     byte [eax], 0   \n\n    jz      finished        \n\n    inc     eax             \n\n    jmp     nextchar        \n\n    \n\nfinished:\n\n    sub     eax, ebx\n\n    pop     ebx             \n\n    ret                     \n\n\n\n\n\n;------------------------------------------\n\n; void sprint(String message)\n\n; String printing function\n\nsprint:\n\n    push    edx\n\n    push    ecx\n\n    push    ebx\n\n    push    eax\n\n    call    slen\n\n    \n\n    mov     edx, eax\n\n    pop     eax\n\n    \n\n    mov     ecx, eax\n\n    mov     ebx, 1\n\n    mov     eax, 4\n\n    int     80h\n\n\n\n    pop     ebx\n\n    pop     ecx\n\n    pop     edx\n\n    ret\n\n\n\n\n\n;------------------------------------------\n\n; void sprintLF(String message)\n\n; String printing with line feed function\n\nsprintLF:\n\n    call    sprint\n\n\n\n    push    eax\n\n    mov     eax, 0AH\n\n    push    eax\n\n    mov     eax, esp\n\n    call    sprint\n\n    pop     eax\n\n    pop     eax\n\n    ret\n\n\n\n    \n\n;------------------------------------------\n\n; void exit()\n\n; Exit program and restore resources\n\nquit:\n\n    mov     ebx, 0      \n\n    mov     eax, 1      \n\n    int     80h\n\n    ret\n\n\n", "; Socket\n\n; Compile with: nasm -f elf socket.asm\n\n; Link with (64 bit systems require elf_i386 option): ld -m elf_i386 socket.o -o socket\n\n; Run with: ./socket\n\n\n\n%include    'functions.asm'\n\n\n\nSECTION .bss\n\nbuffer resb 255,                ; variable to store request headers\n\n\n\nSECTION .text\n\nglobal  _start\n\n\n\n_start:\n\n\n\n    xor     eax, eax            ; initialize some registers\n\n    xor     ebx, ebx\n\n    xor     edi, edi\n\n    xor     esi, esi\n\n\n\n_socket:\n\n\n\n    push    byte 6              ; create socket from lesson 29\n\n    push    byte 1\n\n    push    byte 2\n\n    mov     ecx, esp\n\n    mov     ebx, 1\n\n    mov     eax, 102\n\n    int     80h\n\n\n\n_bind:\n\n\n\n    mov     edi, eax            ; bind socket from lesson 30\n\n    push    dword 0x00000000\n\n    push    word 0x2923\n\n    push    word 2\n\n    mov     ecx, esp\n\n    push    byte 16\n\n    push    ecx\n\n    push    edi\n\n    mov     ecx, esp\n\n    mov     ebx, 2\n\n    mov     eax, 102\n\n    int     80h\n\n\n\n_listen:\n\n\n\n    push    byte 1              ; listen socket from lesson 31\n\n    push    edi\n\n    mov     ecx, esp\n\n    mov     ebx, 4\n\n    mov     eax, 102\n\n    int     80h\n\n\n\n_accept:\n\n\n\n    push    byte 0              ; accept socket from lesson 32\n\n    push    byte 0\n\n    push    edi\n\n    mov     ecx, esp\n\n    mov     ebx, 5\n\n    mov     eax, 102\n\n    int     80h\n\n\n\n_fork:\n\n\n\n    mov     esi, eax            ; move return value of SYS_SOCKETCALL into esi (file descriptor for accepted socket, or -1 on error)\n\n    mov     eax, 2              ; invoke SYS_FORK (kernel opcode 2)\n\n    int     80h                 ; call the kernel\n\n\n\n    cmp     eax, 0              ; if return value of SYS_FORK in eax is zero we are in the child process\n\n    jz      _read               ; jmp in child process to _read\n\n\n\n    jmp     _accept             ; jmp in parent process to _accept\n\n\n\n_read:\n\n\n\n    mov     edx, 255            ; number of bytes to read (we will only read the first 255 bytes for simplicity)\n\n    mov     ecx, buffer         ; move the memory address of our buffer variable into ecx\n\n    mov     ebx, esi            ; move esi into ebx (accepted socket file descriptor)\n\n    mov     eax, 3              ; invoke SYS_READ (kernel opcode 3)\n\n    int     80h                 ; call the kernel\n\n\n\n    mov     eax, buffer         ; move the memory address of our buffer variable into eax for printing\n\n    call    sprintLF            ; call our string printing function\n\n\n\n_exit:\n\n\n\n    call    quit                ; call our quit function\n", ";------------------------------------------\n\n; int atoi(Integer number)\n\n; Ascii to integer function (atoi)\n\natoi:\n\n    push    ebx             ; preserve ebx on the stack to be restored after function runs\n\n    push    ecx             ; preserve ecx on the stack to be restored after function runs\n\n    push    edx             ; preserve edx on the stack to be restored after function runs\n\n    push    esi             ; preserve esi on the stack to be restored after function runs\n\n    mov     esi, eax        ; move pointer in eax into esi (our number to convert)\n\n    mov     eax, 0          ; initialise eax with decimal value 0\n\n    mov     ecx, 0          ; initialise ecx with decimal value 0\n\n\n\n.multiplyLoop:\n\n    xor     ebx, ebx        ; resets both lower and uppper bytes of ebx to be 0\n\n    mov     bl, [esi+ecx]   ; move a single byte into ebx register's lower half\n\n    cmp     bl, 48          ; compare ebx register's lower half value against ascii value 48 (char value 0)\n\n    jl      .finished       ; jump if less than to label finished\n\n    cmp     bl, 57          ; compare ebx register's lower half value against ascii value 57 (char value 9)\n\n    jg      .finished       ; jump if greater than to label finished\n\n\n\n    sub     bl, 48          ; convert ebx register's lower half to decimal representation of ascii value\n\n    add     eax, ebx        ; add ebx to our interger value in eax\n\n    mov     ebx, 10         ; move decimal value 10 into ebx\n\n    mul     ebx             ; multiply eax by ebx to get place value\n\n    inc     ecx             ; increment ecx (our counter register)\n\n    jmp     .multiplyLoop   ; continue multiply loop\n\n\n\n.finished:\n\n    cmp     ecx, 0          ; compare ecx register's value against decimal 0 (our counter register)\n\n    je      .restore        ; jump if equal to 0 (no integer arguments were passed to atoi)\n\n    mov     ebx, 10         ; move decimal value 10 into ebx\n\n    div     ebx             ; divide eax by value in ebx (in this case 10)\n\n\n\n.restore:\n\n    pop     esi             ; restore esi from the value we pushed onto the stack at the start\n\n    pop     edx             ; restore edx from the value we pushed onto the stack at the start\n\n    pop     ecx             ; restore ecx from the value we pushed onto the stack at the start\n\n    pop     ebx             ; restore ebx from the value we pushed onto the stack at the start\n\n    ret\n\n\n\n\n\n;------------------------------------------\n\n; void iprint(Integer number)\n\n; Integer printing function (itoa)\n\niprint:\n\n    push    eax             ; preserve eax on the stack to be restored after function runs\n\n    push    ecx             ; preserve ecx on the stack to be restored after function runs\n\n    push    edx             ; preserve edx on the stack to be restored after function runs\n\n    push    esi             ; preserve esi on the stack to be restored after function runs\n\n    mov     ecx, 0          ; counter of how many bytes we need to print in the end\n\n\n\n.divideLoop:\n\n    inc     ecx             ; count each byte to print - number of characters\n\n    mov     edx, 0          ; empty edx\n\n    mov     esi, 10         ; mov 10 into esi\n\n    idiv    esi             ; divide eax by esi\n\n    add     edx, 48         ; convert edx to it's ascii representation - edx holds the remainder after a divide instruction\n\n    push    edx             ; push edx (string representation of an intger) onto the stack\n\n    cmp     eax, 0          ; can the integer be divided anymore?\n\n    jnz     .divideLoop     ; jump if not zero to the label divideLoop\n\n\n\n.printLoop:\n\n    dec     ecx             ; count down each byte that we put on the stack\n\n    mov     eax, esp        ; mov the stack pointer into eax for printing\n\n    call    sprint          ; call our string print function\n\n    pop     eax             ; remove last character from the stack to move esp forward\n\n    cmp     ecx, 0          ; have we printed all bytes we pushed onto the stack?\n\n    jnz     .printLoop      ; jump is not zero to the label printLoop\n\n\n\n    pop     esi             ; restore esi from the value we pushed onto the stack at the start\n\n    pop     edx             ; restore edx from the value we pushed onto the stack at the start\n\n    pop     ecx             ; restore ecx from the value we pushed onto the stack at the start\n\n    pop     eax             ; restore eax from the value we pushed onto the stack at the start\n\n    ret\n\n\n\n\n\n;------------------------------------------\n\n; void iprintLF(Integer number)\n\n; Integer printing function with linefeed (itoa)\n\niprintLF:\n\n    call    iprint          ; call our integer printing function\n\n\n\n    push    eax             ; push eax onto the stack to preserve it while we use the eax register in this function\n\n    mov     eax, 0Ah        ; move 0Ah into eax - 0Ah is the ascii character for a linefeed\n\n    push    eax             ; push the linefeed onto the stack so we can get the address\n\n    mov     eax, esp        ; move the address of the current stack pointer into eax for sprint\n\n    call    sprint          ; call our sprint function\n\n    pop     eax             ; remove our linefeed character from the stack\n\n    pop     eax             ; restore the original value of eax before our function was called\n\n    ret\n\n\n\n\n\n;------------------------------------------\n\n; int slen(String message)\n\n; String length calculation function\n\nslen:\n\n    push    ebx\n\n    mov     ebx, eax\n\n\n\n.nextchar:\n\n    cmp     byte [eax], 0\n\n    jz      .finished\n\n    inc     eax\n\n    jmp     .nextchar\n\n\n\n.finished:\n\n    sub     eax, ebx\n\n    pop     ebx\n\n    ret\n\n\n\n\n\n;------------------------------------------\n\n; void sprint(String message)\n\n; String printing function\n\nsprint:\n\n    push    edx\n\n    push    ecx\n\n    push    ebx\n\n    push    eax\n\n    call    slen\n\n\n\n    mov     edx, eax\n\n    pop     eax\n\n\n\n    mov     ecx, eax\n\n    mov     ebx, 1\n\n    mov     eax, 4\n\n    int     80h\n\n\n\n    pop     ebx\n\n    pop     ecx\n\n    pop     edx\n\n    ret\n\n\n\n\n\n;------------------------------------------\n\n; void sprintLF(String message)\n\n; String printing with line feed function\n\nsprintLF:\n\n    call    sprint\n\n\n\n    push    eax\n\n    mov     eax, 0AH\n\n    push    eax\n\n    mov     eax, esp\n\n    call    sprint\n\n    pop     eax\n\n    pop     eax\n\n    ret\n\n\n\n\n\n;------------------------------------------\n\n; void exit()\n\n; Exit program and restore resources\n\nquit:\n\n    mov     ebx, 0\n\n    mov     eax, 1\n\n    int     80h\n\n    ret\n\n\n", "; Socket\n\n; Compile with: nasm -f elf socket.asm\n\n; Link with (64 bit systems require elf_i386 option): ld -m elf_i386 socket.o -o socket\n\n; Run with: ./socket\n\n\n\n%include    'functions.asm'\n\n\n\nSECTION .text\n\nglobal  _start\n\n\n\n_start:\n\n\n\n    xor     eax, eax            ; initialize some registers\n\n    xor     ebx, ebx\n\n    xor     edi, edi\n\n    xor     esi, esi\n\n\n\n_socket:\n\n\n\n    push    byte 6              ; create socket from lesson 29\n\n    push    byte 1\n\n    push    byte 2\n\n    mov     ecx, esp\n\n    mov     ebx, 1\n\n    mov     eax, 102\n\n    int     80h\n\n\n\n_bind:\n\n\n\n    mov     edi, eax            ; bind socket from lesson 30\n\n    push    dword 0x00000000\n\n    push    word 0x2923\n\n    push    word 2\n\n    mov     ecx, esp\n\n    push    byte 16\n\n    push    ecx\n\n    push    edi\n\n    mov     ecx, esp\n\n    mov     ebx, 2\n\n    mov     eax, 102\n\n    int     80h\n\n\n\n_listen:\n\n\n\n    push    byte 1              ; listen socket from lesson 31\n\n    push    edi\n\n    mov     ecx, esp\n\n    mov     ebx, 4\n\n    mov     eax, 102\n\n    int     80h\n\n\n\n_accept:\n\n\n\n    push    byte 0              ; push 0 dec onto stack (address length argument)\n\n    push    byte 0              ; push 0 dec onto stack (address argument)\n\n    push    edi                 ; push the file descriptor onto stack\n\n    mov     ecx, esp            ; move address of arguments into ecx\n\n    mov     ebx, 5              ; invoke subroutine ACCEPT (5)\n\n    mov     eax, 102            ; invoke SYS_SOCKETCALL (kernel opcode 102)\n\n    int     80h                 ; call the kernel\n\n\n\n_exit:\n\n\n\n    call    quit                ; call our quit function\n", ";------------------------------------------\n\n; int atoi(Integer number)\n\n; Ascii to integer function (atoi)\n\natoi:\n\n    push    ebx             ; preserve ebx on the stack to be restored after function runs\n\n    push    ecx             ; preserve ecx on the stack to be restored after function runs\n\n    push    edx             ; preserve edx on the stack to be restored after function runs\n\n    push    esi             ; preserve esi on the stack to be restored after function runs\n\n    mov     esi, eax        ; move pointer in eax into esi (our number to convert)\n\n    mov     eax, 0          ; initialise eax with decimal value 0\n\n    mov     ecx, 0          ; initialise ecx with decimal value 0\n\n\n\n.multiplyLoop:\n\n    xor     ebx, ebx        ; resets both lower and uppper bytes of ebx to be 0\n\n    mov     bl, [esi+ecx]   ; move a single byte into ebx register's lower half\n\n    cmp     bl, 48          ; compare ebx register's lower half value against ascii value 48 (char value 0)\n\n    jl      .finished       ; jump if less than to label finished\n\n    cmp     bl, 57          ; compare ebx register's lower half value against ascii value 57 (char value 9)\n\n    jg      .finished       ; jump if greater than to label finished\n\n\n\n    sub     bl, 48          ; convert ebx register's lower half to decimal representation of ascii value\n\n    add     eax, ebx        ; add ebx to our interger value in eax\n\n    mov     ebx, 10         ; move decimal value 10 into ebx\n\n    mul     ebx             ; multiply eax by ebx to get place value\n\n    inc     ecx             ; increment ecx (our counter register)\n\n    jmp     .multiplyLoop   ; continue multiply loop\n\n\n\n.finished:\n\n    cmp     ecx, 0          ; compare ecx register's value against decimal 0 (our counter register)\n\n    je      .restore        ; jump if equal to 0 (no integer arguments were passed to atoi)\n\n    mov     ebx, 10         ; move decimal value 10 into ebx\n\n    div     ebx             ; divide eax by value in ebx (in this case 10)\n\n\n\n.restore:\n\n    pop     esi             ; restore esi from the value we pushed onto the stack at the start\n\n    pop     edx             ; restore edx from the value we pushed onto the stack at the start\n\n    pop     ecx             ; restore ecx from the value we pushed onto the stack at the start\n\n    pop     ebx             ; restore ebx from the value we pushed onto the stack at the start\n\n    ret\n\n\n\n\n\n;------------------------------------------\n\n; void iprint(Integer number)\n\n; Integer printing function (itoa)\n\niprint:\n\n    push    eax             ; preserve eax on the stack to be restored after function runs\n\n    push    ecx             ; preserve ecx on the stack to be restored after function runs\n\n    push    edx             ; preserve edx on the stack to be restored after function runs\n\n    push    esi             ; preserve esi on the stack to be restored after function runs\n\n    mov     ecx, 0          ; counter of how many bytes we need to print in the end\n\n\n\n.divideLoop:\n\n    inc     ecx             ; count each byte to print - number of characters\n\n    mov     edx, 0          ; empty edx\n\n    mov     esi, 10         ; mov 10 into esi\n\n    idiv    esi             ; divide eax by esi\n\n    add     edx, 48         ; convert edx to it's ascii representation - edx holds the remainder after a divide instruction\n\n    push    edx             ; push edx (string representation of an intger) onto the stack\n\n    cmp     eax, 0          ; can the integer be divided anymore?\n\n    jnz     .divideLoop     ; jump if not zero to the label divideLoop\n\n\n\n.printLoop:\n\n    dec     ecx             ; count down each byte that we put on the stack\n\n    mov     eax, esp        ; mov the stack pointer into eax for printing\n\n    call    sprint          ; call our string print function\n\n    pop     eax             ; remove last character from the stack to move esp forward\n\n    cmp     ecx, 0          ; have we printed all bytes we pushed onto the stack?\n\n    jnz     .printLoop      ; jump is not zero to the label printLoop\n\n\n\n    pop     esi             ; restore esi from the value we pushed onto the stack at the start\n\n    pop     edx             ; restore edx from the value we pushed onto the stack at the start\n\n    pop     ecx             ; restore ecx from the value we pushed onto the stack at the start\n\n    pop     eax             ; restore eax from the value we pushed onto the stack at the start\n\n    ret\n\n\n\n\n\n;------------------------------------------\n\n; void iprintLF(Integer number)\n\n; Integer printing function with linefeed (itoa)\n\niprintLF:\n\n    call    iprint          ; call our integer printing function\n\n\n\n    push    eax             ; push eax onto the stack to preserve it while we use the eax register in this function\n\n    mov     eax, 0Ah        ; move 0Ah into eax - 0Ah is the ascii character for a linefeed\n\n    push    eax             ; push the linefeed onto the stack so we can get the address\n\n    mov     eax, esp        ; move the address of the current stack pointer into eax for sprint\n\n    call    sprint          ; call our sprint function\n\n    pop     eax             ; remove our linefeed character from the stack\n\n    pop     eax             ; restore the original value of eax before our function was called\n\n    ret\n\n\n\n\n\n;------------------------------------------\n\n; int slen(String message)\n\n; String length calculation function\n\nslen:\n\n    push    ebx\n\n    mov     ebx, eax\n\n\n\n.nextchar:\n\n    cmp     byte [eax], 0\n\n    jz      .finished\n\n    inc     eax\n\n    jmp     .nextchar\n\n\n\n.finished:\n\n    sub     eax, ebx\n\n    pop     ebx\n\n    ret\n\n\n\n\n\n;------------------------------------------\n\n; void sprint(String message)\n\n; String printing function\n\nsprint:\n\n    push    edx\n\n    push    ecx\n\n    push    ebx\n\n    push    eax\n\n    call    slen\n\n\n\n    mov     edx, eax\n\n    pop     eax\n\n\n\n    mov     ecx, eax\n\n    mov     ebx, 1\n\n    mov     eax, 4\n\n    int     80h\n\n\n\n    pop     ebx\n\n    pop     ecx\n\n    pop     edx\n\n    ret\n\n\n\n\n\n;------------------------------------------\n\n; void sprintLF(String message)\n\n; String printing with line feed function\n\nsprintLF:\n\n    call    sprint\n\n\n\n    push    eax\n\n    mov     eax, 0AH\n\n    push    eax\n\n    mov     eax, esp\n\n    call    sprint\n\n    pop     eax\n\n    pop     eax\n\n    ret\n\n\n\n\n\n;------------------------------------------\n\n; void exit()\n\n; Exit program and restore resources\n\nquit:\n\n    mov     ebx, 0\n\n    mov     eax, 1\n\n    int     80h\n\n    ret\n\n\n", ";------------------------------------------\n\n; int atoi(Integer number)\n\n; Ascii to integer function (atoi)\n\natoi:\n\n    push    ebx             ; preserve ebx on the stack to be restored after function runs\n\n    push    ecx             ; preserve ecx on the stack to be restored after function runs\n\n    push    edx             ; preserve edx on the stack to be restored after function runs\n\n    push    esi             ; preserve esi on the stack to be restored after function runs\n\n    mov     esi, eax        ; move pointer in eax into esi (our number to convert)\n\n    mov     eax, 0          ; initialise eax with decimal value 0\n\n    mov     ecx, 0          ; initialise ecx with decimal value 0\n\n\n\n.multiplyLoop:\n\n    xor     ebx, ebx        ; resets both lower and uppper bytes of ebx to be 0\n\n    mov     bl, [esi+ecx]   ; move a single byte into ebx register's lower half\n\n    cmp     bl, 48          ; compare ebx register's lower half value against ascii value 48 (char value 0)\n\n    jl      .finished       ; jump if less than to label finished\n\n    cmp     bl, 57          ; compare ebx register's lower half value against ascii value 57 (char value 9)\n\n    jg      .finished       ; jump if greater than to label finished\n\n\n\n    sub     bl, 48          ; convert ebx register's lower half to decimal representation of ascii value\n\n    add     eax, ebx        ; add ebx to our interger value in eax\n\n    mov     ebx, 10         ; move decimal value 10 into ebx\n\n    mul     ebx             ; multiply eax by ebx to get place value\n\n    inc     ecx             ; increment ecx (our counter register)\n\n    jmp     .multiplyLoop   ; continue multiply loop\n\n\n\n.finished:\n\n    cmp     ecx, 0          ; compare ecx register's value against decimal 0 (our counter register)\n\n    je      .restore        ; jump if equal to 0 (no integer arguments were passed to atoi)\n\n    mov     ebx, 10         ; move decimal value 10 into ebx\n\n    div     ebx             ; divide eax by value in ebx (in this case 10)\n\n\n\n.restore:\n\n    pop     esi             ; restore esi from the value we pushed onto the stack at the start\n\n    pop     edx             ; restore edx from the value we pushed onto the stack at the start\n\n    pop     ecx             ; restore ecx from the value we pushed onto the stack at the start\n\n    pop     ebx             ; restore ebx from the value we pushed onto the stack at the start\n\n    ret\n\n\n\n\n\n;------------------------------------------\n\n; void iprint(Integer number)\n\n; Integer printing function (itoa)\n\niprint:\n\n    push    eax             ; preserve eax on the stack to be restored after function runs\n\n    push    ecx             ; preserve ecx on the stack to be restored after function runs\n\n    push    edx             ; preserve edx on the stack to be restored after function runs\n\n    push    esi             ; preserve esi on the stack to be restored after function runs\n\n    mov     ecx, 0          ; counter of how many bytes we need to print in the end\n\n\n\n.divideLoop:\n\n    inc     ecx             ; count each byte to print - number of characters\n\n    mov     edx, 0          ; empty edx\n\n    mov     esi, 10         ; mov 10 into esi\n\n    idiv    esi             ; divide eax by esi\n\n    add     edx, 48         ; convert edx to it's ascii representation - edx holds the remainder after a divide instruction\n\n    push    edx             ; push edx (string representation of an intger) onto the stack\n\n    cmp     eax, 0          ; can the integer be divided anymore?\n\n    jnz     .divideLoop      ; jump if not zero to the label divideLoop\n\n\n\n.printLoop:\n\n    dec     ecx             ; count down each byte that we put on the stack\n\n    mov     eax, esp        ; mov the stack pointer into eax for printing\n\n    call    sprint          ; call our string print function\n\n    pop     eax             ; remove last character from the stack to move esp forward\n\n    cmp     ecx, 0          ; have we printed all bytes we pushed onto the stack?\n\n    jnz     .printLoop       ; jump is not zero to the label printLoop\n\n\n\n    pop     esi             ; restore esi from the value we pushed onto the stack at the start\n\n    pop     edx             ; restore edx from the value we pushed onto the stack at the start\n\n    pop     ecx             ; restore ecx from the value we pushed onto the stack at the start\n\n    pop     eax             ; restore eax from the value we pushed onto the stack at the start\n\n    ret\n\n\n\n\n\n;------------------------------------------\n\n; void iprintLF(Integer number)\n\n; Integer printing function with linefeed (itoa)\n\niprintLF:\n\n    call    iprint          ; call our integer printing function\n\n\n\n    push    eax             ; push eax onto the stack to preserve it while we use the eax register in this function\n\n    mov     eax, 0Ah        ; move 0Ah into eax - 0Ah is the ascii character for a linefeed\n\n    push    eax             ; push the linefeed onto the stack so we can get the address\n\n    mov     eax, esp        ; move the address of the current stack pointer into eax for sprint\n\n    call    sprint          ; call our sprint function\n\n    pop     eax             ; remove our linefeed character from the stack\n\n    pop     eax             ; restore the original value of eax before our function was called\n\n    ret\n\n\n\n\n\n;------------------------------------------\n\n; int slen(String message)\n\n; String length calculation function\n\nslen:\n\n    push    ebx\n\n    mov     ebx, eax\n\n\n\n.nextchar:\n\n    cmp     byte [eax], 0\n\n    jz      .finished\n\n    inc     eax\n\n    jmp     .nextchar\n\n\n\n.finished:\n\n    sub     eax, ebx\n\n    pop     ebx\n\n    ret\n\n\n\n\n\n;------------------------------------------\n\n; void sprint(String message)\n\n; String printing function\n\nsprint:\n\n    push    edx\n\n    push    ecx\n\n    push    ebx\n\n    push    eax\n\n    call    slen\n\n\n\n    mov     edx, eax\n\n    pop     eax\n\n\n\n    mov     ecx, eax\n\n    mov     ebx, 1\n\n    mov     eax, 4\n\n    int     80h\n\n\n\n    pop     ebx\n\n    pop     ecx\n\n    pop     edx\n\n    ret\n\n\n\n\n\n;------------------------------------------\n\n; void sprintLF(String message)\n\n; String printing with line feed function\n\nsprintLF:\n\n    call    sprint\n\n\n\n    push    eax\n\n    mov     eax, 0AH\n\n    push    eax\n\n    mov     eax, esp\n\n    call    sprint\n\n    pop     eax\n\n    pop     eax\n\n    ret\n\n\n\n\n\n;------------------------------------------\n\n; void exit()\n\n; Exit program and restore resources\n\nquit:\n\n    mov     ebx, 0\n\n    mov     eax, 1\n\n    int     80h\n\n    ret\n\n\n", "; Namespace\n\n; Compile with: nasm -f elf namespace.asm\n\n; Link with (64 bit systems require elf_i386 option): ld -m elf_i386 namespace.o -o namespace\n\n; Run with: ./namespace\n\n\n\n%include        'functions.asm'\n\n\n\nSECTION .data\n\nmsg1        db      'Jumping to finished label.', 0h        ; a message string\n\nmsg2        db      'Inside subroutine number: ', 0h        ; a message string\n\nmsg3        db      'Inside subroutine \"finished\".', 0h     ; a message string\n\n\n\nSECTION .text\n\nglobal  _start\n\n\n\n_start:\n\n\n\nsubrountineOne:\n\n    mov     eax, msg1       ; move the address of msg1 into eax\n\n    call    sprintLF        ; call our string printing with linefeed function\n\n    jmp     .finished       ; jump to the local label under the subrountineOne scope\n\n\n\n.finished:\n\n    mov     eax, msg2       ; move the address of msg2 into eax\n\n    call    sprint          ; call our string printing function\n\n    mov     eax, 1          ; move the value one into eax (for subroutine number one)\n\n    call    iprintLF        ; call our integer printing function with linefeed function\n\n\n\nsubrountineTwo:\n\n    mov     eax, msg1       ; move the address of msg1 into eax\n\n    call    sprintLF        ; call our string print with linefeed function\n\n    jmp     .finished       ; jump to the local label under the subrountineTwo scope\n\n\n\n.finished:\n\n    mov     eax, msg2       ; move the address of msg2 into eax\n\n    call    sprint          ; call our string printing function\n\n    mov     eax, 2          ; move the value two into eax (for subroutine number two)\n\n    call    iprintLF        ; call our integer printing function with linefeed function\n\n\n\n    mov     eax, msg1       ; move the address of msg1 into eax\n\n    call    sprintLF        ; call our string printing with linefeed function\n\n    jmp     finished        ; jump to the global label finished\n\n\n\nfinished:\n\n    mov     eax, msg3       ; move the address of msg3 into eax\n\n    call    sprintLF        ; call our string printing with linefeed function\n\n    call    quit            ; call our quit function", "; Hello World Program (Calculating string length)\n\n; Compile with: nasm -f elf helloworld-len.asm\n\n; Link with (64 bit systems require elf_i386 option): ld -m elf_i386 helloworld-len.o -o helloworld-len\n\n; Run with: ./helloworld-len\n\n\n\nSECTION .data\n\nmsg     db      'Hello, brave new world!', 0Ah ; we can modify this now without having to update anywhere else in the program\n\n\n\nSECTION .text\n\nglobal  _start\n\n    \n\n_start: \n\n\n\n    mov     ebx, msg        ; move the address of our message string into EBX\n\n    mov     eax, ebx        ; move the address in EBX into EAX as well (Both now point to the same segment in memory)\n\n    \n\nnextchar:\n\n    cmp     byte [eax], 0   ; compare the byte pointed to by EAX at this address against zero (Zero is an end of string delimiter)\n\n    jz      finished        ; jump (if the zero flagged has been set) to the point in the code labeled 'finished'\n\n    inc     eax             ; increment the address in EAX by one byte (if the zero flagged has NOT been set)\n\n    jmp     nextchar        ; jump to the point in the code labeled 'loop'\n\n    \n\nfinished:\n\n    sub     eax, ebx        ; subtract the address in EBX from the address in EAX\n\n                            ; remember both registers started pointing to the same address (see line 15)\n\n                            ; but EAX has been incremented one byte for each character in the message string\n\n                            ; when you subtract one memory address from another of the same type\n\n                            ; the result is number of segments between them - in this case the number of bytes\n\n    \n\n    mov     edx, eax        ; EAX now equals the number of bytes in our string\n\n    mov     ecx, msg        ; the rest of the code should be familiar now\n\n    mov     ebx, 1\n\n    mov     eax, 4\n\n    int     80h\n\n\n\n    mov     ebx, 0      \n\n    mov     eax, 1      \n\n    int     80h", "; Unlink\n\n; Compile with: nasm -f elf unlink.asm\n\n; Link with (64 bit systems require elf_i386 option): ld -m elf_i386 unlink.o -o unlink\n\n; Run with: ./unlink\n\n\n\n%include    'functions.asm'\n\n\n\nSECTION .data\n\nfilename db 'readme.txt', 0h    ; the filename to delete\n\n\n\nSECTION .text\n\nglobal  _start\n\n\n\n_start:\n\n\n\n    mov     ebx, filename       ; filename we will delete\n\n    mov     eax, 10             ; invoke SYS_UNLINK (kernel opcode 10)\n\n    int     80h                 ; call the kernel\n\n\n\n    call    quit                ; call our quit function\n", ";------------------------------------------\n\n; int atoi(Integer number)\n\n; Ascii to integer function (atoi)\n\natoi:\n\n    push    ebx             ; preserve ebx on the stack to be restored after function runs\n\n    push    ecx             ; preserve ecx on the stack to be restored after function runs\n\n    push    edx             ; preserve edx on the stack to be restored after function runs\n\n    push    esi             ; preserve esi on the stack to be restored after function runs\n\n    mov     esi, eax        ; move pointer in eax into esi (our number to convert)\n\n    mov     eax, 0          ; initialise eax with decimal value 0\n\n    mov     ecx, 0          ; initialise ecx with decimal value 0\n\n\n\n.multiplyLoop:\n\n    xor     ebx, ebx        ; resets both lower and uppper bytes of ebx to be 0\n\n    mov     bl, [esi+ecx]   ; move a single byte into ebx register's lower half\n\n    cmp     bl, 48          ; compare ebx register's lower half value against ascii value 48 (char value 0)\n\n    jl      .finished       ; jump if less than to label finished\n\n    cmp     bl, 57          ; compare ebx register's lower half value against ascii value 57 (char value 9)\n\n    jg      .finished       ; jump if greater than to label finished\n\n\n\n    sub     bl, 48          ; convert ebx register's lower half to decimal representation of ascii value\n\n    add     eax, ebx        ; add ebx to our interger value in eax\n\n    mov     ebx, 10         ; move decimal value 10 into ebx\n\n    mul     ebx             ; multiply eax by ebx to get place value\n\n    inc     ecx             ; increment ecx (our counter register)\n\n    jmp     .multiplyLoop   ; continue multiply loop\n\n\n\n.finished:\n\n    cmp     ecx, 0          ; compare ecx register's value against decimal 0 (our counter register)\n\n    je      .restore        ; jump if equal to 0 (no integer arguments were passed to atoi)\n\n    mov     ebx, 10         ; move decimal value 10 into ebx\n\n    div     ebx             ; divide eax by value in ebx (in this case 10)\n\n\n\n.restore:\n\n    pop     esi             ; restore esi from the value we pushed onto the stack at the start\n\n    pop     edx             ; restore edx from the value we pushed onto the stack at the start\n\n    pop     ecx             ; restore ecx from the value we pushed onto the stack at the start\n\n    pop     ebx             ; restore ebx from the value we pushed onto the stack at the start\n\n    ret\n\n\n\n\n\n;------------------------------------------\n\n; void iprint(Integer number)\n\n; Integer printing function (itoa)\n\niprint:\n\n    push    eax             ; preserve eax on the stack to be restored after function runs\n\n    push    ecx             ; preserve ecx on the stack to be restored after function runs\n\n    push    edx             ; preserve edx on the stack to be restored after function runs\n\n    push    esi             ; preserve esi on the stack to be restored after function runs\n\n    mov     ecx, 0          ; counter of how many bytes we need to print in the end\n\n\n\n.divideLoop:\n\n    inc     ecx             ; count each byte to print - number of characters\n\n    mov     edx, 0          ; empty edx\n\n    mov     esi, 10         ; mov 10 into esi\n\n    idiv    esi             ; divide eax by esi\n\n    add     edx, 48         ; convert edx to it's ascii representation - edx holds the remainder after a divide instruction\n\n    push    edx             ; push edx (string representation of an intger) onto the stack\n\n    cmp     eax, 0          ; can the integer be divided anymore?\n\n    jnz     .divideLoop     ; jump if not zero to the label divideLoop\n\n\n\n.printLoop:\n\n    dec     ecx             ; count down each byte that we put on the stack\n\n    mov     eax, esp        ; mov the stack pointer into eax for printing\n\n    call    sprint          ; call our string print function\n\n    pop     eax             ; remove last character from the stack to move esp forward\n\n    cmp     ecx, 0          ; have we printed all bytes we pushed onto the stack?\n\n    jnz     .printLoop      ; jump is not zero to the label printLoop\n\n\n\n    pop     esi             ; restore esi from the value we pushed onto the stack at the start\n\n    pop     edx             ; restore edx from the value we pushed onto the stack at the start\n\n    pop     ecx             ; restore ecx from the value we pushed onto the stack at the start\n\n    pop     eax             ; restore eax from the value we pushed onto the stack at the start\n\n    ret\n\n\n\n\n\n;------------------------------------------\n\n; void iprintLF(Integer number)\n\n; Integer printing function with linefeed (itoa)\n\niprintLF:\n\n    call    iprint          ; call our integer printing function\n\n\n\n    push    eax             ; push eax onto the stack to preserve it while we use the eax register in this function\n\n    mov     eax, 0Ah        ; move 0Ah into eax - 0Ah is the ascii character for a linefeed\n\n    push    eax             ; push the linefeed onto the stack so we can get the address\n\n    mov     eax, esp        ; move the address of the current stack pointer into eax for sprint\n\n    call    sprint          ; call our sprint function\n\n    pop     eax             ; remove our linefeed character from the stack\n\n    pop     eax             ; restore the original value of eax before our function was called\n\n    ret\n\n\n\n\n\n;------------------------------------------\n\n; int slen(String message)\n\n; String length calculation function\n\nslen:\n\n    push    ebx\n\n    mov     ebx, eax\n\n\n\n.nextchar:\n\n    cmp     byte [eax], 0\n\n    jz      .finished\n\n    inc     eax\n\n    jmp     .nextchar\n\n\n\n.finished:\n\n    sub     eax, ebx\n\n    pop     ebx\n\n    ret\n\n\n\n\n\n;------------------------------------------\n\n; void sprint(String message)\n\n; String printing function\n\nsprint:\n\n    push    edx\n\n    push    ecx\n\n    push    ebx\n\n    push    eax\n\n    call    slen\n\n\n\n    mov     edx, eax\n\n    pop     eax\n\n\n\n    mov     ecx, eax\n\n    mov     ebx, 1\n\n    mov     eax, 4\n\n    int     80h\n\n\n\n    pop     ebx\n\n    pop     ecx\n\n    pop     edx\n\n    ret\n\n\n\n\n\n;------------------------------------------\n\n; void sprintLF(String message)\n\n; String printing with line feed function\n\nsprintLF:\n\n    call    sprint\n\n\n\n    push    eax\n\n    mov     eax, 0AH\n\n    push    eax\n\n    mov     eax, esp\n\n    call    sprint\n\n    pop     eax\n\n    pop     eax\n\n    ret\n\n\n\n\n\n;------------------------------------------\n\n; void exit()\n\n; Exit program and restore resources\n\nquit:\n\n    mov     ebx, 0\n\n    mov     eax, 1\n\n    int     80h\n\n    ret\n\n\n", ";------------------------------------------\n\n; int atoi(Integer number)\n\n; Ascii to integer function (atoi)\n\natoi:\n\n    push    ebx             ; preserve ebx on the stack to be restored after function runs\n\n    push    ecx             ; preserve ecx on the stack to be restored after function runs\n\n    push    edx             ; preserve edx on the stack to be restored after function runs\n\n    push    esi             ; preserve esi on the stack to be restored after function runs\n\n    mov     esi, eax        ; move pointer in eax into esi (our number to convert)\n\n    mov     eax, 0          ; initialise eax with decimal value 0\n\n    mov     ecx, 0          ; initialise ecx with decimal value 0\n\n\n\n.multiplyLoop:\n\n    xor     ebx, ebx        ; resets both lower and uppper bytes of ebx to be 0\n\n    mov     bl, [esi+ecx]   ; move a single byte into ebx register's lower half\n\n    cmp     bl, 48          ; compare ebx register's lower half value against ascii value 48 (char value 0)\n\n    jl      .finished       ; jump if less than to label finished\n\n    cmp     bl, 57          ; compare ebx register's lower half value against ascii value 57 (char value 9)\n\n    jg      .finished       ; jump if greater than to label finished\n\n\n\n    sub     bl, 48          ; convert ebx register's lower half to decimal representation of ascii value\n\n    add     eax, ebx        ; add ebx to our interger value in eax\n\n    mov     ebx, 10         ; move decimal value 10 into ebx\n\n    mul     ebx             ; multiply eax by ebx to get place value\n\n    inc     ecx             ; increment ecx (our counter register)\n\n    jmp     .multiplyLoop   ; continue multiply loop\n\n\n\n.finished:\n\n    cmp     ecx, 0          ; compare ecx register's value against decimal 0 (our counter register)\n\n    je      .restore        ; jump if equal to 0 (no integer arguments were passed to atoi)\n\n    mov     ebx, 10         ; move decimal value 10 into ebx\n\n    div     ebx             ; divide eax by value in ebx (in this case 10)\n\n\n\n.restore:\n\n    pop     esi             ; restore esi from the value we pushed onto the stack at the start\n\n    pop     edx             ; restore edx from the value we pushed onto the stack at the start\n\n    pop     ecx             ; restore ecx from the value we pushed onto the stack at the start\n\n    pop     ebx             ; restore ebx from the value we pushed onto the stack at the start\n\n    ret\n\n\n\n\n\n;------------------------------------------\n\n; void iprint(Integer number)\n\n; Integer printing function (itoa)\n\niprint:\n\n    push    eax             ; preserve eax on the stack to be restored after function runs\n\n    push    ecx             ; preserve ecx on the stack to be restored after function runs\n\n    push    edx             ; preserve edx on the stack to be restored after function runs\n\n    push    esi             ; preserve esi on the stack to be restored after function runs\n\n    mov     ecx, 0          ; counter of how many bytes we need to print in the end\n\n\n\n.divideLoop:\n\n    inc     ecx             ; count each byte to print - number of characters\n\n    mov     edx, 0          ; empty edx\n\n    mov     esi, 10         ; mov 10 into esi\n\n    idiv    esi             ; divide eax by esi\n\n    add     edx, 48         ; convert edx to it's ascii representation - edx holds the remainder after a divide instruction\n\n    push    edx             ; push edx (string representation of an intger) onto the stack\n\n    cmp     eax, 0          ; can the integer be divided anymore?\n\n    jnz     .divideLoop     ; jump if not zero to the label divideLoop\n\n\n\n.printLoop:\n\n    dec     ecx             ; count down each byte that we put on the stack\n\n    mov     eax, esp        ; mov the stack pointer into eax for printing\n\n    call    sprint          ; call our string print function\n\n    pop     eax             ; remove last character from the stack to move esp forward\n\n    cmp     ecx, 0          ; have we printed all bytes we pushed onto the stack?\n\n    jnz     .printLoop      ; jump is not zero to the label printLoop\n\n\n\n    pop     esi             ; restore esi from the value we pushed onto the stack at the start\n\n    pop     edx             ; restore edx from the value we pushed onto the stack at the start\n\n    pop     ecx             ; restore ecx from the value we pushed onto the stack at the start\n\n    pop     eax             ; restore eax from the value we pushed onto the stack at the start\n\n    ret\n\n\n\n\n\n;------------------------------------------\n\n; void iprintLF(Integer number)\n\n; Integer printing function with linefeed (itoa)\n\niprintLF:\n\n    call    iprint          ; call our integer printing function\n\n\n\n    push    eax             ; push eax onto the stack to preserve it while we use the eax register in this function\n\n    mov     eax, 0Ah        ; move 0Ah into eax - 0Ah is the ascii character for a linefeed\n\n    push    eax             ; push the linefeed onto the stack so we can get the address\n\n    mov     eax, esp        ; move the address of the current stack pointer into eax for sprint\n\n    call    sprint          ; call our sprint function\n\n    pop     eax             ; remove our linefeed character from the stack\n\n    pop     eax             ; restore the original value of eax before our function was called\n\n    ret\n\n\n\n\n\n;------------------------------------------\n\n; int slen(String message)\n\n; String length calculation function\n\nslen:\n\n    push    ebx\n\n    mov     ebx, eax\n\n\n\n.nextchar:\n\n    cmp     byte [eax], 0\n\n    jz      .finished\n\n    inc     eax\n\n    jmp     .nextchar\n\n\n\n.finished:\n\n    sub     eax, ebx\n\n    pop     ebx\n\n    ret\n\n\n\n\n\n;------------------------------------------\n\n; void sprint(String message)\n\n; String printing function\n\nsprint:\n\n    push    edx\n\n    push    ecx\n\n    push    ebx\n\n    push    eax\n\n    call    slen\n\n\n\n    mov     edx, eax\n\n    pop     eax\n\n\n\n    mov     ecx, eax\n\n    mov     ebx, 1\n\n    mov     eax, 4\n\n    int     80h\n\n\n\n    pop     ebx\n\n    pop     ecx\n\n    pop     edx\n\n    ret\n\n\n\n\n\n;------------------------------------------\n\n; void sprintLF(String message)\n\n; String printing with line feed function\n\nsprintLF:\n\n    call    sprint\n\n\n\n    push    eax\n\n    mov     eax, 0AH\n\n    push    eax\n\n    mov     eax, esp\n\n    call    sprint\n\n    pop     eax\n\n    pop     eax\n\n    ret\n\n\n\n\n\n;------------------------------------------\n\n; void exit()\n\n; Exit program and restore resources\n\nquit:\n\n    mov     ebx, 0\n\n    mov     eax, 1\n\n    int     80h\n\n    ret\n\n\n", "; Time\n\n; Compile with: nasm -f elf time.asm\n\n; Link with (64 bit systems require elf_i386 option): ld -m elf_i386 time.o -o time\n\n; Run with: ./time\n\n\n\n%include        'functions.asm'\n\n\n\nSECTION .data\n\nmsg        db      'Seconds since Jan 01 1970: ', 0h     ; a message string\n\n\n\nSECTION .text\n\nglobal  _start\n\n\n\n_start:\n\n\n\n    mov     eax, msg        ; move our message string into eax for printing\n\n    call    sprint          ; call our string printing function\n\n\n\n    mov     eax, 13         ; invoke SYS_TIME (kernel opcode 13)\n\n    int     80h             ; call the kernel\n\n\n\n    call    iprintLF        ; call our integer printing function with linefeed\n\n    call    quit            ; call our quit function", ";------------------------------------------\n\n; void iprint(Integer number)\n\n; Integer printing function (itoa)\n\niprint:\n\n    push    eax             ; preserve eax on the stack to be restored after function runs\n\n    push    ecx             ; preserve ecx on the stack to be restored after function runs\n\n    push    edx             ; preserve edx on the stack to be restored after function runs\n\n    push    esi             ; preserve esi on the stack to be restored after function runs\n\n    mov     ecx, 0          ; counter of how many bytes we need to print in the end\n\n    \n\ndivideLoop:\n\n    inc     ecx             ; count each byte to print - number of characters\n\n    mov     edx, 0          ; empty edx\n\n    mov     esi, 10         ; mov 10 into esi\n\n    idiv    esi             ; divide eax by esi\n\n    add     edx, 48         ; convert edx to it's ascii representation - edx holds the remainder after a divide instruction\n\n    push    edx             ; push edx (string representation of an intger) onto the stack\n\n    cmp     eax, 0          ; can the integer be divided anymore?\n\n    jnz     divideLoop      ; jump if not zero to the label divideLoop\n\n\n\nprintLoop:\n\n    dec     ecx             ; count down each byte that we put on the stack\n\n    mov     eax, esp        ; mov the stack pointer into eax for printing\n\n    call    sprint          ; call our string print function\n\n    pop     eax             ; remove last character from the stack to move esp forward\n\n    cmp     ecx, 0          ; have we printed all bytes we pushed onto the stack?\n\n    jnz     printLoop       ; jump is not zero to the label printLoop\n\n\n\n    pop     esi             ; restore esi from the value we pushed onto the stack at the start\n\n    pop     edx             ; restore edx from the value we pushed onto the stack at the start\n\n    pop     ecx             ; restore ecx from the value we pushed onto the stack at the start\n\n    pop     eax             ; restore eax from the value we pushed onto the stack at the start\n\n    ret\n\n\n\n\n\n;------------------------------------------\n\n; void iprintLF(Integer number)\n\n; Integer printing function with linefeed (itoa)\n\niprintLF:\n\n    call    iprint          ; call our integer printing function\n\n\n\n    push    eax             ; push eax onto the stack to preserve it while we use the eax register in this function\n\n    mov     eax, 0Ah        ; move 0Ah into eax - 0Ah is the ascii character for a linefeed\n\n    push    eax             ; push the linefeed onto the stack so we can get the address\n\n    mov     eax, esp        ; move the address of the current stack pointer into eax for sprint\n\n    call    sprint          ; call our sprint function\n\n    pop     eax             ; remove our linefeed character from the stack\n\n    pop     eax             ; restore the original value of eax before our function was called\n\n    ret\n\n\n\n    \n\n;------------------------------------------\n\n; int slen(String message)\n\n; String length calculation function\n\nslen:                     \n\n    push    ebx             \n\n    mov     ebx, eax        \n\n    \n\nnextchar:                   \n\n    cmp     byte [eax], 0   \n\n    jz      finished        \n\n    inc     eax             \n\n    jmp     nextchar        \n\n    \n\nfinished:\n\n    sub     eax, ebx\n\n    pop     ebx             \n\n    ret                     \n\n\n\n\n\n;------------------------------------------\n\n; void sprint(String message)\n\n; String printing function\n\nsprint:\n\n    push    edx\n\n    push    ecx\n\n    push    ebx\n\n    push    eax\n\n    call    slen\n\n    \n\n    mov     edx, eax\n\n    pop     eax\n\n    \n\n    mov     ecx, eax\n\n    mov     ebx, 1\n\n    mov     eax, 4\n\n    int     80h\n\n\n\n    pop     ebx\n\n    pop     ecx\n\n    pop     edx\n\n    ret\n\n\n\n\n\n;------------------------------------------\n\n; void sprintLF(String message)\n\n; String printing with line feed function\n\nsprintLF:\n\n    call    sprint\n\n\n\n    push    eax\n\n    mov     eax, 0AH\n\n    push    eax\n\n    mov     eax, esp\n\n    call    sprint\n\n    pop     eax\n\n    pop     eax\n\n    ret\n\n\n\n    \n\n;------------------------------------------\n\n; void exit()\n\n; Exit program and restore resources\n\nquit:\n\n    mov     ebx, 0      \n\n    mov     eax, 1      \n\n    int     80h\n\n    ret\n\n\n", "; Calculator (Addition)\n\n; Compile with: nasm -f elf calculator-addition.asm\n\n; Link with (64 bit systems require elf_i386 option): ld -m elf_i386 calculator-addition.o -o calculator-addition\n\n; Run with: ./calculator-addition\n\n\n\n%include        'functions.asm'\n\n\n\nSECTION .text\n\nglobal  _start\n\n\n\n_start:\n\n\n\n    mov     eax, 90     ; move our first number into eax\n\n    mov     ebx, 9      ; move our second number into ebx\n\n    add     eax, ebx    ; add ebx to eax\n\n    call    iprintLF    ; call our integer print with linefeed function\n\n\n\n    call    quit", "; Hello World Program - asmtutor.com\n\n; Compile with: nasm -f elf helloworld.asm\n\n; Link with (64 bit systems require elf_i386 option): ld -m elf_i386 helloworld.o -o helloworld\n\n; Run with: ./helloworld\n\n\n\nSECTION .data\n\nmsg     db      'Hello World!', 0Ah     ; assign msg variable with your message string\n\n\n\nSECTION .text\n\nglobal  _start\n\n\n\n_start: \n\n\n\n    mov     edx, 13     ; number of bytes to write - one for each letter plus 0Ah (line feed character)\n\n    mov     ecx, msg    ; move the memory address of our message string into ecx\n\n    mov     ebx, 1      ; write to the STDOUT file\n\n    mov     eax, 4      ; invoke SYS_WRITE (kernel opcode 4)\n\n    int     80h", ";------------------------------------------\n\n; int atoi(Integer number)\n\n; Ascii to integer function (atoi)\n\natoi:\n\n    push    ebx             ; preserve ebx on the stack to be restored after function runs\n\n    push    ecx             ; preserve ecx on the stack to be restored after function runs\n\n    push    edx             ; preserve edx on the stack to be restored after function runs\n\n    push    esi             ; preserve esi on the stack to be restored after function runs\n\n    mov     esi, eax        ; move pointer in eax into esi (our number to convert)\n\n    mov     eax, 0          ; initialise eax with decimal value 0\n\n    mov     ecx, 0          ; initialise ecx with decimal value 0\n\n\n\n.multiplyLoop:\n\n    xor     ebx, ebx        ; resets both lower and uppper bytes of ebx to be 0\n\n    mov     bl, [esi+ecx]   ; move a single byte into ebx register's lower half\n\n    cmp     bl, 48          ; compare ebx register's lower half value against ascii value 48 (char value 0)\n\n    jl      .finished       ; jump if less than to label finished\n\n    cmp     bl, 57          ; compare ebx register's lower half value against ascii value 57 (char value 9)\n\n    jg      .finished       ; jump if greater than to label finished\n\n\n\n    sub     bl, 48          ; convert ebx register's lower half to decimal representation of ascii value\n\n    add     eax, ebx        ; add ebx to our interger value in eax\n\n    mov     ebx, 10         ; move decimal value 10 into ebx\n\n    mul     ebx             ; multiply eax by ebx to get place value\n\n    inc     ecx             ; increment ecx (our counter register)\n\n    jmp     .multiplyLoop   ; continue multiply loop\n\n\n\n.finished:\n\n    cmp     ecx, 0          ; compare ecx register's value against decimal 0 (our counter register)\n\n    je      .restore        ; jump if equal to 0 (no integer arguments were passed to atoi)\n\n    mov     ebx, 10         ; move decimal value 10 into ebx\n\n    div     ebx             ; divide eax by value in ebx (in this case 10)\n\n\n\n.restore:\n\n    pop     esi             ; restore esi from the value we pushed onto the stack at the start\n\n    pop     edx             ; restore edx from the value we pushed onto the stack at the start\n\n    pop     ecx             ; restore ecx from the value we pushed onto the stack at the start\n\n    pop     ebx             ; restore ebx from the value we pushed onto the stack at the start\n\n    ret\n\n\n\n\n\n;------------------------------------------\n\n; void iprint(Integer number)\n\n; Integer printing function (itoa)\n\niprint:\n\n    push    eax             ; preserve eax on the stack to be restored after function runs\n\n    push    ecx             ; preserve ecx on the stack to be restored after function runs\n\n    push    edx             ; preserve edx on the stack to be restored after function runs\n\n    push    esi             ; preserve esi on the stack to be restored after function runs\n\n    mov     ecx, 0          ; counter of how many bytes we need to print in the end\n\n\n\n.divideLoop:\n\n    inc     ecx             ; count each byte to print - number of characters\n\n    mov     edx, 0          ; empty edx\n\n    mov     esi, 10         ; mov 10 into esi\n\n    idiv    esi             ; divide eax by esi\n\n    add     edx, 48         ; convert edx to it's ascii representation - edx holds the remainder after a divide instruction\n\n    push    edx             ; push edx (string representation of an intger) onto the stack\n\n    cmp     eax, 0          ; can the integer be divided anymore?\n\n    jnz     .divideLoop     ; jump if not zero to the label divideLoop\n\n\n\n.printLoop:\n\n    dec     ecx             ; count down each byte that we put on the stack\n\n    mov     eax, esp        ; mov the stack pointer into eax for printing\n\n    call    sprint          ; call our string print function\n\n    pop     eax             ; remove last character from the stack to move esp forward\n\n    cmp     ecx, 0          ; have we printed all bytes we pushed onto the stack?\n\n    jnz     .printLoop      ; jump is not zero to the label printLoop\n\n\n\n    pop     esi             ; restore esi from the value we pushed onto the stack at the start\n\n    pop     edx             ; restore edx from the value we pushed onto the stack at the start\n\n    pop     ecx             ; restore ecx from the value we pushed onto the stack at the start\n\n    pop     eax             ; restore eax from the value we pushed onto the stack at the start\n\n    ret\n\n\n\n\n\n;------------------------------------------\n\n; void iprintLF(Integer number)\n\n; Integer printing function with linefeed (itoa)\n\niprintLF:\n\n    call    iprint          ; call our integer printing function\n\n\n\n    push    eax             ; push eax onto the stack to preserve it while we use the eax register in this function\n\n    mov     eax, 0Ah        ; move 0Ah into eax - 0Ah is the ascii character for a linefeed\n\n    push    eax             ; push the linefeed onto the stack so we can get the address\n\n    mov     eax, esp        ; move the address of the current stack pointer into eax for sprint\n\n    call    sprint          ; call our sprint function\n\n    pop     eax             ; remove our linefeed character from the stack\n\n    pop     eax             ; restore the original value of eax before our function was called\n\n    ret\n\n\n\n\n\n;------------------------------------------\n\n; int slen(String message)\n\n; String length calculation function\n\nslen:\n\n    push    ebx\n\n    mov     ebx, eax\n\n\n\n.nextchar:\n\n    cmp     byte [eax], 0\n\n    jz      .finished\n\n    inc     eax\n\n    jmp     .nextchar\n\n\n\n.finished:\n\n    sub     eax, ebx\n\n    pop     ebx\n\n    ret\n\n\n\n\n\n;------------------------------------------\n\n; void sprint(String message)\n\n; String printing function\n\nsprint:\n\n    push    edx\n\n    push    ecx\n\n    push    ebx\n\n    push    eax\n\n    call    slen\n\n\n\n    mov     edx, eax\n\n    pop     eax\n\n\n\n    mov     ecx, eax\n\n    mov     ebx, 1\n\n    mov     eax, 4\n\n    int     80h\n\n\n\n    pop     ebx\n\n    pop     ecx\n\n    pop     edx\n\n    ret\n\n\n\n\n\n;------------------------------------------\n\n; void sprintLF(String message)\n\n; String printing with line feed function\n\nsprintLF:\n\n    call    sprint\n\n\n\n    push    eax\n\n    mov     eax, 0AH\n\n    push    eax\n\n    mov     eax, esp\n\n    call    sprint\n\n    pop     eax\n\n    pop     eax\n\n    ret\n\n\n\n\n\n;------------------------------------------\n\n; void exit()\n\n; Exit program and restore resources\n\nquit:\n\n    mov     ebx, 0\n\n    mov     eax, 1\n\n    int     80h\n\n    ret\n\n\n", "; Write\n\n; Compile with: nasm -f elf write.asm\n\n; Link with (64 bit systems require elf_i386 option): ld -m elf_i386 write.o -o write\n\n; Run with: ./write\n\n\n\n%include    'functions.asm'\n\n\n\nSECTION .data\n\nfilename db 'readme.txt', 0h    ; the filename to create\n\ncontents db 'Hello world!', 0h  ; the contents to write\n\n\n\nSECTION .text\n\nglobal  _start\n\n\n\n_start:\n\n\n\n    mov     ecx, 0777           ; code continues from lesson 22\n\n    mov     ebx, filename\n\n    mov     eax, 8\n\n    int     80h\n\n\n\n    mov     edx, 12             ; number of bytes to write - one for each letter of our contents string\n\n    mov     ecx, contents       ; move the memory address of our contents string into ecx\n\n    mov     ebx, eax            ; move the file descriptor of the file we created into ebx\n\n    mov     eax, 4              ; invoke SYS_WRITE (kernel opcode 4)\n\n    int     80h                 ; call the kernel\n\n\n\n    call    quit                ; call our quit function\n", "; Hello World Program (Subroutines)\n\n; Compile with: nasm -f elf helloworld-len.asm\n\n; Link with (64 bit systems require elf_i386 option): ld -m elf_i386 helloworld-len.o -o helloworld-len\n\n; Run with: ./helloworld-len\n\n\n\nSECTION .data\n\nmsg     db      'Hello, brave new world!', 0AH\n\n\n\nSECTION .text\n\nglobal  _start\n\n    \n\n_start: \n\n\n\n    mov     eax, msg        ; move the address of our message string into EAX\n\n    call    strlen          ; call our function to calculate the length of the string\n\n    \n\n    mov     edx, eax        ; our function leaves the result in EAX\n\n    mov     ecx, msg        ; this is all the same as before\n\n    mov     ebx, 1\n\n    mov     eax, 4\n\n    int     80h\n\n    \n\n    mov     ebx, 0      \n\n    mov     eax, 1      \n\n    int     80h\n\n\n\nstrlen:                     ; this is our first function declaration\n\n    push    ebx             ; push the value in EBX onto the stack to preserve it while we use EBX in this function\n\n    mov     ebx, eax        ; move the address in EAX into EBX (Both point to the same segment in memory)\n\n    \n\nnextchar:                   ; this is the same as lesson3\n\n    cmp     byte [eax], 0   \n\n    jz      finished        \n\n    inc     eax             \n\n    jmp     nextchar        \n\n    \n\nfinished:\n\n    sub     eax, ebx\n\n    pop     ebx             ; pop the value on the stack back into EBX\n\n    ret                     ; return to where the function was called", "; Crawler\n\n; Compile with: nasm -f elf crawler.asm\n\n; Link with (64 bit systems require elf_i386 option): ld -m elf_i386 crawler.o -o crawler\n\n; Run with: ./crawler\n\n\n\n%include    'functions.asm'\n\n\n\nSECTION .data\n\n; our request string\n\nrequest db 'GET / HTTP/1.1', 0Dh, 0Ah, 'Host: 139.162.39.66:80', 0Dh, 0Ah, 0Dh, 0Ah, 0h\n\n\n\nSECTION .bss\n\nbuffer resb 1,                  ; variable to store response\n\n\n\nSECTION .text\n\nglobal  _start\n\n\n\n_start:\n\n\n\n    xor     eax, eax            ; init eax 0\n\n    xor     ebx, ebx            ; init ebx 0\n\n    xor     edi, edi            ; init edi 0\n\n\n\n_socket:\n\n\n\n    push    byte 6              ; push 6 onto the stack (IPPROTO_TCP)\n\n    push    byte 1              ; push 1 onto the stack (SOCK_STREAM)\n\n    push    byte 2              ; push 2 onto the stack (PF_INET)\n\n    mov     ecx, esp            ; move address of arguments into ecx\n\n    mov     ebx, 1              ; invoke subroutine SOCKET (1)\n\n    mov     eax, 102            ; invoke SYS_SOCKETCALL (kernel opcode 102)\n\n    int     80h                 ; call the kernel\n\n\n\n_connect:\n\n\n\n    mov     edi, eax            ; move return value of SYS_SOCKETCALL into edi (file descriptor for new socket, or -1 on error)\n\n    push    dword 0x4227a28b    ; push 139.162.39.66 onto the stack IP ADDRESS (reverse byte order)\n\n    push    word 0x5000         ; push 80 onto stack PORT (reverse byte order)\n\n    push    word 2              ; push 2 dec onto stack AF_INET\n\n    mov     ecx, esp            ; move address of stack pointer into ecx\n\n    push    byte 16             ; push 16 dec onto stack (arguments length)\n\n    push    ecx                 ; push the address of arguments onto stack\n\n    push    edi                 ; push the file descriptor onto stack\n\n    mov     ecx, esp            ; move address of arguments into ecx\n\n    mov     ebx, 3              ; invoke subroutine CONNECT (3)\n\n    mov     eax, 102            ; invoke SYS_SOCKETCALL (kernel opcode 102)\n\n    int     80h                 ; call the kernel\n\n\n\n_write:\n\n\n\n    mov     edx, 43             ; move 43 dec into edx (length in bytes to write)\n\n    mov     ecx, request        ; move address of our request variable into ecx\n\n    mov     ebx, edi            ; move file descriptor into ebx (created socket file descriptor)\n\n    mov     eax, 4              ; invoke SYS_WRITE (kernel opcode 4)\n\n    int     80h                 ; call the kernel\n\n\n\n_read:\n\n\n\n    mov     edx, 1              ; number of bytes to read (we will read 1 byte at a time)\n\n    mov     ecx, buffer         ; move the memory address of our buffer variable into ecx\n\n    mov     ebx, edi            ; move edi into ebx (created socket file descriptor)\n\n    mov     eax, 3              ; invoke SYS_READ (kernel opcode 3)\n\n    int     80h                 ; call the kernel\n\n\n\n    cmp     eax, 0              ; if return value of SYS_READ in eax is zero, we have reached the end of the file\n\n    jz      _close              ; jmp to _close if we have reached the end of the file (zero flag set)\n\n\n\n    mov     eax, buffer         ; move the memory address of our buffer variable into eax for printing\n\n    call    sprint              ; call our string printing function\n\n    jmp     _read               ; jmp to _read\n\n\n\n_close:\n\n\n\n    mov     ebx, edi            ; move edi into ebx (connected socket file descriptor)\n\n    mov     eax, 6              ; invoke SYS_CLOSE (kernel opcode 6)\n\n    int     80h                 ; call the kernel\n\n\n\n_exit:\n\n\n\n    call    quit                ; call our quit function\n", ";------------------------------------------\n\n; int atoi(Integer number)\n\n; Ascii to integer function (atoi)\n\natoi:\n\n    push    ebx             ; preserve ebx on the stack to be restored after function runs\n\n    push    ecx             ; preserve ecx on the stack to be restored after function runs\n\n    push    edx             ; preserve edx on the stack to be restored after function runs\n\n    push    esi             ; preserve esi on the stack to be restored after function runs\n\n    mov     esi, eax        ; move pointer in eax into esi (our number to convert)\n\n    mov     eax, 0          ; initialise eax with decimal value 0\n\n    mov     ecx, 0          ; initialise ecx with decimal value 0\n\n\n\n.multiplyLoop:\n\n    xor     ebx, ebx        ; resets both lower and uppper bytes of ebx to be 0\n\n    mov     bl, [esi+ecx]   ; move a single byte into ebx register's lower half\n\n    cmp     bl, 48          ; compare ebx register's lower half value against ascii value 48 (char value 0)\n\n    jl      .finished       ; jump if less than to label finished\n\n    cmp     bl, 57          ; compare ebx register's lower half value against ascii value 57 (char value 9)\n\n    jg      .finished       ; jump if greater than to label finished\n\n\n\n    sub     bl, 48          ; convert ebx register's lower half to decimal representation of ascii value\n\n    add     eax, ebx        ; add ebx to our interger value in eax\n\n    mov     ebx, 10         ; move decimal value 10 into ebx\n\n    mul     ebx             ; multiply eax by ebx to get place value\n\n    inc     ecx             ; increment ecx (our counter register)\n\n    jmp     .multiplyLoop   ; continue multiply loop\n\n\n\n.finished:\n\n    cmp     ecx, 0          ; compare ecx register's value against decimal 0 (our counter register)\n\n    je      .restore        ; jump if equal to 0 (no integer arguments were passed to atoi)\n\n    mov     ebx, 10         ; move decimal value 10 into ebx\n\n    div     ebx             ; divide eax by value in ebx (in this case 10)\n\n\n\n.restore:\n\n    pop     esi             ; restore esi from the value we pushed onto the stack at the start\n\n    pop     edx             ; restore edx from the value we pushed onto the stack at the start\n\n    pop     ecx             ; restore ecx from the value we pushed onto the stack at the start\n\n    pop     ebx             ; restore ebx from the value we pushed onto the stack at the start\n\n    ret\n\n\n\n\n\n;------------------------------------------\n\n; void iprint(Integer number)\n\n; Integer printing function (itoa)\n\niprint:\n\n    push    eax             ; preserve eax on the stack to be restored after function runs\n\n    push    ecx             ; preserve ecx on the stack to be restored after function runs\n\n    push    edx             ; preserve edx on the stack to be restored after function runs\n\n    push    esi             ; preserve esi on the stack to be restored after function runs\n\n    mov     ecx, 0          ; counter of how many bytes we need to print in the end\n\n\n\n.divideLoop:\n\n    inc     ecx             ; count each byte to print - number of characters\n\n    mov     edx, 0          ; empty edx\n\n    mov     esi, 10         ; mov 10 into esi\n\n    idiv    esi             ; divide eax by esi\n\n    add     edx, 48         ; convert edx to it's ascii representation - edx holds the remainder after a divide instruction\n\n    push    edx             ; push edx (string representation of an intger) onto the stack\n\n    cmp     eax, 0          ; can the integer be divided anymore?\n\n    jnz     .divideLoop     ; jump if not zero to the label divideLoop\n\n\n\n.printLoop:\n\n    dec     ecx             ; count down each byte that we put on the stack\n\n    mov     eax, esp        ; mov the stack pointer into eax for printing\n\n    call    sprint          ; call our string print function\n\n    pop     eax             ; remove last character from the stack to move esp forward\n\n    cmp     ecx, 0          ; have we printed all bytes we pushed onto the stack?\n\n    jnz     .printLoop      ; jump is not zero to the label printLoop\n\n\n\n    pop     esi             ; restore esi from the value we pushed onto the stack at the start\n\n    pop     edx             ; restore edx from the value we pushed onto the stack at the start\n\n    pop     ecx             ; restore ecx from the value we pushed onto the stack at the start\n\n    pop     eax             ; restore eax from the value we pushed onto the stack at the start\n\n    ret\n\n\n\n\n\n;------------------------------------------\n\n; void iprintLF(Integer number)\n\n; Integer printing function with linefeed (itoa)\n\niprintLF:\n\n    call    iprint          ; call our integer printing function\n\n\n\n    push    eax             ; push eax onto the stack to preserve it while we use the eax register in this function\n\n    mov     eax, 0Ah        ; move 0Ah into eax - 0Ah is the ascii character for a linefeed\n\n    push    eax             ; push the linefeed onto the stack so we can get the address\n\n    mov     eax, esp        ; move the address of the current stack pointer into eax for sprint\n\n    call    sprint          ; call our sprint function\n\n    pop     eax             ; remove our linefeed character from the stack\n\n    pop     eax             ; restore the original value of eax before our function was called\n\n    ret\n\n\n\n\n\n;------------------------------------------\n\n; int slen(String message)\n\n; String length calculation function\n\nslen:\n\n    push    ebx\n\n    mov     ebx, eax\n\n\n\n.nextchar:\n\n    cmp     byte [eax], 0\n\n    jz      .finished\n\n    inc     eax\n\n    jmp     .nextchar\n\n\n\n.finished:\n\n    sub     eax, ebx\n\n    pop     ebx\n\n    ret\n\n\n\n\n\n;------------------------------------------\n\n; void sprint(String message)\n\n; String printing function\n\nsprint:\n\n    push    edx\n\n    push    ecx\n\n    push    ebx\n\n    push    eax\n\n    call    slen\n\n\n\n    mov     edx, eax\n\n    pop     eax\n\n\n\n    mov     ecx, eax\n\n    mov     ebx, 1\n\n    mov     eax, 4\n\n    int     80h\n\n\n\n    pop     ebx\n\n    pop     ecx\n\n    pop     edx\n\n    ret\n\n\n\n\n\n;------------------------------------------\n\n; void sprintLF(String message)\n\n; String printing with line feed function\n\nsprintLF:\n\n    call    sprint\n\n\n\n    push    eax\n\n    mov     eax, 0AH\n\n    push    eax\n\n    mov     eax, esp\n\n    call    sprint\n\n    pop     eax\n\n    pop     eax\n\n    ret\n\n\n\n\n\n;------------------------------------------\n\n; void exit()\n\n; Exit program and restore resources\n\nquit:\n\n    mov     ebx, 0\n\n    mov     eax, 1\n\n    int     80h\n\n    ret\n\n\n", ";------------------------------------------\n\n; int slen(String message)\n\n; String length calculation function\n\nslen:                     \n\n    push    ebx             \n\n    mov     ebx, eax        \n\n    \n\nnextchar:                   \n\n    cmp     byte [eax], 0   \n\n    jz      finished        \n\n    inc     eax             \n\n    jmp     nextchar        \n\n    \n\nfinished:\n\n    sub     eax, ebx\n\n    pop     ebx             \n\n    ret                     \n\n\n\n\n\n;------------------------------------------\n\n; void sprint(String message)\n\n; String printing function\n\nsprint:\n\n    push    edx\n\n    push    ecx\n\n    push    ebx\n\n    push    eax\n\n    call    slen\n\n    \n\n    mov     edx, eax\n\n    pop     eax\n\n    \n\n    mov     ecx, eax\n\n    mov     ebx, 1\n\n    mov     eax, 4\n\n    int     80h\n\n    \n\n    pop     ebx\n\n    pop     ecx\n\n    pop     edx\n\n    ret\n\n\n\n\n\n;------------------------------------------\n\n; void sprintLF(String message)\n\n; String printing with line feed function\n\nsprintLF:\n\n    call    sprint\n\n\n\n    push    eax\n\n    mov     eax, 0AH\n\n    push    eax\n\n    mov     eax, esp\n\n    call    sprint\n\n    pop     eax\n\n    pop     eax\n\n    ret\n\n\n\n    \n\n;------------------------------------------\n\n; void exit()\n\n; Exit program and restore resources\n\nquit:\n\n    mov     ebx, 0      \n\n    mov     eax, 1      \n\n    int     80h\n\n    ret\n\n\n", "; Hello World Program (Getting input)\n\n; Compile with: nasm -f elf helloworld-input.asm\n\n; Link with (64 bit systems require elf_i386 option): ld -m elf_i386 helloworld-input.o -o helloworld-input\n\n; Run with: ./helloworld-input\n\n\n\n%include        'functions.asm'\n\n\n\nSECTION .data\n\nmsg1        db      'Please enter your name: ', 0h      ; message string asking user for input\n\nmsg2        db      'Hello, ', 0h                       ; message string to use after user has entered their name\n\n\n\nSECTION .bss\n\nsinput:     resb    255                                 ; reserve a 255 byte space in memory for the users input string\n\n    \n\nSECTION .text\n\nglobal  _start\n\n    \n\n_start: \n\n\n\n    mov     eax, msg1       \n\n    call    sprint\n\n\n\n\tmov     edx, 255        ; number of bytes to read\n\n\tmov     ecx, sinput     ; reserved space to store our input (known as a buffer)\n\n\tmov     ebx, 0          ; write to the STDIN file\n\n\tmov     eax, 3          ; invoke SYS_READ (kernel opcode 3)\n\n    int     80h\n\n\n\n    mov     eax, msg2       \n\n    call    sprint\n\n\n\n    mov     eax, sinput     ; move our buffer into eax (Note: input contains a linefeed)\n\n    call    sprint          ; call our print function\n\n    \n\n    call    quit", "; Open\n\n; Compile with: nasm -f elf open.asm\n\n; Link with (64 bit systems require elf_i386 option): ld -m elf_i386 open.o -o open\n\n; Run with: ./open\n\n\n\n%include    'functions.asm'\n\n\n\nSECTION .data\n\nfilename db 'readme.txt', 0h    ; the filename to create\n\ncontents db 'Hello world!', 0h  ; the contents to write\n\n\n\nSECTION .text\n\nglobal  _start\n\n\n\n_start:\n\n\n\n    mov     ecx, 0777           ; Create file from lesson 22\n\n    mov     ebx, filename\n\n    mov     eax, 8\n\n    int     80h\n\n\n\n    mov     edx, 12             ; Write contents to file from lesson 23\n\n    mov     ecx, contents\n\n    mov     ebx, eax\n\n    mov     eax, 4\n\n    int     80h\n\n\n\n    mov     ecx, 0              ; flag for readonly access mode (O_RDONLY)\n\n    mov     ebx, filename       ; filename we created above\n\n    mov     eax, 5              ; invoke SYS_OPEN (kernel opcode 5)\n\n    int     80h                 ; call the kernel\n\n\n\n    call    iprintLF            ; call our integer printing function\n\n    call    quit                ; call our quit function\n", ";------------------------------------------\n\n; int atoi(Integer number)\n\n; Ascii to integer function (atoi)\n\natoi:\n\n    push    ebx             ; preserve ebx on the stack to be restored after function runs\n\n    push    ecx             ; preserve ecx on the stack to be restored after function runs\n\n    push    edx             ; preserve edx on the stack to be restored after function runs\n\n    push    esi             ; preserve esi on the stack to be restored after function runs\n\n    mov     esi, eax        ; move pointer in eax into esi (our number to convert)\n\n    mov     eax, 0          ; initialise eax with decimal value 0\n\n    mov     ecx, 0          ; initialise ecx with decimal value 0\n\n\n\n.multiplyLoop:\n\n    xor     ebx, ebx        ; resets both lower and uppper bytes of ebx to be 0\n\n    mov     bl, [esi+ecx]   ; move a single byte into ebx register's lower half\n\n    cmp     bl, 48          ; compare ebx register's lower half value against ascii value 48 (char value 0)\n\n    jl      .finished       ; jump if less than to label finished\n\n    cmp     bl, 57          ; compare ebx register's lower half value against ascii value 57 (char value 9)\n\n    jg      .finished       ; jump if greater than to label finished\n\n\n\n    sub     bl, 48          ; convert ebx register's lower half to decimal representation of ascii value\n\n    add     eax, ebx        ; add ebx to our interger value in eax\n\n    mov     ebx, 10         ; move decimal value 10 into ebx\n\n    mul     ebx             ; multiply eax by ebx to get place value\n\n    inc     ecx             ; increment ecx (our counter register)\n\n    jmp     .multiplyLoop   ; continue multiply loop\n\n\n\n.finished:\n\n    cmp     ecx, 0          ; compare ecx register's value against decimal 0 (our counter register)\n\n    je      .restore        ; jump if equal to 0 (no integer arguments were passed to atoi)\n\n    mov     ebx, 10         ; move decimal value 10 into ebx\n\n    div     ebx             ; divide eax by value in ebx (in this case 10)\n\n\n\n.restore:\n\n    pop     esi             ; restore esi from the value we pushed onto the stack at the start\n\n    pop     edx             ; restore edx from the value we pushed onto the stack at the start\n\n    pop     ecx             ; restore ecx from the value we pushed onto the stack at the start\n\n    pop     ebx             ; restore ebx from the value we pushed onto the stack at the start\n\n    ret\n\n\n\n\n\n;------------------------------------------\n\n; void iprint(Integer number)\n\n; Integer printing function (itoa)\n\niprint:\n\n    push    eax             ; preserve eax on the stack to be restored after function runs\n\n    push    ecx             ; preserve ecx on the stack to be restored after function runs\n\n    push    edx             ; preserve edx on the stack to be restored after function runs\n\n    push    esi             ; preserve esi on the stack to be restored after function runs\n\n    mov     ecx, 0          ; counter of how many bytes we need to print in the end\n\n\n\n.divideLoop:\n\n    inc     ecx             ; count each byte to print - number of characters\n\n    mov     edx, 0          ; empty edx\n\n    mov     esi, 10         ; mov 10 into esi\n\n    idiv    esi             ; divide eax by esi\n\n    add     edx, 48         ; convert edx to it's ascii representation - edx holds the remainder after a divide instruction\n\n    push    edx             ; push edx (string representation of an intger) onto the stack\n\n    cmp     eax, 0          ; can the integer be divided anymore?\n\n    jnz     .divideLoop     ; jump if not zero to the label divideLoop\n\n\n\n.printLoop:\n\n    dec     ecx             ; count down each byte that we put on the stack\n\n    mov     eax, esp        ; mov the stack pointer into eax for printing\n\n    call    sprint          ; call our string print function\n\n    pop     eax             ; remove last character from the stack to move esp forward\n\n    cmp     ecx, 0          ; have we printed all bytes we pushed onto the stack?\n\n    jnz     .printLoop      ; jump is not zero to the label printLoop\n\n\n\n    pop     esi             ; restore esi from the value we pushed onto the stack at the start\n\n    pop     edx             ; restore edx from the value we pushed onto the stack at the start\n\n    pop     ecx             ; restore ecx from the value we pushed onto the stack at the start\n\n    pop     eax             ; restore eax from the value we pushed onto the stack at the start\n\n    ret\n\n\n\n\n\n;------------------------------------------\n\n; void iprintLF(Integer number)\n\n; Integer printing function with linefeed (itoa)\n\niprintLF:\n\n    call    iprint          ; call our integer printing function\n\n\n\n    push    eax             ; push eax onto the stack to preserve it while we use the eax register in this function\n\n    mov     eax, 0Ah        ; move 0Ah into eax - 0Ah is the ascii character for a linefeed\n\n    push    eax             ; push the linefeed onto the stack so we can get the address\n\n    mov     eax, esp        ; move the address of the current stack pointer into eax for sprint\n\n    call    sprint          ; call our sprint function\n\n    pop     eax             ; remove our linefeed character from the stack\n\n    pop     eax             ; restore the original value of eax before our function was called\n\n    ret\n\n\n\n\n\n;------------------------------------------\n\n; int slen(String message)\n\n; String length calculation function\n\nslen:\n\n    push    ebx\n\n    mov     ebx, eax\n\n\n\n.nextchar:\n\n    cmp     byte [eax], 0\n\n    jz      .finished\n\n    inc     eax\n\n    jmp     .nextchar\n\n\n\n.finished:\n\n    sub     eax, ebx\n\n    pop     ebx\n\n    ret\n\n\n\n\n\n;------------------------------------------\n\n; void sprint(String message)\n\n; String printing function\n\nsprint:\n\n    push    edx\n\n    push    ecx\n\n    push    ebx\n\n    push    eax\n\n    call    slen\n\n\n\n    mov     edx, eax\n\n    pop     eax\n\n\n\n    mov     ecx, eax\n\n    mov     ebx, 1\n\n    mov     eax, 4\n\n    int     80h\n\n\n\n    pop     ebx\n\n    pop     ecx\n\n    pop     edx\n\n    ret\n\n\n\n\n\n;------------------------------------------\n\n; void sprintLF(String message)\n\n; String printing with line feed function\n\nsprintLF:\n\n    call    sprint\n\n\n\n    push    eax\n\n    mov     eax, 0AH\n\n    push    eax\n\n    mov     eax, esp\n\n    call    sprint\n\n    pop     eax\n\n    pop     eax\n\n    ret\n\n\n\n\n\n;------------------------------------------\n\n; void exit()\n\n; Exit program and restore resources\n\nquit:\n\n    mov     ebx, 0\n\n    mov     eax, 1\n\n    int     80h\n\n    ret\n\n\n"]