["#include <stdlib.h>\n\n#include <stdio.h>\n\n#include <string.h>\n\n\n\n#include \"mapcoder.h\"\n\n\n\nstatic void usage (void) {\n\n  fprintf (stderr, \"Usage: tmc <encode> | <decode>\\n\");\n\n  fprintf (stderr, \"  <encode> ::= -c <lat> <lon> <context> [ <precision> ]\\n\");\n\n  fprintf (stderr, \"  <decode> ::= -d [ <context> ] <mapcode>\\n\");\n\n}\n\n\n\nint main (int argc, char *argv[]) {\n\n\n\n  Mapcodes codes;\n\n  double lat, lon;\n\n  int ctx;\n\n  int i, res;\n\n  int prec;\n\n  char* pmap;\n\n\n\n  if (argc < 3) {\n\n    fprintf (stderr, \"ERROR: Invalid arguments\\n\");\n\n    usage();\n\n    exit (1);\n\n  }\n\n\n\n  if (strcmp (argv[1], \"-c\") == 0 ) {\n\n    if ( (argc < 5) || (argc > 6) ) {\n\n      fprintf (stderr, \"ERROR: Invalid arguments\\n\");\n\n      usage();\n\n      exit (1);\n\n    }\n\n    /* Encode */\n\n    if (sscanf (argv[2], \"%lf\", &lat) != 1) {\n\n      fprintf (stderr, \"ERROR: Invalid lat %s\\n\", argv[2]);\n\n      exit (1);\n\n    }\n\n    if (sscanf (argv[3], \"%lf\", &lon) != 1) {\n\n      fprintf (stderr, \"ERROR: Invalid lon %s\\n\", argv[3]);\n\n      exit (1);\n\n    }\n\n    /* Mandatory context, may be empty */ \n\n    if (strlen (argv[4]) == 0) {\n\n      ctx = 0;\n\n    } else {\n\n      ctx = getTerritoryCode(argv[4], 0);\n\n      if (ctx < 0) {\n\n        fprintf (stderr, \"ERROR: Invalid context %s\\n\", argv[4]);\n\n        exit (1);\n\n      }\n\n    }\n\n    /* Optional precision */\n\n    if (argc == 5) {\n\n      prec = 0;\n\n    } else {\n\n      if ( (sscanf (argv[5], \"%d\", &prec) != 1)\n\n          || (prec < 0) || (prec > 2) ) {\n\n        fprintf (stderr, \"ERROR: Invalid precision %s\\n\", argv[5]);\n\n        exit (1);\n\n      }\n\n    }\n\n\n\n    /* Do encode */\n\n    res = encodeLatLonToMapcodes (&codes, lat, lon, ctx, prec);\n\n    if (res == 0) {\n\n      fprintf (stderr, \"ERROR: Cannot encode %s %s in context %s with precision %1d\\n\",\n\n               argv[2], argv[3], argv[4], prec);\n\n      exit (1);\n\n    }\n\n\n\n    for (i = 0; i < codes.count; i++) {\n\n      printf (\"%s\\n\", codes.mapcode[i]);\n\n    }\n\n\n\n  } else if (strcmp (argv[1], \"-d\") == 0 ) {\n\n    /* Decode */\n\n    /* Optional leading context */\n\n    if (argc == 4)  {\n\n      pmap = argv[3];\n\n      ctx = getTerritoryCode(argv[2], 0);\n\n      if (ctx < 0) {\n\n        fprintf (stderr, \"ERROR: Invalid context %s\\n\", argv[2]);\n\n        exit (1);\n\n      }\n\n    } else if (argc == 3) {\n\n      pmap = argv[2];\n\n      ctx = 0;\n\n    } else {\n\n      fprintf (stderr, \"ERROR: Invalid arguments\\n\");\n\n      usage();\n\n      exit (1);\n\n    }\n\n\n\n    /* Do decode */\n\n    res = decodeMapcodeToLatLon (&lat, &lon, pmap, ctx);\n\n    if (res != 0) {\n\n      fprintf (stderr, \"ERROR: Cannot decode %s in context%d\\n\", pmap, ctx);\n\n      exit (1);\n\n    }\n\n    printf (\"%3.9lf %3.9lf\\n\", lat, lon);\n\n\n\n  } else {\n\n    fprintf (stderr, \"ERROR: Invalid arguments\\n\");\n\n    usage();\n\n    exit (1);\n\n  }\n\n\n\n  exit (0);\n\n}\n\n\n", "\n\n#include <stdio.h>\n\n\n\n#include \"socket.h\"\n\n\n\n#define BUFF_SIZE 500\n\n#define PORT_NAME \"test_udp\"\n\n\n\n\n", "#include <stdio.h>\n\n#include <stdlib.h>\n\n#include <string.h>\n\n#include \"Poing.h\"\n\n\n\nstatic void error (const char *s) __attribute__ ((noreturn));\n\n\n\nstatic void error(const char *s);\n\n\n\nint main (int argc, char *argv[] __attribute__ ((unused)) ) {\n\n    soc_token soc = init_soc;\n\n    int res;\n\n    char buff[BUFF_SIZE];\n\n    soc_length len;\n\n\n\n    /* Parse command line arguments : no arg */\n\n    if (argc != 1) error(\"Syntax\");\n\n\n\n    /* Create socket */\n\n    res = soc_open(&soc, udp_socket);\n\n    if (res != SOC_OK) {\n\n        perror(\"soc_open\");\n\n        error(\"Socket creation\");\n\n    }\n\n\n\n    /* Connect to port */\n\n    res = soc_link_service (soc, PORT_NAME);\n\n    if (res != SOC_OK) {\n\n        perror(\"soc_link_service\");\n\n        error(\"Connecting to port\");\n\n    }\n\n\n\n    for (;;) {\n\n        /* Receive */\n\n        len = (soc_length)sizeof(buff);\n\n        res = soc_receive (soc, buff, len, TRUE);\n\n        if (res != SOC_OK) {\n\n            perror(\"soc_receive\");\n\n            error(\"Receiving message\");\n\n        }\n\n        len = res;\n\n\n\n        /* Print */\n\n        buff[len]='\\0';\n\n        printf(\"Received: >%s<\\n\", buff);\n\n\n\n        /* Reply */\n\n        strcpy (buff, \"Pong\");\n\n        res = soc_send (soc, buff, (soc_length)strlen(buff));\n\n        if (res != SOC_OK) {\n\n            perror(\"soc_send\");\n\n            error(\"Sending reply\");\n\n        }\n\n    }\n\n\n\n    /* Close socket\n\n    res = soc_close(&soc);\n\n    if (res != SOC_OK) {\n\n        perror(\"soc_close\");\n\n        error(\"Closing socket\");\n\n    }\n\n    */\n\n\n\n}\n\n\n\nstatic void error(const char *s) {\n\n    printf (\"ERROR: %s\\nUsage: Pong\\n\", s);\n\n    exit(1);\n\n}\n\n\n", "#include <stdio.h>\n\n#include <stdlib.h>\n\n#include <string.h>\n\n#include \"Poing.h\"\n\n\n\nstatic void error (const char *s) __attribute__ ((noreturn));\n\n\n\nint main (int argc, char *argv[]) {\n\n    soc_token soc = init_soc;\n\n    int res;\n\n    char buff[BUFF_SIZE];\n\n    soc_length len;\n\n    boolean ping_lan;\n\n\n\n    /* Parse command line arguments : host_name */\n\n    if (argc != 3) error(\"Syntax\");\n\n\n\n    /* Syntax is Ping lan <lan_name> or Ping host <host_name> */\n\n    ping_lan = false;\n\n    if (strcmp(argv[1], \"host\") == 0) {\n\n      ping_lan = false;\n\n    } else if (strcmp(argv[1], \"lan\") == 0) {\n\n      ping_lan = true;\n\n    } else {\n\n      error(\"Syntax\");\n\n    }\n\n\n\n    /* Create socket */\n\n    res = soc_open(&soc, udp_socket);\n\n    if (res != SOC_OK) {\n\n        perror(\"soc_open\");\n\n        error(\"Socket creation\");\n\n    }\n\n\n\n    /* Set destination */\n\n    res = soc_set_dest_name_service(soc, argv[2], ping_lan, PORT_NAME);\n\n    if (res != SOC_OK) {\n\n        perror(\"soc_set_dest_service\");\n\n        error(\"Setting destination\");\n\n    }\n\n\n\n    /* Connect to port */\n\n    res = soc_link_service (soc, PORT_NAME);\n\n    if (res != SOC_OK) {\n\n        perror(\"soc_link_service\");\n\n        error(\"Connecting to port\");\n\n    }\n\n\n\n    /* Send */\n\n    strcpy (buff, \"Ping\");\n\n    res = soc_send (soc, buff, (soc_length)strlen(buff));\n\n    if (res != SOC_OK) {\n\n        perror(\"soc_send\");\n\n        error(\"Sending message\");\n\n    }\n\n\n\n    /* Receive */\n\n    len = (soc_length)sizeof(buff);\n\n    res = soc_receive (soc, buff, len, FALSE);\n\n    if (res != SOC_OK) {\n\n        perror(\"soc_receive\");\n\n        error(\"receiving message\");\n\n    }\n\n    len = res;\n\n\n\n    /* Print */\n\n    buff[len]='\\0';\n\n    printf(\"Received: >%s<\\n\", buff);\n\n\n\n    /* Close socket */\n\n    res = soc_close(&soc);\n\n    if (res != SOC_OK) {\n\n        perror(\"soc_close\");\n\n        error(\"Closing socket\");\n\n    }\n\n    exit(0);\n\n}\n\n\n\nstatic void error (const char *s) {\n\n    printf (\"ERROR: %s\\nUsage: Ping host <host_name>  or  Ping lan <lan_name> \\n\", s);\n\n    exit(1);\n\n}\n\n\n", "#include <pthread.h>\n\n\n\npthread_t th;\n\n\n\nstatic void * the_thread (void * arg) {\n\n  return arg;\n\n}\n\n\n\nextern void dummy (void);\n\n\n\nextern void dummy (void) {\n\n  (void) pthread_create (&th, NULL, &the_thread, NULL);\n\n}\n\n\n", "#include <stdlib.h>\n\n#include <stdio.h>\n\n#include <unistd.h>\n\n#include <libgen.h>\n\n#include <string.h>\n\n\n\n#include \"rusage.h\"\n\n\n\n#define L_MAX       10000\n\n#define N_MAX       1000\n\n#define MALLOC_MAX (100 * 1024)\n\n\n\n/* Random value from 1 to max included */\n\nstatic int rnd (int max) {\n\n  int i;\n\n  double d;\n\n  i = rand();\n\n  d = (double)i / ( (double)RAND_MAX + 1.0) * (double)max;\n\n  return (int)d;\n\n}\n\n\n\nint main (int argc, char *argv[]) {\n\n\n\n  unsigned int seed;\n\n  unsigned int n, i, j, size;\n\n  void * array[N_MAX];\n\n\n\n  /* Fixed seed */\n\n  seed = 0;\n\n  if (argc == 2) {\n\n    seed = atoi (argv[1]);\n\n  }\n\n  if ((int)seed < 0) seed = 0;\n\n  srand (seed);\n\n\n\n  printf (\"%s pid is %d\\n\", basename(argv[0]), getpid());\n\n\n\n\n\n  if (init_rusage() != RUSAGE_OK) {\n\n    perror (\"init_rusage\");\n\n    exit (1);\n\n  }\n\n  dump_rusage_str (\"Start\");\n\n\n\n  for (i = 1; i <= L_MAX; i++) {\n\n    n = rnd (N_MAX);\n\n\n\n    /* N mallocs of random size */\n\n    size = rnd (MALLOC_MAX);\n\n    for (j = 0; j < n; j++) {\n\n      array[j] = malloc (size);\n\n      if (array[j] == NULL) {\n\n        perror (\"malloc\");\n\n        exit (1);\n\n      }\n\n    }\n\n\n\n    /* Free */\n\n    for (j = 0; j < n; j++) {\n\n      free (array[j]);\n\n    }\n\n  }\n\n\n\n  dump_rusage_str (\"Stop\");\n\n  printf (\"Done\\n\");\n\n  exit (0);\n\n}\n\n\n\n\n", "#include <stdio.h>\n\n#include <stdlib.h>\n\n\n\n#define LEN 50\n\n\n\nint main (int argc, char *argv[]) {\n\n\n\n  short s, *ps;\n\n  char str[LEN];\n\n  int i;\n\n  int v;\n\n\n\n  if (argc == 2) {\n\n    v = atoi(argv[1]);\n\n  } else {\n\n    exit (1);\n\n  }\n\n\n\n  for (i = 0; i < LEN; i++) {\n\n    str[i] = (char) v;\n\n  }\n\n\n\n  printf (\"%d : \", v);\n\n  for (i = 0; i < 4 ; i++) {\n\n    ps = (short*) (&str[i]);\n\n    s = *ps;\n\n    printf (\"%d -> %04hX    \", i, s);\n\n  }\n\n  printf (\"\\n\");\n\n  exit(0);\n\n}\n\n\n", "#include <stdio.h>\n\n#include <string.h>\n\n#include <unistd.h>\n\n#include <pcreposix.h>\n\n#include <pcre.h>\n\n\n\nstatic void usage (char *name) {\n\n  fprintf (stderr, \"Usage: %s <regex> { [ <string> ] }\\n\", name);\n\n}\n\n\n\nstatic void print_match (regmatch_t match) {\n\n  printf (\"Match at %d-%d\\n\", match.rm_so, match.rm_eo - 1);\n\n}\n\n\n\n#define MAX_MATCHES 100\n\nint main (int argc, char *argv[]) {\n\n\n\n  int i, j, n, res;\n\n  regex_t regex;\n\n  char buffer[1024];\n\n  regmatch_t matches[MAX_MATCHES];\n\n\n\n  /* At least one argument, -h | --help | <regex> */\n\n  if (argc < 2) {\n\n    usage (argv[0]);\n\n    exit (1);\n\n  }\n\n\n\n  /* Help */\n\n  if ( (strcmp (argv[1], \"-h\") == 0) || (strcmp (argv[1], \"--help\") == 0) ) {\n\n    usage (argv[0]);\n\n    exit (0);\n\n  }\n\n  /* Show version */\n\n  if ( (strcmp (argv[1], \"-v\") == 0) || (strcmp (argv[1], \"--version\") == 0) ) {\n\n    printf (\"Pcre version is %s\\n\", pcre_version());\n\n    exit (0);\n\n  }\n\n\n\n  /* Compile regex */\n\n  res = regcomp (&regex, argv[1], 0);\n\n  if (res != 0) {\n\n    (void) regerror (res, &regex, buffer, sizeof(buffer));\n\n    fprintf (stderr, \"ERROR: Compilation has failed with error: %s\\n\",\n\n             buffer);\n\n    exit (1);\n\n  }\n\n\n\n  /* Check strings */\n\n  for (i = 3; i <= argc; i++) {\n\n    /* Compile */\n\n    res = regexec (&regex, argv[i-1], MAX_MATCHES, matches, 0);\n\n    if (res == REG_NOMATCH) {\n\n      printf (\"No match\\n\");\n\n      continue;\n\n    }\n\n    if (res != 0) {\n\n      (void) regerror (res, &regex, buffer, sizeof(buffer));\n\n      fprintf (stderr, \"ERROR: Execution has failed with error: %s\\n\",\n\n               buffer);\n\n      exit (1);\n\n    }\n\n    /* Print result */\n\n    print_match (matches[0]);\n\n\n\n    /* Count matching substrings */\n\n    n = 0;\n\n    for (j = MAX_MATCHES - 1; j >= 0; j--) {\n\n      if (matches[j].rm_so != -1) {\n\n        n = j;\n\n        break;\n\n      }\n\n    }\n\n\n\n    /* Print matching substrings */\n\n    for (j = 1; j <= n; j++) {\n\n      print_match (matches[j]);\n\n    }\n\n  }\n\n\n\n  /* Cleanup */\n\n  regfree (&regex);\n\n    \n\n  /* Done */\n\n  exit (0);\n\n}\n\n\n", "#include <stdio.h>\n\n#include <string.h>\n\n#include <unistd.h>\n\n\n\n#include <pcre2posix.h>\n\n#define PCRE2_CODE_UNIT_WIDTH 8\n\n#include <pcre2.h>\n\n\n\nstatic void usage (char *name) {\n\n  fprintf (stderr, \"Usage: %s <regex> { [ <string> ] }\\n\", name);\n\n}\n\n\n\nstatic void print_match (regmatch_t match) {\n\n  printf (\"Match at %d-%d\\n\", match.rm_so, match.rm_eo - 1);\n\n}\n\n\n\n#define MAX_MATCHES 100\n\nint main (int argc, char *argv[]) {\n\n\n\n  int i, j, n, res;\n\n  regex_t regex;\n\n  char buffer[1024];\n\n  regmatch_t matches[MAX_MATCHES];\n\n\n\n  /* At least one argument, -h | --help | <regex> */\n\n  if (argc < 2) {\n\n    usage (argv[0]);\n\n    exit (1);\n\n  }\n\n\n\n  /* Help */\n\n  if ( (strcmp (argv[1], \"-h\") == 0) || (strcmp (argv[1], \"--help\") == 0) ) {\n\n    usage (argv[0]);\n\n    exit (0);\n\n  }\n\n  /* Show version */\n\n  if ( (strcmp (argv[1], \"-v\") == 0) || (strcmp (argv[1], \"--version\") == 0) ) {\n\n    res = pcre2_config (PCRE2_CONFIG_VERSION, buffer);\n\n    printf (\"Pcre version is %s\\n\", buffer);\n\n    exit (0);\n\n  }\n\n\n\n  /* Compile regex */\n\n  res = regcomp (&regex, argv[1], 0);\n\n  if (res != 0) {\n\n    (void) regerror (res, &regex, buffer, sizeof(buffer));\n\n    fprintf (stderr, \"ERROR: Compilation has failed with error: %s\\n\",\n\n             buffer);\n\n    exit (1);\n\n  }\n\n\n\n  /* Check strings */\n\n  for (i = 3; i <= argc; i++) {\n\n    /* Compile */\n\n    res = regexec (&regex, argv[i-1], MAX_MATCHES, matches, 0);\n\n    if (res == REG_NOMATCH) {\n\n      printf (\"No match\\n\");\n\n      continue;\n\n    }\n\n    if (res != 0) {\n\n      (void) regerror (res, &regex, buffer, sizeof(buffer));\n\n      fprintf (stderr, \"ERROR: Execution has failed with error: %s\\n\",\n\n               buffer);\n\n      exit (1);\n\n    }\n\n    /* Print result */\n\n    print_match (matches[0]);\n\n\n\n    /* Count matching substrings */\n\n    n = 0;\n\n    for (j = MAX_MATCHES - 1; j >= 0; j--) {\n\n      if (matches[j].rm_so != -1) {\n\n        n = j;\n\n        break;\n\n      }\n\n    }\n\n\n\n    /* Print matching substrings */\n\n    for (j = 1; j <= n; j++) {\n\n      print_match (matches[j]);\n\n    }\n\n  }\n\n\n\n  /* Cleanup */\n\n  regfree (&regex);\n\n    \n\n  /* Done */\n\n  exit (0);\n\n}\n\n\n", "#include <stdio.h>\n\n#include <string.h>\n\n#include <unistd.h>\n\n\n\n#include <posix2pcre.h>\n\n\n\nstatic void usage (char *name) {\n\n  fprintf (stderr, \"Usage: %s <regex> { [ <string> ] }\\n\", name);\n\n}\n\n\n\nstatic void print_match (regmatch_t match) {\n\n  printf (\"Match at %d-%d\\n\", match.rm_so, match.rm_eo - 1);\n\n}\n\n\n\n#define MAX_MATCHES 100\n\nint main (int argc, char *argv[]) {\n\n\n\n  int i, j, n, res;\n\n  regex_t regex;\n\n  char buffer[1024];\n\n  const char *pchar;\n\n  regmatch_t matches[MAX_MATCHES];\n\n\n\n  /* At least one argument, -h | --help | <regex> */\n\n  if (argc < 2) {\n\n    usage (argv[0]);\n\n    exit (1);\n\n  }\n\n\n\n  /* Help */\n\n  if ( (strcmp (argv[1], \"-h\") == 0) || (strcmp (argv[1], \"--help\") == 0) ) {\n\n    usage (argv[0]);\n\n    exit (0);\n\n  }\n\n  /* Show version */\n\n  if ( (strcmp (argv[1], \"-v\") == 0) || (strcmp (argv[1], \"--version\") == 0) ) {\n\n    pchar = pcre_version ();\n\n    printf (\"Pcre version is %s\\n\", pchar);\n\n    exit (0);\n\n  }\n\n\n\n  /* Compile regex */\n\n  res = posix2pcre_regcomp (&regex, argv[1], 0);\n\n  if (res != 0) {\n\n    (void) posix2pcre_regerror (res, &regex, buffer, sizeof(buffer));\n\n    fprintf (stderr, \"ERROR: Compilation has failed with error: %s\\n\",\n\n             buffer);\n\n    exit (1);\n\n  }\n\n\n\n  /* Check strings */\n\n  for (i = 3; i <= argc; i++) {\n\n    /* Compile */\n\n    res = posix2pcre_regexec (&regex, argv[i-1], MAX_MATCHES, matches, 0);\n\n    if (res == REG_NOMATCH) {\n\n      printf (\"No match\\n\");\n\n      continue;\n\n    }\n\n    if (res != 0) {\n\n      (void) posix2pcre_regerror (res, &regex, buffer, sizeof(buffer));\n\n      fprintf (stderr, \"ERROR: Execution has failed with error: %s\\n\",\n\n               buffer);\n\n      exit (1);\n\n    }\n\n    /* Print result */\n\n    print_match (matches[0]);\n\n\n\n    /* Count matching substrings */\n\n    n = 0;\n\n    for (j = MAX_MATCHES - 1; j >= 0; j--) {\n\n      if (matches[j].rm_so != -1) {\n\n        n = j;\n\n        break;\n\n      }\n\n    }\n\n\n\n    /* Print matching substrings */\n\n    for (j = 1; j <= n; j++) {\n\n      print_match (matches[j]);\n\n    }\n\n  }\n\n\n\n  /* Cleanup */\n\n  posix2pcre_regfree (&regex);\n\n    \n\n  /* Done */\n\n  exit (0);\n\n}\n\n\n", "#include <stdio.h>\n\n#include <stdlib.h>\n\n#include <unistd.h>\n\n#include <string.h>\n\n\n\n\n\n#include \"get_line.h\"\n\n#include \"socket.h\"\n\n\n\nstatic void error(const char *msg, const char *arg)\n\n  __attribute__ ((noreturn));\n\nstatic void error(const char *msg, const char *arg) {\n\n  fprintf(stderr, \"ERROR : %s %s\\n\", msg, arg);\n\n  fprintf(stderr, \"Usage : udp_send <dest_type> <dest>:<port> [ <message> ]\\n\");\n\n  fprintf(stderr, \"   <dest_type> ::= lan | host\\n\");\n\n  fprintf(stderr, \"   <dest> ::= <lan_or_host_name> | <lan_or_host_ip_address>\\n\");\n\n  fprintf(stderr, \"   <port> ::= <port_name> | <port_no>\\n\");\n\n  fprintf(stderr, \"Reads stdin if no <message>.\\n\");\n\n  exit (1);\n\n}\n\n\n\nstatic char message[1024 *1024];\n\n\n\nint main (int argc, char *argv[]) {\n\n  boolean dest_lan;\n\n  char host_name[1024];\n\n  soc_host host_no;\n\n  char port_name[256];\n\n  soc_port port_no;\n\n  soc_token soc = init_soc;\n\n  char buffer[1024];\n\n  int i, res, len;\n\n  boolean interactive;\n\n\n\n  /* Parse command line arguments */\n\n  /* Syntax is udp_send lan/host <dest>:<port> [ <message> ] */\n\n  if (argc < 3) error(\"Invalid number of arguments\", \"\");\n\n\n\n  if (strcmp(argv[1], \"host\") == 0) {\n\n    dest_lan = false;\n\n  } else if (strcmp(argv[1], \"lan\") == 0) {\n\n    dest_lan = true;\n\n  } else {\n\n    error(\"Invalid argument\", argv[1]);\n\n  }\n\n  interactive = (isatty(0) == 1);\n\n\n\n  /* Locate ':' in dest:port */\n\n  strcpy (host_name, argv[2]);\n\n  res = -1;\n\n  for (i = 0; i < (int) strlen(host_name); i++) {\n\n    if (host_name[i] == ':') {\n\n      if (res != -1) {\n\n        error (\"Invalid destination\", host_name);\n\n      }\n\n      res = i;\n\n    }\n\n  }\n\n  /* ':' must exist and not at beginning or end */\n\n  if ( (res == -1) || (res == 0) || (res == (int)strlen (host_name) - 1) ) {\n\n    error (\"Invalid destination\", host_name);\n\n  }\n\n  host_name[res] = '\\0';\n\n  strcpy (port_name, &host_name[res+1]);\n\n\n\n  /* Create socket */\n\n  res = soc_open(&soc, udp_socket);\n\n  if (res != SOC_OK) {\n\n      error(\"Socket creation\", soc_error(res));\n\n  }\n\n\n\n  /* Set destination */\n\n  if (soc_str2host (host_name, &host_no) == SOC_OK) {\n\n    if (soc_str2port (port_name, &port_no) == SOC_OK) {\n\n      res = soc_set_dest_host_port(soc, &host_no, port_no);\n\n    } else {\n\n      res = soc_set_dest_host_service (soc, &host_no, port_name);\n\n    }\n\n  } else {\n\n    if (soc_str2port (port_name, &port_no) == SOC_OK) {\n\n      res = soc_set_dest_name_port(soc, host_name, dest_lan, port_no);\n\n    } else {\n\n      res = soc_set_dest_name_service(soc, host_name, dest_lan, port_name);\n\n    }\n\n  }\n\n  if (res != SOC_OK) {\n\n    error(\"Setting destination\", soc_error(res));\n\n  }\n\n\n\n  /* Link */\n\n  if (soc_str2port (port_name, &port_no) == SOC_OK) {\n\n    res = soc_link_port(soc, port_no);\n\n  } else {\n\n    res = soc_link_service (soc, port_name);\n\n  }\n\n  if (res != SOC_OK) {\n\n    error(\"Linking to port\", soc_error(res));\n\n  }\n\n\n\n  /* Build or read message */\n\n  message[0] = '\\0';\n\n  if (argc > 3) {\n\n    /* Concatenate arguments separated by spaces */\n\n    for (i = 3; i < argc; i++) {\n\n      if (i != 3) {\n\n        strcat (message, \" \");\n\n      }\n\n      strcat (message, argv[i]);\n\n    }\n\n    len = strlen(message);\n\n  } else {\n\n    /* Read from stdin */\n\n    if (interactive) {\n\n      printf (\"Enter message to send (end with Ctrl-D): \");\n\n      fflush (stdout);\n\n    }\n\n    len = 0;\n\n    for (;;) {\n\n      /* Read a buffer of data from stdin */\n\n      res = (int) get_text (NULL, buffer, sizeof(buffer));\n\n      if (res == 0) {\n\n        /* End of input flow */\n\n        break;\n\n      }\n\n      /* Concatenate to message */\n\n      memmove (&message[len], buffer, res);\n\n      len += res;\n\n    }\n\n    if (interactive) {\n\n      printf (\"\\n\");\n\n    }\n\n  }\n\n\n\n  /* Send */\n\n  res = soc_send (soc, message, (soc_length)len);\n\n  if (res != SOC_OK) {\n\n      error(\"Sending message\", soc_error(res));\n\n  }\n\n\n\n  /* Receive */\n\n  res = soc_set_blocking (soc, FALSE);\n\n  sleep (1);\n\n  for (;;) {\n\n    res = soc_receive (soc, message, (soc_length)sizeof(message), TRUE);\n\n    if (res > 0) {\n\n      message[res] = '\\0';\n\n      printf (\"-->%s<\\n\", message);\n\n    } else {\n\n      break;\n\n    }\n\n  }\n\n\n\n  exit (0);\n\n}\n\n\n", "/*\n\n * Program name: shm.c\n\n *\n\n * This program tries to find valid  shared memory addresses to which\n\n * shared memory segments may be attached.\n\n * It creates two shared memory segments first and attaches them to\n\n * the process' virtual memory space. The system determines the shared\n\n * memory addresses for these segments.\n\n * Then the program determines the address interval between the two\n\n * segments. The whole virtual address space is then scanned for valid\n\n * shared memory addresses with the interval. Scanning may\n\n * take several minutes.\n\n *\n\n * Build the program by:\n\n *    cc -o shm shm.c\n\n *\n\n * This program has an optional command line option : size for a first\n\n *  shared memory segment to attach to.\n\n */\n\n\n\n#include <stdio.h>\n\n#include <string.h>\n\n#include <stdlib.h>\n\n#include <sys/types.h>\n\n#include <sys/ipc.h>\n\n#include <sys/shm.h>\n\n#include <signal.h>\n\n#include <errno.h>\n\n#include <unistd.h>\n\n\n\n#include \"sig_util.h\"\n\n\n\nstatic int shmid1;\n\n\n\nstatic void clean_up (int signum) __attribute__ ((noreturn));\n\nstatic void clean_up (int signum) {\n\n    if (shmctl(shmid1, IPC_RMID, NULL) < 0) {\n\n        perror(\"Removing first shm segment\");\n\n        exit (1);\n\n    }\n\n    exit ((signum > 0) ? 0 : 1);\n\n}\n\n\n\nstatic unsigned long getul (const char *str, const char *msg) {\n\n    unsigned long result;\n\n\n\n    errno = 0;\n\n    if (strncmp(str, \"0x\", 2) == 0) {\n\n        result = (size_t) strtoull(str, NULL, 16);\n\n    } else {\n\n        result = (size_t) strtoull(str, NULL, 10);\n\n    }\n\n    if (errno != 0) {\n\n        printf (\"Invalid argument for %s : %s\\n\", msg, str);\n\n        exit(1);\n\n    }\n\n    return result;\n\n}\n\n\n\nstatic void usage (void) {\n\n    printf (\"Usage: shm [ <basic_size> [ <address> ] ]\\n\");\n\n    printf (\"  By default (no arg) gets first segment of size 1\\n\");\n\n    printf (\"   then following segements of size 1.\\n\");\n\n    printf (\"  With a size, get a segment of this size, either\\n\");\n\n    printf (\"   to OS defined or to provided address.\\n\");\n\n}\n\n\n\n\n\nint main(int argc, char *argv[]) {\n\n    char *addr, *addr0, *addr1, *addr2;\n\n    unsigned long tmp_addr;\n\n    int shmid2;\n\n    int interval;\n\n    int valid_shmaddr = 0;\n\n    size_t size0;\n\n    int increasing;\n\n    int ok = 1;\n\n\n\n    size0 = 0;\n\n    addr = NULL;\n\n    if (argc == 2) {\n\n      if ( (strcmp (argv[1], \"-h\") == 0)\n\n        || (strcmp (argv[1], \"--help\") == 0 ) ) {\n\n        usage();\n\n        exit (1);\n\n      }\n\n    }\n\n    if (argc > 3) {\n\n        printf (\"Too many arguments\\n\");\n\n        usage();\n\n        exit(1);\n\n    } else if (argc >= 2) {\n\n        size0 = getul (argv[1], \"<basic_size>\");\n\n        if (argc == 3) {\n\n          tmp_addr = getul (argv[2], \"<address>\");\n\n          addr = (char*) tmp_addr;\n\n        }\n\n    } else {\n\n      addr = 0;\n\n    }\n\n    (void) set_handler (SIGINT, clean_up, (void *) NULL);\n\n    (void) set_handler (SIGTERM, clean_up, (void *) NULL);\n\n\n\n    if (size0 != 0) {\n\n        if ((shmid1 = shmget(10, size0, IPC_CREAT | IPC_EXCL | 0777)) < 0) {\n\n            perror(\"Getting basic shm segment\");\n\n            ok = 0;\n\n        }\n\n        if ((addr0 = (char *)shmat(shmid1, addr, 0)) == (char *)-1) {\n\n            perror(\"Attaching basic shm segment\");\n\n            ok = 0;\n\n        }\n\n\n\n        if (! ok) {\n\n            exit (1);\n\n        } else {\n\n            printf(\"Basic shared memory segment (size 0x%lx) at address: %p\\n\",\n\n                   (unsigned long) size0, addr0);\n\n            printf (\"Hit Ctrl C to clean\\n\");\n\n            while (TRUE) {\n\n                sleep (1);\n\n            }\n\n        }\n\n    }\n\n\n\n\n\n    if ((shmid1 = shmget(10, 1, IPC_CREAT | IPC_EXCL | 0777)) < 0) {\n\n        perror(\"Getting first shm segment\");\n\n        exit (1);\n\n    }\n\n\n\n    if ((shmid2 = shmget(11, 1, IPC_CREAT | IPC_EXCL | 0777)) < 0) {\n\n        perror(\"Getting second shm segment\");\n\n        ok = 0;\n\n    }\n\n\n\n    if ((addr1 = (char *)shmat(shmid1, 0, 0)) == (char *)-1) {\n\n        perror(\"Attaching first shm segment\");\n\n        ok = 0;\n\n    }\n\n\n\n    if ((addr2 = (char *)shmat(shmid2, 0, 0)) == (char *)-1) {\n\n        perror(\"Attaching second shm segment\");\n\n        ok = 0;\n\n    }\n\n\n\n    if (shmdt(addr1) < 0) {\n\n        perror(\"Detaching first shm segment\");\n\n        ok = 0;\n\n    }\n\n\n\n    if (shmdt(addr2) < 0) {\n\n        perror(\"Detaching second shm segment\");\n\n        ok = 0;\n\n    }\n\n\n\n    if (shmctl(shmid2, IPC_RMID, NULL) < 0) {\n\n        perror(\"Removing second shm segment\");\n\n        ok = 0;\n\n    }\n\n\n\n    if (! ok) {\n\n        clean_up(-1);\n\n    } else {\n\n        printf(\"The system would attach the first shared memory segment at address: %p\\n\", addr1);\n\n    }\n\n\n\n    interval = addr2 - addr1;\n\n    if (interval < 0) {\n\n        /* Address of 2nd shm segment lower than first */\n\n        interval = -interval;\n\n        addr  = addr1;\n\n        addr1 = addr2;\n\n        addr2 = addr;\n\n        increasing = 0;\n\n    } else {\n\n        increasing = 1;\n\n    }\n\n\n\n    printf(\"The shared memory address interval of the system is probably : 0x%X - \", interval);\n\n    if (increasing) {\n\n        printf(\"Increasing\\n\");\n\n    } else {\n\n        printf(\"Decreasing\\n\");\n\n    }\n\n\n\n    printf (\"Hit Return for a dump of all addresses \");\n\n    (void) getchar();\n\n\n\n    printf(\"\\nThe following valid shared memory addresses were also found:\\n\");\n\n    for (addr = addr2; addr != addr1; addr = addr + interval) {\n\n        if (addr == (char *)shmat(shmid1, (char *)addr, 0)) {\n\n            printf(\"%p\\n\", addr);\n\n            if (shmdt(addr) < 0) {\n\n                perror(\"Detaching shm\");\n\n                ok = 0;\n\n                break;\n\n            }\n\n            valid_shmaddr++;\n\n        }\n\n    }\n\n    if (! ok) {\n\n        clean_up(-1);\n\n    } else {\n\n        printf(\"\\n\");\n\n        printf(\"%d valid shared memory addresses found (first not included)\\n\", valid_shmaddr);\n\n    }\n\n\n\n    clean_up(SIGTERM);\n\n}\n\n\n", "#include <stdio.h>\n\n#include <libgen.h>\n\n#include <string.h>\n\n#include <errno.h>\n\n#include <unistd.h>\n\n#include <stdlib.h>\n\n#include <fcntl.h>\n\n#include <sys/types.h>\n\n#include <sys/stat.h>\n\n\n\nstatic void Close (int fd) {\n\n  if (fd != 0) (void) close (fd);\n\n}\n\n\n\n#define BLK_SZ 1024\n\n\n\nint main (int argc, char *argv[]) {\n\n\n\n  char *me = basename (argv[0]);\n\n  int sfd, dfd;\n\n  int res;\n\n  off_t offset;\n\n  size_t rsize, wsize;\n\n  char buffer[BLK_SZ];\n\n  char *ifm, *ofm;\n\n\n\n  /* 1 arg : dest file */\n\n  /* 2 args: source file, dest file */\n\n  if (argc == 2) {\n\n    ifm = NULL;\n\n    ofm = argv[1];\n\n  } else if (argc == 3) {\n\n    ifm = argv[1];\n\n    ofm = argv[2];\n\n  } else {\n\n    fprintf (stderr, \"Usage: %s [ <source_file> ] <destination_file>\\n\", me);\n\n    exit (1);\n\n  }\n\n\n\n  /* Open source file for reading */\n\n  if ( (ifm == NULL) || (strcmp (ifm, \"-\") == 0) ) {\n\n    sfd = 0;\n\n  } else {\n\n    for (;;) {\n\n      sfd = open (ifm, O_RDONLY, 0);\n\n      if ( (sfd >= 0) || (errno != EINTR) ) break;\n\n    }\n\n    if (sfd < 0) {\n\n      fprintf (stderr, \"%s: Cannot open file %s for reading -> %s\\n\",\n\n               me, ifm, strerror(errno));\n\n      exit (2);\n\n    }\n\n  }\n\n\n\n  /* Open dest file for writting (not append, cause we need to lock */\n\n  for (;;) {\n\n    dfd = open (ofm, O_RDWR, 0);\n\n    if ( (dfd >= 0) || (errno != EINTR) ) break;\n\n  }\n\n  if (dfd < 0) {\n\n    fprintf (stderr, \"%s: Cannot open file %s for writting -> %s\\n\",\n\n             me, ofm, strerror(errno));\n\n    Close (sfd);\n\n    exit (3);\n\n  }\n\n\n\n  /* Lock dest file */\n\n  for (;;) {\n\n    res = lockf (dfd, F_LOCK, 0);\n\n    if ( (res != 0) || (errno != EINTR) ) break;\n\n  }\n\n  if (res != 0) {\n\n    fprintf (stderr, \"%s: Cannot lock file %s for appending -> %s\\n\",\n\n             me, ofm, strerror(errno));\n\n    (void) Close (sfd);\n\n    (void) close (dfd);\n\n    exit (3);\n\n  }\n\n\n\n  /* Prepare dest for append */\n\n  for (;;) {\n\n    offset = lseek (dfd, 0, SEEK_END);\n\n    if ( (offset != (off_t) -1) || (errno != EINTR) ) break;\n\n  }\n\n  if (offset == (off_t) -1) {\n\n    fprintf (stderr, \"%s: Cannot seek file %s for appending -> %s\\n\",\n\n             me, ofm, strerror(errno));\n\n    (void) Close (sfd);\n\n    (void) close (dfd);\n\n    exit (3);\n\n  }\n\n\n\n  /* Copy */\n\n  for (;;) {\n\n\n\n    /* Read */\n\n    for (;;) {\n\n      rsize = read (sfd, buffer, BLK_SZ);\n\n      if ( (rsize != (size_t) -1) || (errno != EINTR) ) break;\n\n    }\n\n    if (rsize == (size_t) -1) {\n\n      fprintf (stderr, \"%s: Cannot read from file %s -> %s\\n\",\n\n               me, ifm, strerror(errno));\n\n      (void) Close (sfd);\n\n      (void) close (dfd);\n\n      exit (2);\n\n    }\n\n\n\n    /* Write */\n\n    for (;;) {\n\n      wsize = write (dfd, buffer, rsize);\n\n      if ( (wsize != (size_t) -1) || (errno != EINTR) ) break;\n\n    }\n\n    if (wsize != rsize) {\n\n      fprintf (stderr, \"%s: Cannot write to file %s -> %s\\n\",\n\n               me, ofm, strerror(errno));\n\n      (void) Close (sfd);\n\n      (void) close (dfd);\n\n      exit (3);\n\n    }\n\n\n\n    /* Done when full block could not be read */\n\n    if (rsize != BLK_SZ) {\n\n      break;\n\n    }\n\n  }\n\n\n\n\n\n  /* Rewind and unlock if possible */\n\n  offset = lseek (dfd, 0, SEEK_SET);\n\n  if (offset != (off_t) -1) {\n\n    (void) lockf (dfd, F_ULOCK, 0);\n\n  }\n\n\n\n  /* Close */\n\n  (void) Close (sfd);\n\n  (void) close (dfd);\n\n\n\n  /* Done */\n\n  exit (0);\n\n\n\n}\n\n\n", "/* Use /proc/pid/maps to measure memory heap allocated to a process,\n\n   given its pid: a segment with empty path (entry with only 5 fields)\n\n   and with perms (field 2) not \"----\".\n\n   Field 1 is <start_addr>-<end_addr> so the segment size is the substraction.\n\n   Sum the overall size of these segments (in bytes)\n\n   Show <pid> <heap> <cmdline>\n\n   On option (-d <delta>), show it each <delta> seconds (delta is int or float)\n\n */\n\n#include <stdio.h>\n\n#include <stdlib.h>\n\n#include <sys/types.h>\n\n#include <string.h>\n\n#include <limits.h>\n\n#include <time.h>\n\n\n\n#include \"timeval.h\"\n\n#include \"get_line.h\"\n\n\n\n/* Max size of command line */\n\n#define CMDLINE_SIZE 2014\n\n\n\n/* Compute the heap size once */\n\nstatic unsigned long hsize (pid_t pid) {\n\n  char file_name[1024];\n\n  char line[1024];\n\n  char *addrs, *perms, *path;\n\n  int i, got;\n\n  FILE *file;\n\n  unsigned long addr1, addr2;\n\n  unsigned long size;\n\n\n\n#define NEXT_SPACE while ((line[i] != ' ') && (line[i] != '\\0')) i++\n\n#define SKIP_SPACES while (line[i] == ' ') i++\n\n\n\n  /* Open maps */\n\n  sprintf(file_name, \"/proc/%d/maps\", pid);\n\n  file = fopen (file_name, \"r\");\n\n  if (file == NULL) {\n\n    return 0;\n\n  }\n\n\n\n  /* Scan each line */\n\n  size = 0;\n\n  for (;;) {\n\n    got = get_line (file, line, sizeof(line));\n\n    /* end of file? */\n\n    if (got == -1) break;\n\n\n\n    /* Parse addresses */\n\n    i = 0;\n\n    addrs = line;\n\n    NEXT_SPACE;\n\n    line[i] = '\\0';\n\n    i++;\n\n    SKIP_SPACES;\n\n    /* Parse perms */\n\n    perms=&line[i];\n\n    NEXT_SPACE;\n\n    line[i] = '\\0';\n\n    i++;\n\n    SKIP_SPACES;\n\n    /* Skip offset, dev, inod */\n\n    NEXT_SPACE; SKIP_SPACES;\n\n    NEXT_SPACE; SKIP_SPACES;\n\n    NEXT_SPACE;\n\n    if (line[i] == '\\0') {\n\n      /* No path at all (usually the inode is followed by a space) */\n\n      path = NULL;\n\n    } else {\n\n      SKIP_SPACES;\n\n      path=&line[i];\n\n    }\n\n#ifdef DEBUG\n\n      printf (\">%s< >%s< >%s<\\n\", addrs, perms, path);\n\n#endif\n\n\n\n    /* Check if line matches: no path or [heap] and perms != '----' */\n\n    if ( (path == NULL) || (strcmp (path, \"\") == 0)\n\n                        || (strcmp (path, \"[heap]\") == 0) ) {\n\n      if (strcmp (perms, \"----\") != 0) {\n\n        /* OK, matches */\n\n        sscanf (addrs, \"%lx-%lx\", &addr1, &addr2);\n\n#ifdef DEBUG\n\n        printf (\"  %lx - %lx = %lx\\n\", addr1, addr2, addr2 - addr1);\n\n#endif\n\n        size += addr2 - addr1;\n\n      }\n\n    }\n\n  }\n\n\n\n  /* Done */\n\n  fclose(file);\n\n  return size;\n\n\n\n}\n\n\n\n/* Error and Usage */\n\nstatic void error (const char *msg) __attribute__ ((noreturn));\n\n\n\nstatic void error (const char *msg) {\n\n  if ( (msg != NULL) && (strlen(msg) != 0) ) {\n\n    fprintf(stderr, \"ERROR: %s.\\n\", msg);\n\n  }\n\n  fprintf(stderr, \"Usage: mheap [ -d <delta> ] <pid>\\n\");\n\n  exit(1);\n\n}\n\n\n\nint main (int argc, char *argv[]) {\n\n  /* The pid and command line of the scanned process */\n\n  pid_t pid;\n\n  float delta;\n\n  char cmd_line[CMDLINE_SIZE];\n\n  char file_name[1024];\n\n  char msg[2048];\n\n  FILE *file;\n\n  unsigned long size;\n\n  timeout_t curr_time, delta_time, next_time;\n\n  char str_time[27];\n\n\n\n  /* Parse arguments */\n\n  if (argc == 2) {\n\n    delta = 0.0;\n\n  } else if ( (argc == 4) && (strcmp (argv[1], \"-d\") == 0) ) {\n\n    delta = -1.0;\n\n    sscanf (argv[2], \"%f\", &delta);\n\n  } else {\n\n    error(\"Invalid arguments\");\n\n  }\n\n  if (delta < 0.0) {\n\n    error (\"Invalid delta\");\n\n  }\n\n\n\n  /* Parse pid */\n\n  pid = (pid_t) strtoul(argv[argc-1], NULL, 10);\n\n  if ( (pid <= 0) || ((unsigned long) pid == ULONG_MAX) ) {\n\n    error(\"Invalid <pid> value\");\n\n  }\n\n\n\n  /* Get delta */\n\n  double_to_time ((double) delta, &delta_time);\n\n\n\n  /* Get command line (check pid is running) */\n\n  sprintf(file_name, \"/proc/%d/cmdline\", pid);\n\n  file = fopen (file_name, \"r\");\n\n  if (file == NULL) {\n\n    sprintf(msg, \"Cannot open file %s, pid %d is probably not running\",\n\n            file_name, pid);\n\n    error(msg);\n\n  }\n\n  fscanf (file, \"%s\", cmd_line);\n\n\n\n  /* Loop on all outputs */\n\n  get_time (&next_time);\n\n  for (;;) {\n\n    /* Get and put time and size */\n\n    size = hsize(pid);\n\n    if (size == 0) break;\n\n\n\n    get_time(&curr_time);\n\n    (void) image(&curr_time, str_time);\n\n    str_time[23] = '\\0';\n\n    printf(\"%s %d %20lu %s\\n\", str_time, pid, size, cmd_line);\n\n\n\n    /* Done if no iteration */\n\n    if (delta <= 0.0) break;\n\n\n\n    /* Sleep until next expiration */\n\n    add_time (&next_time, &delta_time);\n\n    wait_until (&next_time);\n\n  }\n\n\n\n  /* Done */\n\n  exit(0);\n\n}\n\n\n", "#include <time.h>\n\n#include <stdio.h>\n\n#include <stdlib.h>\n\n#include <unistd.h>\n\n\n\nint main (void) {\n\n\n\n  time_t t1, t2;\n\n  struct tm *ptm;\n\n\n\n  t1 = time(&t2);\n\n\n\n  printf (\"time %d %d\\n\", (int)t1, (int)t2);\n\n\n\n  ptm = localtime(&t1);\n\n\n\n  printf (\"localtime %d:%d\\n\", ptm->tm_hour, ptm->tm_min);\n\n\n\n  exit (0);\n\n}\n", "#include <stdio.h>\n\n#include <unistd.h>\n\n#include <string.h>\n\n#include <ctype.h>\n\n#include <stdlib.h>\n\n\n\n#include \"boolean.h\"\n\n#include \"socket.h\"\n\n\n\nstatic void usage (void) {\n\n  fprintf (stderr, \"ERROR. Only one argument, host name or ip address, accepted\\n\");\n\n}\n\n\n\nint main (int argc, char *argv[]) {\n\n\n\n  soc_host host;\n\n  boolean ip_addr;\n\n  int ndots;\n\n  int i;\n\n  char *p;\n\n  char addr[500];\n\n  int res;\n\n\n\n  if (argc != 2) {\n\n    usage();\n\n    exit(2);\n\n  }\n\n\n\n  ip_addr = TRUE;\n\n  ndots = 0;\n\n\n\n  for (i = 0; i < (int)strlen(argv[1]); i++) {\n\n    if (argv[1][i] == '.') {\n\n      ndots ++;\n\n    } else if (! isdigit(argv[1][i])) {\n\n      ip_addr = FALSE;\n\n    }\n\n  }\n\n\n\n  if (ip_addr && (ndots != 3)) {\n\n    usage();\n\n  }\n\n\n\n\n\n  if (ip_addr) {\n\n    strcpy (addr, argv[1]);\n\n    p = addr;\n\n    ndots = 0;\n\n    for (i = 0; i < (int)strlen(argv[1]); i++) {\n\n      if (addr[i] == '.') {\n\n        addr[i] = '\\0';\n\n        host.bytes[ndots] = atoi(p);\n\n        p = &(addr[i+1]);\n\n        ndots++;\n\n      }\n\n    }\n\n    host.bytes[ndots] = atoi(p);\n\n\n\n    printf(\"Looking for ip addr: \");\n\n    for (i = 0; i <= 3; i++) {\n\n      printf(\"%d\", (int)host.bytes[i]);\n\n      if (i != 3) {\n\n        printf(\".\");\n\n      }\n\n    }\n\n    printf(\"\\n\");\n\n    res = soc_host_name_of (&host, addr, sizeof(addr));\n\n    if (res != SOC_OK) {\n\n      fprintf (stderr, \"soc_host_name_of -> %d\\n\", res);\n\n      exit (1);\n\n    } else {\n\n      printf (\"Got: %s\\n\", addr);\n\n    }\n\n  } else {\n\n    printf(\"Looking for host name: %s\\n\", argv[1]);\n\n    res = soc_host_of (argv[1], &host);\n\n    if (res != SOC_OK) {\n\n      fprintf (stderr, \"soc_host_of -> %d\\n\", res);\n\n      exit (1);\n\n    } else {\n\n      printf(\"Got: \");\n\n      for (i = 0; i <= 3; i++) {\n\n        printf(\"%d\", (int)host.bytes[i]);\n\n        if (i != 3) {\n\n          printf(\".\");\n\n        }\n\n      }\n\n      printf(\"\\n\");\n\n    }\n\n\n\n  }\n\n  exit (0);\n\n}\n\n\n\n\n", "/*----------------------------------------------------------------------------*/\n\n/* Ver | Date     | Who        | What                                         */\n\n/*----------------------------------------------------------------------------*/\n\n/* 2.4 | 19980701 | P. Malaise | Manage input key 7f as 08 (dos.c)            */\n\n/*     |          |            | If EscA in search, no reset of length,       */\n\n/*     |          |            |  prev string is kept                         */\n\n/* 2.5 | 19980818 | P. Malaise | Display offset                               */\n\n/* 2.6 | 19990310 | P. Malaise | Port to AIX (MU_PAGE_SIZE)                   */\n\n/* 2.7 | 19990325 | P. Malaise | Bold->norm does not erase all the characater */\n\n/* 2.8 | 19990711 | P. Malaise | Main returns int                             */\n\n/* 2.9 | 20000127 | P. Malaise | Fix many warnings                            */\n\n/* 2.A | 20110329 | P. Malaise | Add getenv of unprintable character          */\n\n/* 2.B | 20120726 | P. Malaise | Support file length larger than 31 bits      */\n\n/*----------------------------------------------------------------------------*/\n\n#include <fcntl.h>\n\n#include <errno.h>\n\n#include <stdio.h>\n\n#include <stdlib.h>\n\n#include <string.h>\n\n#include <unistd.h>\n\n#include <ctype.h>\n\n\n\n#include \"vt100.h\"\n\n\n\n#define TITLE \"Malaise utilities - V2.B -->\"\n\n#define USAGE \"Usage : mu [-r] file\\n\"\n\n\n\n#define ABORT(str) (printf (\"%s\\n\", str), exit(1))\n\n\n\n#define MU_PAGE_SIZE 256\n\n\n\ntypedef enum {true=1, false=0} boolean;\n\ntypedef unsigned char byte;\n\n\n\n/* Char for unprintable code */\n\nchar default_unprintable='~';\n\nchar *unprintable=&default_unprintable;\n\n\n\n/* File name and descriptor */\n\nstatic char *file_name;\n\nstatic int  file_des;\n\n\n\n/* Number of bytes of the file */\n\nstatic long long file_size;\n\n\n\n/* Last page no 1 .. */\n\nstatic unsigned int last_page;\n\n/* Current page no 1 .. last_page */\n\nstatic unsigned int current_page;\n\n\n\n/* Last of last and current page */\n\nstatic unsigned short last_page_size;\n\nstatic unsigned short current_page_size;\n\n\n\n/* Current copy of page */\n\nstatic byte tab[MU_PAGE_SIZE];\n\n\n\n/* Current pos in page */\n\nstatic unsigned short pos;\n\n\n\n/* First or second hexa digit */\n\nstatic boolean first_hexa;\n\n\n\n/* In hexa or ascii side */\n\nstatic boolean hexa_side;\n\n\n\n/* Current page modified */\n\nstatic boolean modified;\n\n\n\n/* Message to erased at next input */\n\nstatic boolean to_erase;\n\n\n\n/* Can mu write on file (can modify) */\n\nstatic boolean can_modify;\n\n\n\n/* SCREEN ****************************************************************/\n\n\n\nstatic void mvprint (int x, int y, const char chaine1[]) {\n\n  gotoxy (x, y);\n\n  cprintf (\"%s\", chaine1);\n\n}\n\n\n\n/* Unused\n\n * static void mvprints (int x, int y, short num) {\n\n *   char str[9];\n\n *   short l = 0;\n\n *\n\n *   if (num < 0)   {str[l ++] = '-'; num = - num;}\n\n *   if (num > 9999) str[l ++] = (num / 10000) + 48;\n\n *   if (num > 999)  str[l ++] = ((num % 10000)/ 1000) + 48;\n\n *   if (num > 99)   str[l ++] = ((num % 1000)/ 100) + 48;\n\n *   if (num > 9)    str[l ++] = ((num % 100) / 10) + 48;\n\n *   str[l ++] = (num % 10) + 48;\n\n *\n\n *   str[l] = '\\0';\n\n *   mvprint (x, y, str);\n\n * }\n\n */\n\n\n\n/* TITLE *****************************************************************/\n\n\n\n#define FILE_NAME_LEN 25\n\n#define PREFIX \"... \"\n\nstatic void title (void) {\n\n  char printed_file_name [FILE_NAME_LEN];\n\n  char *p;\n\n\n\n  if (strlen(file_name) < FILE_NAME_LEN) {\n\n    strcpy (printed_file_name, file_name);\n\n  } else {\n\n    p = file_name + strlen(file_name) - (FILE_NAME_LEN-1);\n\n    strcpy (printed_file_name, p);\n\n    memcpy (printed_file_name, PREFIX, strlen(PREFIX));\n\n  }\n\n\n\n  mvprint (1,  9,\"Page\");\n\n  mvprint (1, 25, TITLE);\n\n  if (!can_modify) {\n\n    highvideo ();\n\n  }\n\n  mvprint (1, 55, printed_file_name);\n\n  lowvideo();\n\n  mvprint (2, 25, \"Esc -> Find Page Save Undo eXit Quit Home End A Z\");\n\n  mvprint (3, 25, \"Tab - Arrows - Ctrl : Nextpage/Prevpage\");\n\n}\n\n\n\n\n\n\n\nstatic void usage (void) {\n\n\n\n  printf (USAGE);\n\n}\n\n\n\n\n\n/* FILE ******************************************************************/\n\n\n\nstatic long file_pos (unsigned int page, unsigned short pos) {\n\n  return (MU_PAGE_SIZE * ((long) page - 1L) + pos);\n\n}\n\n\n\nstatic void read_file (void) {\n\n\n\n  lseek (file_des, file_pos (current_page, 0), SEEK_SET);\n\n\n\n  read (file_des, tab, current_page_size);\n\n\n\n}\n\n\n\nstatic void write_file (void) {\n\n  lseek (file_des, file_pos (current_page, 0), SEEK_SET);\n\n\n\n  write (file_des, tab, current_page_size);\n\n\n\n}\n\n\n\nstatic void open_file (void) {\n\n\n\n  file_des = open (file_name, O_RDWR);\n\n  if (file_des == -1) {\n\n    can_modify = false;\n\n    file_des = open (file_name, O_RDONLY);\n\n    if (file_des == -1) {\n\n      printf (\"Can't open file \\\"%s\\\"\\n\", file_name);\n\n      perror (\"open\");\n\n      usage ();\n\n      exit (0);\n\n    }\n\n  }\n\n\n\n  file_size = filelength (file_des);\n\n  if (file_size == 0) {\n\n    printf (\"Empty file \\\"%s\\\"\\n\", file_name);\n\n    exit (0);\n\n  }\n\n\n\n  last_page      = (file_size-1) / MU_PAGE_SIZE + 1;\n\n  last_page_size = (file_size-1) % MU_PAGE_SIZE + 1;\n\n\n\n}\n\n\n\nstatic void write_modif (void);\n\nstatic void display_page (void);\n\nstatic boolean confirm (char yes, char no);\n\n\n\n/* MOVEMENT **************************************************************/\n\n\n\nstatic void new_page (void) {\n\n\n\n  if (current_page != last_page)\n\n    current_page_size = MU_PAGE_SIZE;\n\n  else\n\n    current_page_size = last_page_size;\n\n}\n\n\n\n\n\nstatic void page_down (void) {\n\n\n\n  write_modif ();\n\n\n\n  if (current_page < last_page)\n\n    current_page ++;\n\n  else\n\n    current_page = 1;\n\n\n\n  new_page ();\n\n  read_file ();\n\n  display_page ();\n\n  if (pos >= current_page_size) pos = current_page_size -1;\n\n}\n\n\n\nstatic void page_up (void) {\n\n\n\n  write_modif ();\n\n\n\n  if (current_page > 1)\n\n    current_page --;\n\n  else\n\n    current_page = last_page;\n\n\n\n  new_page ();\n\n  read_file ();\n\n  display_page ();\n\n  if (pos >= current_page_size) pos = current_page_size -1;\n\n}\n\n\n\nstatic void g_first_page (void) {\n\n\n\n  write_modif ();\n\n\n\n  current_page = 1;\n\n\n\n  new_page ();\n\n  read_file ();\n\n  display_page ();\n\n\n\n  pos = 0;\n\n}\n\n\n\nstatic void g_last_page (void) {\n\n\n\n  write_modif ();\n\n\n\n  current_page = last_page;\n\n\n\n  new_page ();\n\n  read_file ();\n\n  display_page ();\n\n\n\n  pos = 0;\n\n}\n\n\n\n\n\nstatic void movement (short dx, short dy) {\n\n\n\n  first_hexa = true;\n\n\n\n  if ((short)pos + dy + 16 * dx >= MU_PAGE_SIZE) {\n\n    pos = ((short)pos + dy + 16 * dx) % MU_PAGE_SIZE;\n\n    page_down ();\n\n  } else if ((short)pos + dy + 16 * dx < 0) {\n\n    pos = ((short)pos + dy + 16 * dx + MU_PAGE_SIZE) % MU_PAGE_SIZE;\n\n    page_up ();\n\n  } else if ((short)pos + dy + 16 * dx >= current_page_size) {\n\n    /* End of file */\n\n    if (dy == 1) {\n\n      pos = 0;\n\n    } else {\n\n      pos = pos % 16;\n\n    }\n\n    page_down ();\n\n  } else {\n\n    pos = (short)pos + dy + 16 * dx;\n\n  }\n\n}\n\n\n\nstatic void home_mvt (void) {\n\n\n\n  pos = 0;\n\n}\n\n\n\nstatic void end_mvt (void) {\n\n\n\n  pos = current_page_size - 1;\n\n}\n\n/* PRINT PAGE ************************************************************/\n\n\n\nstatic void move_to_hexa (unsigned short p, boolean first_digit) {\n\n  int x, y;\n\n\n\n  x = p / 16 + 5;\n\n  y = (p % 16) * 3 + 5 + (p % 16 > 7 ? 3 : 0);\n\n  if (! first_digit) {\n\n    y ++;\n\n  }\n\n  gotoxy (x, y);\n\n}\n\n\n\nstatic void move_to_ascii (unsigned short p) {\n\n  int x, y;\n\n\n\n  x = p / 16 + 5;\n\n  y = p % 16 + 60;\n\n  gotoxy (x, y);\n\n}\n\n\n\nstatic void move_to (unsigned short p, boolean hexa, boolean first_digit) {\n\n\n\n  if (hexa) {\n\n    move_to_hexa (p, first_digit);\n\n  } else {\n\n    move_to_ascii (p);\n\n  }\n\n}\n\n\n\n\n\nstatic void display_data (unsigned short p, boolean hexa, byte b) {\n\n\n\n  move_to (p, hexa, true);\n\n\n\n  if (hexa) {\n\n    cprintf (\"%02X \", b);\n\n  } else {\n\n    if ( (b > 0x1F) && (b < 0x7F) )\n\n      cprintf(\"%c\", b);\n\n    else\n\n      cprintf(\"%s\", unprintable);\n\n  }\n\n}\n\n\n\nstatic void display_page_num (void) {\n\n\n\n  gotoxy (2, 3);\n\n  cprintf (\"%6d / %d\", current_page, last_page);\n\n}\n\n\n\nstatic void display_pos (void) {\n\n  gotoxy (3, 3);\n\n  cprintf (\"Pos: 0x%012lX\", file_pos(current_page, pos));\n\n}\n\n\n\nstatic void display_page (void) {\n\n  int i;\n\n\n\n  for (i = 0; i < current_page_size; i ++) {\n\n    display_data (i, true,  tab[i]);\n\n    display_data (i, false, tab[i]);\n\n  }\n\n  for (i = current_page_size; i < MU_PAGE_SIZE; i ++) {\n\n    move_to (i, true,  true);  cprintf (\"  \");\n\n    move_to (i, false,  true); cprintf (\" \");\n\n  }\n\n  display_page_num ();\n\n\n\n}\n\n\n\nstatic void modify_page_hex (char car) {\n\n\n\n  if (!can_modify) return;\n\n\n\n  if (first_hexa)\n\n    tab[pos] = tab[pos] % 16\n\n             + ((car >= '0' && car <= '9') ? (car - '0') * 16 : (car - 'A' + 10) * 16);\n\n  else\n\n    tab[pos] = (tab[pos] / 16) * 16\n\n            + ((car >= '0' && car <= '9') ? (car - '0') : (car - 'A' + 10));\n\n\n\n  highvideo ();\n\n  display_data (pos, true,  tab[pos]);\n\n  display_data (pos, false, tab[pos]);\n\n  lowvideo();\n\n\n\n  if (!first_hexa) {\n\n    if (pos < (current_page_size - 1) ) pos ++;\n\n  }\n\n\n\n  first_hexa = ! first_hexa;\n\n\n\n  modified = true;\n\n}\n\n\n\nstatic void modify_page_asc (char car) {\n\n\n\n  if (!can_modify) return;\n\n\n\n  tab[pos] = car;\n\n\n\n  highvideo();\n\n  display_data (pos, true,  tab[pos]);\n\n  display_data (pos, false, tab[pos]);\n\n  lowvideo();\n\n\n\n  if (pos < (current_page_size - 1) ) pos ++;\n\n\n\n  modified = true;\n\n}\n\n\n\nstatic void write_modif (void) {\n\n\n\n  if (! modified) return;\n\n\n\n  mvprint (22, 10, \"Modif. exists !!! Write (y/n) ? \");\n\n\n\n  if (!confirm('Y', 'N')) {\n\n    read_file ();\n\n    display_page ();\n\n  } else {\n\n    write_file ();\n\n  }\n\n\n\n  mvprint (22, 10, \"                                \");\n\n\n\n  modified = false;\n\n  display_page ();\n\n}\n\n\n\n/* USER INPUT ************************************************************/\n\n\n\nstatic char get_asc (void) {\n\n  char c;\n\n\n\n  c = read_char();\n\n  if (to_erase) {\n\n    mvprint (22, 10, \"                          \");\n\n    to_erase = false;\n\n  }\n\n  return (c);\n\n}\n\n\n\nstatic boolean confirm (char yes, char no) {\n\n  char car;\n\n\n\n  yes = (char)toupper((int)yes);\n\n  no = (char)toupper((int)no);\n\n  do {\n\n    car = (char)toupper((int)get_asc());\n\n  } while ( (car != yes) && (car != no) && ((int)car != 20) );\n\n  return (car == yes);\n\n}\n\n\n\n/* PAGE & FIND ****************************************************************/\n\n\n\n#define STR_PAGE_LEN 11\n\n\n\nstatic void goto_page (void) {\n\n  char str[STR_PAGE_LEN], car;\n\n  int i, ii;\n\n\n\n  write_modif ();\n\n\n\n  for (ii = 0; ii < STR_PAGE_LEN - 1; ii ++) str[ii] = ' ';\n\n  str[STR_PAGE_LEN - 1] = '\\0';\n\n\n\n  mvprint (22, 10, \"Enter page number (or Esc Clear, or Esc Abort) : \");\n\n\n\n  i = 0;\n\n\n\n  for (; ;) {\n\n    gotoxy (22, 59 + i);\n\n    car = get_asc();\n\n    if (car == 13) {\n\n      break;\n\n    } else if (car == 20) {\n\n      i = 0;\n\n      break;\n\n    } else if (car == 21) {\n\n      i = 0;\n\n      for (ii = 0; ii < STR_PAGE_LEN - 1; ii ++) str[ii] = ' ';\n\n    } else if (car == 8) {\n\n        if (i > 0) {\n\n          i --;\n\n          str[i] = ' ';\n\n        }\n\n    } else if ( (car >= '0') && (car <= '9') ) {\n\n      if (i != 10) {\n\n        str[i] = car;\n\n        i ++;\n\n      }\n\n    }\n\n\n\n    mvprint (22, 59, str);\n\n  }\n\n\n\n  mvprint (22, 10, \"                                                           \");\n\n\n\n  if (i == 0) return;\n\n\n\n  str[i] = '\\0';\n\n  i = atoi (str);\n\n\n\n  if ( (i >= 1) && ((unsigned int)i <= last_page) ) {\n\n    current_page = i;\n\n    new_page ();\n\n\n\n    pos = 0;\n\n    first_hexa = true;\n\n\n\n    read_file ();\n\n    display_page ();\n\n  } else {\n\n    mvprint (22, 10, \"No such page !!!\");\n\n    to_erase = true;\n\n  }\n\n\n\n}\n\n\n\nstatic int to_val (char car) {\n\n\n\n  if ( (car >= 'A') && (car <= 'F') ) {\n\n    return ((int) (car - 'A') + 10);\n\n  } else if ( (car >= '0') && (car <= '9') ) {\n\n    return ((int) (car - '0'));\n\n  } else {\n\n    return (-1);\n\n  }\n\n}\n\n\n\n#define STR_FIND_LEN 60\n\n\n\nstatic byte read_byte (long file_index) {\n\n\n\n  if (file_index % MU_PAGE_SIZE == 0) {\n\n    current_page = file_index / MU_PAGE_SIZE + 1;\n\n    new_page ();\n\n    read_file ();\n\n    display_page_num ();\n\n  }\n\n  pos = file_index % MU_PAGE_SIZE;\n\n  return (tab[pos]);\n\n}\n\n\n\nstatic void find_loop (byte *template, unsigned length) {\n\n  /* Previous position if not found */\n\n  unsigned int page_sav;\n\n  unsigned short pos_sav;\n\n\n\n  /* Pos_file is the index in file (0 .. size-1) of read_str[0] */\n\n  long pos_file, file_index;\n\n  byte read_str[(STR_FIND_LEN / 3) * 2];\n\n  int curi;\n\n  int i;\n\n\n\n  /* Check length */\n\n  pos_file = file_pos (current_page, pos);\n\n  if ((long long)pos_file + (long long)length > file_size) {\n\n    mvprint (22, 10, \"Not found !!!\");\n\n    to_erase = true;\n\n    beep (3, 3000);\n\n    return;\n\n  }\n\n\n\n  mvprint (22, 10, \"Searching ...\");\n\n\n\n  /* Save current position */\n\n  page_sav = current_page;\n\n  pos_sav = pos;\n\n\n\n  /* Read first bloc */\n\n  lseek (file_des, pos_file, SEEK_SET);\n\n  for (i = 0, file_index = pos_file; (unsigned)i < length; i ++, file_index ++) {\n\n    read_str[i] = read_byte(file_index);\n\n    read_str[length + i] = read_str[i];\n\n  }\n\n  curi = 0;\n\n\n\n  for (;;) {\n\n    if (memcmp (&read_str[curi], template, length) == 0) {\n\n      /* Beginning of found string */\n\n      pos = pos_file % MU_PAGE_SIZE;\n\n      current_page = pos_file / MU_PAGE_SIZE + 1;\n\n      pos_sav = pos;\n\n      page_sav = current_page;\n\n\n\n      /* Show found string */\n\n      new_page ();\n\n      read_file ();\n\n      display_page ();\n\n      display_pos ();\n\n\n\n      /* Restore file index */\n\n      lseek (file_des, file_index, SEEK_SET);\n\n\n\n      mvprint (22, 10, \"Next/Quit ?     \");\n\n\n\n      /* To move to found data */\n\n      move_to (pos, hexa_side, true);\n\n      beep (1, 1000);\n\n\n\n      if (!confirm('N', 'Q')) {\n\n        mvprint (22, 10, \"                 \");\n\n        return;\n\n      }\n\n      mvprint (22, 10, \"Searching ...\");\n\n      display_page_num ();\n\n    }\n\n\n\n    /* Check length */\n\n    if ((long long)file_index >= file_size) {\n\n      current_page = page_sav;\n\n      pos = pos_sav;\n\n      new_page ();\n\n      read_file ();\n\n      display_page ();\n\n      mvprint (22, 10, \"Not found !!!\");\n\n      to_erase = true;\n\n      beep (3, 3000);\n\n      return;\n\n    }\n\n\n\n    /* Next byte */\n\n    read_str[curi] = read_byte (file_index);\n\n    read_str[length + curi] = read_str[curi];\n\n\n\n    /* Shift */\n\n    file_index ++;\n\n    pos_file ++;\n\n    curi ++;\n\n    if ((unsigned)curi == length) curi = 0;\n\n\n\n  }\n\n\n\n}\n\n\n\nstatic unsigned length;\n\nstatic byte strf[STR_FIND_LEN/3];\n\n\n\nstatic void find_seq (void) {\n\n  char stra[STR_FIND_LEN+1], strh[STR_FIND_LEN+1];\n\n  char str[3];\n\n  boolean out, abort, part_last;\n\n  char car;\n\n  byte b;\n\n  int i, j, val, valf, l, ii;\n\n  int llength;\n\n\n\n  /* Save */\n\n  write_modif();\n\n\n\n  /* Init */\n\n  for (ii = 0; ii < STR_FIND_LEN; ii ++) {\n\n    stra[ii] = ' ';\n\n    strh[ii] = ' ';\n\n  }\n\n  stra[STR_FIND_LEN] = '\\0';\n\n  strh[STR_FIND_LEN] = '\\0';\n\n\n\n  /* Init from previous search */\n\n  llength = length;\n\n  for  (ii = 0; ii < llength; ii ++) {\n\n      b = strf[ii];\n\n      if ( (b >= 0x1F) && (b < 0x7F) ) {\n\n          stra[3 * ii + 1] = (char) b;\n\n      } else {\n\n          stra[3 * ii + 1] = '.';\n\n      }\n\n      sprintf (str, \"%02X\", (int)b);\n\n      strh[3 * ii]     = str[0];\n\n      strh[3 * ii + 1] = str[1];\n\n  }\n\n\n\n  j = 0;\n\n  i = llength * 3; l = llength * 3;\n\n\n\n  mvprint (22, 5, \"Enter string, TAB for ascii<->hexa, Esc C to clear, or Esc A to abort :\");\n\n  mvprint (23, 3, \"ASCII\");\n\n  mvprint (24, 3, \"HEXA \");\n\n\n\n  part_last = false;\n\n  out = false;\n\n  abort = false;\n\n\n\n  while (! out) {\n\n    mvprint (23, 10, stra);\n\n    mvprint (24, 10, strh);\n\n\n\n    if (!hexa_side) {\n\n      gotoxy (23, 10 + i + 1);\n\n    } else {\n\n      gotoxy (24, 10 + i + j);\n\n    }\n\n\n\n    car = get_asc ();\n\n    switch (car) {\n\n      case 13:\n\n        /* return */\n\n        if (!part_last) {\n\n          out = true;\n\n          abort = (l == 0);\n\n        }\n\n      break;\n\n\n\n      case 9:\n\n      case 1:\n\n      case 3:\n\n        /* Ascii <-> hexa */\n\n        if (part_last) {\n\n          stra[i+1] = ' ';\n\n          strh[i]   = ' ';\n\n          strh[i+1] = ' ';\n\n          part_last = false;\n\n        }\n\n        hexa_side = ! hexa_side;\n\n        j = 0;\n\n      break;\n\n\n\n      case 20:\n\n        /* Esc A */\n\n        out = true;\n\n        abort = true;\n\n        if (part_last) {\n\n          stra[i+1] = ' ';\n\n          strh[i]   = ' ';\n\n          strh[i+1] = ' ';\n\n        }\n\n      break;\n\n\n\n      case 21:\n\n        /* Esc C */\n\n        part_last = 0;\n\n        i = 0; j = 0; l = 0; llength = 0;\n\n        for (ii = 0; ii < STR_FIND_LEN; ii ++) {\n\n          stra[ii] = ' ';\n\n          strh[ii] = ' ';\n\n        }\n\n\n\n      break;\n\n\n\n      case 8:\n\n      /* Back space */\n\n        if (!hexa_side) {\n\n          if ( (i > 0) && (i == l) ) {\n\n            i -= 3;\n\n            l -= 3;\n\n            stra[i+1] = ' ';\n\n            strh[i]   = ' ';\n\n            strh[i+1] = ' ';\n\n          }\n\n        } else {\n\n          if (j == 0) {\n\n            if ( (i > 0) && (i == l) ) {\n\n              i -= 3;\n\n              l -= 3;\n\n              j = 1;\n\n              stra[i+1] = ' ';\n\n              strh[i+1] = ' ';\n\n              part_last = true;\n\n            }\n\n          } else {\n\n            if (part_last) {\n\n              j = 0;\n\n              strh[i] = ' ';\n\n              part_last = false;\n\n            }\n\n          }\n\n        }\n\n      break;\n\n\n\n      case 2:\n\n        /* Right */\n\n        if (!hexa_side) {\n\n          if (i != l) {\n\n            i += 3;\n\n          }\n\n        } else {\n\n          if (j == 1) {\n\n            if (i != l) {\n\n              i += 3;\n\n              j = 0;\n\n            }\n\n          } else {\n\n            if (strh[i] != ' ') j = 1;\n\n          }\n\n        }\n\n      break;\n\n\n\n      case 4:\n\n        /* Left */\n\n        if (!hexa_side) {\n\n          if (i != 0) {\n\n            i -= 3;\n\n          }\n\n        } else {\n\n          if (j == 0) {\n\n            if (i != 0) {\n\n              if (part_last) {\n\n                str[i+1]  = ' ';\n\n                strh[i]   = ' ';\n\n                strh[i+1] = ' ';\n\n                part_last = false;\n\n              }\n\n              i -= 3;\n\n              j = 1;\n\n            }\n\n          } else {\n\n            j = !j;\n\n          }\n\n        }\n\n      break;\n\n\n\n      default:\n\n        if ( (car >= 0x1F) && (car < 0x7F) ) {\n\n          if (i != STR_FIND_LEN) {\n\n            if (!hexa_side) {\n\n              stra[i + 1] = car;\n\n              sprintf (str, \"%02X\", (int)car);\n\n              strh[i]   = str[0];\n\n              strh[i+1] = str[1];\n\n              i += 3;\n\n            } else {\n\n              if ( ((car >= '0') && (car <= '9')) ||\n\n                   ((car >= 'a') && (car <= 'z')) || ((car >= 'A') && (car <= 'Z')) ) {\n\n                if ( (car >= 'a') && (car <= 'z') ) car = 'A' + car - 'a';\n\n                val = to_val (car);\n\n                if (val != -1) {\n\n                  if (j == 0) {\n\n                    strh[i] = car;\n\n                    j = 1;\n\n                    part_last = (strh[i + 1] == ' ');\n\n                    if (!part_last) {\n\n                      valf = to_val (strh[i + 1]);\n\n                      if (valf == -1) ABORT(\"String conv 1st\");\n\n                      val = val * 0x10 + valf;\n\n                      if ( (val >= 0x7F) || (val <= 0x1F) ) {\n\n                        stra[i + 1] = '.';\n\n                      } else {\n\n                        stra[i + 1] = (char) val;\n\n                      }\n\n                      strh[i + 1]=car;\n\n                    }\n\n                  } else {\n\n                    valf = to_val (strh[i]);\n\n                    if (valf == -1) ABORT(\"String conv 2nd\");\n\n                    val = valf * 0x10 + val;\n\n                    if ( (val >= 0x7F) || (val <= 0x1F) ) {\n\n                      stra[i + 1] = '.';\n\n                    } else {\n\n                      stra[i + 1] = (char) val;\n\n                    }\n\n                    strh[i + 1] = car;\n\n                    i += 3;\n\n                    j = 0;\n\n                    part_last = false;\n\n                  }\n\n                }\n\n              }\n\n            }\n\n          }\n\n        }\n\n        if (i > l) l = i;\n\n      break;\n\n\n\n    }\n\n  }\n\n\n\n  mvprint (22, 5, \"                                                                       \");\n\n\n\n  llength = l / 3;\n\n  if (!abort) {\n\n    /* Save for search */\n\n    length = llength;\n\n    for (i = 0; (unsigned)i < length; i ++) {\n\n      strf[i] = (byte) to_val (strh[3 * i]) * 0x10 + to_val (strh[3 * i + 1]);\n\n    }\n\n\n\n    /* Search until no more or user quit */\n\n    find_loop (strf, length);\n\n\n\n    read_file ();\n\n    display_page ();\n\n\n\n  }\n\n\n\n  for (i = 0; i < STR_FIND_LEN; i ++) stra[i] = ' ';\n\n  mvprint (23, 10, stra);\n\n  mvprint (24, 10, stra);\n\n  mvprint (23, 3, \"     \");\n\n  mvprint (24, 3, \"     \");\n\n}\n\n\n\n\n\n/*************************************************************************/\n\n\n\nint main (int argc, char *argv[]) {\n\nchar car;\n\nchar *pchar;\n\nboolean done;\n\n\n\n  if (argc == 2) {\n\n    file_name = argv[1];\n\n    can_modify = true;\n\n  } else if ( (argc == 3) && (strcmp(argv[1], \"-r\") == 0) ) {\n\n    file_name = argv[2];\n\n    can_modify = false;\n\n  } else {\n\n    usage ();\n\n    exit(0);\n\n  }\n\n\n\n  pchar=getenv(\"MU_UNPRINTABLE\");\n\n  if (pchar && (strlen(pchar) == 1) ) unprintable=pchar;\n\n\n\n  open_file ();\n\n\n\n  open_keybd ();\n\n  clrscr ();\n\n  lowvideo ();\n\n\n\n\n\n  current_page = 1;\n\n  new_page ();\n\n  pos = 0;\n\n  first_hexa = true;\n\n  hexa_side = true;\n\n  modified = false;\n\n  to_erase = false;\n\n\n\n  title ();\n\n\n\n  read_file ();\n\n  display_page ();\n\n  display_pos();\n\n\n\n\n\n  done = false;\n\n  while (!done) {\n\n\n\n    /* Move */\n\n    move_to (pos, hexa_side, first_hexa);\n\n\n\n    car = get_asc();\n\n\n\n    if ( (hexa_side) && (car >= 'a' && car <= 'f') ) car = 'A' + car - 'a';\n\n\n\n    if ( (hexa_side) && ((car >= 'A' && car <= 'F') || (car >= '0' && car <= '9')) ) {\n\n      modify_page_hex (car);\n\n\n\n    } else if ( (!hexa_side) && (car >= 0x1F) ) {\n\n      modify_page_asc (car);\n\n\n\n    } else {\n\n      switch (car) {\n\n        case 9 : /* tab */\n\n          hexa_side = !hexa_side;\n\n        break;\n\n        case 6 : /* page down */\n\n          page_down();\n\n        break;\n\n        case 5 : /* page up */\n\n          page_up();\n\n        break;\n\n        case 1 : /* up */\n\n          movement (-1,  0);\n\n        break;\n\n        case 2 : /* right */\n\n          movement ( 0,  1);\n\n        break;\n\n        case 3 : /* down */\n\n          movement ( 1,  0);\n\n        break;\n\n        case  4 : /* left */\n\n          movement ( 0, -1);\n\n        break;\n\n        case 10 : /* home */\n\n          home_mvt ();\n\n        break;\n\n        case 11 : /* end */\n\n          end_mvt ();\n\n        break;\n\n        case 15 : /* find */\n\n          find_seq ();\n\n        break;\n\n        case 16 : /* goto page */\n\n          goto_page ();\n\n        break;\n\n        case 17 : /* save modif */\n\n          write_modif();\n\n          display_page ();\n\n        break;\n\n        case 18 : /* exit */\n\n          write_modif();\n\n          done = true;\n\n        break;\n\n        case 19 : /* end file */\n\n          g_last_page ();\n\n        break;\n\n        case 20 : /* begin file */\n\n          g_first_page ();\n\n        break;\n\n        case 22 : /* quit */\n\n          done = true;\n\n        break;\n\n        case 23 : /* undo modif */\n\n          modified = false;\n\n          read_file ();\n\n          display_page ();\n\n        break;\n\n      } /* switch Special code */\n\n\n\n    } /* if Special car */\n\n\n\n    /* Display current_pos */\n\n    display_pos();\n\n\n\n  } /* for */\n\n\n\n  close (file_des);\n\n\n\n  clrscr ();\n\n\n\n  close_keybd ();\n\n\n\n  exit (0);\n\n}\n", "#include <stdlib.h>\n\n#include <stdio.h>\n\n#include <unistd.h>\n\n\n\n#include \"boolean.h\"\n\n#include \"timeval.h\"\n\n#include \"sem_util.h\"\n\n#include \"rusage.h\"\n\n\n\nstatic int semid;\n\n\n\n#define NTIMES 21\n\n\n\nstatic int get_vtime (timeout_t *time) {\n\n  t_result r;\n\n\n\n  /* Mesure time for decr_sem, gettimeofday, incr_sem */\n\n  r = decr_sem_id (semid, TRUE);\n\n  if (r == ERR) {\n\n    perror (\"decr_sem_id\");\n\n    return 1;\n\n  }\n\n  get_time (time);\n\n  r = incr_sem_id (semid, TRUE);\n\n  if (r == ERR) {\n\n    perror (\"decr_sem_id\");\n\n    return 1;\n\n\n\n  }\n\n  return 0;\n\n}\n\n\n\nint main (void) {\n\n  timeout_t t1, t2, t3;\n\n  timeout_t times[NTIMES];\n\n  int i;\n\n  char buffer[500];\n\n  t_result r;\n\n\n\n  if (init_rusage() != RUSAGE_OK) {\n\n    perror(\"init_rusage\");\n\n    exit(1);\n\n  }\n\n\n\n  /* Create sem */\n\n  r = create_sem_key (21, &semid);\n\n  if (r == ERR) {\n\n    perror (\"create_sem_key\");\n\n    exit (1);\n\n  }\n\n\n\n  /* Do something */\n\n  usleep (1000000);\n\n  for (i = 1; i <= 100000; i++) {\n\n    if (get_vtime(&t1) != 0) {\n\n      perror(\"get_vtime\");\n\n      exit(1);\n\n    }\n\n  }\n\n\n\n  /* Get current time */\n\n  dump_rusage_str (\"Start iterations between changes\");\n\n  get_time (&t1);\n\n\n\n  /* Wait until it changes */\n\n  for (;;) {\n\n    get_time (&t2);\n\n    if (comp_time(&t1, &t2) != 0) {\n\n      break;\n\n    }\n\n  }\n\n\n\n  /* Wait until it changes */\n\n  for (i = 1; ; i++) {\n\n    get_time (&t3);\n\n    if (comp_time(&t3, &t2) != 0) {\n\n      break;\n\n    }\n\n  }\n\n\n\n  /* Compute delta */\n\n  (void) sub_time (&t3, &t2);\n\n\n\n  /* Display result */\n\n  sprintf (buffer, \"Changes after %d iterations\", i);\n\n  dump_rusage_str (buffer);\n\n\n\n  /* Mesure time for decr_sem, gettimeofday, incr_sem */\n\n  dump_rusage_str (\"Start 1000000 cycles decr_sem&gettimeofday&incr_sem\");\n\n  for (i = 1; i <= 1000000; i++) {\n\n    if (get_vtime(&t1) != 0) {\n\n      perror(\"get_vtime\");\n\n      exit(1);\n\n    }\n\n  }\n\n  dump_rusage_str (\"After 1000000 cycles decr_sem&gettimeofday&incr_sem\");\n\n\n\n  /* Mesure time for gettimeofday */\n\n  dump_rusage_str (\"Start 1000000 cycles gettimeofday\");\n\n  for (i = 1; i <= 1000000; i++) {\n\n    get_time (&t3);\n\n  }\n\n  dump_rusage_str (\"After 1000000 cycles gettimeofday\");\n\n\n\n  /* Mesure time of usleep 1, 10, 100, 1000, 100000, 1000000 */\n\n  dump_rusage_str (\"Start usleep 1, 10, 100, 1000, 10000, 100000, 1000000\");\n\n  usleep (1);\n\n  dump_rusage_str (\"After usleep 1\");\n\n  usleep (10);\n\n  dump_rusage_str (\"After usleep 10\");\n\n  usleep (100);\n\n  dump_rusage_str (\"After usleep 100\");\n\n  usleep (1000);\n\n  dump_rusage_str (\"After usleep 1000\");\n\n  usleep (10000);\n\n  dump_rusage_str (\"After usleep 10000\");\n\n  usleep (100000);\n\n  dump_rusage_str (\"After usleep 100000\");\n\n  usleep (1000000);\n\n  dump_rusage_str (\"After usleep 1000000\");\n\n\n\n  /* Several successive gettimeofday */\n\n  for (i = 0; i < NTIMES; i++) {\n\n    get_time(&times[i]);\n\n  }\n\n  for (i = 0; i < NTIMES; i++) {\n\n    sprintf(buffer, \"Gettime[%04d] -> %06ld.%06ld\\n\", i, times[i].tv_sec, times[i].tv_usec);\n\n    dump_rusage_str (buffer);\n\n  }\n\n\n\n  /* Delete sem & exit */\n\n  delete_sem_id (semid);\n\n  return 0;\n\n}\n\n\n", "#include <stdlib.h>\n\n#include <stdio.h>\n\n#include <libgen.h>\n\n#include <string.h>\n\n#include <errno.h>\n\n\n\n#include \"boolean.h\"\n\n#include \"timeval.h\"\n\n#include \"socket.h\"\n\n#include \"wait_evt.h\"\n\n#include \"dynlist.h\"\n\n\n\n/* Timeout for client to collect replies */\n\n#define DELAY_CLIENT_MS 1000\n\n\n\n/* Current program name */\n\nstatic char prog[256];\n\n\n\n\n\n/* Prog syntax */\n\nstatic void usage (void) {\n\n  fprintf (stderr, \"Usage: %s <imp_address>:<port_num>\\n\", prog);\n\n}\n\n\n\n/* Log error messages and exit */\n\nstatic void error (const char * msg) __attribute__ ((noreturn));\n\nstatic void error (const char * msg) {\n\n  fprintf (stderr, \"ERROR: %s.\\n\", msg);\n\n  usage();\n\n  exit (1);\n\n}\n\n\n\n/* Put IP address image */\n\nstatic void addr_image (soc_host *addr, char image[]) {\n\n  int i;\n\n  char buf[10];\n\n  for (i = 0; i < 4; i++) {\n\n    sprintf (buf, \"%d\", (int)addr->bytes[i]);\n\n    strcat (image, buf);\n\n    if (i != 3) {\n\n      strcat (image, \".\");\n\n    }\n\n  }\n\n}\n\n\n\n\n\n/* Message exchanged on IPM socket */\n\ntypedef struct {\n\n  boolean ping;\n\n  timeout_t time;\n\n} msg_type;\n\n\n\n/* Info kept in client about from each server */\n\ntypedef struct {\n\n  soc_host host;\n\n  timeout_t server_time;\n\n  timeout_t reception_time;\n\n} info_type;\n\n\n\n/* THE MAIN */\n\nint main (const int argc, const char * argv[]) {\n\n\n\n  /* Socket data */\n\n  soc_token soc = init_soc;\n\n  soc_host lan;\n\n  soc_port port;\n\n  int soc_fd, fd;\n\n\n\n  /* Socket message */\n\n  msg_type msg;\n\n\n\n  /* Times and timeouts */\n\n  timeout_t start_time, end_time, current_time;\n\n  timeout_t wait_timeout;\n\n  double local_time, remote_time;\n\n\n\n  /* Dynamic list of server infos */\n\n  dlist list;\n\n  info_type info;\n\n\n\n  /* Utilities */\n\n  boolean for_read;\n\n  char addr[256], buff[1024];\n\n  int res;\n\n  char *index;\n\n\n\n  /*********/\n\n  /* Start */\n\n  /*********/\n\n  /* Save prog name */\n\n  strcpy (prog, argv[0]);\n\n  strcpy (prog, basename (prog));\n\n\n\n  /*******************/\n\n  /* Parse arguments */\n\n  /*******************/\n\n  /* Check args */\n\n  if (argc != 2) {\n\n    error (\"Invalid argument\");\n\n  }\n\n  /* Parse IPM address and port */\n\n  strcpy (addr, argv[1]);\n\n  index = strstr (addr, \":\");\n\n  if (index == NULL) {\n\n     error (\"Invalid argument\");\n\n  }\n\n  *index = '\\0';\n\n  index++;\n\n  if (soc_str2host (addr, &lan) != SOC_OK) {\n\n    sprintf (buff, \"Invalid ipm address %s\", addr);\n\n    error (buff);\n\n  }\n\n  if (soc_str2port (index, &port) != SOC_OK) {\n\n    sprintf (buff, \"Invalid port num %s\", index);\n\n    error (buff);\n\n  }\n\n\n\n  /**************/\n\n  /* Initialize */\n\n  /**************/\n\n  /* Init dynamic list */\n\n  dlist_init (& list, sizeof(info_type));\n\n  /* Init socket */\n\n  if (soc_open (&soc, udp_socket) != SOC_OK) {\n\n    perror (\"opening socket\");\n\n    error (\"Socket initialization failed\");\n\n  }\n\n  if (soc_set_dest_host_port (soc, &lan, port) != SOC_OK) {\n\n    perror (\"setting destination\");\n\n    error (\"Socket initialization failed\");\n\n  }\n\n  if (soc_link_port (soc, port) != SOC_OK) {\n\n    perror (\"linking to port\");\n\n    error (\"Socket initialization failed\");\n\n  }\n\n  if (soc_get_dest_host (soc, &lan) != SOC_OK) {\n\n    perror (\"getting dest lan\");\n\n    error (\"Socket initialization failed\");\n\n  }\n\n  if (soc_get_dest_port (soc, &port) != SOC_OK) {\n\n    perror (\"getting dest port\");\n\n    error (\"Socket initialization failed\");\n\n  }\n\n  /* Add socket to waiting point */\n\n  if (soc_get_id(soc, &soc_fd) != SOC_OK) {\n\n    perror (\"getting socket id\");\n\n    error (\"Socket initialization failed\");\n\n\n\n  }\n\n  if (evt_add_fd(soc_fd, TRUE) != WAIT_OK) {\n\n    perror(\"Adding fd\");\n\n    error (\"Socket initialization failed\");\n\n  }\n\n  /* Activate signal catching */\n\n  activate_signal_handling();\n\n  /* Report starting */\n\n  buff[0]='\\0';\n\n  addr_image (&lan, buff);\n\n  printf (\"%s mcasting at address %s on port %d.\\n\", prog, buff, (int) port);\n\n  /* Init times */\n\n  get_time (&start_time);\n\n  current_time = start_time;\n\n  end_time = start_time;\n\n  incr_time (&end_time, DELAY_CLIENT_MS);\n\n  /* Send initial ping request */\n\n  msg.ping = TRUE;\n\n  msg.time = start_time;\n\n  if (soc_send (soc, (soc_message) &msg, sizeof(msg)) != SOC_OK) {\n\n    perror (\"sending ping\");\n\n    error (\"Sending ping request failed\");\n\n  }\n\n\n\n  /*************/\n\n  /* Main loop */\n\n  /*************/\n\n  for (;;) {\n\n    /* First step is to loop until timeout */\n\n    if (wait_timeout.tv_sec != -1) {\n\n      wait_timeout = end_time;\n\n      res = sub_time (&wait_timeout, &current_time);\n\n      if (res <= 0) {\n\n        break;\n\n      }\n\n    }\n\n    if (evt_wait (&fd, &for_read, &wait_timeout) != WAIT_OK) {\n\n      perror (\"waiting for event\");\n\n      error (\"Waiting for events failed\");\n\n    }\n\n    if (! for_read) {\n\n      error (\"Write event received\");\n\n    }\n\n    /* Termination signal */\n\n    if (fd == SIG_EVENT) {\n\n      if (get_signal () == SIG_TERMINATE) {\n\n        break;\n\n      }\n\n    } else if (fd == NO_EVENT) {\n\n      /* Timeout: first step ends with a dump of servers */\n\n      if (dlist_length(&list) != 0) {\n\n        dlist_rewind (&list, TRUE);\n\n        for (;;) {\n\n          dlist_read (&list, &info);\n\n          /* Get host name if possible, else dump address */\n\n          res = soc_host_name_of (&info.host, buff, sizeof(buff));\n\n          if (res != SOC_OK) {\n\n            buff[0]='\\0';\n\n            addr_image (&info.host, buff);\n\n          }\n\n          /* Compute (Start_time + Reception_time) / 2 */\n\n          local_time = (time_to_double (&start_time)\n\n                        + time_to_double (&info.reception_time) ) / 2.0;\n\n          remote_time = time_to_double (&info.server_time);\n\n          printf (\"Host %s is shifted by %4.03fs\\n\", buff, remote_time - local_time);\n\n\n\n          /* Done when last record has been put */\n\n          if (dlist_get_pos (&list, FALSE) == 1) {\n\n            break;\n\n          }\n\n          dlist_move (&list, TRUE);\n\n        }\n\n      }\n\n      /* Now entering second step: infinite timeout */\n\n      wait_timeout.tv_sec = -1;\n\n      wait_timeout.tv_usec = -1;\n\n      printf (\"%s ready.\\n\", prog);\n\n    } else if (fd != soc_fd) {\n\n      sprintf (buff, \"Invalid fd %d received\", fd);\n\n      error (buff);\n\n    } else {\n\n      /* Now this is the socket, read message */\n\n      res = soc_receive (soc, (soc_message) &msg, sizeof(msg), TRUE);\n\n      if (res < 0) {\n\n        perror (\"reading from socket\");\n\n        error (\"Reading message failed\");\n\n      } else if (res != sizeof(msg)) {\n\n        sprintf (buff, \"Invalid size received, expected %d, got %d\",\n\n                       (int)sizeof(msg), res);\n\n        error (buff);\n\n      }\n\n      get_time (&current_time);\n\n      /* Client and server different behaviours */\n\n      if ((wait_timeout.tv_sec != -1) && !msg.ping) {\n\n        /* First step: store the address and time of server, if pong */\n\n        if (soc_get_dest_host (soc, &(info.host)) != SOC_OK) {\n\n          perror (\"getting dest host\");\n\n          error (\"Getting server address failed\");\n\n        }\n\n        info.server_time = msg.time;\n\n        info.reception_time = current_time;\n\n        dlist_insert (&list, &info, TRUE);\n\n\n\n      } else if ( (wait_timeout.tv_sec == -1) && msg.ping) {\n\n        /* Second step: reply pong and time to ping */\n\n        msg.time = current_time;\n\n        msg.ping = FALSE;\n\n        if (soc_send (soc, (soc_message) &msg, sizeof(msg)) != SOC_OK) {\n\n          perror (\"sending pong\");\n\n          error (\"Sending pong request failed\");\n\n        }\n\n      }\n\n    }\n\n  } /* End of main loop */\n\n\n\n\n\n  /* Clean - Close */\n\n  dlist_delete_all (&list);\n\n  (void) evt_del_fd (soc_fd, TRUE);\n\n  (void) soc_close (&soc);\n\n  printf (\"Done.\\n\");\n\n  exit (0);\n\n}\n\n\n", "#include <stdio.h>\n\n#include <stdlib.h>\n\n#include <locale.h>\n\n\n\n#define ALL 1\n\n#define ONE 0\n\n\n\nstatic void draw (char *str[], int  count, char param);\n\nstatic void help(char *str[]);\n\n\n\nint main (int argc, char *argv[]) {\n\n\n\n  (void) setlocale(LC_ALL, \"\");\n\n\n\n  if ( argc < 2 ) help(argv);\n\n  else draw (argv, argc, ONE);\n\n  exit(0);\n\n}\n\n\n\nstatic void help (char *str[]) {\n\n  printf (\"-- usage : \\n\");\n\n  printf (\"           ascii [ARG]\\n\");\n\n  printf (\"             where ARG is a character or a string\\n\");\n\n  printf (\"             if no argument is specified \\n\");\n\n  printf (\"             print the whole ascii table\\n\\n\");\n\n  draw (str, ALL, ' ');\n\n}\n\n\n\nstatic void draw (char *str[], int  count, char param) {\n\n  int j=0, i=0;\n\n\n\n  printf (\"+-----------+-----+-----+-----+\\n\");\n\n  printf (\"| character | dec | oct | hex |\\n\");\n\n  printf (\"+-----------+-----+-----+-----+\\n\");\n\n\n\n  if ( param == ONE )\n\n  {\n\n     for ( j = 1; j < count; )\n\n     {\n\n        i = 0;\n\n        while ( str[j][i] != '\\0' )\n\n        {\n\n           printf (\"|     %c     | %3d | %3o | %3X |\\n\", str[j][i], str[j][i], str[j][i], str[j][i]);\n\n           i++;\n\n         }\n\n         if ( j < count - 1) printf (\"+-----------+-----+-----+-----+\\n\");\n\n         j++;\n\n     }\n\n  }\n\n  else\n\n  {\n\n     for ( i = 32; i < 256; i++)\n\n     {\n\n        printf (\"|     %c     | %3d | %3o | %3X |\\n\", i, i, i, i);\n\n     }\n\n  }\n\n\n\n  printf (\"+-----------+-----+-----+-----+\\n\");\n\n\n\n}\n\n\n", "#include <unistd.h>\n\n#include <stdlib.h>\n\n#include <stdio.h>\n\n\n\n\n\n#include \"socket.h\"\n\n#define SIZE 8*1024\n\nchar buff[10000000];\n\n\n\nstatic void error (const char *call, int res) __attribute__ ((noreturn));\n\nstatic void error (const char *call, int res) {\n\n    perror (call);\n\n    fprintf (stderr, \"Error %d\\n\", res);\n\n    exit (1);\n\n}\n\n\n\nint main (int argc, char *argv[]) {\n\n  soc_token socket = NULL;\n\n  int res;\n\n  int size = 0;\n\n\n\n  if (argc > 1) {\n\n    size = atoi(argv[1]);\n\n  }\n\n  if (size == 0) {\n\n    size = SIZE;\n\n  }\n\n\n\n  res = soc_open(&socket, udp_socket);\n\n  if (res != SOC_OK) error(\"soc_open\", res);\n\n\n\n  res = soc_set_dest_name_service (socket, \"test_ipm\", TRUE, \"test_udp\");\n\n  if (res != SOC_OK) error(\"soc_set_dest_name_service\", res);\n\n\n\n  printf (\"Sending %d bytes\\n\", size);\n\n  res = soc_send (socket, (soc_message)buff, (soc_length)size);\n\n  if (res != SOC_OK) error(\"soc_send\", res);\n\n  printf (\"Done.\\n\");\n\n\n\n  return 0;\n\n}\n\n\n", "#include \"boolean.h\"\n\n\n\n/****************************************************************************/\n\n/****** Preliminary definitions                                        ******/\n\n/****************************************************************************/\n\n\n\n/* Kind of request and report */\n\ntypedef enum {start_command, kill_command, fexit_command, ping_command}\n\n             request_kind_list;\n\ntypedef enum {start_report, kill_report, exit_report, fexit_report,\n\n              pong_report} report_kind_list;\n\n\n\n/* Request sizing */\n\ntypedef unsigned int command_number;\n\n#define MAX_TEXT_LG 512               /* Program + arguments               */\n\n#define MAX_ENV_LG  256               /* Environment variables             */\n\n#define MAX_DIR_LG  256               /* Current dir/stdout /stderr        */\n\n\n\n/* Start request structure */\n\ntypedef struct {\n\n  command_number number;              /* Managed by the client              */\n\n  char command_text[MAX_TEXT_LG];     /* program\\0arg1\\0arg2\\0 ... argb\\0\\0 */\n\n  char environ_variables[MAX_ENV_LG]; /* var1=val1\\0 ........ varn=valn\\0\\0 */\n\n  char currend_dir[MAX_DIR_LG];       /* path\\0                             */\n\n  char output_flow[MAX_DIR_LG];       /* path_to_file\\0                     */\n\n  unsigned char append_output;        /* 0 (create) or 1 (append)           */\n\n  char error_flow[MAX_DIR_LG];        /* path_to_file\\0                     */\n\n  unsigned char append_error;         /* 0 (create) or 1 (append)           */\n\n} start_request_t;\n\n\n\n/* Kill request structure */\n\ntypedef struct {\n\n  command_number number;              /* Managed by the client              */\n\n  int    signal_number;               /* Signal num to send                 */\n\n} kill_request_t;\n\n\n\n/* Forker Exit request structure */\n\ntypedef struct {\n\n  int exit_code;                      /* Code to exit with                  */\n\n} fexit_request_t;\n\n\n\n/* Request */\n\ntypedef union {\n\n  start_request_t start_request;\n\n  kill_request_t  kill_request;\n\n  fexit_request_t fexit_request;\n\n} request_u;\n\n\n\n/* Start report */\n\ntypedef struct {\n\n  command_number number;              /* Managed by the client              */\n\n  int started_pid;                    /* Pid of Started process or -1       */\n\n} start_report_t;\n\n\n\n/* Kill report */\n\ntypedef struct {\n\n  command_number number;              /* Managed by the client              */\n\n  int killed_pid;                     /* Pid of Killed  process or -1       */\n\n} kill_report_t;\n\n\n\n/* Exit report */\n\ntypedef struct {\n\n  command_number number;              /* Managed by the client              */\n\n  int     exit_pid;                   /* Pid of exited command              */\n\n  int     exit_status;                /* Exit status of command             */\n\n} exit_report_t;\n\n\n\ntypedef union {\n\n  start_report_t start_report;\n\n  kill_report_t  kill_report;\n\n  exit_report_t  exit_report;\n\n} report_u;\n\n\n\n/****************************************************************************/\n\n/****** Interface definitions                                          ******/\n\n/****************************************************************************/\n\n/* The interface request message client -> forker */\n\ntypedef struct {\n\n  request_kind_list kind;\n\n#define start_req   request.start_request\n\n#define kill_req    request.kill_request\n\n#define fexit_req   request.fexit_request\n\n  request_u         request;\n\n} request_message_t;\n\n\n\n/* The interface report message forker -> client */\n\ntypedef struct {\n\n  report_kind_list  kind;\n\n#define start_rep   report.start_report\n\n#define kill_rep    report.kill_report\n\n#define exit_rep    report.exit_report\n\n  report_u       report;              /* Ok/Nok/Exit_code                   */\n\n} report_message_t;\n\n\n\n\n", "#include <unistd.h>\n\n#include <stdlib.h>\n\n#include <stdio.h>\n\n#include <string.h>\n\n#include <sys/types.h>\n\n#include <sys/wait.h>\n\n\n\n\n\n#include \"get_line.h\"\n\n\n\n#include \"socket.h\"\n\n#include \"forker_messages.h\"\n\n\n\n\n\n/* To is:   \"bla\\0bla\\0...bla\\0\\0 */\n\n/* becomes: \"bla\\0bla\\0...bla\\0str\\0\\0 */\n\nstatic void cat_str (char *to, char *str) {\n\n  char p;\n\n\n\n  p = ' ';\n\n  while ( (*to != '\\0') || (p != '\\0') ) {\n\n    p = *to;\n\n    to++;\n\n  }\n\n  strcpy (to, str);\n\n  while (*to != '\\0') to++;\n\n  *(to+1) = '\\0';\n\n}\n\n\n\n\n\n/* Trace a socket error */\n\nstatic void terror (const char *call, const int code) {\n\n  if (code != SOC_OK) {\n\n    fprintf(stderr, \"%s returned %s.\\n\", call, soc_error(code));\n\n  }\n\n}\n\n\n\n\n\nint main(int argc, char *argv[]) {\n\n\n\n  command_number number;\n\n  typedef enum {None, Udp, Tcp, Ipm} proto_list;\n\n  proto_list proto;\n\n  soc_token soc = NULL;\n\n  int port_no;\n\n  char buff[500];\n\n  request_message_t request;\n\n  report_message_t report;\n\n  int i, n, res;\n\n  soc_host  my_host;\n\n  soc_port  my_port;\n\n\n\n\n\n  /* printf(\"Req_size: %d\\n\", sizeof(request_message_t)); */\n\n  /* printf(\"Rep_size: %d\\n\", sizeof(report_message_t)); */\n\n\n\n  proto = None;\n\n  if (argc == 4) {\n\n    if (strcmp (argv[1], \"-u\") == 0) {\n\n      proto = Udp;\n\n    } else if (strcmp (argv[1], \"-t\") == 0) {\n\n      proto = Tcp;\n\n    } else if (strcmp (argv[1], \"-m\") == 0) {\n\n      proto = Ipm;\n\n    }\n\n  }\n\n  if (proto == None) {\n\n    fprintf(stderr, \"Error. Three args -u/-t/-m <hostname> <port_name/num> expected.\\n\");\n\n    exit(1);\n\n  }\n\n\n\n  /* Socket stuff */\n\n  res = soc_open(&soc, (proto == Tcp ? tcp_header_socket : udp_socket));\n\n  if (res != SOC_OK) {\n\n    perror(\"soc_open\");\n\n    terror(\"soc_open\", res);\n\n    exit(1);\n\n  }\n\n\n\n  /* Dest to host (tcp/udp) or lan (ipm) */\n\n  port_no = atoi(argv[3]);\n\n  if (port_no <= 0) {\n\n    res  = soc_set_dest_name_service(soc, argv[2], proto == Ipm, argv[3]);\n\n    if (res != SOC_OK) {\n\n      perror(\"soc_set_dest_name_service\");\n\n      terror(\"soc_set_dest_name_service\", res);\n\n      exit (1);\n\n    }\n\n  } else {\n\n    res  = soc_set_dest_name_port(soc, argv[2], proto == Ipm, port_no);\n\n    if (res != SOC_OK) {\n\n      perror(\"soc_set_dest_name_port\");\n\n      terror(\"soc_open\", res);\n\n      exit (1);\n\n    }\n\n  }\n\n  if (proto != Tcp) {\n\n    res = soc_link_dynamic(soc);\n\n    if (res != SOC_OK) {\n\n      perror(\"soc_link_dynamic\");\n\n      terror(\"soc_link_dynamic\", res);\n\n      exit(1);\n\n    }\n\n  }\n\n  res = soc_set_blocking(soc, FALSE);\n\n  if (res != SOC_OK) {\n\n    perror(\"soc_set_blocking\");\n\n    terror(\"soc_set_blocking\", res);\n\n    exit(1);\n\n  }\n\n\n\n  /* Get current host and port */\n\n  res = soc_get_local_host_id(&my_host);\n\n  if (res != SOC_OK) {\n\n    perror(\"soc_get_local_host\");\n\n    terror(\"soc_get_local_host\", res);\n\n    exit(1);\n\n  }\n\n  my_port = 0;\n\n  if (proto != Tcp) {\n\n    res = soc_get_linked_port(soc, &my_port);\n\n    if (res != SOC_OK) {\n\n      perror(\"soc_get_linked_port\");\n\n      terror(\"soc_get_linked_port\", res);\n\n      exit(1);\n\n    }\n\n  }\n\n  printf (\"I am host %u port %u\\n\", my_host.integer, my_port);\n\n\n\n  number = 0;\n\n  for (;;) {\n\n    printf (\"\\n\");\n\n\n\n    printf (\"Start Kill Exit Ping Read (s k e p r) ? \");\n\n    i = get_line (NULL, buff, sizeof(buff));\n\n\n\n    if (strcmp(buff, \"s\") == 0) {\n\n      /* Start */\n\n      memset(request.start_req.command_text, 0,\n\n             sizeof(request.start_req.command_text));\n\n      memset(request.start_req.environ_variables, 0,\n\n             sizeof(request.start_req.environ_variables));\n\n      request.kind = start_command;\n\n      printf (\"Number: %d\\n\", number);\n\n      request.start_req.number = number;\n\n      number += 1;\n\n      printf (\"Command ? \");\n\n      i = get_line (NULL, request.start_req.command_text,\n\n                  sizeof(request.start_req.command_text));\n\n      for (;;) {\n\n        printf (\"Argument (Empty to end) ? \");\n\n        i = get_line (NULL, buff, sizeof(buff));\n\n        if (i == 0) break;\n\n        cat_str (request.start_req.command_text, buff);\n\n      }\n\n      for (n = 1;;n++) {\n\n        printf (\"Environ (Empty to end) ? \");\n\n        i = get_line (NULL, buff, sizeof(buff));\n\n        if (i == 0) break;\n\n        if (n == 1) {\n\n          strcpy (request.start_req.environ_variables, buff);\n\n        } else {\n\n          cat_str (request.start_req.environ_variables, buff);\n\n        }\n\n      }\n\n\n\n      printf (\"Current dir ? \");\n\n      i = get_line (NULL, request.start_req.currend_dir,\n\n                    sizeof(request.start_req.currend_dir));\n\n\n\n      printf (\"Output flow ? \");\n\n      i = get_line (NULL, request.start_req.output_flow,\n\n                    sizeof(request.start_req.output_flow));\n\n      if (i != 0) {\n\n        for (;;) {\n\n          printf (\"  Append (t or [f]) ? \");\n\n          i = get_line (NULL, buff, sizeof(buff));\n\n          if (strcmp(buff, \"t\") == 0) {\n\n            request.start_req.append_output = 1;\n\n            break;\n\n          } else if ( (i == 0) || (strcmp(buff, \"f\") == 0) ) {\n\n            request.start_req.append_output = 0;\n\n            break;\n\n          }\n\n        }\n\n      }\n\n\n\n      printf (\"Error flow ? \");\n\n      i = get_line (NULL, request.start_req.error_flow,\n\n                    sizeof(request.start_req.error_flow));\n\n      if (i != 0) {\n\n        for (;;) {\n\n          printf (\"  Append (t or [f]) ? \");\n\n          i = get_line (NULL, buff, sizeof(buff));\n\n          if (strcmp(buff, \"t\") == 0) {\n\n            request.start_req.append_error = 1;\n\n            break;\n\n          } else if ( (i == 0) || (strcmp(buff, \"f\") == 0) ) {\n\n            request.start_req.append_error = 0;\n\n            break;\n\n          }\n\n        }\n\n      }\n\n\n\n      res = soc_send(soc, (char*)&request, sizeof(request));\n\n      if (res != SOC_OK) {\n\n        perror(\"soc_send\");\n\n        terror(\"soc_send\", res);\n\n      }\n\n\n\n    } else if (strcmp(buff, \"k\") == 0) {\n\n      /* Kill */\n\n      request.kind = kill_command;\n\n      for (;;) {\n\n        printf (\"Number ? \");\n\n        i = get_line (NULL, buff, sizeof(buff));\n\n        i = atoi(buff);\n\n        if (i >= 0) break;\n\n      }\n\n      request.start_req.number = i;\n\n      for (;;) {\n\n        printf (\"Signal ? \");\n\n        i = get_line (NULL, buff, sizeof(buff));\n\n        i = atoi(buff);\n\n        if (i >= 0) break;\n\n      }\n\n      request.kill_req.signal_number = i;\n\n\n\n      res = soc_send(soc, (char*)&request, sizeof(request));\n\n      if (res != SOC_OK) {\n\n        perror(\"soc_send\");\n\n        terror(\"soc_send\", res);\n\n      }\n\n\n\n    } else if (strcmp(buff, \"e\") == 0) {\n\n      /* Exit */\n\n      request.kind = fexit_command;\n\n      for (;;) {\n\n        printf (\"Exit code ? \");\n\n        i = get_line (NULL, buff, sizeof(buff));\n\n        i = atoi(buff);\n\n        if (i >= 0) break;\n\n      }\n\n      request.fexit_req.exit_code = i;\n\n\n\n      res = soc_send(soc, (char*)&request, sizeof(request));\n\n      if (res != SOC_OK) {\n\n        perror(\"soc_send\");\n\n        terror(\"soc_send\", res);\n\n      }\n\n\n\n    } else if (strcmp(buff, \"p\") == 0) {\n\n      /* Exit */\n\n      request.kind = ping_command;\n\n\n\n      res = soc_send(soc, (char*)&request, sizeof(request));\n\n      if (res != SOC_OK) {\n\n        perror(\"soc_send\");\n\n        terror(\"soc_send\", res);\n\n      }\n\n\n\n    } else if (strcmp(buff, \"r\") == 0) {\n\n      /* Read report */\n\n      n = soc_receive(soc, &report, sizeof(report), FALSE);\n\n      if (n == sizeof(report)) {\n\n        switch (report.kind) {\n\n          case start_report :\n\n            printf (\"Start: command %d pid %d\\n\", report.start_rep.number,\n\n                    report.start_rep.started_pid);\n\n          break;\n\n          case kill_report :\n\n            printf (\"Kill: command %d pid %d\\n\", report.kill_rep.number,\n\n                    report.kill_rep.killed_pid);\n\n          break;\n\n          case exit_report :\n\n            printf (\"Exit: command %d pid %d code %d \", report.exit_rep.number,\n\n                    report.exit_rep.exit_pid, report.exit_rep.exit_status);\n\n            if (WIFEXITED(report.exit_rep.exit_status)) {\n\n              printf (\"exit normally code %d\\n\",\n\n                      WEXITSTATUS(report.exit_rep.exit_status));\n\n            } else if (WIFSIGNALED(report.exit_rep.exit_status)) {\n\n              printf (\"exit on signal %d\\n\",\n\n                      WTERMSIG(report.exit_rep.exit_status));\n\n            } else {\n\n              printf (\"stopped on signal %d\\n\",\n\n                      WSTOPSIG(report.exit_rep.exit_status));\n\n            }\n\n          break;\n\n          case fexit_report :\n\n            printf (\"Forker exited\\n\");\n\n          break;\n\n          case pong_report :\n\n            printf (\"Pong\\n\");\n\n          break;\n\n          default :\n\n           printf (\"Unknown report kind\\n\");\n\n          break;\n\n        }\n\n      } else if (n == SOC_WOULD_BLOCK) {\n\n        printf (\"No report\\n\");\n\n      } else if (n == SOC_READ_0) {\n\n        printf (\"Disconnected\\n\");\n\n        exit (0);\n\n      } else {\n\n        perror(\"soc_receive\");\n\n      }\n\n    }\n\n  }\n\n}\n\n\n", "#include <sys/types.h>\n\n#include <sys/wait.h>\n\n#include <sys/stat.h>\n\n#include <stdio.h>\n\n#include <stdlib.h>\n\n#include <unistd.h>\n\n#include <signal.h>\n\n#include <string.h>\n\n#include <errno.h>\n\n#include <fcntl.h>\n\n#include <time.h>\n\n#include <sys/time.h>\n\n#include <stdarg.h>\n\n\n\n\n\n#include \"boolean.h\"\n\n#include \"socket.h\"\n\n\n\n#include \"forker_messages.h\"\n\n\n\n/* Should be defined in stdlib (not on DU 4.0) */\n\nextern int clearenv (void);\n\n\n\n/* For error messages */\n\n#define PROG_NAME \"FORKER\"\n\n\n\n/* Exit code when something is wrong */\n\n#define FATAL_ERROR_EXIT_CODE 1\n\n\n\n/* Rights of redirections: -rw-r--r-- 0644 */\n\n#define FILE_RIGHTS  (S_IRUSR|S_IWUSR|S_IRGRP|S_IROTH)\n\n\n\n/* Running command */\n\ntypedef struct com_cell {\n\n  command_number  number;\n\n  int             pid;\n\n  soc_token       soc;\n\n  soc_host        client_host;\n\n  soc_port        client_port;\n\n  struct com_cell *next, *prev;\n\n} command_cell;\n\ncommand_cell *first_com_cell, *last_com_cell;\n\n\n\n/* Known clients */\n\ntypedef struct cli_cell {\n\n  soc_token       soc;\n\n  int             fd;\n\n  struct cli_cell *next, *prev;\n\n} client_cell;\n\nclient_cell *first_cli_cell, *last_cli_cell;\n\n\n\n/* Fd to write on when child exited */\n\nstatic int write_on_me;\n\n\n\n/* Debug flag */\n\n#ifdef DEBUG\n\nstatic int debug=TRUE;\n\n#else\n\nstatic int debug=FALSE;\n\n#endif\n\n#define FORKER_DEBUG \"FORKER_DEBUG\"\n\n\n\n/* Flush traces */\n\nstatic void flush (void) {\n\n  (void) fflush (stdout);\n\n  (void) fflush (stderr);\n\n}\n\n\n\nstatic char *date_str (void) {\n\n  struct timeval time;\n\n  struct tm *tm_date_p;\n\n  static char printed_date[50];\n\n\n\n  gettimeofday (&time, NULL);\n\n  tm_date_p = gmtime(&(time.tv_sec));\n\n  sprintf (printed_date, \"%04d/%02d/%02d %02d:%02d:%02d.%03ld\",\n\n        (tm_date_p->tm_year)+1900, (tm_date_p->tm_mon)+1, tm_date_p->tm_mday,\n\n        tm_date_p->tm_hour, tm_date_p->tm_min, tm_date_p->tm_sec,\n\n        time.tv_usec/1000);\n\n\n\n  return printed_date;\n\n}\n\n\n\n/* Display error and fataf error message */\n\nstatic void fatal (const char *msg, const char *extra) {\n\n  fprintf(stderr, \"%s %s FATAL: %s%s.\\n\", date_str(), PROG_NAME, msg, extra);\n\n}\n\nstatic void error (const char *msg, const char *extra) {\n\n  fprintf(stderr, \"%s %s ERROR: %s%s.\\n\", date_str(), PROG_NAME, msg, extra);\n\n}\n\n\n\n/* Extract basename of program name */\n\nstatic char * progpath = NULL;\n\nstatic const char * progname (void) {\n\n  char *p;\n\n  int i, len;\n\n\n\n  if (progpath == NULL) {\n\n    return \"\\\"Noname\\\"\";\n\n  }\n\n  p = progpath;\n\n\n\n  len = strlen(p);\n\n\n\n  for (i = 0; i < len; i++) {\n\n    if (progpath[i] == '/') {\n\n      p = &(progpath[i+1]);\n\n    }\n\n  }\n\n  return p;\n\n}\n\n\n\n/* Display program usage */\n\nstatic void usage (void) {\n\n  fprintf(stderr, \"Usage: %s  <protocol>\\n\", progname());\n\n  fprintf(stderr, \" <protocol> ::= <udp> | <tcp> | <ipm>\\n\");\n\n  fprintf(stderr, \" <udp>      ::= -u <port>\\n\");\n\n  fprintf(stderr, \" <tcp>      ::= -t <port>\\n\");\n\n  fprintf(stderr, \" <ipm>      ::= -m <lan>:<port>\\n\");\n\n  fprintf(stderr, \" <port>     ::= <port_num> | <port_nane>\\n\");\n\n  fprintf(stderr, \" <lan>      ::= <lan_num> | <lan_name>\\n\");\n\n}\n\n\n\n/* Display trace message */\n\nstatic void trace (const char *f,...) {\n\n  va_list args;\n\n\n\n  printf (\"%s \", date_str());\n\n\n\n  va_start(args, f);\n\n  vprintf (f, args);\n\n  va_end(args);\n\n\n\n  printf (\"\\n\");\n\n\n\n}\n\n\n\n/* Trace a socket error */\n\nstatic void terror (const char *call, const int code) {\n\n  if (code != SOC_OK) {\n\n    fprintf(stderr, \"%s returned %s.\\n\", call, soc_error(code));\n\n  }\n\n}\n\n\n\n/* Toggle debug on SIGUSR1 */\n\nstatic void sigusr1_handler (int signum) {\n\n  if (signum != SIGUSR1) {\n\n    error(\"Handler called but not on sig usr1\", \"\");\n\n    return;\n\n  }\n\n  debug = !debug;\n\n  trace(\"Caught sigusr1, debug %s\", (debug ? \"on\" : \"off\"));\n\n}\n\n\n\n/* Write a byte on pipe when a child exits */\n\nstatic void sigchild_handler (int signum) {\n\n\n\n  int res;\n\n  char c = 'C';\n\n\n\n  if (signum != SIGCHLD) {\n\n    error(\"Handler called but not on sig child\", \"\");\n\n    return;\n\n  }\n\n\n\n  if (debug) {\n\n    trace(\"Caught sigchild\");\n\n  }\n\n\n\n  /* Write on pipe */\n\n  for (;;) {\n\n    res = write(write_on_me, &c, 1);\n\n    if (res > 0) break;\n\n    if ( (res == -1) && (errno != EINTR) ) {\n\n      break;\n\n    }\n\n  }\n\n  if (debug) {\n\n    trace(\"Pipe written\");\n\n  }\n\n}\n\n\n\n/* Check there is one terminator ('\\0') in string */\n\nstatic boolean has_1_nul (char *str, int len) {\n\n  int i;\n\n  for (i = 0; i < len; i++) {\n\n    if (str[i] == '\\0') {\n\n      return TRUE;\n\n    }\n\n  }\n\n  return FALSE;\n\n}\n\n\n\n/* Check there are two successive terminators (\"\\0\\0\") in string */\n\nstatic boolean has_2_nuls (char *str, int len) {\n\n  int i;\n\n  char p;\n\n\n\n  p = ' ';\n\n  for (i = 0; i < len; i++) {\n\n    if ( (str[i] == '\\0') && (p == '\\0') ) {\n\n      return TRUE;\n\n    }\n\n    p = str[i];\n\n  }\n\n  return FALSE;\n\n}\n\n\n\n/* Fork and launch a command, return forked pid or -1 */\n\nstatic int do_start_command (start_request_t *request,\n\n                             soc_token soc,\n\n                             soc_host *client_host,\n\n                             soc_port client_port) {\n\n  int res;\n\n  command_cell *cur_com_cell;\n\n  int fd;\n\n  char *start;\n\n  int nargs;\n\n  char **args;\n\n\n\n  /* Check there is a command */\n\n  if (request->command_text[0] == '\\0') {\n\n    error(\"Empty command in start message\", \"\");\n\n    return -1;\n\n  }\n\n\n\n  /* Check all strings are propoerly terminated */\n\n  if (! has_2_nuls(request->command_text,\n\n                   sizeof(request->command_text)) ) {\n\n    error(\"Invalid text in start command\", \"\");\n\n    return -1;\n\n  }\n\n  if (! has_2_nuls(request->environ_variables,\n\n                   sizeof(request->environ_variables)) ) {\n\n    error(\"Invalid text in start environ\", \"\");\n\n    return -1;\n\n  }\n\n  if (! has_1_nul(request->currend_dir,\n\n                  sizeof(request->currend_dir)) ) {\n\n    error(\"Invalid text in start curdir\", \"\");\n\n    return -1;\n\n  }\n\n  if (! has_1_nul(request->output_flow,\n\n                  sizeof(request->output_flow)) ) {\n\n    error(\"Invalid text in start stdout\", \"\");\n\n    return -1;\n\n  }\n\n  if (! has_1_nul(request->error_flow,\n\n                  sizeof(request->error_flow)) ) {\n\n    error(\"Invalid text in start stderr\", \"\");\n\n    return -1;\n\n  }\n\n\n\n  /* Procreate */\n\n  flush();\n\n  res = fork();\n\n  if (res == -1) {\n\n    perror(\"fork\");\n\n    error(\"Cannot fork\", \"\");\n\n    return -1;\n\n  } else if (res != 0) {\n\n    /***************/\n\n    /* Forker code */\n\n    /***************/\n\n    cur_com_cell = malloc(sizeof(command_cell));\n\n    if (cur_com_cell == NULL) {\n\n      perror(\"malloc\");\n\n      error(\"Cannot malloc a new command cell\", \"\");\n\n      return -1;\n\n    }\n\n    /* Allocate a cell and store command and pid */\n\n    cur_com_cell->pid = res;\n\n    cur_com_cell->number = request->number;\n\n    cur_com_cell->soc = soc;\n\n    memcpy (&(cur_com_cell->client_host), client_host, sizeof(soc_host));\n\n    cur_com_cell->client_port = client_port;\n\n    cur_com_cell->client_port = client_port;\n\n    cur_com_cell->next = first_com_cell;\n\n    cur_com_cell->prev = NULL;\n\n    first_com_cell = cur_com_cell;\n\n    if (cur_com_cell->next != NULL) {\n\n      (cur_com_cell->next)->prev = cur_com_cell;\n\n    } else {\n\n      last_com_cell = cur_com_cell;\n\n    }\n\n    if (debug) {\n\n      trace (\"Forked pid %d\", res);\n\n    }\n\n    /* Done */\n\n    return res;\n\n  }\n\n\n\n  /**************/\n\n  /* Child code */\n\n  /**************/\n\n  /* Set current directory */\n\n  if (request->currend_dir[0] != '\\0') {\n\n    if (chdir(request->currend_dir) != 0) {\n\n      perror(\"chdir\");\n\n      error(\"Cannot change to current directory: \", request->currend_dir);\n\n      exit(FATAL_ERROR_EXIT_CODE);\n\n    }\n\n    if (debug) {\n\n      trace (\"Curdir changed to >%s<\", request->currend_dir);\n\n    }\n\n  }\n\n\n\n  /* Set environnement variables */\n\n  start = request->environ_variables;\n\n  while (*start != '\\0') {\n\n    if(putenv(start) != 0) {\n\n      perror(\"putenv\");\n\n      error(\"Cannot set environement variable: \", start);\n\n      exit(FATAL_ERROR_EXIT_CODE);\n\n    }\n\n    if (debug) {\n\n      trace (\"Envir added: >%s<\", start);\n\n    }\n\n    /* Find end of string */\n\n    while (*start != '\\0') start++;\n\n    /* Start of next env */\n\n    start++;\n\n  }\n\n\n\n  /* Output flow */\n\n  if (request->output_flow[0] != '\\0') {\n\n    if (debug) {\n\n      trace (\"Setting stdout to >%s< append %d\", request->output_flow,\n\n              (int)request->append_output);\n\n    }\n\n    fd = open (request->output_flow,\n\n                O_CREAT | O_WRONLY | (request->append_output ? O_APPEND : O_TRUNC),\n\n                FILE_RIGHTS);\n\n    if (fd == -1) {\n\n      perror(\"open\");\n\n      error(\"Cannot open output flow: \", request->output_flow);\n\n      exit(FATAL_ERROR_EXIT_CODE);\n\n    }\n\n    flush ();\n\n    if (dup2(fd, fileno(stdout)) == -1) {\n\n      perror(\"dup2\");\n\n      error(\"Cannot duplicate output flow\", \"\");\n\n      exit(FATAL_ERROR_EXIT_CODE);\n\n    }\n\n    close(fd);\n\n    if (debug) {\n\n      trace (\"Stdout set to >%s< append %d\", request->output_flow,\n\n              (int)request->append_output);\n\n    }\n\n  }\n\n\n\n  /* Error flow */\n\n  if (request->error_flow[0] != '\\0') {\n\n    if (debug) {\n\n      trace (\"Setting stderr to >%s< append %d\", request->error_flow,\n\n              (int)request->append_error);\n\n    }\n\n    fd = open (request->error_flow,\n\n                O_CREAT | O_WRONLY | (request->append_error ? O_APPEND : O_TRUNC),\n\n                FILE_RIGHTS);\n\n    if (fd == -1) {\n\n      perror(\"open\");\n\n      error(\"Cannot open error flow: \", request->error_flow);\n\n      exit(FATAL_ERROR_EXIT_CODE);\n\n    }\n\n    flush ();\n\n    if (dup2(fd, fileno(stderr)) == -1) {\n\n      perror(\"dup2\");\n\n      error(\"Cannot duplicate error flow\", \"\");\n\n      exit(FATAL_ERROR_EXIT_CODE);\n\n    }\n\n    close(fd);\n\n    if (debug) {\n\n      trace (\"Stderr set to >%s< append %d\", request->error_flow,\n\n              (int)request->append_error);\n\n    }\n\n  }\n\n\n\n  /* Count program name + arguments */\n\n  nargs = 0;\n\n  start = request->command_text;\n\n  while (*start != '\\0') {\n\n    nargs++;\n\n    while (*start != '\\0') start++;\n\n    start++;\n\n  }\n\n\n\n  /* Need one slot more for NULL */\n\n  nargs++;\n\n\n\n  /* Allocate table */\n\n  args = malloc(nargs * sizeof(char*));\n\n  if (args == NULL) {\n\n    perror(\"malloc\");\n\n    error(\"Cannot malloc array of arguments\", \"\");\n\n    exit(FATAL_ERROR_EXIT_CODE);\n\n  }\n\n\n\n  /* Fill table[0] <- program name */\n\n  args[0] = request->command_text;\n\n  start = request->command_text;\n\n  while (*start != '\\0') start++;\n\n  start++;\n\n  nargs = 1;\n\n\n\n  /* Fill table with arguments */\n\n  while (*start != '\\0') {\n\n    args[nargs] = start;\n\n    while (*start != '\\0') start++;\n\n    start++;\n\n    nargs++;\n\n  }\n\n  args[nargs] = NULL;\n\n\n\n  if (debug) {\n\n    int li = 0;\n\n    trace (\"\");\n\n    printf (\"Command line: >%s<\", request->command_text);\n\n    while (args[li] != NULL) {\n\n      printf (\" >%s<\", args[li]);\n\n      li++;\n\n    }\n\n    printf (\"\\n\\n\");\n\n    flush ();\n\n  }\n\n\n\n  /* Now the exec */\n\n  if (execv(request->command_text, args) == -1) {\n\n    perror(\"execv\");\n\n    error(\"Cannot exec command: \", request->command_text);\n\n    exit(FATAL_ERROR_EXIT_CODE);\n\n  }\n\n\n\n  /* Never reached */\n\n  exit(FATAL_ERROR_EXIT_CODE);\n\n}\n\n\n\n\n\n/* Check message kind and size are correct and match */\n\n/* len has to be size of request_u or size of current request_t */\n\nstatic boolean msg_ok (soc_length len, request_kind_list kind) {\n\n  switch (kind) {\n\n    case start_command:\n\n      if (len == sizeof(start_request_t)) return TRUE;\n\n    break;\n\n    case kill_command:\n\n      if (len == sizeof(kill_request_t)) return TRUE;\n\n    break;\n\n    case fexit_command:\n\n      if (len == sizeof(fexit_request_t)) return TRUE;\n\n    break;\n\n    case ping_command:\n\n      if (len == 0) return TRUE;\n\n    break;\n\n    default:\n\n      error(\"Received a message with invalid command\", \"\");\n\n    return FALSE;\n\n  }\n\n  if (len == sizeof(request_u)) {\n\n    return TRUE;\n\n  } else {\n\n    error(\"Received a message of invalid size\", \"\");\n\n    return FALSE;\n\n  }\n\n}\n\n\n\nstatic boolean send (soc_token dest, soc_message msg,  soc_length len) {\n\n  int res;\n\n\n\n  /* Try to send */\n\n  res = soc_send(dest, msg, len);\n\n  if (res == SOC_OK) {\n\n    if (debug) {\n\n      trace (\"Report message sent\");\n\n    }\n\n    return TRUE;\n\n  } else if (res == SOC_WOULD_BLOCK) {\n\n    if (debug) {\n\n      trace (\"Overflow while sending report\");\n\n    }\n\n    return TRUE;\n\n  } else if (res != SOC_TAIL_ERR) {\n\n    perror(\"sending on socket\");\n\n    terror(\"soc_send\", res);\n\n    error(\"Cannot send report message\", \"\");\n\n    return FALSE;\n\n  }\n\n\n\n  /* Socket was in overflow */\n\n  res = soc_resend(dest);\n\n  if (res != SOC_OK) {\n\n    perror(\"sending on socket\");\n\n    terror(\"soc_resend\", res);\n\n    error(\"Cannot resend previous report message\", \"\");\n\n    return FALSE;\n\n  }\n\n  if (debug) {\n\n    trace (\"Previous report message resent\");\n\n  }\n\n\n\n  /* Retry to send */\n\n  res = soc_send(dest, msg, len);\n\n  if (res == SOC_OK) {\n\n    if (debug) {\n\n      trace (\"Report message sent\");\n\n    }\n\n    return TRUE;\n\n  } else if (res == SOC_WOULD_BLOCK) {\n\n    if (debug) {\n\n      trace (\"Overflow while sending report\");\n\n    }\n\n    return TRUE;\n\n  } else {\n\n    perror(\"sending on socket\");\n\n    terror(\"soc_send\", res);\n\n    error(\"Cannot send report message\", \"\");\n\n    return FALSE;\n\n  }\n\n}\n\n\n\n\n\nint main (int argc, char *argv[]) {\n\n\n\n  char *debug_var;\n\n  soc_token service_soc = NULL;\n\n  soc_token client_soc = NULL;\n\n  typedef enum {None, Udp, Tcp, Ipm} proto_list;\n\n  int i, j, k, separator;\n\n  proto_list proto;\n\n  int port_no;\n\n  char *port_name;\n\n  char *lan_name;\n\n  int nfds;\n\n  fd_set saved_mask, select_mask;\n\n  int service_fd, client_fd;\n\n  int pipe_fd[2];\n\n  int res;\n\n  char c;\n\n  pid_t a_pid;\n\n  command_cell *cur_com_cell;\n\n  client_cell  *cur_cli_cell = NULL;\n\n  report_message_t report;\n\n  request_message_t request_message;\n\n  soc_length        request_len;\n\n  soc_host          request_host, lan_no;\n\n  soc_port          request_port;\n\n\n\n\n\n  /* Init debug */\n\n  progpath = argv[0];\n\n  debug_var = getenv(FORKER_DEBUG);\n\n  if ( (debug_var != NULL)\n\n    && (strcmp(debug_var, \"Y\") == 0) ) {\n\n    debug = TRUE;\n\n  } else if ( (debug_var != NULL)\n\n            && (strcmp(debug_var, \"N\") == 0) ) {\n\n    debug = FALSE;\n\n  } /* Else unchanged from compilation option */\n\n\n\n\n\n  /* Check and parse the argument: -u/-t/-m then port [@lan]*/\n\n  proto = None;\n\n  if (argc == 1) {\n\n    fatal(\"Missing argument for protocole\", \"\");\n\n  } else if (argc != 3) {\n\n    fatal(\"Invalid arguments\", \"\");\n\n  } else {\n\n    if (strcmp (argv[1], \"-u\") == 0) {\n\n      proto = Udp;\n\n    } else if (strcmp (argv[1], \"-t\") == 0) {\n\n      proto = Tcp;\n\n    } else if (strcmp (argv[1], \"-m\") == 0) {\n\n      proto = Ipm;\n\n    } else {\n\n      fatal(\"Invalid argument: \", argv[1]);\n\n    }\n\n  }\n\n  if (proto == None) {\n\n    usage();\n\n    exit(FATAL_ERROR_EXIT_CODE);\n\n  }\n\n\n\n  /* Set port_name */\n\n  port_name = malloc(strlen(argv[2])+1);\n\n  strcpy (port_name, argv[2]);\n\n\n\n  /* Decode ipm address: <port>@<lan>:* One unique '@', not first nor last */\n\n  if (proto == Ipm) {\n\n    separator = 0;\n\n    for (i = 0; i < (signed)strlen(argv[2]); i++) {\n\n      if (port_name[i] == ':') {\n\n        if (separator != 0) {\n\n          /* Several separator: error */\n\n          separator = 0;\n\n          break;\n\n        }\n\n        separator = i;\n\n      }\n\n    }\n\n    /* Check separator is found not last */\n\n    if (separator == (signed)strlen(port_name) - 1) separator = 0;\n\n    if (separator == 0) {\n\n      fatal(\"Invalid ipm address: \", port_name);\n\n      usage();\n\n      exit(FATAL_ERROR_EXIT_CODE);\n\n    }\n\n    lan_name = port_name;\n\n    port_name[separator] = '\\0';\n\n    port_name += separator + 1;\n\n    /* See if lan name or num */\n\n    separator = -1;\n\n    j = 0;\n\n    k = (signed) strlen(lan_name);\n\n    for (i = 0; i < k; i++) {\n\n      if (lan_name[i] == '.') {\n\n        /* Separator between bytes */\n\n        lan_name[i] = '\\0';\n\n        lan_no.bytes[j] = (byte) atoi (&lan_name[separator+1]);\n\n        separator = i;\n\n        j++;\n\n      } else if ( (lan_name[i] < '0') || (lan_name[i] > '9') ) {\n\n        /* Not a byte */\n\n        separator = -1;\n\n        break;\n\n      }\n\n    }\n\n    if (separator != -1) {\n\n      /* Last byte */\n\n      lan_no.bytes[j] = (byte) atoi (&lan_name[separator+1]);\n\n      for (i = 0; i<= 3; i++) {\n\n        if (lan_no.bytes[i] == 0) {\n\n          separator = -1;\n\n        }\n\n      }\n\n    }\n\n    if (separator != -1) {\n\n      lan_name = NULL;\n\n    }\n\n  }\n\n  port_no = atoi(port_name);\n\n\n\n  /* Create the socket */\n\n  res = soc_open(&service_soc,\n\n               ((proto == Tcp) ? tcp_header_socket : udp_socket) );\n\n  if (res != SOC_OK) {\n\n    perror(\"opening socket\");\n\n    terror(\"soc_open\", res);\n\n    fatal(\"Cannot create socket\", \"\");\n\n    exit(FATAL_ERROR_EXIT_CODE);\n\n  }\n\n\n\n  /* Set IPM LAN */\n\n  if (proto == Ipm) {\n\n    if (port_no <= 0) {\n\n      if (lan_name != NULL) {\n\n        res = soc_set_dest_name_service(service_soc, lan_name, TRUE, port_name);\n\n        if (res != SOC_OK) {\n\n          perror(\"setting socket dest lan name with port name\");\n\n          terror(\"soc_set_dest_name_service\", res);\n\n          fatal(\"Cannot set ipm lan to: \", argv[2]);\n\n          exit (FATAL_ERROR_EXIT_CODE);\n\n        }\n\n      } else {\n\n        res = soc_set_dest_host_service(service_soc, &lan_no, port_name);\n\n        if (res != SOC_OK) {\n\n          perror(\"setting socket dest lan num with port name\");\n\n          terror(\"soc_set_dest_host_service\", res);\n\n          fatal(\"Cannot set ipm lan to: \", argv[2]);\n\n          exit (FATAL_ERROR_EXIT_CODE);\n\n        }\n\n      }\n\n    } else {\n\n      if (lan_name != NULL) {\n\n        res = soc_set_dest_name_port (service_soc, lan_name, TRUE, port_no);\n\n        if (res != SOC_OK) {\n\n          perror(\"setting socket dest lan name with port no\");\n\n          terror(\"soc_set_dest_name_port\", res);\n\n          fatal(\"Cannot set ipm lan to: \", argv[2]);\n\n          exit (FATAL_ERROR_EXIT_CODE);\n\n        }\n\n      } else {\n\n        res = soc_set_dest_host_port (service_soc, &lan_no, port_no);\n\n        if (res != SOC_OK) {\n\n          perror(\"setting socket dest lan num with port no\");\n\n          terror(\"soc_set_dest_host_port\", res);\n\n          fatal(\"Cannot set ipm lan to: \", argv[2]);\n\n          exit (FATAL_ERROR_EXIT_CODE);\n\n        }\n\n      }\n\n    }\n\n  }\n\n\n\n  /* Bind */\n\n  if (port_no <= 0) {\n\n    res = soc_link_service(service_soc, port_name);\n\n    if (res != SOC_OK) {\n\n      perror(\"linking socket\");\n\n      terror(\"soc_link_service\", res);\n\n      fatal(\"Cannot bind socket to name: \", port_name);\n\n      exit (FATAL_ERROR_EXIT_CODE);\n\n    }\n\n  } else {\n\n    res = soc_link_port(service_soc, port_no);\n\n    if (res != SOC_OK) {\n\n      perror(\"linking socket\");\n\n      terror(\"soc_link_port\", res);\n\n      fatal(\"Cannot bind socket to no: \", port_name);\n\n      exit (FATAL_ERROR_EXIT_CODE);\n\n    }\n\n  }\n\n\n\n  /* Get socket fd for the select */\n\n  res = soc_get_id(service_soc, &service_fd);\n\n  if (res != SOC_OK) {\n\n    perror(\"getting service socket fd\");\n\n    terror(\"soc_get_id\", res);\n\n    fatal(\"Cannot get service socket fd\", \"\");\n\n    exit (FATAL_ERROR_EXIT_CODE);\n\n  }\n\n\n\n  /* Create pipe and save writting fd for sigchild handler */\n\n  if (pipe(pipe_fd) == -1) {\n\n    perror(\"pipe\");\n\n    fatal(\"Cannot create pipe\", \"\");\n\n    exit (FATAL_ERROR_EXIT_CODE);\n\n  }\n\n  write_on_me = pipe_fd[1];\n\n\n\n  /* Close on exec on pipe fds */\n\n  if (fcntl(pipe_fd[0], F_SETFD, FD_CLOEXEC) < 0) {\n\n    perror(\"fcntl(FD_CLOEXEC)\");\n\n    fatal(\"Cannot set close on exec on pipe_fd[0]\", \"\");\n\n    exit (FATAL_ERROR_EXIT_CODE);\n\n  }\n\n  if (fcntl(pipe_fd[1], F_SETFD, FD_CLOEXEC) < 0) {\n\n    perror(\"fcntl(FD_CLOEXEC)\");\n\n    fatal(\"Cannot set close on exec on pipe_fd[1]\", \"\");\n\n    exit (FATAL_ERROR_EXIT_CODE);\n\n  }\n\n\n\n\n\n  /* Build select mask */\n\n  nfds = 0;\n\n  FD_ZERO (&saved_mask);\n\n  FD_SET(service_fd, &saved_mask);\n\n  if (service_fd > nfds) nfds = service_fd;\n\n  FD_SET(pipe_fd[0], &saved_mask);\n\n  if (pipe_fd[0] > nfds) nfds = pipe_fd[0];\n\n\n\n  /* Hook handler for child signal */\n\n  if (signal (SIGCHLD, sigchild_handler) == SIG_ERR) {\n\n    perror(\"signal\");\n\n    fatal(\"Cannot hook signal child handler\", \"\");\n\n    exit (FATAL_ERROR_EXIT_CODE);\n\n  }\n\n\n\n  /* Hook handler for usr1 signal */\n\n  if (signal (SIGUSR1, sigusr1_handler) == SIG_ERR) {\n\n    perror(\"signal\");\n\n    fatal(\"Cannot hook signal usr1 handler\", \"\");\n\n    exit (FATAL_ERROR_EXIT_CODE);\n\n  }\n\n\n\n  /* Init lists of commands and clients*/\n\n  first_com_cell = last_com_cell = NULL;\n\n  first_cli_cell = last_cli_cell = NULL;\n\n\n\n  /* Clear environ */\n\n  if (clearenv() != 0) {\n\n    perror(\"clearenv\");\n\n    fatal(\"Cannot clear environment\", \"\");\n\n    exit (FATAL_ERROR_EXIT_CODE);\n\n  }\n\n\n\n\n\n  /* Ready */\n\n  fprintf(stderr, \"%s %s ready. %s\\n\", date_str(), PROG_NAME, (debug ? \"Debug on.\" : \"\"));\n\n\n\n  /* Main loop */\n\n  for (;;) {\n\n\n\n    /* Select loop while EINTR */\n\n    for (;;) {\n\n\n\n      /* Flush traces including signals */\n\n      flush ();\n\n\n\n      /* The Select */\n\n      memcpy(&select_mask, &saved_mask, sizeof(fd_set));\n\n      res = select(nfds+1, &select_mask, (fd_set*)NULL, (fd_set*)NULL,\n\n                   (struct timeval*)NULL);\n\n      if (res > 0) break;\n\n      if ( (res == -1) && (errno != EINTR) ) break;\n\n    }\n\n    if (res < 0) {\n\n      perror(\"select\");\n\n      continue;\n\n    }\n\n\n\n    /* Where data to read? */\n\n    if (FD_ISSET(pipe_fd[0], &select_mask)) {\n\n\n\n      /* Data on pipe, read the byte */\n\n      if (debug) {\n\n        trace (\"Data on pipe\");\n\n      }\n\n      for (;;) {\n\n        res = read(pipe_fd[0], &c, 1);\n\n        if (res > 0) break;\n\n        if ( (res == -1) && (errno != EINTR) ) break;\n\n      }\n\n      if (res < 0) {\n\n        perror(\"read\");\n\n        continue;\n\n      }\n\n      if (debug) {\n\n        trace (\"Data read on pipe\");\n\n      }\n\n\n\n      /* Look for several exited children */\n\n      report.kind = exit_report;\n\n      for (;;) {\n\n        boolean do_send;\n\n\n\n        /* Get a dead pid */\n\n        for (;;) {\n\n          res = waitpid((pid_t)-1, &(report.exit_rep.exit_status), WNOHANG);\n\n          if (res > 0) break;\n\n          if ( (res == -1) && (errno != EINTR) ) break;\n\n        }\n\n        if ((res == 0) || ( (res == -1) && (errno == ECHILD) ) ) {\n\n          /* No more child */\n\n          if (debug) {\n\n            trace (\"No more child\\n\");\n\n          }\n\n          break;\n\n        } else if (res < 0) {\n\n          perror(\"waitpid\");\n\n          continue;\n\n        }\n\n\n\n        /* Child pid */\n\n        a_pid = res;\n\n        if (debug) {\n\n          trace (\"Pid %d exited code %d\", a_pid, report.exit_rep.exit_status);\n\n        }\n\n\n\n        /* Look for pid in list */\n\n        cur_com_cell = last_com_cell;\n\n        while ( (cur_com_cell != NULL) && (cur_com_cell->pid != a_pid) ) {\n\n          cur_com_cell = cur_com_cell->prev;\n\n        }\n\n        if (cur_com_cell == NULL) {\n\n          char dbg[50];\n\n          sprintf(dbg, \"%d\", a_pid);\n\n          error(\"Cannot find in list pid: \", dbg);\n\n          continue;\n\n        }\n\n\n\n        /* Found the command number */\n\n        report.exit_rep.number = cur_com_cell->number;\n\n        report.exit_rep.exit_pid = cur_com_cell->pid;\n\n        if (debug) {\n\n          trace (\"Command was %d\", report.exit_rep.number);\n\n        }\n\n\n\n        /* Set dest to client for report */\n\n        do_send = TRUE;\n\n        if (proto != Tcp) {\n\n          client_soc = service_soc;\n\n          res = soc_set_dest_host_port(client_soc, &(cur_com_cell->client_host),\n\n                                       cur_com_cell->client_port);\n\n          if (res != SOC_OK) {\n\n            error(\"Cannot set dest to client\", \"\");\n\n            terror(\"soc_set_dest_host_port\", res);\n\n            do_send = FALSE;\n\n          }\n\n        } else {\n\n          client_soc = cur_com_cell->soc;\n\n        }\n\n        if (do_send && debug) {\n\n          trace (\"Dest set to host %u port %u\",\n\n                  cur_com_cell->client_host.integer,\n\n                  cur_com_cell->client_port);\n\n        }\n\n\n\n        /* Free the cell */\n\n        if (cur_com_cell->next != NULL) {\n\n          (cur_com_cell->next)->prev = cur_com_cell->prev;\n\n        } else {\n\n          last_com_cell = cur_com_cell->prev;\n\n        }\n\n        if (cur_com_cell->prev != NULL) {\n\n          (cur_com_cell->prev)->next = cur_com_cell->next;\n\n        } else {\n\n          first_com_cell = cur_com_cell->next;\n\n        }\n\n        free(cur_com_cell);\n\n\n\n        /* Send report */\n\n        if (do_send) {\n\n          res = send(client_soc, (soc_message)&report, sizeof(report));\n\n          if (debug && res) {\n\n            trace (\"Exit report sent\");\n\n          }\n\n        }\n\n\n\n      } /* For each dead child */\n\n      continue;\n\n    }\n\n\n\n    if ( (proto == Tcp) && FD_ISSET(service_fd, &select_mask)) {\n\n      if (debug) {\n\n        trace (\"Accepting new client\");\n\n      }\n\n      /* Accept */\n\n      client_soc = init_soc;\n\n      res = soc_accept(service_soc, &client_soc);\n\n      if (res  != SOC_OK) {\n\n        perror(\"accepting new client\");\n\n        terror(\"soc_accept\", res);\n\n        error(\"Cannot accept new client\", \"\");\n\n        continue;\n\n      }\n\n      res = soc_set_blocking(client_soc, FALSE);\n\n      if (res  != SOC_OK) {\n\n        perror(\"setting non blocking\");\n\n        terror(\"soc_set_blocking\", res);\n\n        error(\"Cannot set new client socket non blocking\", \"\");\n\n      }\n\n      res  = soc_get_id (client_soc, &client_fd);\n\n      if (res  != SOC_OK) {\n\n        perror(\"getting new client fd\");\n\n        terror(\"soc_get_id\", res);\n\n        error(\"Cannot get fd of new client\", \"\");\n\n        continue;\n\n      }\n\n\n\n      /* Insert client cell */\n\n      cur_cli_cell = malloc(sizeof(client_cell));\n\n      if (cur_cli_cell == NULL) {\n\n        perror(\"malloc\");\n\n        error(\"Cannot malloc a new client cell\", \"\");\n\n        continue;\n\n      }\n\n      cur_cli_cell->soc = client_soc;\n\n      cur_cli_cell->fd = client_fd;\n\n      cur_cli_cell->next = first_cli_cell;\n\n      cur_cli_cell->prev = NULL;\n\n      first_cli_cell = cur_cli_cell;\n\n      if (cur_cli_cell->next != NULL) {\n\n        (cur_cli_cell->next)->prev = cur_cli_cell;\n\n      } else {\n\n        last_cli_cell = cur_cli_cell;\n\n      }\n\n\n\n      /* Add to mask */\n\n      FD_SET(client_fd, &saved_mask);\n\n      if (client_fd > nfds) nfds = client_fd;\n\n      if (debug) {\n\n        trace (\"New client accepted with fd %d\", client_fd);\n\n      }\n\n      continue;\n\n\n\n    }\n\n\n\n    /* Get client socket */\n\n    client_soc = init_soc;\n\n    if (proto != Tcp) {\n\n      if (FD_ISSET(service_fd, &select_mask)) {\n\n        client_soc = service_soc;\n\n        client_fd  = service_fd;\n\n      }\n\n    } else {\n\n      /* Look for client */\n\n      cur_cli_cell = first_cli_cell;\n\n      while (cur_cli_cell != NULL) {\n\n        if (FD_ISSET(cur_cli_cell->fd, &select_mask)) {\n\n          client_soc = cur_cli_cell->soc;\n\n          client_fd = cur_cli_cell->fd;\n\n          break;\n\n        }\n\n        cur_cli_cell = cur_cli_cell->next;\n\n      }\n\n    }\n\n\n\n    if (client_soc == init_soc) {\n\n      int i;\n\n      error(\"received data on an unknown fd\", \"\");\n\n      for (i = 0; i <= nfds; i++) {\n\n        if (FD_ISSET(i, &select_mask)) {\n\n          FD_CLR(i, &saved_mask);\n\n          trace(\"removed from mask fd %d\", i);\n\n        }\n\n      }\n\n      continue;\n\n    }\n\n\n\n\n\n    /* A request */\n\n    if (debug) {\n\n      trace (\"Data on socket\");\n\n    }\n\n\n\n    /* Read request */\n\n    request_len = soc_receive(client_soc, &request_message,\n\n                              sizeof(request_message), (proto != Tcp));\n\n\n\n    /* Handle Tcp disconnection */\n\n    if ((proto == Tcp) && ( (request_len == SOC_CONN_LOST)\n\n               || (request_len == SOC_READ_0) ) ) {\n\n      if (debug) {\n\n        trace (\"Disconnection of client on fd %d\", client_fd);\n\n      }\n\n\n\n      FD_CLR(client_fd, &saved_mask);\n\n      soc_close (&client_soc);\n\n\n\n      /* Free the cell */\n\n      if (cur_cli_cell->next != NULL) {\n\n        (cur_cli_cell->next)->prev = cur_cli_cell->prev;\n\n      } else {\n\n        last_cli_cell = cur_cli_cell->prev;\n\n      }\n\n      if (cur_cli_cell->prev != NULL) {\n\n        (cur_cli_cell->prev)->next = cur_cli_cell->next;\n\n      } else {\n\n        first_cli_cell = cur_cli_cell->next;\n\n      }\n\n      free(cur_cli_cell);\n\n      continue;\n\n    }\n\n\n\n    /* Check len */\n\n    if (request_len < SOC_OK) {\n\n      perror(\"receiving from socket\");\n\n      terror(\"soc_receive\", request_len);\n\n      error(\"Cannot receive request message\", \"\");\n\n      continue;\n\n    }\n\n\n\n    /* Check message */\n\n    if ((unsigned int)request_len < sizeof(request_message.kind)) {\n\n      error(\"Received a message of invalid size\", \"\");\n\n      continue;\n\n    }\n\n    if (! msg_ok (request_len - sizeof(request_message.kind), request_message.kind) ) {\n\n      continue;\n\n    }\n\n\n\n\n\n    /* Get client host and port */\n\n    res  = soc_get_dest_host(client_soc, &request_host);\n\n    if (res != SOC_OK) {\n\n      terror(\"soc_get_dest_host\", res);\n\n      error(\"Cannot get client host\", \"\");\n\n      continue;\n\n    }\n\n    res = soc_get_dest_port(client_soc, &request_port);\n\n    if (res != SOC_OK) {\n\n      terror(\"soc_get_dest_port\", res);\n\n      error(\"Cannot get client port\", \"\");\n\n      continue;\n\n    }\n\n    if (debug) {\n\n      trace (\"Client is host %u port %u\",\n\n              request_host.integer,\n\n              request_port);\n\n    }\n\n\n\n    if (request_message.kind == kill_command) {\n\n\n\n      report.kind = kill_report;\n\n      report.kill_rep.number = request_message.kill_req.number;\n\n      if (debug) {\n\n        trace (\"Request kill num %d sig %d\",\n\n              request_message.kill_req.number,\n\n              request_message.kill_req.signal_number);\n\n      }\n\n\n\n      /* Kill command: Find pid from criteria Num, host, port */\n\n      report.kill_rep.killed_pid = -1;\n\n      cur_com_cell = last_com_cell;\n\n      while (cur_com_cell != NULL) {\n\n        if ( (cur_com_cell->number == request_message.kill_req.number)\n\n          && (cur_com_cell->client_port == request_port)\n\n          && (memcmp(&(cur_com_cell->client_host),\n\n                     &request_host,\n\n                     sizeof(soc_host)) == 0) ) {\n\n            break;\n\n        }\n\n        cur_com_cell = cur_com_cell->prev;\n\n      }\n\n      if (cur_com_cell == NULL) {\n\n        if (debug) {\n\n          trace (\"Cannot find command-host-port in list\");\n\n        }\n\n        report.kill_rep.killed_pid = -1;\n\n      } else {\n\n        if (debug) {\n\n          trace (\"Pid to kill is %d\", cur_com_cell->pid);\n\n        }\n\n        report.kill_rep.killed_pid = cur_com_cell->pid;\n\n      }\n\n\n\n      /* Kill the child */\n\n      if ( (report.kill_rep.killed_pid != -1)\n\n        && (kill(cur_com_cell->pid,\n\n                 request_message.kill_req.signal_number) == -1) ) {\n\n        char dbg[50];\n\n        perror(\"kill\");\n\n        sprintf(dbg, \"%d\", cur_com_cell->pid);\n\n        error(\"Cannot kill child pid: \", dbg);\n\n        report.kill_rep.killed_pid = -1;\n\n      }\n\n    } else if (request_message.kind == start_command) {\n\n\n\n      /* Start command */\n\n      if (debug) {\n\n        trace (\"Request start %d: %s\",\n\n                request_message.start_req.number,\n\n                request_message.start_req.command_text);\n\n      }\n\n      report.kind = start_report;\n\n      report.start_rep.number = request_message.start_req.number;\n\n      report.start_rep.started_pid =\n\n             do_start_command(&request_message.start_req,\n\n                              client_soc,\n\n                              &request_host, request_port);\n\n\n\n    } else if (request_message.kind == fexit_command) {\n\n\n\n      /* Exit command */\n\n      if (debug) {\n\n        trace (\"Request exit %d\", request_message.fexit_req.exit_code);\n\n      }\n\n      report.kind = fexit_report;\n\n\n\n    } else if (request_message.kind == ping_command) {\n\n\n\n      /* Ping command */\n\n      if (debug) {\n\n        trace (\"Request ping\");\n\n      }\n\n      report.kind = pong_report;\n\n\n\n    } else {\n\n        error(\"Received a message with invalid command\", \"\");\n\n        continue;\n\n    }\n\n\n\n    /* Send report */\n\n    if (! send(client_soc, (soc_message)&report, sizeof(report)) ) {\n\n      perror(\"sending on socket\");\n\n      error(\"Cannot send exit report message\", \"\");\n\n    } else if (debug) {\n\n      trace (\"Start/Kill/Exit/Pong report sent\\n\");\n\n    }\n\n\n\n    if (request_message.kind == fexit_command) {\n\n      if (debug) {\n\n        trace (\"Exiting code %d\", request_message.fexit_req.exit_code);\n\n      }\n\n      exit(request_message.fexit_req.exit_code);\n\n    }\n\n\n\n\n\n  } /* Main loop */\n\n\n\n}\n\n\n", "#include <stdlib.h>\n\n#include <errno.h>\n\n\n\n#define __USE_GNU\n\n#include \"mutex.h\"\n\n\n\n/* Create a mutex */\n\nextern mutex_t mutex_create(void) {\n\n  mutex_t mutex;\n\n  pthread_mutex_t mut = PTHREAD_ERRORCHECK_MUTEX_INITIALIZER_NP;\n\n\n\n  /* Allocate mutex */\n\n  mutex = malloc(sizeof(pthread_mutex_t));\n\n  if (mutex == NULL) {\n\n    return NULL;\n\n  }\n\n\n\n  /* Init mutex */\n\n  *mutex = mut;\n\n\n\n  return mutex;\n\n}\n\n\n\n\n\n/* Destroy a mutex */\n\n/* Returns MUT_LOCKED if the mutex is locked */\n\n/* Else returns MUT_OK */\n\nextern int mutex_destroy (mutex_t mutex) {\n\n  int res;\n\n\n\n  /* Destroy mutex */\n\n  res = pthread_mutex_destroy(mutex);\n\n\n\n  switch (res ) {\n\n    case 0 : break;\n\n    case EBUSY : return MUT_LOCKED;\n\n    default : return MUT_ERROR;\n\n  }\n\n\n\n  /* Free mutex*/\n\n  free (mutex);\n\n  return MUT_OK;\n\n}\n\n\n\n\n\n/* Get a mutex */\n\n/* Returns MUT_DEADLOCK if this thread already owns this mutex */\n\n/* If wait is set to TRUE, wait for mutex and return MUT_OK */\n\n/* Else, may return MUT_OK or MUT_LOCKED */\n\nextern int mutex_lock (mutex_t mutex, boolean wait) {\n\n  int res;\n\n\n\n  if (wait) {\n\n    res = pthread_mutex_lock (mutex);\n\n  } else {\n\n    res = pthread_mutex_trylock (mutex);\n\n  }\n\n\n\n  switch (res ) {\n\n    case 0 : return MUT_OK;\n\n    case EINVAL : return MUT_ERROR;\n\n    case EDEADLK : return MUT_DEADLOCK;\n\n    case EBUSY : return MUT_LOCKED;\n\n    default : return MUT_ERROR;\n\n  }\n\n}\n\n\n\n\n\n/* Release a mutex */\n\n/* Returns MUT_NOTLOCKED if not locked by this thread (or not locked at all) */\n\n/* Else returns MUT_OK */\n\nextern int mutex_unlock (mutex_t mutex) {\n\n  int res;\n\n\n\n  res = pthread_mutex_unlock (mutex);\n\n\n\n  switch (res) {\n\n    case 0 : return MUT_OK;\n\n    case EINVAL : return MUT_ERROR;\n\n    case EPERM : return MUT_DEADLOCK;\n\n    default : return MUT_ERROR;\n\n  }\n\n}\n\n\n", "#include <pthread.h>\n\n\n\n#include \"boolean.h\"\n\n\n\n#define MUT_OK         (0)\n\n#define MUT_LOCKED    (-1)\n\n#define MUT_DEADLOCK  (-2)\n\n#define MUT_NOTLOCKED (-3)\n\n#define MUT_ERROR     (-4)\n\n\n\ntypedef pthread_mutex_t *mutex_t;\n\n\n\n/* All calls excep create may raise MUT_ERROR */\n\n/* If mutex not init or destroyed or... */\n\n\n\n/* Create a mutex */\n\n/* Returns NULL if malloc error */\n\nextern mutex_t mutex_create(void);\n\n\n\n/* Destroy a mutex */\n\n/* Returns MUT_LOCKED if the mutex is locked */\n\n/* Else returns MUT_OK */\n\nextern int mutex_destroy (mutex_t mutex);\n\n\n\n\n\n/* Get a mutex */\n\n/* Returns MUT_DEADLOCK if this thread already owns this mutex */\n\n/* If wait is set to TRUE, wait for mutex and return MUT_OK */\n\n/* Else, may return MUT_OK or MUT_LOCKED */\n\nextern int mutex_lock (mutex_t mutex, boolean wait);\n\n\n\n/* Release a mutex */\n\n/* Returns MUT_NOTLOCKED if not locked by this thread (or not locked at all) */\n\n/* Else returns MUT_OK */\n\nextern int mutex_unlock (mutex_t mutex);\n\n\n", "#include <stdio.h>\n\n#include <stdlib.h>\n\n\n\n#define ALL 1\n\n#define ONE 0\n\n\n\nstatic void draw (char *str[], int  count, char param);\n\nstatic void help(char *str[]);\n\n\n\nint main (int argc, char *argv[]) {\n\n\n\n  if ( argc < 2 ) help(argv);\n\n  else draw (argv, argc, ONE);\n\n  exit(0);\n\n}\n\n\n\nstatic void help (char *str[]) {\n\n  printf (\"-- usage : \\n\");\n\n  printf (\"           ascii [ARG]\\n\");\n\n  printf (\"             where ARG is a character or a string\\n\");\n\n  printf (\"             if no argument is specified \\n\");\n\n  printf (\"             print the whole ascii table\\n\\n\");\n\n  draw (str, ALL, ' ');\n\n}\n\n\n\nstatic void draw (char *str[], int  count, char param) {\n\n  int j=0, i=0;\n\n\n\n  printf (\"+-----------+-----+-----+-----+\\n\");\n\n  printf (\"| character | dec | oct | hex |\\n\");\n\n  printf (\"+-----------+-----+-----+-----+\\n\");\n\n\n\n  if ( param == ONE )\n\n  {\n\n     for ( j = 1; j < count; )\n\n     {\n\n        i = 0;\n\n        while ( str[j][i] != '\\0' )\n\n        {\n\n           printf (\"|     %c     | %3d | %3o | %3X |\\n\", str[j][i], str[j][i], str[j][i], str[j][i]);\n\n           i++;\n\n         }\n\n         if ( j < count - 1) printf (\"+-----------+-----+-----+-----+\\n\");\n\n         j++;\n\n     }\n\n  }\n\n  else\n\n  {\n\n     for ( i = 32; i < 127; i++)\n\n     {\n\n        printf (\"|     %c     | %3d | %3o | %3X |\\n\", i, i, i, i);\n\n     }\n\n  }\n\n\n\n  printf (\"+-----------+-----+-----+-----+\\n\");\n\n\n\n}\n\n\n", "#include <stdio.h>\n\n#include <stdlib.h>\n\nint main (void) {\n\n\n\n  int n;\n\n  int i;\n\n  char *p;\n\n\n\n  printf (\"01 02 03 04\\n\");\n\n  for (i = 1, p = (char*)&n; i <= 4; i++, p++) {\n\n    *p = (char)i;\n\n  }\n\n  printf (\"%08X\\n\", n);\n\n  exit(0);\n\n}\n", "#include <stdio.h>\n\n#include <signal.h>\n\n#include <sys/time.h>\n\n#include <stdlib.h>\n\n\n\n#include \"sig_util.h\"\n\n#include \"timeval.h\"\n\n\n\nstatic void sig_handler(int sig);\n\n\n\nint main(void) {\n\n  timeout_t timeout;\n\n\n\n  set_handler (SIGTERM, sig_handler, NULL);\n\n  set_handler (SIGINT, sig_handler, NULL);\n\n  timeout.tv_sec =  5;\n\n  timeout.tv_usec =  0;\n\n\n\n  for (;;) {\n\n    printf (\"Running\\n\");\n\n    delay (&timeout);\n\n  }\n\n\n\n}\n\n\n\nstatic void sig_handler(int sig) {\n\n  printf (\"        signal received : %3d\\n\", sig);\n\n}\n\n\n\n\n\n\n", "#include \"boolean.h\"\n\n\n\n/* Results of calls */\n\n#define OK 0\n\n#define ERR -1\n\n\n\n#define t_time int\n\n#define t_result int\n\n\n\n\n\n/* To set an signal handler to a signal. */\n\n/*  or to restore default handler */\n\n/* See signal.h for sig_num possible values */\n\n/* SIG_DFL and SIG_IGN can be used for default or ignore handlers */\n\n/* Old_handler may be NULL if of no interest */\n\n\n\nt_result set_handler (int sig_num, void (*sig_handler)(int),\n\n void (**old_handler)(int) );\n\n\n\n/* To arm one or disarm of the 3 timers. */\n\n/* See sys/time.h for the list of timers */\n\n/* sec and usec specify the interval (delay between 2 signals) */\n\n/* If the delay is <= 0 then the timer is desabled */\n\n/* if not repeat then only one signal will be generated after delay */\n\n/* if repeat     then a signal will be generated repetitively */\n\n\n\nt_result arm_timer (int timer, t_time sec, t_time usec, boolean repeat);\n\n\n", "#include <stdio.h>\n\n#include <unistd.h>\n\n#include <signal.h>\n\n#include <sys/time.h>\n\n#include <stdlib.h>\n\n\n\n#include \"sig_util.h\"\n\n\n\n#define ALRM_S 000005\n\n#define ALRM_U 000000\n\n\n\nextern void  sigpause (int mask);\n\n\n\nstatic void handler_sigalrm(int sig);\n\nstatic void handler_sigusr1(int sig);\n\nstatic void handler_sigusr2(int sig);\n\n\n\nint main(void) {\n\n\n\n  printf (\"My pid is %d\\n\", getpid());\n\n  printf (\n\n   \"Signal managed : SIGTALRM(intern), SIGUSR1(30), SIGUSR2(31)\\n\");\n\n\n\n\n\n  set_handler (SIGALRM, handler_sigalrm, NULL);\n\n  set_handler (SIGUSR1, handler_sigusr1, NULL);\n\n  set_handler (SIGUSR2, handler_sigusr2, NULL);\n\n\n\n  printf (\"Start timer\\n\");\n\n  arm_timer (ITIMER_REAL, (long)ALRM_S, (long)ALRM_U, 1);\n\n\n\n  sigpause (sigmask(SIGALRM) | sigmask(SIGUSR1));\n\n  printf (\"Done.\\n\");\n\n  exit(0);\n\n}\n\n\n\nstatic void handler_sigalrm (int sig) {\n\n  printf (\"        SIGALRM...%3d\\n\", sig);\n\n}\n\n\n\nstatic void handler_sigusr1 (int sig) {\n\n  printf (\"        SIGUSR1...%3d\\n\", sig);\n\n}\n\n\n\nstatic void handler_sigusr2 (int sig) {\n\n  printf (\"        SIGUSR2...%3d\\n\", sig);\n\n}\n\n\n\n\n\n\n", "#include <stdio.h>\n\n#include <signal.h>\n\n#include <sys/time.h>\n\n#include <sys/types.h>\n\n#include <errno.h>\n\n\n\n#include \"sig_util.h\"\n\n\n\nt_result set_handler (int sig_num, void (*sig_handler)(int),\n\n                                   void (**old_handler)(int)) {\n\n  void (*loc_old_handler)(int);\n\n\n\n\n\n  loc_old_handler = signal (sig_num, sig_handler);\n\n  if ( (loc_old_handler != SIG_ERR) && (old_handler != NULL) ) {\n\n    *old_handler = loc_old_handler;\n\n  }\n\n\n\n  if (loc_old_handler != SIG_ERR) {\n\n    return (OK);\n\n  } else {\n\n    perror (\"set_handler.signal\");\n\n    return (ERR);\n\n  }\n\n}\n\n\n\n\n\nt_result arm_timer (int timer, t_time sec, t_time usec, boolean repeat) {\n\n  struct itimerval val;\n\n\n\n  val.it_value.tv_sec  = sec;\n\n  val.it_value.tv_usec = usec;\n\n\n\n  /* set interval; if not repeat, set it to 0 */\n\n  if (repeat) {\n\n    val.it_interval.tv_sec  = sec;\n\n    val.it_interval.tv_usec = usec;\n\n  } else {\n\n    val.it_interval.tv_sec  = 0;\n\n    val.it_interval.tv_usec = 0;\n\n  }\n\n\n\n\n\n  if (setitimer (timer, &val, NULL) == -1) {\n\n    perror (\"arm.setitimer\");\n\n    return (ERR);\n\n  } else {\n\n    return (OK);\n\n  }\n\n}\n\n\n\n\n\n\n", "#include <stdio.h>\n\n#include <stdlib.h>\n\n\n\n#include \"dynlist.h\"\n\n\n\nstatic boolean less_than (const void *l, const void *r) {\n\n  return (*(const int*)l < *(const int*)r);\n\n}\n\n\n\nint main (void) {\n\n\n\n  dlist list;\n\n  int i, v;\n\n\n\n  dlist_init (&list, sizeof(int));\n\n\n\n  printf (\"Add 10 elements\\n\");\n\n  for (i = 1; i <= 10; i++) {\n\n    dlist_insert (&list, &i, TRUE);\n\n  }\n\n\n\n  printf (\"Reads 5 elements from the last one:\");\n\n  dlist_rewind (&list, FALSE);\n\n  for (i = 1; i <= 5; i++) {\n\n    dlist_read (&list, &v);\n\n    printf (\" %02d\", v);\n\n    dlist_move (&list, FALSE);\n\n  }\n\n  printf (\"\\n\");\n\n\n\n  printf (\"List length: %02d\\n\", dlist_length (&list));\n\n\n\n  printf (\"Deletes the current\\n\");\n\n  dlist_delete (&list, TRUE);\n\n\n\n  printf (\"Pos from first: %02d List length: %02d\\n\",\n\n          dlist_get_pos (&list, TRUE), dlist_length (&list));\n\n\n\n  printf (\"Reads 7 elements from the first one:\");\n\n  dlist_rewind (&list, TRUE);\n\n  for (i = 1; i <= 7; i++) {\n\n    dlist_read (&list, &v);\n\n    printf (\" %02d\", v);\n\n    dlist_move (&list, TRUE);\n\n  }\n\n  printf (\"\\n\");\n\n\n\n  printf (\"Adds the element 50 before current position and read: \");\n\n  v = 50;\n\n  dlist_insert (&list, &v, FALSE);\n\n  dlist_read (&list, &v);\n\n  printf (\"%02d\\n\", v);\n\n\n\n  printf (\"List length: %02d\\n\", dlist_length (&list));\n\n  printf (\"Reads all elements from the first one:\");\n\n  dlist_rewind (&list, TRUE);\n\n  for (;;) {\n\n    dlist_read (&list, &v);\n\n    printf (\" %02d\", v);\n\n    if (dlist_get_pos (&list, FALSE) == 1) break;\n\n    dlist_move (&list, TRUE);\n\n  }\n\n  printf (\"\\n\");\n\n\n\n  printf (\"Sort: \");\n\n  dlist_sort (&list, less_than);\n\n  for (;;) {\n\n    dlist_read (&list, &v);\n\n    printf (\" %02d\", v);\n\n    if (dlist_get_pos (&list, FALSE) == 1) break;\n\n    dlist_move (&list, TRUE);\n\n  }\n\n  printf (\"\\n\");\n\n\n\n  printf (\"Delete all\\n\");\n\n  dlist_delete_all (&list);\n\n  printf (\"List length: %02d\\n\", dlist_length (&list));\n\n\n\n  exit (0);\n\n}\n\n\n", "#ifndef DYNLIST_H\n\n#define DYNLIST_H\n\n\n\n#include \"boolean.h\"\n\n\n\n/* The list (ADT) */\n\ntypedef struct dlist dlist;\n\n\n\n/* Initialise a list */\n\nextern void dlist_init (dlist *list, unsigned int data_size);\n\n\n\n/* NAVIGATION */\n\n/* Is list empty */\n\nextern boolean dlist_is_empty (const dlist *list);\n\n/* List length is 0 or pos_from_first + pos_from_last - 1) */\n\nextern unsigned int dlist_length (const dlist *list);\n\n/* Position in list, from start or from end */\n\n/* 0 when list is empty */\n\n/* List length is 0 or pos_from_first + pos_from_last - 1) */\n\nextern unsigned int dlist_get_pos (const dlist *list, boolean from_first);\n\n/* Move at beginning or end */\n\nextern void dlist_rewind (dlist *list, boolean at_first);\n\n/* Move one cell forward or backward (if possible) */\n\nextern void dlist_move (dlist *list, boolean forward);\n\n\n\n/* READ / INSERT / DELETE */\n\n/* Read current (copy from list) */\n\nextern void dlist_read (const dlist *list, void * data);\n\n/* Replace current */\n\nextern void dlist_replace (const dlist *list, void * data);\n\n/* Insert after or before current (copy to list and become current) */\n\nextern void dlist_insert (dlist *list, const void * data, boolean after_curr);\n\n/* Delete current. Move to next or prev */\n\nextern void dlist_delete (dlist *list, boolean forward);\n\n/* Delete the whole list (re-inits) */\n\nextern void dlist_delete_all (dlist *list);\n\n\n\n/* SORT */\n\n/* Type of function that compares 2 data. */\n\n/* Must be strict: less_than (p, p) -> FALSE */\n\ntypedef boolean less_than_func (const void *, const void*);\n\n/* Quick sort the list according to less_than function and rewind */\n\nextern void dlist_sort (dlist *list, less_than_func *less_than);\n\n\n\n/* Private */\n\nstruct cell;\n\n\n\ntypedef struct cell {\n\n  struct cell * prev;\n\n  struct cell * next;\n\n  void * data;\n\n} cell;\n\n\n\nstruct dlist {\n\n  cell * first;\n\n  cell * last;\n\n  cell * curr;\n\n  unsigned int pos_first;\n\n  unsigned int pos_last;\n\n  unsigned int data_size;\n\n};\n\n\n\n#endif\n\n\n", "#include <stdio.h>\n\n#include <string.h>\n\n#include <malloc.h>\n\n#include <errno.h>\n\n\n\n#include \"dynlist.h\"\n\n\n\n/* Init list */\n\nextern void dlist_init (dlist *list, unsigned int data_size) {\n\n  if (data_size == 0) {\n\n    return;\n\n  }\n\n  list->first = NULL;\n\n  list->last = NULL;\n\n  list->curr = NULL;\n\n  list->pos_first = 0;\n\n  list->pos_last = 0;\n\n  list->data_size = data_size;\n\n}\n\n\n\n\n\n/* Is list empty */\n\nextern boolean dlist_is_empty (const dlist *list) {\n\n  return (list->curr == NULL);\n\n}\n\n\n\n/* List length is 0 or pos_from_first + pos_from_last - 1) */\n\nextern unsigned int dlist_length (const dlist *list) {\n\n  if (list->curr == NULL) {\n\n    return 0;\n\n  } else {\n\n    return list->pos_first + list->pos_last - 1;\n\n  }\n\n}\n\n\n\n/* Position in list, from start or from end */\n\n/* 0 when list is empty */\n\nextern unsigned int dlist_get_pos (const dlist *list, boolean from_first) {\n\n  if (from_first) {\n\n    return list->pos_first;\n\n  } else {\n\n    return list->pos_last;\n\n  }\n\n}\n\n\n\n/* Move at beginning or end */\n\nextern void dlist_rewind (dlist *list, boolean at_first) {\n\n  if (list->curr == NULL) return;\n\n  if (at_first) {\n\n    list->curr = list->first;\n\n    list->pos_last += list->pos_first - 1;\n\n    list->pos_first = 1;\n\n  } else {\n\n    list->curr = list->last;\n\n    list->pos_first += list->pos_last - 1;\n\n    list->pos_last = 1;\n\n  }\n\n}\n\n\n\n/* Move one cell forward or backward (if possible) */\n\nextern void dlist_move (dlist *list, boolean forward) {\n\n  if (list->curr == NULL) return;\n\n  if (forward) {\n\n    if (list->curr->next != NULL) {\n\n      list->curr = list->curr->next;\n\n      list->pos_first++;\n\n      list->pos_last--;\n\n    }\n\n  } else {\n\n    if (list->curr->prev != NULL) {\n\n      list->curr = list->curr->prev;\n\n      list->pos_first--;\n\n      list->pos_last++;\n\n    }\n\n  }\n\n}\n\n\n\n/* Read current (copy from list) */\n\nextern void dlist_read (const dlist *list, void * data) {\n\n  if (list->curr == NULL) return;\n\n  memcpy (data, list->curr->data, list->data_size);\n\n}\n\n\n\n/* Replace current (insert if list is empty) */\n\nextern void dlist_replace (const dlist *list, void * data) {\n\n  if (list->curr == NULL) return;\n\n  memcpy (list->curr->data, data, list->data_size);\n\n}\n\n\n\n\n\n/* Adjust prev and next of current to point on current */\n\n/* Or adjust first or last */\n\nstatic void adjust (dlist *list) {\n\n  if (list->curr->next != NULL) {\n\n    list->curr->next->prev = list->curr;\n\n  } else {\n\n    /* New is last */\n\n    list->last = list->curr;\n\n  }\n\n  if (list->curr->prev != NULL) {\n\n    list->curr->prev->next = list->curr;\n\n  } else {\n\n    /* New is first */\n\n    list->first = list->curr;\n\n  }\n\n}\n\n\n\n/* Insert after or before current (copy to list and become current) */\n\nextern void dlist_insert (dlist *list, const void * data, boolean after_curr) {\n\n  cell *ptr, *tmp;\n\n\n\n  /* Malloc and copy */\n\n  ptr = malloc (sizeof(cell));\n\n  if (ptr == NULL) {\n\n    perror (\"malloc cell\");\n\n    return;\n\n  }\n\n\n\n  ptr->data = malloc (list->data_size);\n\n  if (ptr->data == NULL) {\n\n    perror (\"malloc data\");\n\n    return;\n\n  }\n\n  memcpy (ptr->data, data, list->data_size);\n\n\n\n  /* Insert */\n\n  if (list->curr == NULL) {\n\n    /* First cell inserted in empty list*/\n\n    list->curr = ptr;\n\n    list->first = list->curr;\n\n    list->last = list->curr;\n\n    list->pos_first = 1;\n\n    list->pos_last = 1;\n\n    list->curr->next = NULL;\n\n    list->curr->prev = NULL;\n\n  } else {\n\n    tmp = list->curr;\n\n    list->curr = ptr;\n\n    if (after_curr) {\n\n      list->curr->prev = tmp;\n\n      list->curr->next = tmp->next;\n\n      list->pos_first++;\n\n    } else {\n\n      list->curr->prev = tmp->prev;\n\n      list->curr->next = tmp;\n\n      list->pos_last++;\n\n    }\n\n    /* Link brothers or first/last to me */\n\n    adjust(list);\n\n  }\n\n}\n\n\n\n/* Delete current. Move to next or prev */\n\nextern void dlist_delete (dlist *list, boolean forward) {\n\n  cell *tmp;\n\n\n\n  if (list->curr == NULL) return;\n\n\n\n  /* Link brothers together */\n\n  tmp = list->curr;\n\n  if (tmp->next != NULL) {\n\n    tmp->next->prev = tmp->prev;\n\n  } else {\n\n    /* Removing last */\n\n    list->last = tmp->prev;\n\n  }\n\n  if (tmp->prev != NULL) {\n\n    tmp->prev->next = tmp->next;\n\n  } else {\n\n    /* Removing first */\n\n    list->first = tmp->next;\n\n  }\n\n\n\n  /* Update current and pos */\n\n  if (forward) {\n\n    if (tmp->next != NULL) {\n\n      /* Move forward */\n\n      list->curr = tmp->next;\n\n      list->pos_last--;\n\n    } else {\n\n      /* End of list: try to move backwards */\n\n      forward = FALSE;\n\n    }\n\n  }\n\n  if (!forward) {\n\n    /* Try to move backwards */\n\n    if (tmp->prev != NULL) {\n\n      list->curr = tmp->prev;\n\n      list->pos_first--;\n\n    }\n\n  }\n\n\n\n  /* Free data and cell */\n\n  free (tmp->data);\n\n  free (tmp);\n\n}\n\n\n\n/* Delete the whole list (re-inits) */\n\nextern void dlist_delete_all (dlist *list) {\n\n\n\n  /* Iterate on all from first */\n\n  list->curr = list->first;\n\n  while (list->curr != NULL) {\n\n    list->last = list->curr;\n\n    /* Free data and cell */\n\n    free (list->curr->data);\n\n    free (list->curr);\n\n    /* Next */\n\n    list->curr = list->last->next;\n\n  }\n\n\n\n  /* Reset all fields except data size */\n\n  dlist_init (list, list->data_size);\n\n}\n\n\n\n/* Local absolute move */\n\nstatic void move_at (dlist *list, unsigned int offset) {\n\n  unsigned int i;\n\n\n\n  dlist_rewind (list, TRUE);\n\n  for (i = 0; i < offset; i++) {\n\n    dlist_move (list, TRUE);\n\n  }\n\n}\n\n\n\n/* Local swap of 2 cells */\n\nstatic void swap (dlist *list, cell *left, cell *right) {\n\n\n\n  cell *next, *prev;\n\n\n\n  prev = left->prev;\n\n  next = left->next;\n\n\n\n  if ( (left->next != right) && (left->prev != right) ) {\n\n    /* Not adjacent cells */\n\n    /* Exchange neighbours links */\n\n    if (left->prev != NULL) {\n\n      left->prev->next = right;\n\n    } else {\n\n      list->first = right;\n\n    }\n\n    if (left->next != NULL) {\n\n      left->next->prev = right;\n\n    } else {\n\n      list->last = right;\n\n    }\n\n    if (right->prev != NULL) {\n\n      right->prev->next = left;\n\n    } else {\n\n      list->first = left;\n\n    }\n\n    if (right->next != NULL) {\n\n      right->next->prev = left;\n\n    } else {\n\n      list->last = left;\n\n    }\n\n\n\n    /* Exchange swapped cells links to neighbours */\n\n    left->prev = right->prev;\n\n    left->next = right->next;\n\n    right->prev = prev;\n\n    right->next = next;\n\n\n\n  } else if (left->next == right) {\n\n    /* Left just before right */\n\n    /* Exchange neighbours links */\n\n    if (left->prev != NULL) {\n\n      left->prev->next = right;\n\n    } else {\n\n      list->first = right;\n\n    }\n\n    if (right->next != NULL) {\n\n      right->next->prev = left;\n\n    } else {\n\n      list->last = left;\n\n    }\n\n\n\n    /* Exchange swapped cells links to neighbours */\n\n    left->prev = right;\n\n    left->next = right->next;\n\n    right->prev = prev;\n\n    right->next = left;\n\n  } else if (left->prev == right) {\n\n    /* Left just after right */\n\n    /* Exchange neighbours links */\n\n    if (left->next != NULL) {\n\n      left->next->prev = right;\n\n    } else {\n\n      list->last = right;\n\n    }\n\n    if (right->prev != NULL) {\n\n      right->prev->next = left;\n\n    } else {\n\n      list->first = left;\n\n    }\n\n\n\n    /* Exchange swapped cells links to neighbours */\n\n    left->prev = right->prev;\n\n    left->next = right;\n\n    right->prev = left;\n\n    right->next = next;\n\n  }\n\n\n\n}\n\n\n\n\n\n/* Local recursive sorting */\n\nstatic void subqsort (dlist *list,\n\n                      const unsigned int left, const unsigned int right,\n\n                      less_than_func *less_than) {\n\n  /* Middle of the slice */\n\n  const unsigned int i_front = (left + right ) / 2;\n\n  cell *l_front;\n\n  /* Both halfs of the slice */\n\n  unsigned int i_left, i_right;\n\n  cell *l_left, *l_right;\n\n\n\n  i_left = left;\n\n  i_right = right;\n\n  /* Set link to frontier */\n\n  move_at (list, i_front);\n\n  l_front = list->curr;\n\n\n\n  for (;;) {\n\n    /* First element at left of slice and not positioned ok */\n\n    /*  regarding the frontier */\n\n    move_at (list, i_left - 1);\n\n    while (less_than (list->curr->data, l_front->data)) {\n\n      dlist_move (list, TRUE);\n\n    }\n\n    l_left = list->curr;\n\n    i_left = dlist_get_pos (list, TRUE);\n\n\n\n    /* Last  element a right of slice and not positioned ok */\n\n    /*  regarding the frontier */\n\n    move_at (list, i_right - 1);\n\n    while (less_than (l_front->data, list->curr->data)) {\n\n      dlist_move (list, FALSE);\n\n    }\n\n    l_right = list->curr;\n\n    i_right = dlist_get_pos (list, TRUE);\n\n\n\n    /* Exchange and go to next elements if not both in frontier */\n\n    if (i_left < i_right) {\n\n      swap (list, l_left, l_right);\n\n      i_left ++;\n\n      i_right --;\n\n    } else if (i_left == i_right) {\n\n      /* Go to next elements if not crossed */\n\n      if (i_left != right) {\n\n        i_left ++;\n\n      }\n\n      if (i_right != left) {\n\n        i_right --;\n\n      }\n\n    }\n\n\n\n    /* Leave if crossed now */\n\n    if (i_left > i_right) break;\n\n    if ( (i_left == right) && (i_right == left) ) break;\n\n  }\n\n\n\n  /* Sort both new slices */\n\n  if (left   < i_right) subqsort(list, left,   i_right, less_than);\n\n  if (i_left < right)   subqsort(list, i_left, right, less_than);\n\n\n\n}\n\n\n\n/* Quick sort the list according to comp function */\n\nextern void dlist_sort (dlist *list, less_than_func *less_than) {\n\n\n\n  unsigned int last = dlist_length (list);\n\n\n\n  if (last <= 1) {\n\n    return;\n\n  }\n\n  subqsort (list, 1, last, less_than);\n\n  dlist_rewind (list, TRUE);\n\n}\n\n\n", "#include <stdio.h>\n\n#include <stdlib.h>\n\n#include <string.h>\n\n#include <unistd.h>\n\n\n\n/* Usage substit <search_pattern> <change_patern> { <file> }             */\n\n/* Replace each <search_patter> with <change_pattern> in files, in ASCII */\n\n/* mode (file size may be changed).                                      */\n\n/* \\b -> space    \\t -> tab     \\n -> ret   \\ij -> hexa                  */\n\n\n\n#define SUBSTIT_VERSION  \"2.2\"\n\n\n\n#define EOF_CHAR (int)0x1A\n\n\n\nstatic void usage (void) {\n\n  fprintf (stderr,\n\n  \"Substit V%s\\n\", SUBSTIT_VERSION);\n\n  fprintf (stderr,\n\n  \"Usage: substit <search_pattern> <change_patern> { <file> } \\n\");\n\n  fprintf (stderr,\n\n  \"  pattern can be: \\\\b -> space   \\\\t -> tab   \\\\n -> ret   \\\\ij -> hexa\\n\");\n\n}\n\n\n\n#define write_char(char) {                   \\\n\n        if (putc (char, fo) == EOF) {        \\\n\n          perror (\"putc\");                   \\\n\n          fprintf (stderr, \"Error: writing when processing file %s\\n\", \\\n\n                           file_name);       \\\n\n          return (0);                        \\\n\n        }                                    \\\n\n  }\n\n\n\n/* Write pending then skipped chars */\n\n#define flush_pending_chars() {              \\\n\n        int iii;                             \\\n\n        for (iii = 0; iii < match; iii++) {  \\\n\n          write_char ((int)search[iii]);     \\\n\n        }                                    \\\n\n  }\n\n\n\nstatic int subst_one (char *search, int ls, char *change, int lc,\n\n                const char *file_name,\n\n                FILE *fi, FILE *fo,\n\n                int say_it) {\n\n  /* Read char */\n\n  int c;\n\n  /* Index in search for next matching char */\n\n  int match;\n\n  int i;\n\n  /* Character matches */\n\n  int char_match;\n\n\n\n  if (say_it) {\n\n    printf (\"processing file %s\\n\", file_name);\n\n  }\n\n\n\n  /* Search, change pattern lengths */\n\n  ls = strlen (search);\n\n  lc = strlen (change);\n\n\n\n  match = 0;\n\n\n\n  /* Infinite loop of substitutions */\n\n  for (;;) {\n\n    c = getc (fi);\n\n\n\n    /* Test end of file */\n\n    /* End of file if EOF */\n\n    /*  flush pending chars */\n\n    if (c == EOF) {\n\n      flush_pending_chars ();\n\n      /* Done */\n\n      break;\n\n    }\n\n\n\n    if (c != (int) (unsigned char) search[match]) {\n\n      /* This character does not match */\n\n      /* Write any pending (previous matching) bytes */\n\n      flush_pending_chars ();\n\n      if (match == 0) {\n\n        write_char (c);\n\n        char_match = 0;\n\n      } else {\n\n        /* Reset match */\n\n        match = 0;\n\n        /* Check if matches first char of search */\n\n        if (c != (int) (unsigned char) search[match]) {\n\n          write_char (c);\n\n          char_match = 0;\n\n        } else {\n\n          char_match = 1;\n\n        }\n\n      }\n\n    } else {\n\n      char_match = 1;\n\n    }\n\n\n\n    if (char_match) {\n\n      /* This read character matches */\n\n      if (match != (ls - 1) ) {\n\n        /* Check not completed, go on (character is pending) */\n\n        match++;\n\n      } else {\n\n        /* Check of pattern completed */\n\n        /* write change */\n\n        for (i = 0; i < lc; i++) {\n\n          write_char (change[i]);\n\n        }\n\n        match = 0;\n\n      }\n\n    }\n\n\n\n  } /* for */\n\n\n\n  return (1);\n\n}\n\n\n\nstatic int ishex (char c) {\n\n    return ( ( (c >= '0') && (c <= '9') )\n\n          || ( (c >= 'a') && (c <= 'f') ) );\n\n}\n\n\n\nstatic unsigned char val (char c) {\n\n\n\n    if ( (c >= '0') && (c <= '9') ) {\n\n        return ( (unsigned char) (c - '0') );\n\n    } else {\n\n        return ( (unsigned char) (c - 'a') + 0x0A);\n\n    }\n\n}\n\n\n\n/* \\b -> space    \\t -> tab     \\n -> ret   \\ij -> hexa */\n\nstatic void format_arg (char *arg, char *format, int *p_len) {\n\n  int i, j;\n\n\n\n  i = 0;\n\n  j = 0;\n\n  for (;;) {\n\n    if (arg[i] == '\\0') {\n\n        format[j] = '\\0';\n\n        break;\n\n    }\n\n    if (arg[i] != '\\\\') {\n\n        format[j] = arg[i];\n\n    } else {\n\n        i++;\n\n        if (arg[i] == '\\0') {\n\n            format[j] = '\\\\';\n\n            j++;\n\n            format[j] = '\\0';\n\n            break;\n\n        }\n\n        if (arg[i] == 'b') {\n\n            format[j] = ' ';\n\n        } else if (arg[i] == 't') {\n\n            format[j] = '\\t';\n\n        } else if (arg[i] == 'n') {\n\n            format[j] = '\\n';\n\n        } else if (ishex(arg[i]) ) {\n\n            i++;\n\n            if (arg[i] == '\\0') {\n\n                format[j] = '\\\\';\n\n                j++;\n\n                format[j] = arg[i-1];\n\n                j++;\n\n                format[j] = '\\0';\n\n                break;\n\n            }\n\n            if (ishex(arg[i]) ) {\n\n                format[j] = 0x10 * val(arg[i-1]) + val(arg[i]);\n\n            } else {\n\n                format[j] = '\\\\';\n\n                j++;\n\n                format[j] = arg[i-1];\n\n                j++;\n\n                format[j] = arg[i];\n\n            }\n\n        } else {\n\n            format[j] = '\\\\';\n\n            j++;\n\n            format[j] = arg[i];\n\n            }\n\n        }\n\n        i++;\n\n        j++;\n\n    }\n\n    *p_len = j;\n\n}\n\n\n\n\n\n        \n\n\n\n\n\n\n\nint main (int argc, char *argv[]) {\n\n\n\n  FILE *fi, *fo;\n\n  int error = 0;\n\n  char tmp_file_name[1024];\n\n  int i;\n\n  int subst_ok;\n\n  int ls, lc;\n\n\n\n  char to_search[1024], to_subst[1024];\n\n\n\n  /* Check \"-h\" or at least 2 argument */\n\n  if ( (argc == 2) && (strcmp(argv[1], \"-h\") == 0) ) {\n\n    usage ();\n\n    exit (1);\n\n  }\n\n  if (argc < 3) {\n\n    fprintf (stderr, \"Error: syntax\\n\");\n\n    usage ();\n\n    exit (1);\n\n  }\n\n\n\n  format_arg (argv[1], to_search, &ls);\n\n  format_arg (argv[2], to_subst, &lc);\n\n\n\n  for (i = 3; i < argc; i++) {\n\n\n\n    /* Check that file exists and is read-write */\n\n    fi = fopen (argv[i], \"r+b\");\n\n    if (fi == (FILE*) NULL) {\n\n      perror (\"fopen\");\n\n      fprintf (stderr, \"Error: opening file %s in read-write\\n\", argv[i]);\n\n      error = 1;\n\n      continue;\n\n    }\n\n\n\n    /* Build tmp_file_name */\n\n    if (strlen(argv[i]) >= sizeof(tmp_file_name) - 5) {\n\n      fprintf (stderr, \"Error: file name %s too long\\n\", argv[i]);\n\n      error = 1;\n\n      continue;\n\n    }\n\n    strcpy (tmp_file_name, argv[i]);\n\n\n\n#ifdef DOS\n\n    {\n\n      int j;\n\n      int dot_found;\n\n\n\n      /* Search last '.' (stop at last '\\') */\n\n      dot_found = 0;\n\n      for (j = strlen(tmp_file_name) - 1; j >= 0; j--) {\n\n        if (tmp_file_name[j] == '.') {\n\n          dot_found = 1;\n\n          break;\n\n        } else if (tmp_file_name[j] == '\\\\') {\n\n          break;\n\n        }\n\n      }\n\n  \n\n      /* Subst / add \".$$$\" */\n\n      if (dot_found) {\n\n        tmp_file_name[j] = '\\0';\n\n      }\n\n    }\n\n#endif\n\n    strcat (tmp_file_name, \".$$$\");\n\n\n\n    /* Create output file */\n\n    fo = fopen (tmp_file_name, \"wb\");\n\n    if (fo == (FILE*) NULL) {\n\n      perror (\"fopen\");\n\n      fprintf (stderr, \"Error: opening file %s in read-write\\n\",\n\n                       tmp_file_name);\n\n      error = 1;\n\n      continue;\n\n    }\n\n\n\n    /* call substitution */\n\n    subst_ok = subst_one (to_search, ls, to_subst, lc, argv[i], fi, fo, 1);\n\n    if (!subst_ok) error = 1;\n\n\n\n    /* close in file */\n\n    if (fclose(fi) == EOF) {\n\n      perror (\"fclose\");\n\n      fprintf (stderr, \"Error: closing file %s\\n\", argv[i]);\n\n      error = 1;\n\n    }\n\n\n\n    /* close out file */\n\n    if (fclose(fo) == EOF) {\n\n      perror (\"fclose\");\n\n      fprintf (stderr, \"Error: closing file %s\\n\", tmp_file_name);\n\n      error = 1;\n\n      continue;\n\n    }\n\n\n\n    if (subst_ok) {\n\n      if (unlink(argv[i]) == -1) {\n\n        perror (\"unlink\");\n\n        fprintf (stderr, \"Error: removing file %s\\n\", argv[i]);\n\n        error = 1;\n\n        continue;\n\n      }\n\n\n\n      if (rename(tmp_file_name, argv[i]) == -1) {\n\n        perror (\"rename\");\n\n        fprintf (stderr, \"Error: renaming file %s in %s\\n\",\n\n                         tmp_file_name, argv[i]);\n\n        error = 1;\n\n        continue;\n\n      }\n\n    } else {\n\n      (void) unlink (tmp_file_name);\n\n    }\n\n\n\n  }\n\n\n\n  if (argc == 3) {\n\n    /* call substitution  on stdin / stdout */\n\n    subst_ok = subst_one (to_search, ls, to_subst, lc, \"stdin/out\", stdin, stdout, 0);\n\n    if (!subst_ok) error = 1;\n\n  }\n\n\n\n  if (error) exit (2);\n\n  exit (0);\n\n}\n\n\n\n\n", "#include <stdio.h>\n\n#include <stdlib.h>\n\n#include <string.h>\n\n#include <time.h>\n\n#include <sys/time.h>\n\n#include <signal.h>\n\n\n\n#include \"boolean.h\"\n\n#include \"tty.h\"\n\n#include \"timeval.h\"\n\n#include \"gorgy_decode.h\"\n\n#include \"adjtime_call.h\"\n\n#include \"sig_util.h\"\n\n\n\n#define BUFFER_SIZE 1000\n\n\n\n\n\n#define MIN_THRESHOLD_MSEC 10\n\n#define DEFAULT_THRESHOLD_MSEC 100\n\n\n\nextern int fd;\n\nstatic unsigned char buffer[BUFFER_SIZE];\n\nstatic unsigned int eti_index;\n\nstatic boolean verbose;\n\nstatic int threshold_msec;\n\nstatic boolean frame_expected, frame_received;\n\nstatic char prev_precision;\n\n\n\nstatic void store (unsigned char oct) {\n\n  if (eti_index == BUFFER_SIZE - 1) {\n\n    eti_index = 0;\n\n  }\n\n  buffer[eti_index] = oct;\n\n  eti_index ++;\n\n}\n\n\n\n/*\n\n  static void print (char oct) {\n\n    if (oct < 32) printf (\"'%02X' \", (int)oct);\n\n    else printf (\"%c \", oct);\n\n  }\n\n*/\n\n\n\nstatic void decode_and_synchro (void) {\n\n  struct timeval new_time, curr_time, curr_delta, curr_adjust, delta_delta;\n\n  char *curr_time_str;\n\n  char precision;\n\n  boolean prev_frame_received;\n\n\n\n  prev_frame_received = frame_received;\n\n\n\n  /* Get current time ASAP */\n\n  if (gettimeofday(&curr_time, (struct timezone*) NULL) == -1) {\n\n    perror (\"Gettimeofday\");\n\n    frame_received = true;\n\n    return;\n\n  }\n\n\n\n  /* For dating report messages */\n\n  curr_time_str = ctime(&curr_time.tv_sec);\n\n  /* Skip last \\n */\n\n  curr_time_str[strlen(curr_time_str)-1] = '\\0';\n\n\n\n  /* A frame after no frame */\n\n  if (!prev_frame_received) {\n\n    printf (\"At %s, INFO: time received\\n\", curr_time_str);\n\n  }\n\n\n\n  /* Decode frame */\n\n  if (gorgy_decode ((char*)buffer, &new_time, &precision) < 0) {\n\n    fprintf (stderr, \"At %s, \", curr_time_str);\n\n    fprintf (stderr, \"ERROR. Wrong time format or value.\\n\");\n\n    frame_received = false;\n\n    return;\n\n  }\n\n\n\n  /* Discard if bad precision. Warn if degraded precision */\n\n  if (precision == '?') {\n\n    if (prev_precision != precision) {\n\n      fprintf (stderr, \"At %s, \", curr_time_str);\n\n      fprintf (stderr, \"ERROR. Bad precision.\\n\");\n\n    }\n\n    prev_precision = precision;\n\n    frame_received = true;\n\n    return;\n\n  } else if (precision == '#') {\n\n    if (verbose && (prev_precision != precision)) {\n\n      fprintf (stderr, \"At %s, \", curr_time_str);\n\n      fprintf (stderr, \"WARNING. Degraded precision.\\n\");\n\n    }\n\n  } else {\n\n    if ((prev_precision == '?') || (verbose && (prev_precision =='#') ) ) {\n\n      fprintf (stderr, \"At %s, \", curr_time_str);\n\n      fprintf (stderr, \"INFO. Good precision.\\n\");\n\n    }\n\n  }\n\n  prev_precision = precision;\n\n  frame_received = true;\n\n\n\n  /* Compute delta = new_time - current_time */\n\n  (void) memcpy (&curr_delta, &new_time, sizeof(curr_delta));\n\n  (void) sub_time (&curr_delta, &curr_time);\n\n\n\n  /* Get current adjustment  = current_time - desired_time */\n\n  if (adjtime_call ((struct timeval*)NULL, &curr_adjust) == -1) {\n\n    fprintf (stderr, \"At %s, \", curr_time_str);\n\n    perror (\"Adjtime_call\");\n\n    return;\n\n  }\n\n\n\n  /* Delta_delta = curr_delta - curr_adjust */\n\n  (void) memcpy (&delta_delta, &curr_delta, sizeof(curr_delta));\n\n  (void) sub_time (&delta_delta, &curr_adjust);\n\n\n\n  /* If |delta_delta| < threshold, then */\n\n  if ( (delta_delta.tv_sec != 0)\n\n    || (abs ((int)(delta_delta.tv_usec/1000)) > threshold_msec) ) {\n\n    if (adjtime_call (&curr_delta, (struct timeval*)NULL)  == -1) {\n\n      fprintf (stderr, \"At %s, \", curr_time_str);\n\n      perror (\"Adjtime_call\");\n\n      return;\n\n    }\n\n    if (verbose) {\n\n      printf (\"At %s,      Synchro: %d.%06d,      Prev adjust:  %d.%06d\\n\",\n\n               curr_time_str, (int)curr_delta.tv_sec, (int)curr_delta.tv_usec,\n\n               (int)curr_adjust.tv_sec, (int)curr_adjust.tv_usec);\n\n    }\n\n  }\n\n}\n\n\n\nstatic void sig_handler(int signum __attribute__ ((unused)) ) {\n\n    struct timeval curr_time;\n\n    char *curr_time_str;\n\n\n\n    /* Get current time */\n\n    if (gettimeofday(&curr_time, (struct timezone*) NULL) == -1) {\n\n        perror (\"Gettimeofday\");\n\n        return;\n\n    }\n\n\n\n    /* For dating report messages */\n\n    curr_time_str = ctime(&curr_time.tv_sec);\n\n    /* Skip last \\n */\n\n    curr_time_str[strlen(curr_time_str)-1] = '\\0';\n\n\n\n    if (frame_expected) {\n\n        fprintf (stderr, \"At %s, \", curr_time_str);\n\n        fprintf (stderr, \"ERROR. No time received\\n\");\n\n    }\n\n\n\n    /* For tracing when next message arrives */\n\n    frame_received = false;\n\n}\n\n\n\n\n\n#define USAGE  \"Usage : eti <tty_no>:<stopb>:<datab>:<parity>:<bauds> [ <accuracy_ms> ] [ -v ]\"\n\n\n\nint main(int argc, char *argv[]) {\n\n  unsigned char oct;\n\n\n\n  boolean started;\n\n\n\n  if (argc == 2) {\n\n    threshold_msec = DEFAULT_THRESHOLD_MSEC;\n\n    verbose = false;\n\n  } else if (argc == 3) {\n\n    if (strcmp(argv[2], \"-v\") == 0) {\n\n      threshold_msec = DEFAULT_THRESHOLD_MSEC;\n\n      verbose = true;\n\n    } else {\n\n      threshold_msec = atoi(argv[2]);\n\n    }\n\n  } else if ( (argc == 4) && (strcmp(argv[3], \"-v\") == 0) ) {\n\n      verbose = true;\n\n      threshold_msec = atoi(argv[2]);\n\n  } else {\n\n    fprintf (stderr, \"FATAL syntax error. %s\\n\", USAGE);\n\n    exit (1);\n\n  }\n\n\n\n  if (threshold_msec < MIN_THRESHOLD_MSEC) {\n\n    fprintf (stderr, \"FATAL invalid threshold error. %s\\n\", USAGE);\n\n    exit (1);\n\n  }\n\n\n\n  init_tty(argv[1], 1);\n\n\n\n  /* Hook signal handler and start 1 timer (1.5s) */\n\n  if (set_handler (SIGALRM, sig_handler, NULL) == ERR) {\n\n    perror (\"Set_handler\");\n\n    fprintf (stderr, \"FATAL error. Setting signal handler\\n\");\n\n    exit (2);\n\n  }\n\n  if (arm_timer (ITIMER_REAL , 2, 0, 0) == -1) {\n\n    perror (\"arm_timer\");\n\n    fprintf (stderr, \"FATAL error. Starting timer\\n\");\n\n    exit (2);\n\n  }\n\n\n\n  if (!verbose) {\n\n    printf (\"Silent mode\\n\");\n\n  } else {\n\n    printf (\"Verbose mode,  accuracy %d ms,  serial setting %s\\n\", threshold_msec, argv[1]);\n\n  }\n\n\n\n  started = false;\n\n  frame_received = false;\n\n  frame_expected = true;\n\n  prev_precision = ' ';\n\n  eti_index = 0;\n\n\n\n  for(;;) {\n\n    read_tty (&oct, 1);\n\n    if (oct == 0x02) started = true;\n\n    if (started) {\n\n      store (oct);\n\n      if (oct == 0x0d) {\n\n        /* End of message */\n\n        frame_expected = false;\n\n        decode_and_synchro();\n\n        eti_index = 0;\n\n        if (arm_timer (ITIMER_REAL , 2, 0, 0) == -1) {\n\n          perror (\"main Arm_timer\");\n\n        }\n\n        frame_expected = true;\n\n      }\n\n    }\n\n  }\n\n}\n\n\n", "#include <stdio.h>\n\n#include <stdlib.h>\n\n\n\n#ifdef UBSS\n\n#include \"bs.h\"\n\n#include \"scm.h\"\n\n#include \"npm.h\"\n\n#endif\n\n\n\n#include \"socket.h\"\n\n#include \"timeval.h\"\n\n\n\n#include \"synchro.h\"\n\n\n\n#define USAGE() {fprintf(stderr, \"Usage : synchro_server <port_name>\\n\");}\n\n\n\nint main (int argc, char *argv[]) {\n\n\n\n  soc_token soc = init_soc;\n\n  soc_port port_no;\n\n  synchro_msg_t synchro_msg;\n\n  soc_length length;\n\n  int cr;\n\n\n\n#ifdef UBSS\n\n  if (npm_bs_init()==BS_ERROR) {\n\n    scm_bscall_error();\n\n    exit (1);\n\n  }\n\n#endif\n\n\n\n  if (argc != 2) {\n\n    fprintf (stderr, \"SYNTAX error : Wrong number of arguments\\n\");\n\n    USAGE();\n\n    exit (1);\n\n  }\n\n\n\n  /* Create socket and bind to service */\n\n  if (soc_open(&soc, udp_socket) != SOC_OK) {\n\n    perror (\"opening socket\");\n\n    exit (2);\n\n  }\n\n\n\n  port_no = atoi(argv[1]);\n\n  if (port_no <= 0) {\n\n    if (soc_link_service(soc, argv[1]) != SOC_OK) {\n\n      perror (\"linking socket\");\n\n      exit (1);\n\n    }\n\n  } else {\n\n    if (soc_link_port(soc, port_no) != SOC_OK) {\n\n      perror (\"linking socket\");\n\n      exit (1);\n\n    }\n\n  }\n\n\n\n#ifdef UBSS\n\n  if (npm_proc_online()==BS_ERROR) {\n\n    scm_bscall_error();\n\n    exit (1);\n\n  }\n\n#else\n\n  printf (\"Server ready.\\n\");\n\n#endif\n\n\n\n\n\n  /* Wait for request and reply with current time */\n\n  for (;;) {\n\n    length = sizeof (synchro_msg);\n\n    cr = soc_receive (soc, (soc_message) &synchro_msg, length, FALSE);\n\n    if ( (cr == sizeof (synchro_msg))\n\n      && (synchro_msg.magic_number == magic_request_value) ) {\n\n\n\n      synchro_msg.magic_number = magic_reply_value;\n\n      get_time (&(synchro_msg.server_time));\n\n      length = cr;\n\n      cr = soc_send (soc, (soc_message) &synchro_msg, length);\n\n      if (cr != SOC_OK) {\n\n        perror (\"sending reply\");\n\n      }\n\n    } else if (cr != SOC_OK) {\n\n      perror (\"receiving request\");\n\n    } else {\n\n      fprintf (stderr, \"Error : wrong request received\");\n\n    }\n\n  }\n\n}\n\n\n", "#include \"timeval.h\"\n\n\n\n#define magic_request_value 0x21212121\n\n#define magic_reply_value   0x12121212\n\n\n\ntypedef struct {\n\n    unsigned int magic_number;\n\n    timeout_t request_time;\n\n    timeout_t server_time;\n\n} synchro_msg_t;\n\n\n", "#include <stdio.h>\n\n#include <time.h>\n\n\n\n#include \"gorgy_decode.h\"\n\n\n\n\n\nint gorgy_decode (char frame[], struct timeval *p_new_time, char *p_precision) {\n\n   struct tm   tms;\n\n   time_t      new_time_secs;\n\n\n\n    /* Decode external clock message */\n\n    if (sscanf(frame, \"%*4s %d/%d/%d  %d:%d:%d%c\\n\",\n\n                       &tms.tm_mday, &tms.tm_mon,\n\n                       &tms.tm_year, &tms.tm_hour,\n\n                       &tms.tm_min,  &tms.tm_sec,\n\n                       p_precision) != 7) {\n\n        return (-1);\n\n    }\n\n    tms.tm_year   = (tms.tm_year < 70) ? tms.tm_year + 100 : tms.tm_year;\n\n    tms.tm_mon   -= 1;\n\n    tms.tm_isdst  = 0;\n\n    new_time_secs = mktime(&tms);\n\n    if (new_time_secs == (time_t)-1) {\n\n        return (-1);\n\n    }\n\n    p_new_time->tv_sec = new_time_secs;\n\n    p_new_time->tv_usec = 0;\n\n\n\n    return (0);\n\n}\n\n\n", "#include <stdio.h>\n\n#include <stdlib.h>\n\n#include \"socket.h\"\n\n#include \"timeval.h\"\n\n#include \"wait_evt.h\"\n\n\n\n#include \"synchro.h\"\n\n\n\n#define DEFAULT_TIMEOUT_MS   1000\n\n#define DEFAULT_ACCURACY_MS   100\n\n\n\n#define USAGE() {fprintf(stderr, \"Usage : synchro_client <port_name> [ <timeout_ms> [ <accuracy_ms> ]\\n\");}\n\n\n\nint main (int argc, char *argv[]) {\n\n\n\n  timeout_t timeout;\n\n  int timeout_ms;\n\n  int accuracy_ms;\n\n  soc_token soc = init_soc;\n\n  soc_port port_no;\n\n  char lan_name[80];\n\n  synchro_msg_t synchro_msg;\n\n  soc_length length;\n\n  int cr, fd;\n\n  boolean read;\n\n  unsigned int travel_ms;\n\n\n\n  timeout_t request_time, reply_time, travel_delta;\n\n  timeout_t accuracy_timeout, wait_timeout;\n\n\n\n\n\n  if ( (argc != 2) && (argc != 3) && (argc != 4) ) {\n\n    fprintf (stderr, \"SYNTAX error : Wrong number of arguments\\n\");\n\n    USAGE();\n\n    exit (1);\n\n  }\n\n\n\n  if (argc >= 3) {\n\n    timeout_ms = atoi(argv[2]);\n\n    if (timeout_ms <= 0) {\n\n      fprintf (stderr, \"SYNTAX error : Wrong timeout value\\n\");\n\n      USAGE();\n\n      exit (1);\n\n    }\n\n  } else {\n\n    timeout_ms = DEFAULT_TIMEOUT_MS;\n\n  }\n\n  wait_timeout.tv_sec = timeout_ms / 1000; \n\n  wait_timeout.tv_usec = (timeout_ms % 1000) * 1000;\n\n\n\n  if (argc == 4) {\n\n    accuracy_ms = atoi(argv[3]);\n\n    if (accuracy_ms <= 0) {\n\n      fprintf (stderr, \"SYNTAX error : Wrong accuracy value\\n\");\n\n      USAGE();\n\n      exit (1);\n\n    }\n\n  } else {\n\n    accuracy_ms = DEFAULT_ACCURACY_MS;\n\n  }\n\n  accuracy_timeout.tv_sec = accuracy_ms / 1000;\n\n  accuracy_timeout.tv_usec = (accuracy_ms % 1000) * 1000;\n\n\n\n\n\n  if (soc_get_local_lan_name(lan_name, sizeof(lan_name)) != SOC_OK) {\n\n    perror (\"getting lan name\");\n\n    exit (1);\n\n  }\n\n\n\n  if (soc_open(&soc, udp_socket) != SOC_OK) {\n\n    perror (\"opening socket\");\n\n    exit (1);\n\n  }\n\n\n\n  port_no = atoi(argv[1]);\n\n  if (port_no <= 0) {\n\n    if (soc_set_dest_name_service(soc, lan_name, true, argv[1]) != SOC_OK) {\n\n      perror (\"setting destination service\");\n\n      exit (1);\n\n    }\n\n  } else {\n\n    if (soc_set_dest_name_port(soc, lan_name, true, port_no) != SOC_OK) {\n\n      perror (\"setting destination port\");\n\n      exit (1);\n\n    }\n\n  }\n\n\n\n  if (soc_get_dest_port(soc, &port_no) != SOC_OK) {\n\n    perror (\"getting destination port no\");\n\n    exit (1);\n\n  }\n\n\n\n  if (soc_link_port(soc, port_no) != SOC_OK) {\n\n    perror (\"linking socket\");\n\n    exit (1);\n\n  }\n\n\n\n  /* List for wait */\n\n  if (soc_get_id(soc, &fd) != SOC_OK) {\n\n    perror (\"getting socket id\");\n\n    exit (1);\n\n  }\n\n  if (evt_add_fd(fd, TRUE) != WAIT_OK) {\n\n    perror(\"Adding fd\");\n\n    exit (1);\n\n  }\n\n\n\n  for (;;) {\n\n    synchro_msg.magic_number = magic_request_value;\n\n    get_time (&(synchro_msg.request_time));\n\n\n\n    cr = soc_send (soc, (soc_message) &synchro_msg, sizeof(synchro_msg));\n\n    if (cr != SOC_OK) {\n\n      perror (\"sending request\");\n\n      exit (1);\n\n    }\n\n\n\n    request_time = synchro_msg.request_time;\n\n\n\n    for (;;) {\n\n\n\n      timeout = wait_timeout;\n\n      if (evt_wait (&fd, &read, &timeout) != WAIT_OK) {\n\n        perror (\"waiting for event\");\n\n        exit (1);\n\n      }\n\n\n\n      if (fd == NO_EVENT) {\n\n        printf (\"Timeout expired. Giving up.\\n\");\n\n        exit (2);\n\n      } else if (fd <= 0) {\n\n        /* Other non fd event */\n\n        continue;\n\n      }\n\n\n\n      length = sizeof (synchro_msg);\n\n      cr = soc_receive (soc, (soc_message) &synchro_msg, length, FALSE);\n\n      get_time (&reply_time);\n\n\n\n      if ( cr == sizeof (synchro_msg) ) {\n\n        if (synchro_msg.magic_number == magic_request_value) {\n\n          ;\n\n        } else if ( (synchro_msg.magic_number == magic_reply_value)\n\n                 && (synchro_msg.request_time.tv_sec == request_time.tv_sec)\n\n                 && (synchro_msg.request_time.tv_usec == request_time.tv_usec) ) {\n\n\n\n          travel_delta = reply_time;\n\n          (void) sub_time (&travel_delta, &request_time);\n\n          if (comp_time(&travel_delta, &accuracy_timeout) > 0) {\n\n              printf (\"Insuficient accuracy. Skipping...\\n\");\n\n              break;\n\n          }\n\n\n\n          /* Compute time (reply + travel/2) and settimofday */\n\n          travel_ms = travel_delta.tv_sec * 1000;\n\n          travel_ms += travel_delta.tv_usec / 1000;\n\n          incr_time (&synchro_msg.server_time, travel_ms / 2);\n\n\n\n          (void) sub_time (&reply_time, &synchro_msg.server_time);\n\n          printf (\"Synchro %ld.%06d s\\n\", reply_time.tv_sec,\n\n                                         (int)reply_time.tv_usec);\n\n\n\n          if (settimeofday (&synchro_msg.server_time, NULL) < 0) {\n\n             perror (\"settimeofday\");\n\n             exit (1);\n\n          }\n\n          exit (0);\n\n        } else {\n\n          fprintf (stderr, \"Error : wrong reply received\");\n\n        }\n\n\n\n      } else if (cr != SOC_OK) {\n\n        perror (\"receiving reply\");\n\n      } else {\n\n        fprintf (stderr, \"Error : wrong reply received\");\n\n      }\n\n    }\n\n\n\n    /* Reset dest */\n\n    if (soc_set_dest_name_port(soc, lan_name, true, port_no) != SOC_OK) {\n\n      perror (\"linking socket\");\n\n      exit (1);\n\n    }\n\n  }\n\n}\n\n\n", "#include <stdio.h>\n\n#include <stdlib.h>\n\n#include <time.h>\n\n#include <sys/time.h>\n\n#include <signal.h>\n\n\n\n#include \"sig_util.h\"\n\n#include \"tty.h\"\n\n#include \"timeval.h\"\n\n#include \"gorgy_decode.h\"\n\n\n\n#define BUFFER_SIZE 1000\n\n\n\n\n\n\n\nextern int fd;\n\nstatic  unsigned char buffer[BUFFER_SIZE];\n\nstatic  unsigned int index;\n\n\n\nstatic void store (unsigned char oct) {\n\n  if (index == BUFFER_SIZE - 1) {\n\n    index = 0;\n\n  }\n\n  buffer[index] = oct;\n\n  index ++;\n\n}\n\n\n\n/* static void print (char oct) {\n\n *   if (oct < 32) printf (\"'%02X' \", (int)oct);\n\n *   else printf (\"%c \", oct);\n\n * }\n\n */\n\n\n\nstatic void decode_and_synchro (void) __attribute__ ((noreturn));\n\nstatic void decode_and_synchro (void) {\n\n    char        precision;\n\n    struct timeval new_time, curr_time;\n\n\n\n    /* Cancel timer */\n\n    (void) arm_timer (ITIMER_REAL , 0, 0, 0);\n\n\n\n    /* Decode external clock message */\n\n    if (gorgy_decode ((char*)buffer, &new_time, &precision) < 0) {\n\n        fprintf (stderr, \"ERROR. Wrong time format or value.\\n\");\n\n        exit (2);\n\n    }\n\n    if (precision == '?') {\n\n        fprintf (stderr, \"ERROR. Bad precision.\\n\");\n\n        exit (2);\n\n    } else if (precision == '#') {\n\n        fprintf (stderr, \"WARNING. degraded precision.\\n\");\n\n    } else {\n\n        fprintf (stderr, \"INFO. good precision.\\n\");\n\n    }\n\n\n\n    /* For computing delta */\n\n    if (gettimeofday(&curr_time, (struct timezone*) NULL) == -1) {\n\n        perror (\"ERROR. Gettimeofday\");\n\n        exit (2);\n\n    }\n\n\n\n    /* Set time */\n\n    if (settimeofday(&new_time, (struct timezone*) NULL) == -1) {\n\n        perror (\"ERROR. Settimeofday\");\n\n        exit (2);\n\n    }\n\n\n\n\n\n    /* Print delta */\n\n    (void) sub_time (&new_time, &curr_time);\n\n    printf (\"Synchro %ld.%06d s\\n\", new_time.tv_sec, (int)new_time.tv_usec);\n\n    exit(0);\n\n}\n\n\n\nstatic void sig_handler(int signum) __attribute__ ((noreturn));\n\nstatic void sig_handler(int signum __attribute__ ((unused)) ) {\n\n    fprintf (stderr, \"ERROR. No time received\\n\");\n\n    exit (2);\n\n}\n\n\n\n\n\nint main(int argc, char *argv[]) {\n\n  unsigned char oct;\n\n\n\n  int started;\n\n\n\n  if ( argc != 2) {\n\n    printf (\"SYNTAX ERROR. Usage : serial_spy <tty_no>:<stopb>:<datab>:<parity>:<bauds>\\n\");\n\n    exit (1);\n\n  }\n\n\n\n  init_tty(argv[1], 1);\n\n\n\n  /* Hook signal handler and start 1 timer (3s) */\n\n  if (set_handler (SIGALRM, sig_handler, NULL) == ERR) {\n\n      fprintf (stderr, \"ERROR. Setting signal handler\\n\");\n\n      exit (2);\n\n  }\n\n  if (arm_timer (ITIMER_REAL , 3, 0, 0) == -1) {\n\n      fprintf (stderr, \"ERROR. Starting timer\\n\");\n\n      exit (2);\n\n  }\n\n\n\n\n\n  started = 0;\n\n  index = 0;\n\n\n\n  for(;;) {\n\n    read_tty (&oct, 1);\n\n    if (oct == 0x02) started = 1;\n\n    if (started) {\n\n      store (oct);\n\n      if (oct == 0x0d) {\n\n        decode_and_synchro();\n\n      }\n\n    }\n\n  }\n\n}\n\n\n", "#include <sys/time.h>\n\n\n\nint gorgy_decode (char frame[], struct timeval *p_new_time, char *p_precision);\n", "#include <sys/types.h>\n\n#include <signal.h>\n\n#include <stdlib.h>\n\n\n\nint main (int argc, char *argv[]) {\n\n\n\n  int pid = atoi(argv[1]);\n\n\n\n  if (argc == 2) {\n\n    pid = atoi(argv[1]);\n\n\n\n    for (;;) {\n\n      kill (pid, SIGUSR1);\n\n    }\n\n  }\n\n  exit(0);\n\n}\n\n\n", "#include <stdlib.h>\n\n#include <stdio.h>\n\n#include <malloc.h>\n\n#include <signal.h>\n\n\n\nstatic char *b0;\n\nstatic char *p;\n\nstatic int size_handler;\n\n\n\nstatic void sig_handler (int sig_num __attribute__ ((unused)) ) {\n\n\n\n  if (p == NULL) {\n\n      size_handler=rand()%1000+1;\n\n      p = malloc (size_handler);\n\n  }\n\n}\n\n\n\nint main(void) {\n\n  int size;\n\n\n\n  (void) signal (SIGUSR1, sig_handler);\n\n\n\n  p = NULL;\n\n\n\n   for (;;) {\n\n     size = rand() %1000+1;\n\n     b0 = malloc (size);\n\n     if (p != NULL) {\n\n         if ( (p >= b0) && (p <= b0 + size) ) {\n\n             printf (\"Fatal! %p %p %p\\n\" ,b0, p, b0 + size);\n\n             printf (\"Sizes %d %d\\n\", size, size_handler);\n\n             exit (1);\n\n         }\n\n         if ( (b0 >= p) && (b0 <= p + size_handler) ) {\n\n             printf (\"Fatal!! %p %p %p\\n\" ,b0, p, b0 + size);\n\n             printf (\"Sizes %d %d\\n\", size, size_handler);\n\n             exit (1);\n\n         }\n\n         free (p);\n\n         p = NULL;\n\n      }\n\n      free (b0);\n\n   }\n\n}\n\n\n", "#include <stdio.h>\n\n#include <time.h>\n\n#include <sys/time.h>\n\n#include <stdlib.h>\n\n#include <errno.h>\n\n#include <string.h>\n\n#include <strings.h>\n\n\n\nstatic void error(void) __attribute__ ((noreturn));\n\nstatic void error(void) {\n\n    fprintf (stderr, \"Usage: settime Dd/Mm/YYyy hh:mm:ss [ms]\\n\");\n\n    exit (1);\n\n}\n\n\n\nint main (int argc, char *argv[]) {\n\n  struct tm tms;\n\n  struct timeval tv;\n\n  char a1[11];\n\n  int l1;\n\n  char a2[9];\n\n  int l2;\n\n  char *p, *pp;\n\n\n\n  /* DD/MM/YYYY hh:mm:ss [ms] */\n\n  if ((argc != 3) && (argc != 4) ) error();\n\n  l1 = strlen(argv[1]);\n\n  l2 = strlen(argv[2]);\n\n  if (l1 != 10) error();\n\n  if (l2 != 8)  error();\n\n\n\n  strcpy (a1, argv[1]);\n\n  strcpy (a2, argv[2]);\n\n\n\n  /* Parse a1 */\n\n  pp = argv[1];\n\n  p = strchr(pp, '/');\n\n  if (p == NULL) error();\n\n  *p = '\\0';\n\n  if (strlen(pp) != 2) error();\n\n  tms.tm_mday = atoi(pp);\n\n  if ( (tms.tm_mday < 1) || (tms.tm_mday > 31) ) error();\n\n\n\n  pp = p + 1;\n\n  p = strchr(pp, '/');\n\n  if (p == NULL) error();\n\n  *p = '\\0';\n\n  if (strlen(pp) != 2) error();\n\n  tms.tm_mon = atoi(pp) - 1;\n\n  if ( (tms.tm_mon < 0) || (tms.tm_mon > 11) ) error();\n\n\n\n  pp = p + 1;\n\n  p = strchr(pp, '/');\n\n  if (p != NULL) error();\n\n  if (strlen(pp) != 4) error();\n\n  tms.tm_year = atoi(pp) - 1900;\n\n  if (tms.tm_year < 0) error();\n\n\n\n\n\n\n\n  /* Parse a2 */\n\n  pp = argv[2];\n\n  p = strchr(pp, ':');\n\n  if (p == NULL) error();\n\n  *p = '\\0';\n\n  if (strlen(pp) != 2) error();\n\n  tms.tm_hour = atoi(pp);\n\n  if ( (tms.tm_hour < 0) || (tms.tm_hour > 23) ) error();\n\n\n\n  pp = p + 1;\n\n  p = strchr(pp, ':');\n\n  if (p == NULL) error();\n\n  *p = '\\0';\n\n  if (strlen(pp) != 2) error();\n\n  tms.tm_min = atoi(pp);\n\n  if ( (tms.tm_min < 0) || (tms.tm_min > 59) ) error();\n\n\n\n  pp = p + 1;\n\n  p = strchr(pp, ':');\n\n  if (p != NULL) error();\n\n  if (strlen(pp) != 2) error();\n\n  tms.tm_sec = atoi(pp);\n\n  if ( (tms.tm_sec < 0) || (tms.tm_sec > 59) ) error();\n\n\n\n  /* Make tv_secs */\n\n  tv.tv_sec = mktime(&tms);\n\n  if (tv.tv_sec == -1) {\n\n    perror(\"mktime\");\n\n    error();\n\n  }\n\n\n\n  /* make tv_usecs */\n\n  if (argc == 4) {\n\n    tv.tv_usec = atoi(argv[3]);\n\n  } else {\n\n    tv.tv_usec = 0;\n\n  }\n\n  if ( (tv.tv_usec < 0) || (tv.tv_usec >= 1000) ) error();\n\n  tv.tv_usec = tv.tv_usec * 1000;\n\n\n\n  printf (\"%ld secs %ld usecs.\\n\", tv.tv_sec, tv.tv_usec);\n\n\n\n  /* Set time */\n\n  if (settimeofday(&tv, NULL) == 0) {\n\n    printf (\"Done\\n\");\n\n    exit(0);\n\n  } else {\n\n    perror(\"settimeofday\");\n\n    error();\n\n  }\n\n}\n\n\n", "#include <stdio.h>\n\n#include <sys/time.h>\n\n#include <time.h>\n\n#include <ctype.h>\n\n#include <string.h>\n\n#include <stdlib.h>\n\n#include <libgen.h>\n\n\n\nchar prog_name[500];\n\n\n\n\n\nstatic void usage(const char *msg) {\n\n  fprintf (stderr, \"%s\\n\", msg);\n\n  fprintf (stderr, \"Usage : %s <seconds>   |   [[dd/mm/yyyy] hh:mm:ss]\\n\", prog_name);\n\n  fprintf (stderr, \"Examples : %s 81365\\n           %s 25/10/1971 10:30:25\\n           %s 12:00:01\\n\",\n\n           prog_name, prog_name, prog_name);\n\n}\n\n\n\nstatic int to_int(char *str) {\n\n  int i, r;\n\n\n\n  r = atoi(str);\n\n  if (r == 0) {\n\n    for (i = 0; (unsigned)i < strlen(str) ; i++) {\n\n      if (str[i] != '0') return -1;\n\n    }\n\n  }\n\n  return (r);\n\n}\n\n\n\nstatic void printd (time_t sec) {\n\n  struct tm *tm_date_p;\n\n  /* String of the date printed : year month day hours:min:sec */\n\n  char printed_date [133];\n\n\n\n  tm_date_p = gmtime(&sec);\n\n  if (tm_date_p == (struct tm*)NULL) {\n\n    perror(\"gmtime\");\n\n    fprintf (stderr, \"Cannot convert %ld seconds in date. Abort.\\n\", sec);\n\n    exit (1);\n\n  }\n\n\n\n  /* dd/mm/yyyy hh:mm:ss */\n\n  sprintf (printed_date, \"%02d/%02d/%04d %02d:%02d:%02d\",\n\n      tm_date_p->tm_mday, (tm_date_p->tm_mon)+1, (tm_date_p->tm_year)+1900,\n\n      tm_date_p->tm_hour, tm_date_p->tm_min, tm_date_p->tm_sec);\n\n\n\n  printf (\"%ld secs -> %s GMT\\n\", sec, printed_date);\n\n}\n\n\n\nint main(int argc, char *argv[]) {\n\n\n\n  time_t timeoffset;\n\n  struct timeval time;\n\n\n\n  /* Struct returned by gmtime */\n\n  struct tm tm_date, *tm_date_p;\n\n  char buff[50];\n\n  int digits;\n\n  int i, j, k;\n\n\n\n  strcpy (prog_name, basename(argv[0]));\n\n\n\n  if ((argc == 2)  && (strcmp(argv[1], \"-h\") == 0) ) {\n\n    usage(\"\");\n\n    exit(0);\n\n  }\n\n\n\n  if (argc == 1) {\n\n    digits = 0;\n\n  } else if (argc == 2) {\n\n    /* One arg : either secs (digits) or hh:mm:ss */\n\n    digits = 1;\n\n    for (i = 0; (unsigned)i < strlen(argv[1]); i++) {\n\n      if (!isdigit(argv[1][i])) {\n\n        /* Not a digit : so this might be hh:mm:ss (check later on) */\n\n        digits = 0;\n\n        break;\n\n      }\n\n    }\n\n  } else if (argc == 3) {\n\n    digits = 0;\n\n  } else {\n\n    usage(\"SYNTAX ERROR\");\n\n    exit(1);\n\n  }\n\n\n\n  /* Compute local time offset */\n\n  if (gettimeofday(&time, (struct timezone *)NULL) == -1) {\n\n    perror (\"gettimeofday\");\n\n    fprintf (stderr, \"Cannot get current date and time. Abort.\\n\");\n\n    exit (2);\n\n  }\n\n  tm_date_p = gmtime ((time_t*) &time.tv_sec);\n\n  if (tm_date_p == (struct tm*)NULL) {\n\n    perror(\"gmtime\");\n\n    fprintf (stderr, \"Cannot convert current date. Abort.\\n\");\n\n    exit (1);\n\n  }\n\n\n\n  timeoffset = mktime (tm_date_p);\n\n  if (timeoffset == -1) {\n\n    perror(\"mktime\");\n\n    fprintf (stderr, \"Cannot convert date 0 to localtime. Abort.\\n\");\n\n    exit (1);\n\n  }\n\n  timeoffset = time.tv_sec - timeoffset;\n\n  printf (\"Local time offset is %ds\\n\", (int)timeoffset);\n\n\n\n  if (digits == 1) {\n\n    /* One arg: tv_secs */\n\n    /* Seconds from 01/01/1979 00:00:00  -->   dd/mm/yyyy hh:mm:ss */\n\n    time.tv_sec = to_int(argv[1]);\n\n    if (time.tv_sec == -1) {\n\n      fprintf (stderr, \"Cannot convert >%s< string in int. Abort.\\n\", argv[1]);\n\n      usage(\"SYNTAX ERROR\");\n\n      exit (1);\n\n    }\n\n\n\n    printd (time.tv_sec);\n\n    /* Done */\n\n    exit(0);\n\n  }\n\n\n\n  if (argc == 1) {\n\n    /* No arg -> gettimeofday */\n\n    if (gettimeofday(&time, (struct timezone *)NULL) == -1) {\n\n      perror (\"gettimeofday\");\n\n      fprintf (stderr, \"Cannot get current date and time. Abort.\\n\");\n\n      exit (2);\n\n    }\n\n\n\n    printd (time.tv_sec);\n\n    /* Done */\n\n    exit(0);\n\n  }\n\n\n\n  /* [ dd/mm/yyyy ] hh:mm:ss */\n\n  /* Check length */\n\n  if ( ( (argc == 2) && (strlen(argv[1]) != 8) )\n\n    || (  (argc == 3) && (strlen(argv[1]) != 10) && (strlen(argv[2]) != 8) ) ) {\n\n\n\n    usage(\"SYNTAX ERROR\");\n\n    exit(1);\n\n  }\n\n\n\n  /* Check digits of dd/mm/yyyy if any, then check hh:mm:ss */\n\n  if (argc == 3) {\n\n    strcpy (buff, argv[2]);\n\n    if ( (!isdigit(argv[1][0])) || (!isdigit(argv[1][1])) || (argv[1][2] != '/')\n\n      || (!isdigit(argv[1][3])) || (!isdigit(argv[1][4])) || (argv[1][5] != '/')\n\n      || (!isdigit(argv[1][6])) || (!isdigit(argv[1][7]))\n\n      || (!isdigit(argv[1][8])) || (!isdigit(argv[1][9])) ) {\n\n      usage(\"SYNTAX ERROR\");\n\n      exit(1);\n\n    }\n\n  } else {\n\n    strcpy (buff, argv[1]);\n\n  }\n\n\n\n  if ( (!isdigit(buff[0])) || (!isdigit(buff[1])) || (buff[2] != ':')\n\n    || (!isdigit(buff[3])) || (!isdigit(buff[4])) || (buff[5] != ':')\n\n    || (!isdigit(buff[6])) || (!isdigit(buff[7])) ) {\n\n    usage(\"SYNTAX ERROR\");\n\n    exit(1);\n\n  }\n\n\n\n  /* Set date */\n\n  bzero ((char*)&tm_date, sizeof(struct tm));\n\n\n\n  if (argc == 2) {\n\n    /* No year month day : get current */\n\n    if (gettimeofday(&time, (struct timezone *)NULL) == -1) {\n\n      perror (\"gettimeofday\");\n\n      fprintf (stderr, \"Cannot get current date and time. Abort.\\n\");\n\n      exit (2);\n\n    }\n\n\n\n    tm_date_p = localtime( (time_t*) &(time.tv_sec) );\n\n    if (tm_date_p == (struct tm*)NULL) {\n\n      perror(\"localtime\");\n\n      fprintf (stderr, \"Cannot convert current date. Abort.\\n\");\n\n      exit (1);\n\n    }\n\n    bcopy ((char*)tm_date_p, (char*)&tm_date, sizeof(struct tm));\n\n  } else {\n\n    /* Load tm structure (year month day) from argv[1] */\n\n    strcpy(buff, argv[1]);\n\n    buff[2] = '\\0';\n\n    buff[5] = '\\0';\n\n    i = to_int(&buff[0]);\n\n    j = to_int(&buff[3]);\n\n    k = to_int(&buff[6]);\n\n    if ( (i == -1) || (j == -1) || (k == -1) || (i < 0) || (i > 31) || (j < 1) || (j > 12) || (k < 1970) ) {\n\n      fprintf (stderr, \"Cannot convert >%s< date in date. Abort.\\n\", argv[1]);\n\n      usage(\"SYNTAX ERROR\");\n\n      exit (1);\n\n    }\n\n    tm_date.tm_mday = i;\n\n    tm_date.tm_mon = j - 1;\n\n    tm_date.tm_year = k - 1900;\n\n  }\n\n\n\n  /* Load tm structure (hour min sec) from argv */\n\n  if (argc == 2) {\n\n    strcpy (buff, argv[1]);\n\n  } else {\n\n    strcpy (buff, argv[2]);\n\n  }\n\n\n\n  buff[2] = '\\0';\n\n  buff[5] = '\\0';\n\n  i = to_int(&buff[0]);\n\n  j = to_int(&buff[3]);\n\n  k = to_int(&buff[6]);\n\n  if ( (i == -1) || (j == -1) || (k == -1) || (i > 23) || (j > 59) || (k > 59) ) {\n\n      fprintf (stderr, \"Cannot convert >%s< time in date. Abort.\\n\", buff);\n\n      usage(\"SYNTAX ERROR\");\n\n      exit (1);\n\n  }\n\n  tm_date.tm_hour = i;\n\n  tm_date.tm_min = j;\n\n  tm_date.tm_sec = k;\n\n\n\n  /* Compute secs since 01/10/1970 00:00:00 localtime */\n\n  tm_date.tm_isdst = 0;\n\n  time.tv_sec = mktime(&tm_date) + timeoffset;\n\n\n\n  if (time.tv_sec == (time_t)-1) {\n\n    perror(\"mktime\");\n\n    if (argc == 2) {\n\n      fprintf (stderr, \"Cannot convert >%s< to time. Abort.\\n\", argv[1]);\n\n    } else {\n\n      fprintf (stderr, \"Cannot convert >%s< >%s< to date. Abort.\\n\", argv[1], argv[2]);\n\n    }\n\n    exit (1);\n\n  }\n\n\n\n  printd (time.tv_sec);\n\n\n\n  exit (0);\n\n\n\n}\n\n\n", "/* Removes all \"<char> Backspace\" sequences from stdin to stdout */\n\n#include <stdio.h>\n\n#include <stdlib.h>\n\n\n\nint main (void) {\n\n\n\n  char c1, c2;\n\n\n\n    c1 = (char) getchar();\n\n    if ((int)c1 == EOF)  exit (0);\n\n\n\n  for (;;) {\n\n    c2 = (char) getchar();\n\n\n\n    if ( (int)c2 == 8 )  {\n\n      /* A backspace. Read next char */\n\n      c1 = (char) getchar();\n\n    } else if ((int)c2 == EOF) {\n\n      /* End of file. Done. */\n\n      break;\n\n    } else {\n\n      /* Other char */\n\n      putchar (c1);\n\n      c1 = c2;\n\n    }\n\n  }\n\n  exit(0);\n\n\n\n}\n\n\n", "#include <stdio.h>\n\n#include <stdlib.h>\n\n#include <string.h>\n\n#include <libgen.h>\n\n#include <ctype.h>\n\n#include <errno.h>\n\n#include <time.h>\n\n#include <unistd.h>\n\n\n\n#include \"boolean.h\"\n\n#include \"socket.h\"\n\n#include \"timeval.h\"\n\n#include \"util.h\"\n\n\n\n/* String terminator */\n\n#define NUL '\\0'\n\n\n\n/* Current version */\n\n#define VERSION \"2.0\"\n\n\n\n/* Exit code */\n\n#define ERROR_EXIT_CODE 1\n\n\n\n/* Our program name */\n\nstatic char prog_name[1024];\n\n\n\n\n\n/* Debug on or off */\n\n#define DEBUG_VAR \"UDPSPY_DEBUG\"\n\nstatic boolean debug = FALSE;\n\nextern void trace (const char *msg, const char *arg) {\n\n  if (debug) {\n\n    fprintf (stderr, \"%s->%s %s\\n\", prog_name, msg, arg);\n\n  }\n\n}\n\n\n\n/* Result of argument parsing */\n\ntypedef enum {no_dump, short_dump, long_dump, binary_dump} dump_kind_list;\n\nstatic dump_kind_list dump_kind;\n\nstatic char lan_name[1024];\n\nstatic soc_host lan_num;\n\nstatic char port_name[1024];\n\nstatic soc_port port_num;\n\n\n\n/* Display usage message on stderr */\n\nextern void usage (void) {\n\n  fprintf (stderr, \"Usage: %s [ -s | -l | -b ] <lan>:<port>\\n\", prog_name);\n\n  fprintf (stderr, \"   or: %s   -h | --help\\n\", prog_name);\n\n  fprintf (stderr, \"   or: %s   -v | --version\\n\", prog_name);\n\n  fprintf (stderr, \" <lan>  ::=  <lan_name>  | <lan_num>\\n\");\n\n  fprintf (stderr, \" <port> ::=  <port_name> | <port_num>\\n\");\n\n  fprintf (stderr, \" -s or --short for short data dump.\\n\");\n\n  fprintf (stderr, \" -l or --long for long data dump\\n\");\n\n  fprintf (stderr, \" -b or --binary for binary data dump\\n\");\n\n}\n\n\n\n/* Display an error message on stderr and exit */\n\nextern void error (const char *msg, const char *arg) {\n\n  fprintf (stderr, \"ERROR: %s %s\\n\", msg, arg);\n\n  usage();\n\n  exit (ERROR_EXIT_CODE);\n\n}\n\n\n\n/* Locate a char in a string. Return relative index (0 to N) or -1 */\n\n#define NOT_FOUND (-1)\n\nstatic int locate (const char c, const char *str) {\n\n  int i;\n\n\n\n  /* Look for c, exit on NUL */\n\n  i = 0;\n\n  for (;;) {\n\n    if (str[i] == c) {\n\n      return i;\n\n    } else if (str[i] == NUL) {\n\n      break;\n\n    }\n\n    i++;\n\n  }\n\n  return NOT_FOUND;\n\n}\n\n\n\nstatic int parse_dump (const char *flag) {\n\n  if ( (strcmp(flag, \"-s\") == 0) || (strcmp(flag, \"--short\") == 0) ) {\n\n    dump_kind = short_dump;\n\n    return TRUE;\n\n  } else if ( (strcmp(flag, \"-l\") == 0) || (strcmp(flag, \"--long\") == 0) ) {\n\n    dump_kind = long_dump;\n\n    return TRUE;\n\n  } else if ( (strcmp(flag, \"-b\") == 0) || (strcmp(flag, \"--binary\") == 0) ) {\n\n    dump_kind = binary_dump;\n\n    return TRUE;\n\n  } else {\n\n    return FALSE;\n\n  }\n\n\n\n}\n\n\n\n/* Parse lan name or num */\n\nstatic void parse_lan (const char *lan) {\n\n  trace (\"Parsing lan\", lan);\n\n  /* Try to parse a LAN address byte.byte.byte.byte */\n\n  /*  otherwise consider it is a lan name */\n\n\n\n  if (soc_str2host (lan, &lan_num) == SOC_OK) {\n\n    char buffer[16];\n\n    sprintf (buffer, \"%d.%d.%d.%d\", (int)lan_num.bytes[0],\n\n             (int)lan_num.bytes[1], (int)lan_num.bytes[2],\n\n             (int)lan_num.bytes[3]);\n\n    trace (\"Lan parsed as address\", buffer);\n\n  } else {\n\n    /* Byte parsing failed */\n\n    trace (\"Lan parsed as name\", lan);\n\n    strcpy (lan_name, lan);\n\n  }\n\n}\n\n/* Parse port name or num */\n\nstatic void parse_port (const char *port) {\n\n\n\n  /* Try to convert to port num */\n\n  if (soc_str2port (port, &port_num) == SOC_OK) {\n\n    char buffer[6];\n\n    sprintf (buffer, \"%d\", (int) port_num);\n\n    trace (\"Port parsed as num\", buffer);\n\n  } else {\n\n    trace (\"Port parsed as name\", port);\n\n    strcpy (port_name, port);\n\n  }\n\n}\n\n\n\n/* Parse lan:port, exit on error */\n\nstatic void parse_arg (const char *arg) {\n\n  int column_i;\n\n  char locarg [1024];\n\n\n\n  /* Init to default */\n\n  lan_name[0] = NUL;\n\n  lan_num.integer = 0;\n\n  port_name[0] = NUL;\n\n  port_num = 0;\n\n\n\n  /* Locate column in arg */\n\n  column_i = locate (':', arg);\n\n  if ( (column_i == NOT_FOUND)\n\n    || (column_i == 1)\n\n    || (column_i == (int)strlen(arg)-1) ) {\n\n    error (\"invalid argument\", arg);\n\n  }\n\n  /* Only one clumn */\n\n  if (locate (':', &arg[column_i+1]) != NOT_FOUND) {\n\n    error (\"invalid argument\", arg);\n\n  }\n\n\n\n  /* Save arg, split and parse lan and port */\n\n  strcpy (locarg, arg);\n\n  locarg[column_i] = NUL;\n\n  parse_lan (&locarg[0]);\n\n  parse_port (&locarg[column_i+1]);\n\n\n\n}\n\n\n\n/* Parse arguments, exit on error */\n\nextern void parse_args (const int argc, const char *argv[]) {\n\n  char buffer [sizeof(prog_name)];\n\n  char *debugstr;\n\n\n\n  /* Store program name (basename alters buffer) */\n\n  strcpy (buffer, argv[0]);\n\n  strcpy (prog_name, basename(buffer));\n\n\n\n  /* Set debug */\n\n  debugstr = getenv (DEBUG_VAR);\n\n  if ( (debugstr != NULL) && (toupper(debugstr[0]) == 'Y') ) {\n\n   debug = TRUE;\n\n  }\n\n\n\n  /* Parse arguments */\n\n  if (argc == 1) {\n\n    error (\"missing argument\", \"\");\n\n  } else if (argc == 2) {\n\n    if ( (strcmp (argv[1], \"-h\") == 0)\n\n      || (strcmp (argv[1], \"--help\") == 0) ) {\n\n      usage();\n\n      exit (ERROR_EXIT_CODE);\n\n    } else if ( (strcmp (argv[1], \"-v\") == 0)\n\n             || (strcmp (argv[1], \"--version\") == 0) ) {\n\n      fprintf (stderr, \"%s version %s\\n\", prog_name, VERSION);\n\n      exit (ERROR_EXIT_CODE);\n\n    } else {\n\n      dump_kind = no_dump;\n\n      parse_arg (argv[1]);\n\n    }\n\n  } else if (argc == 3) {\n\n    if (parse_dump(argv[1])) {\n\n      trace (\"Dump detected as arg 1\", \"\");\n\n      parse_arg (argv[2]);\n\n    } else if (parse_dump(argv[2])) {\n\n      trace (\"Dump detected as arg 2\", \"\");\n\n      parse_arg (argv[1]);\n\n    } else {\n\n      trace (\"Full not detected\", \"\");\n\n      error (\"invalid arguments\", \"\");\n\n    }\n\n  } else {\n\n    error (\"too many arguments\", \"\");\n\n  }\n\n}\n\n\n\nstatic void put_stamp (const soc_token socket, const char *msg) {\n\n  /* Result of operation */\n\n  int res;\n\n\n\n  /* Time stuff */\n\n  timeout_t time;\n\n  struct tm *p_tm;\n\n\n\n  /* Scoekt address */\n\n  soc_host from_host;\n\n  soc_port from_port;\n\n\n\n  /* Get time */\n\n  get_time (&time);\n\n  p_tm = gmtime (&time.tv_sec);\n\n\n\n  /* Get from */\n\n  if ((res = soc_get_dest_host (socket, &from_host)) != SOC_OK) {\n\n    trace (\"soc_get_dest_host error\", soc_error (res));\n\n    error (\"cannot get sender host\", \"\");\n\n  }\n\n  if ((res = soc_get_dest_port (socket, &from_port)) != SOC_OK) {\n\n    trace (\"soc_get_dest_port error\", soc_error (res));\n\n    error (\"cannot get sender port\", \"\");\n\n  }\n\n\n\n  /* Put time and from */\n\n  printf (\"At %02d/%02d %02d:%02d:%02d.%03d  %s %d.%d.%d.%d:%d\",\n\n          p_tm->tm_mon+1, p_tm->tm_mday,\n\n          p_tm->tm_hour, p_tm->tm_min, p_tm->tm_sec,\n\n          (int)(time.tv_usec / 1000), msg,\n\n          (int)from_host.bytes[0], (int)from_host.bytes[1],\n\n          (int)from_host.bytes[2], (int)from_host.bytes[3],\n\n          (int)from_port);\n\n}\n\n\n\n/* Bind the socket to the IPM lan and port */\n\nextern void bind_socket (soc_token socket) {\n\n  int res1, res2;\n\n\n\n  /* Set dest and bind */\n\n  if (strlen(port_name) == 0) {\n\n    if (strlen(lan_name) == 0) {\n\n      /* Lan num and port num */\n\n      res1 = soc_set_dest_host_port (socket, &lan_num, port_num);\n\n    } else {\n\n      /* Lan name and port num */\n\n      res1 = soc_set_dest_name_port (socket, lan_name, TRUE, port_num);\n\n    }\n\n    res2 = (res1 == SOC_OK) && soc_link_port (socket, port_num);\n\n  } else {\n\n    if (strlen(lan_name) == 0) {\n\n      /* Lan num and port name */\n\n      res1 = soc_set_dest_host_service (socket, &lan_num, port_name);\n\n    } else {\n\n      /* Lan name and port name */\n\n      res1 = soc_set_dest_name_service (socket, lan_name, TRUE, port_name);\n\n    }\n\n    res2 = (res1 == SOC_OK) && soc_link_service (socket, port_name);\n\n  }\n\n\n\n  if (res1 != SOC_OK) {\n\n    trace (\"soc_set_dest error\", soc_error (res1));\n\n    error (\"cannot set socket dest\", \"\");\n\n  }\n\n  if (res2 != SOC_OK) {\n\n    trace (\"soc_link error\", soc_error (res2));\n\n    error (\"cannot link socket\", \"\");\n\n  }\n\n\n\n  /* Put address we are listening to */\n\n  if (dump_kind != binary_dump) {\n\n    put_stamp (socket, \"Listening to\");\n\n\n\n    /* Put kind of dump */\n\n    printf (\"  For \");\n\n    switch (dump_kind) {\n\n      case no_dump :\n\n        printf (\"no\");\n\n        break;\n\n      case short_dump :\n\n        printf (\"short\");\n\n        break;\n\n      case long_dump :\n\n        printf (\"long\");\n\n        break;\n\n      case binary_dump :\n\n        /* Unreachable */\n\n        break;\n\n    }\n\n    printf (\" dumps.\\n\");\n\n  }\n\n}\n\n\n\n/* Put message info */\n\n#define BPL 16\n\n#define SHORT_LENGTH 64\n\nextern void display (const soc_token socket, const char *message,\n\n                                             const int length) {\n\n  int nrow, row, ncol, col, offset, sep, len;\n\n  int res;\n\n  unsigned char uchar;\n\n\n\n  if (dump_kind == binary_dump) {\n\n    /* Handle specific binary dump */\n\n    for (;;) {\n\n      res = write (1, message, length);\n\n      if (res >= 0) {\n\n        /* Done */\n\n        return;\n\n      } else if (errno != EINTR) {\n\n        perror (\"write\");\n\n        error (\"cannot write binary dump of message\", \"\");\n\n      }\n\n    }\n\n  }\n\n\n\n  /* Put from and lenght */\n\n  put_stamp (socket, \"From\");\n\n  printf (\"  Len %d\", length);\n\n\n\n  /* Put data if full */\n\n  if (dump_kind != no_dump) {\n\n    len = length;\n\n    /* SHORT_LENGTH max of data if short dump */\n\n    if ( (dump_kind == short_dump) && (length > SHORT_LENGTH) ) {\n\n      len = SHORT_LENGTH;\n\n    }\n\n\n\n    /* Separator offset */\n\n    sep = BPL / 2 - 1;\n\n    /* Loop on number of rows */\n\n    nrow = len / BPL + 1;\n\n    /* Offset in message for c */\n\n    offset = 0;\n\n\n\n    for (row = 1; row <= nrow; row++) {\n\n      /* Number of columns for this row: BPL or the remaining */\n\n      ncol = (row != nrow ? BPL : len % BPL);\n\n      if (ncol == 0) {\n\n        break;\n\n      }\n\n      /* Dump hexa */\n\n      printf (\"\\n  \");\n\n      for (col = 0; col < BPL; col++) {\n\n        if (col < ncol) {\n\n          uchar = (unsigned char)message[offset + col];\n\n          printf (\"%02x \", (int)uchar);\n\n        } else {\n\n          printf (\"   \");\n\n        }\n\n        if (col == sep) {\n\n          printf (\"  \");\n\n        }\n\n      }\n\n      printf (\"  \");\n\n      /* Dump ascii */\n\n      for (col = 0; col < ncol; col++) {\n\n        if (isprint((int)message[offset + col])) {\n\n          printf (\"%c\", message[offset + col]);\n\n        } else {\n\n          printf (\".\");\n\n        }\n\n      }\n\n      offset += BPL;\n\n    }\n\n    printf (\"\\n\");\n\n  } /* if dump */\n\n\n\n  printf (\"\\n\");\n\n}\n\n\n\nextern void the_end (void) {\n\n\n\n  if (dump_kind != binary_dump) {\n\n    printf (\"Done.\\n\");\n\n  }\n\n  exit (0);\n\n}\n\n\n", "#include \"socket.h\"\n\n\n\n/* Parse arguments, exit on error */\n\nextern void parse_args (const int argc, const char *argv[]);\n\n\n\n/* Trace a message if debug is on */\n\nextern void trace (const char *msg, const char *arg);\n\n\n\n/* Display usage message on stderr */\n\nextern void usage (void);\n\n\n\n/* Display an error message on stderr and exit */\n\nextern void error (const char *msg, const char *arg)\n\n                  __attribute__ ((noreturn));\n\n\n\n/* Bind the socket to the IPM lan and port */\n\nextern void bind_socket (soc_token socket);\n\n\n\n/* Put message info */\n\nextern void display (const soc_token socket,\n\n                     const char *message, const int length);\n\n\n\n/* Execute end of program actions */\n\nextern void the_end (void)\n\n                    __attribute__ ((noreturn));\n\n\n", "#include \"timeval.h\"\n\n#include \"socket.h\"\n\n#include \"wait_evt.h\"\n\n#include \"util.h\"\n\n\n\n/* Message read */\n\nstatic char message[128*1024];\n\n\n\nint main (const int argc, const char *argv[]) {\n\n  /* Result of operation */\n\n  int res;\n\n  char buffer[255];\n\n\n\n  /* The socket and its fd */\n\n  soc_token socket = init_soc;\n\n  int fd;\n\n\n\n  /* Event result */\n\n  boolean read;\n\n  timeout_t timeout;\n\n  int evtfd;\n\n\n\n  /* parse arguments */\n\n  parse_args (argc, argv);\n\n\n\n  /* Create socket and get fd */\n\n  if ( (res = soc_open (&socket, udp_socket)) != SOC_OK) {\n\n    trace (\"soc_open error\", soc_error (res));\n\n    error (\"cannot open socket\", \"\");\n\n  }\n\n  if ( (res = soc_get_id (socket, &fd)) != SOC_OK) {\n\n    trace (\"soc_get_id error\", soc_error (res));\n\n    error (\"cannot get socket fd\", \"\");\n\n  }\n\n  /* Bind socket to lan:port */\n\n  bind_socket (socket);\n\n\n\n  /* Attach fd for reading */\n\n  if ( (res = evt_add_fd (fd, TRUE)) != WAIT_OK) {\n\n    trace (\"evt_add_fd error\", \"\");\n\n    error (\"cannot add fd\", \"\");\n\n  }\n\n\n\n  /* Main loop */\n\n  timeout.tv_sec = -1;\n\n  timeout.tv_usec = -1;\n\n  for (;;) {\n\n    /* Infinite wait for events */\n\n    if ( (res = evt_wait (&evtfd, & read, &timeout)) != WAIT_OK) {\n\n      trace (\"evt_wait error\", \"\");\n\n      error (\"cannot wait for event\", \"\");\n\n    }\n\n    /* Analyse event */\n\n    if (evtfd == SIG_EVENT) {\n\n      if (get_signal() == SIG_TERMINATE) {\n\n        /* Sigterm/sigint */\n\n        break;\n\n      } /* else unexpected signal => drop */\n\n    } else if (evtfd == fd) {\n\n      /* Got a packet: read it */\n\n      res = soc_receive (socket, message, sizeof(message), TRUE);\n\n      if (res < 0) {\n\n        sprintf (buffer, \"%d\", res);\n\n        trace (\"soc_receive error\", soc_error (res));\n\n        error (\"cannot read message\", soc_error(res));\n\n      } else {\n\n        if (res > (int)sizeof(message)) {\n\n          sprintf (buffer, \"%d\", res);\n\n          trace (\"soc_receive truncated message length\", \"buffer\");\n\n          res = (int)sizeof(message);\n\n         }\n\n         /* Put message info */\n\n         display (socket, message, res);\n\n      }\n\n    } else if (evtfd >= 0) {\n\n      /* Unexpected event on an unexpected fd */\n\n      sprintf (buffer, \"%d\", evtfd);\n\n      trace (\"evt_wait got unexpected even on fd\", \"buffer\");\n\n      error (\"even on unexpected fd\", \"\");\n\n    }\n\n\n\n  } /* Main loop */\n\n\n\n  /* Done */\n\n  (void) evt_del_fd (fd, TRUE);\n\n  (void) soc_close (&socket);\n\n  the_end ();\n\n}\n\n\n", "#include<unistd.h>\n\n#include <stdlib.h>\n\n\n\nint main (void) {\n\n    (void) pause();\n\n    exit(0);\n\n}\n", "#include <signal.h>\n\n#include <stdio.h>\n\n#include <stdlib.h>\n\n#include <string.h>\n\n#include <sys/time.h>\n\n#include <time.h>\n\n#include <ctype.h>\n\n\n\n#define LF (char)0x0A\n\n#define TAB (char)0x09\n\n\n\n#if defined(alpha)\n\n#define TCPDUMP \"/usr/sbin/tcpdump\"\n\n#define PFCONFIG \"/usr/sbin/pfconfig\"\n\n#elif defined(linux)\n\n#define TCPDUMP \"/usr/sbin/tcpdump\"\n\n#define PFCONFIG \"\"\n\n#elif defined(cetaix)\n\n#define TCPDUMP \"/usr/sbin/tcpdump\"\n\n#define PFCONFIG \"\"\n\n#endif\n\n\n\n\n\n\n\nstatic char get_char (void) {\n\n  int i;\n\n\n\n  i = getchar();\n\n  if (i == EOF) {\n\n    exit (0);\n\n  }\n\n  return (char) i;\n\n}\n\n\n\nstatic int get_day (void) {\n\n  struct timeval time;\n\n  struct tm *pdate;\n\n\n\n  gettimeofday(&time, NULL);\n\n  pdate = localtime (&time.tv_sec);\n\n  return (pdate->tm_mday);\n\n}\n\n\n\nint main (int argc, char *argv[]) {\n\n\n\n  int i, d;\n\n  char c, c1, c2;\n\n  char buffer[512];\n\n  char interface_name[50];\n\n  int size_set;\n\n  int hexa_only;\n\n  int skip_arg;\n\n  int day, prev_hour, hour;\n\n  char pfconfig_cmd_down[50], pfconfig_cmd_up[50], tcpdump_cmd[1024], tcpdump_arg[1024];\n\n  char pfconfig[80];\n\n\n\n  strcpy(pfconfig, PFCONFIG);\n\n\n\n  if ( (argc != 2) || (strcmp(argv[1], \"-a\") != 0) ) {\n\n    /* First tcpdump : config interface */\n\n    /* and start \"/usr/sbin/tcpdump | tcpdump -a\" */\n\n\n\n\n\n    interface_name[0] = '\\0';\n\n    /* Look for -i (to store interface for pfconfig)     */\n\n    /* -s : otherwise set default size                   */\n\n    /* -h : no | tcpdump -a (not transmitted to tcpdump) */\n\n    size_set = 0;\n\n    hexa_only = 0;\n\n    tcpdump_arg[0] = '\\0';\n\n    for (i = 1; i < argc; i++) {\n\n      skip_arg = 0;\n\n      if ( (argv[i][0] == '-') && (argv[i][1] == 'i') ) {\n\n        if (argv[i][2] == '\\0') {\n\n          if (i != argc) {\n\n            strcpy (interface_name, argv[i+1]);\n\n          }\n\n        } else {\n\n          strcpy (interface_name, &(argv[i][2]));\n\n        }\n\n      } else if ( (argv[i][0] == '-') && (argv[i][1] == 's') ) {\n\n        size_set = 1;\n\n      } else if ( (argv[i][0] == '-') && (argv[i][1] == 'h') ) {\n\n        hexa_only = 1;\n\n        skip_arg = 1;\n\n      }\n\n      if (skip_arg == 0) {\n\n        strcat (tcpdump_arg, \" \");\n\n        strcat (tcpdump_arg, argv[i]);\n\n      }\n\n    }\n\n\n\n    if (interface_name[0] == '\\0') {\n\n      strcpy (interface_name, \"tu0\");\n\n    }\n\n\n\n    strcpy (pfconfig_cmd_up, pfconfig);\n\n    strcpy (pfconfig_cmd_down, pfconfig_cmd_up);\n\n    strcat (pfconfig_cmd_up, \" +p +c \");\n\n    strcat (pfconfig_cmd_down, \" -p -c \");\n\n    strcat (pfconfig_cmd_up, interface_name);\n\n    strcat (pfconfig_cmd_down, interface_name);\n\n\n\n    strcpy (tcpdump_cmd, TCPDUMP);\n\n    if (size_set == 0) {\n\n      strcat (tcpdump_cmd, \" -s 1514\");\n\n    }\n\n    strcat (tcpdump_cmd, tcpdump_arg);\n\n\n\n    if (hexa_only == 0) {\n\n      /* /usr/sbin/tcpdump | myself -a */\n\n      strcat (tcpdump_cmd, \" | \");\n\n      strcat (tcpdump_cmd, argv[0]);\n\n      strcat (tcpdump_cmd, \" -a\");\n\n    }\n\n\n\n    /* Do it */\n\n    if (pfconfig[0] != '\\0') {\n\n      fprintf (stderr, \"%s\\n\", pfconfig_cmd_up);\n\n      system (pfconfig_cmd_up);\n\n    }\n\n\n\n    fprintf (stderr, \"%s\\n\", tcpdump_cmd);\n\n    fflush(stderr);\n\n    system (tcpdump_cmd);\n\n\n\n    if (pfconfig[0] != '\\0') {\n\n      fprintf (stderr, \"%s\\n\", pfconfig_cmd_down);\n\n      system (pfconfig_cmd_down);\n\n    }\n\n\n\n  } else {\n\n    /* Myself -a : take standard tcpdump traces as input and */\n\n    /* Add ascii dump of messages */\n\n\n\n    /* Ignore signal INT */\n\n    signal (SIGINT, SIG_IGN);\n\n\n\n    /* Current day */\n\n    day = get_day();\n\n    prev_hour = -1;\n\n\n\n    /* Each line */\n\n    for (;;) {\n\n      i = 0;\n\n      c = get_char();\n\n      if ( (c == ' ') || (c == TAB) ) {\n\n        /* First char is tab, skip all tab, print 5 spaces */\n\n        do {\n\n          c = get_char();\n\n        } while ( (c == ' ') || (c == TAB) );\n\n        (void) printf (\"     \");\n\n        /* Dump and store the exa */\n\n        do {\n\n          buffer[i] = c;\n\n          i++;\n\n          (void) putchar(c);\n\n          c = get_char();\n\n        } while (c != LF);\n\n        /* Dump the ascii corresponding ascii */\n\n        buffer[i] = '\\0';\n\n        /* Pad end of exa line with spaces */\n\n        while (i < 44) {\n\n          (void) putchar(' ');\n\n          i++;\n\n        }\n\n        (void) printf (\"->     \");\n\n        i = 0;\n\n        for (;;) {\n\n          c1 = buffer[i];\n\n          i++;\n\n          c2 = buffer[i];\n\n          i++;\n\n          if (isdigit(c1)) {\n\n            d = (int) (c1 - '0');\n\n          } else {\n\n            d = (int) (c1 - 'a') + 10;\n\n          }\n\n          d = d * 16;\n\n          if (isdigit(c2)) {\n\n            d = d + (int) (c2 - '0');\n\n          } else {\n\n            d = d + (int) (c2 - 'a') + 10;\n\n          }\n\n          c = (char)d;\n\n          if ( (c >= ' ') && (c <= '~') ) {\n\n            (void) putchar ((char)d);\n\n          } else {\n\n            (void) putchar ('.');\n\n          }\n\n          /* Here, there is a space or '\\0' */\n\n          if (buffer[i] == '\\0') {\n\n            /* End of bufferd line */\n\n            break;\n\n          }\n\n          if (buffer[i] == ' ') {\n\n            /* Skip space */\n\n            i++;\n\n          }\n\n        }\n\n\n\n        (void) putchar(LF);\n\n      } else {\n\n        /* Line does not start with space, copy it */\n\n        i = 0;\n\n        while (c != LF) {\n\n          buffer[i] = c;\n\n          c = get_char();\n\n          i++;\n\n        }\n\n        buffer[i] = '\\0';\n\n\n\n        sscanf (buffer, \"%2d\", &hour);\n\n        if ( (prev_hour >= 18) && (hour <= 6) ) {\n\n          day = get_day();\n\n        }\n\n        prev_hour = hour;\n\n        printf (\"%02d-%s\\n\", day, buffer);\n\n      }\n\n    }\n\n    (void) putchar(LF);\n\n\n\n  }\n\n  exit(0);\n\n}\n\n\n", "#include <sys/types.h>\n\n#include <sys/stat.h>\n\n#include <sys/param.h>\n\n#include <sys/procfs.h>\n\n#include <sys/ioctl.h>\n\n#include <fcntl.h>\n\n#include <strings.h>\n\n#include <time.h>\n\n#include <stdio.h>\n\n#include <stdlib.h>\n\n#include <unistd.h>\n\n#include <string.h>\n\n\n\n\n\n#include \"rusage.h\"\n\n\n\n/* Is the dump_rusage function already installed */\n\nstatic int rusage_installed = 0;\n\n/* File where file_block are written */\n\nstatic FILE *rusage_file = (FILE*) NULL;\n\n\n\n#ifdef alpha\n\n/* Fd of our entry in /proc */\n\nstatic int my_fd = -1;\n\n#endif\n\n\n\n\n\n/* Handler of RUSAGE_SIG signal */\n\n\n\n#ifdef __STDC__\n\n/*ARGSUSED*/\n\nstatic void signal_rusage (int sig)\n\n#else\n\nstatic void signal_rusage (sig)\n\nint sig;\n\n#endif\n\n{\n\n  char str [30];\n\n  sprintf (str, \"Signal %d\", sig);\n\n  dump_rusage_str (str);\n\n}\n\n\n\n/* Inititialises the dump_rusage function */\n\n/* Returns : RUSAGE_OK if success; RUSAGE_ERROR otherwise */\n\n#ifdef __STDC__\n\nint init_rusage(void)\n\n#else\n\nint init_rusage()\n\n#endif /* __STDC__ */\n\n{\n\n\n\n  /* Hook dump_rusage signal handler on RUSAGE_SIG signal */\n\n  if (signal (RUSAGE_SIG, signal_rusage) == SIG_ERR) {\n\n    return (RUSAGE_ERROR);\n\n  } else {\n\n    return (RUSAGE_OK);\n\n  }\n\n\n\n}\n\n\n\n#ifdef __STDC__\n\nstatic int open_file(void)\n\n#else\n\nstatic int open_file()\n\n#endif /* __STDC__ */\n\n{\n\n  /* Pid image on 5 digits */\n\n  pid_t my_pid;\n\n\n\n  char hostname[MAXHOSTNAMELEN];\n\n  char file_name [255];\n\n\n\n  if (rusage_installed != 0) return rusage_installed;\n\n\n\n  /* Get pid */\n\n  my_pid = getpid();\n\n\n\n#ifdef alpha\n\n  /* Open /proc/<pid> */\n\n  {\n\n    char proc_name[255];\n\n    sprintf (proc_name, \"/proc/%05d\", my_pid);\n\n    my_fd = open(proc_name, O_RDONLY, 0);\n\n  }\n\n#endif\n\n\n\n  /* Build file name : \"rusage_HOSTNAME_PID\" */\n\n  if (gethostname(hostname, sizeof(hostname)) != 0) {\n\n    return (RUSAGE_ERROR);\n\n  }\n\n  (void) sprintf (file_name, \"rusage_%s_%05d\", hostname, my_pid);\n\n\n\n  /* Open file */\n\n  rusage_file = fopen(file_name, \"w\");\n\n  if (rusage_file == (FILE*)NULL) {\n\n    /* Failed */\n\n    rusage_installed = -1;\n\n  } else {\n\n    /* Done OK */\n\n    rusage_installed = 1;\n\n  }\n\n  return rusage_installed;\n\n}\n\n\n\n#ifdef __STDC__\n\n/*ARGSUSED*/\n\nvoid dump_rusage (void)\n\n#else\n\nvoid dump_rusage ()\n\n#endif\n\n{\n\n  dump_rusage_str(NULL);\n\n}\n\n\n\n#ifdef __STDC__\n\n/*ARGSUSED*/\n\nvoid dump_rusage_str (const char *str)\n\n#else\n\nvoid dump_rusage_str (str)\n\nchar *str;\n\n#endif\n\n{\n\n\n\n  file_block block;\n\n\n\n  /* One check on the status of the file on normal execution (file open) */\n\n  if (open_file() != 1) {\n\n    /* Failure in opening file. No action. */\n\n    return;\n\n  }\n\n\n\n  /* Get time and rusage */\n\n  gettimeofday (&block.time, NULL);\n\n  getrusage(RUSAGE_SELF, &block.usage);\n\n\n\n#ifdef alpha\n\n  /* Get virtual size */\n\n  {\n\n    struct prpsinfo procinfo;\n\n    block.pr_size = -1;\n\n    if (my_fd != -1) {\n\n      if (ioctl(my_fd, PIOCPSINFO, &procinfo) != -1) {\n\n        block.pr_size = procinfo.pr_size;\n\n      }\n\n    }\n\n  }\n\n#else\n\n  block.pr_size = 0;\n\n#endif\n\n\n\n  if (str == NULL) {\n\n    block.msg[0] = '\\0';\n\n  } else {\n\n    strncpy (block.msg, str, RU_USER_MSG_SIZE-1);\n\n    block.msg[RU_USER_MSG_SIZE-1] =  '\\0';\n\n  }\n\n\n\n  /* Write file_block on file */\n\n  (void) fwrite ((void*)&block, sizeof(file_block), 1, rusage_file);\n\n  (void) fflush (rusage_file);\n\n}\n\n\n\n\n\n\n", "/* Analyser of rusage dumps */\n\n\n\n#include <time.h>\n\n#include <stdio.h>\n\n#include <unistd.h>\n\n#include <sys/types.h>\n\n#include <strings.h>\n\n#include <stdlib.h>\n\n#include <string.h>\n\n\n\n#include \"rusage.h\"\n\n\n\n/* Computes the difference between 2 times : td = t2 - t1 */\n\n#ifdef __STDC__\n\nstatic void delta (struct timeval *t1, struct timeval *t2, struct timeval *td)\n\n#else\n\nstatic void delta (t1, t2, td)\n\n  struct timeval *t1, *t2, *td;\n\n#endif\n\n{\n\n  td->tv_sec = t2->tv_sec - t1->tv_sec;\n\n  td->tv_usec = t2->tv_usec - t1->tv_usec;\n\n\n\n  if (td->tv_usec < 0) {\n\n    td->tv_usec += 1000000;\n\n    (td->tv_sec)--;\n\n  }\n\n}\n\n\n\n/* Computes the sum of 2 times : ts = t1 + t2 */\n\n#ifdef __STDC__\n\nstatic void sum (struct timeval *t1, struct timeval *t2, struct timeval *ts)\n\n#else\n\nstatic void sum (t1, t2, ts)\n\n  struct timeval *t1, *t2, *ts;\n\n#endif\n\n{\n\n  ts->tv_sec = t1->tv_sec + t2->tv_sec;\n\n  ts->tv_usec = t1->tv_usec + t2->tv_usec;\n\n\n\n  if (ts->tv_usec > 1000000) {\n\n    ts->tv_usec -= 1000000;\n\n    (ts->tv_sec)++;\n\n  }\n\n}\n\n\n\n/* Converts a time in a float */\n\n#ifdef __STDC__\n\nstatic float to_float (struct timeval *time_ptr)\n\n#else\n\nstatic float to_float (time_ptr)\n\n   struct timeval *time_ptr;\n\n#endif\n\n{\n\n  float f;\n\n\n\n  f = (float)time_ptr->tv_sec + (float) time_ptr->tv_usec / 1000000.0;\n\n  return (f);\n\n}\n\n\n\n/* Anal_rusage */\n\n#ifdef __STDC__\n\nint main (int argc, char **argv)\n\n#else\n\nint main ( argc, argv)\n\nint argc;\n\nchar *argv[];\n\n#endif\n\n{\n\n\n\n  /* File and block to read */\n\n  FILE *file;\n\n  size_t n_read;\n\n  file_block block, old_block;\n\n\n\n  /* String of the date returned by ctime : day_name month day hours:min:sec year*/\n\n  char *date;\n\n  /* String of the date printed : year month day hours:min:sec */\n\n  char printed_date [133];\n\n\n\n  /* Delta with previous record */\n\n  struct timeval delta_time;\n\n  /* Delta with previous record */\n\n  float time_delta = 0.0;\n\n  /* Sum of user and system cpu times */\n\n  struct timeval sum_time;\n\n  float total_cpu;\n\n  float val_delta1 = 0.0, val_delta2 = 0.0, val_percent1, val_percent2;\n\n  int i_delta;\n\n\n\n  int i;\n\n\n\n  /* Must be launched with file_name as argument */\n\n  if (argc != 2) {\n\n    (void) printf (\"Usage : anal_usage file_name\\n\");\n\n    exit (1);\n\n  }\n\n\n\n  /* open file */\n\n  file = fopen (argv[1], \"r\");\n\n  if (file == (FILE*) NULL) {\n\n    (void) printf (\"Error. Can't open file %s.\\n\", argv[1]);\n\n    exit (1);\n\n  }\n\n\n\n\n\n  /* read blocks */\n\n  for (i=1; 1; i++) {\n\n    n_read = fread ((void*)&block, sizeof(file_block), 1, file);\n\n    if (n_read != 1) {\n\n        break;\n\n    }\n\n\n\n    /* Convert time structure in a string */\n\n    date = ctime (&(block.time.tv_sec) );\n\n    /* Printed_date[0..3] <- year */\n\n    (void) strncpy (&(printed_date[0]), &(date[20]), 4);\n\n    printed_date[4] = ' ';\n\n    /* Printed_date[5..19] <- month  day time */\n\n    (void) strncpy (&(printed_date[5]), &(date[4]), 15);\n\n    printed_date[20] = '\\0';\n\n\n\n    /* Title of the record, number and time stamp */\n\n    (void) printf (\"\\nResources usage record no %09d at %s.%06d\\n\", i, printed_date,\n\n                   (int)block.time.tv_usec);\n\n    if (block.msg[0] != '\\0') {\n\n      (void) printf(\"%s\\n\", block.msg);\n\n    }\n\n    (void) printf (  \"------------------------------------------------------------------\\n\");\n\n    if ( i != 1 ) {\n\n      /* Time between this record and previous one */\n\n      delta (&old_block.time, &block.time, &delta_time);\n\n\n\n      if ((delta_time.tv_sec == 0) && (delta_time.tv_usec == 0)) {\n\n        delta_time.tv_usec = 1;\n\n      }\n\n\n\n      time_delta = to_float(&delta_time);\n\n      (void) printf (\"Previous record was %9.6f sec ago.\\n\", time_delta);\n\n    }\n\n\n\n    /* Total CPU consumption */\n\n    sum (&block.usage.ru_utime, &block.usage.ru_stime, &sum_time);\n\n    total_cpu = to_float (&sum_time);\n\n\n\n    /* Memory sizes */\n\n    if (block.pr_size != -1) {\n\n      (void) printf (\"Virtual size            (8K page) %9ld\", block.pr_size);\n\n      if ( i != 1 ) {\n\n        (void) printf (\"    delta %9ld\", (block.pr_size - old_block.pr_size));\n\n      }\n\n      (void) printf (\"\\n\");\n\n    }\n\n\n\n    /* @@@ This one is in kb on DG, in pages on SUN an on DEC !!! */\n\n    (void) printf (\"Max resident set size   (8K page) %9ld\\n\", block.usage.ru_maxrss);\n\n    (void) printf (\"Integral shared text  size (kb.s) %9ld\", block.usage.ru_ixrss);\n\n    (void) printf (\"                          average  %10.3f\\n\", (float) block.usage.ru_ixrss / total_cpu);\n\n    /* @@@ This one is not on DG nor SUN */\n\n#ifdef linux\n\n    (void) printf (\"Integral shared mem   size (kb.s) %9ld\", block.usage.ru_ixrss);\n\n    (void) printf (\"                          average  %10.3f\\n\", (float) block.usage.ru_ixrss / total_cpu);\n\n#endif\n\n    (void) printf (\"Integral        data  size (kb.s) %9ld\", block.usage.ru_idrss);\n\n    (void) printf (\"                          average  %10.3f\\n\", (float) block.usage.ru_idrss / total_cpu);\n\n    (void) printf (\"Integral        stack size (kb.s) %9ld\", block.usage.ru_isrss);\n\n    (void) printf (\"                          average  %10.3f\\n\", (float) block.usage.ru_isrss / total_cpu);\n\n\n\n    /* Page faults and swapp */\n\n    (void) printf (\"Number of page faults without IO  %9ld\", block.usage.ru_minflt);\n\n    if ( i != 1 ) {\n\n      i_delta = block.usage.ru_minflt - old_block.usage.ru_minflt;\n\n      (void) printf (\"    delta %9d       average  %11.6f /s\", i_delta, (float) i_delta / time_delta);\n\n    }\n\n    (void) printf (\"\\n\");\n\n\n\n    (void) printf (\"Number of page faults with    IO  %9ld\", block.usage.ru_majflt);\n\n    if ( i != 1 ) {\n\n      i_delta = block.usage.ru_majflt - old_block.usage.ru_majflt;\n\n      (void) printf (\"    delta %9d       average  %11.6f /s\", i_delta, (float) i_delta / time_delta);\n\n    }\n\n    (void) printf (\"\\n\");\n\n\n\n    (void) printf (\"Number of swaps ................  %9ld\", block.usage.ru_nswap);\n\n    if ( i != 1 ) {\n\n      i_delta = block.usage.ru_nswap - old_block.usage.ru_nswap;\n\n      (void) printf (\"    delta %9d       average  %11.6f /s\", i_delta, (float) i_delta / time_delta);\n\n    }\n\n    (void) printf (\"\\n\");\n\n\n\n    /* System inputs / outputs */\n\n    (void) printf (\"Number of file system  inputs ..  %9ld\", block.usage.ru_inblock);\n\n    if ( i != 1 ) {\n\n      i_delta = block.usage.ru_inblock - old_block.usage.ru_inblock;\n\n      (void) printf (\"    delta %9d       average  %11.6f /s\", i_delta, (float) i_delta / time_delta);\n\n    }\n\n    (void) printf (\"\\n\");\n\n\n\n    (void) printf (\"Number of file system outputs ..  %9ld\", block.usage.ru_oublock);\n\n    if ( i != 1 ) {\n\n      i_delta = block.usage.ru_oublock - old_block.usage.ru_oublock;\n\n      (void) printf (\"    delta %9d       average  %11.6f /s\", i_delta, (float) i_delta / time_delta);\n\n    }\n\n    (void) printf (\"\\n\");\n\n\n\n    /* Messages sent received */\n\n    (void) printf (\"Number of messages sent ........  %9ld\", block.usage.ru_msgsnd);\n\n    if ( i != 1 ) {\n\n      i_delta = block.usage.ru_msgsnd - old_block.usage.ru_msgsnd;\n\n      (void) printf (\"    delta %9d       average  %11.6f /s\", i_delta, (float) i_delta / time_delta);\n\n    }\n\n    (void) printf (\"\\n\");\n\n\n\n    (void) printf (\"Number of messages received ....  %9ld\", block.usage.ru_msgrcv);\n\n    if ( i != 1 ) {\n\n      i_delta = block.usage.ru_msgrcv - old_block.usage.ru_msgrcv;\n\n      (void) printf (\"    delta %9d       average  %11.6f /s\", i_delta, (float) i_delta / time_delta);\n\n    }\n\n    (void) printf (\"\\n\");\n\n\n\n    /* Signal delivered */\n\n    (void) printf (\"Number of signals delivered ....  %9ld\", block.usage.ru_nsignals);\n\n    if ( i != 1 ) {\n\n      i_delta = block.usage.ru_nsignals - old_block.usage.ru_nsignals;\n\n      (void) printf (\"    delta %9d       average  %11.6f /s\", i_delta, (float) i_delta / time_delta);\n\n    }\n\n    (void) printf (\"\\n\");\n\n\n\n    (void) printf (\"Number of voluntary switches ...  %9ld\", block.usage.ru_nvcsw);\n\n    if ( i != 1 ) {\n\n      i_delta = block.usage.ru_nvcsw - old_block.usage.ru_nvcsw;\n\n      (void) printf (\"    delta %9d       average  %11.6f /s\", i_delta, (float) i_delta / time_delta);\n\n    }\n\n    (void) printf (\"\\n\");\n\n\n\n    /* Context switches */\n\n    (void) printf (\"Number of switches due prio/slice %9ld\", block.usage.ru_nivcsw);\n\n    if ( i != 1 ) {\n\n      i_delta = block.usage.ru_nivcsw - old_block.usage.ru_nivcsw;\n\n      (void) printf (\"    delta %9d       average  %11.6f /s\", i_delta, (float) i_delta / time_delta);\n\n    }\n\n    (void) printf (\"\\n\");\n\n\n\n    (void) printf (\"User time ................ %9ld.%06d s\", block.usage.ru_utime.tv_sec,\n\n                                                            (int)block.usage.ru_utime.tv_usec);\n\n    if ( i != 1 ) {\n\n      val_delta1 = to_float(&block.usage.ru_utime) - to_float(&old_block.usage.ru_utime);\n\n      val_percent1 = val_delta1 / time_delta * 100.0;\n\n      (void) printf (\"  delta %11.6f s  percentage %10.6f %%\", val_delta1, val_percent1);\n\n    }\n\n    (void) printf (\"\\n\");\n\n\n\n    /* System and user time */\n\n    (void) printf (\"Sys  time ................ %9ld.%06d s\", block.usage.ru_stime.tv_sec,\n\n                                                            (int)block.usage.ru_stime.tv_usec);\n\n    if ( i != 1 ) {\n\n      val_delta2 = to_float(&block.usage.ru_stime) - to_float(&old_block.usage.ru_stime);\n\n      val_percent2 = val_delta2 / time_delta * 100.0;\n\n      (void) printf (\"  delta %11.6f s  percentage %10.6f %%\",  val_delta2, val_percent2);\n\n    }\n\n    (void) printf (\"\\n\");\n\n\n\n    /* Total CPU time */\n\n    (void) printf (\"                           ------------------\");\n\n    if ( i != 1 ) {\n\n      (void) printf (\"        -------------             ------------\");\n\n    }\n\n    (void) printf (\"\\n\");\n\n\n\n    sum (&block.usage.ru_utime, &block.usage.ru_stime, &sum_time);\n\n    (void) printf (\"Total cpu time ........... %9ld.%06d s\", sum_time.tv_sec, (int)sum_time.tv_usec);\n\n    if ( i != 1 ) {\n\n      (void) printf (\"  delta %11.6f s  percentage %10.6f %%\\n\",\n\n       val_delta1 + val_delta2, (val_delta1 + val_delta2) / time_delta * 100.0);\n\n    }\n\n    (void) printf (\"\\n\");\n\n\n\n    /* Store current data as old, for deltas of next record */\n\n    bcopy ((char *)&block, (char *)&old_block, sizeof(file_block));\n\n  }\n\n\n\n  (void) printf (\"\\nDone.\\n\");\n\n  fclose (file);\n\n  exit (0);\n\n}\n\n\n", "\n\n#ifndef __RUSAGE_H__\n\n#define __RUSAGE_H__ 1\n\n\n\n#include <sys/time.h>\n\n#include <sys/resource.h>\n\n#include <signal.h>\n\n\n\n/* Signal which makes the rusage to be dumped */\n\n# define RUSAGE_SIG SIGXFSZ\n\n\n\n/* Result */\n\n#define RUSAGE_OK        0\n\n#define RUSAGE_ERROR    -1\n\n\n\n#ifdef __STDC__\n\n\n\n/* First call to initialise the rusage procedure */\n\n/* Need to be called once before call to dump_rusage */\n\n/* Returns RUSAGE_OK, or RUSAGE_ERROR. */\n\nextern int init_rusage(void);\n\n\n\n/* Call to dump a record. */\n\n/* init_rusage must have been called first */\n\nextern void dump_rusage(void);\n\n\n\nextern void dump_rusage_str(const char *);\n\n\n\n#else /* !__STDC__ */\n\n\n\nextern int init_rusage();\n\nextern void dump_rusage();\n\nextern void dump_rusage_str();\n\n\n\n#endif /* __STDC__ */\n\n\n\n/* Structure dumped in the file \"rusage_PID\" */\n\n/* At each time the RUSAGE_SIG signal is received */\n\n/* and to be read by anal_rusage program */\n\n\n\n#define RU_USER_MSG_SIZE 128\n\n\n\ntypedef struct {\n\n  struct timeval time;\n\n  struct rusage  usage;\n\n  long   pr_size;\n\n  char   msg[RU_USER_MSG_SIZE];\n\n} file_block;\n\n\n\n#endif /* __RUSAGE_H__ */\n\n\n", "#include <stdio.h>\n\n#include <stdlib.h>\n\n#include <unistd.h>\n\n\n\n#include \"rusage.h\"\n\n\n\nint main (void) {\n\n\n\n  int i;\n\n\n\n  if (init_rusage() != RUSAGE_OK) {\n\n    fprintf (stderr, \"Cannot init rusage\\n\");\n\n    exit (1);\n\n  }\n\n\n\n\n\n  for (;;)  {\n\n     dump_rusage_str (\"Call\");\n\n     for (i=1; i< 10000; i++)\n\n        (void) malloc(1 * 1024 * 1024);\n\n     (void) sleep (1) ;\n\n  }\n\n\n\n}\n\n\n", "#include <errno.h>\n\n\n\n#include \"get_line.h\"\n\n\n\n/* Reads at most len chars from FILE (stdin if FILE=NULL) */\n\n/*  or until EOL (return) is entered. */\n\n/* The out string is always terminated by \"\\n\\0\" */\n\n/* Returns the strlen of str if OK */\n\n/* It returns 0 if EOF or error */\n\nextern unsigned int get_text (FILE *file, char *str,\n\n                              const unsigned int len) {\n\n    unsigned int u;\n\n    char c;\n\n\n\n    errno = 0;\n\n\n\n    if (len <= 0) return (0);\n\n\n\n\n\n    /* Read line */\n\n    u = 0;\n\n    do {\n\n        if (u >= len - 1) {\n\n          /* End of buffer */\n\n          break;\n\n        }\n\n        /* Read char */\n\n        if (file == (FILE*)NULL) {\n\n            c = (char) getchar();\n\n        } else {\n\n            c = (char) fgetc(file);\n\n        }\n\n        if ((int)c == EOF) {\n\n            /* Error or end of file */\n\n            break;\n\n        } else {\n\n            str[u] = c;\n\n            u++;\n\n        }\n\n\n\n    } while (c != EOL);\n\n\n\n    str[u] = NUL;\n\n    return (u);\n\n}\n\n\n\n/* Reads at most len chars from FILE (stdin if FILE=NULL) */\n\n/*  or until Cr (return) is entered. */\n\n/* The out string is always NUL terminated (Cr removed) */\n\n/* Returns the strlen of str if OK */\n\n/* It returns -1 if EOF or error */\n\nint get_line (FILE *file, char *str, const int len) {\n\n\n\n    int i;\n\n    char c;\n\n\n\n    errno = 0;\n\n\n\n    if (len <= 0) return (0);\n\n\n\n    str[0] = NUL;\n\n\n\n    /* Read line */\n\n    i = -1;\n\n    do {\n\n        i ++;\n\n        if (i >= len - 1) {\n\n          /* End of buffer */\n\n          str[i] = NUL;\n\n          break;\n\n        }\n\n        /* Read char */\n\n        if (file == (FILE*)NULL) {\n\n            c = (char) getchar();\n\n        } else {\n\n            c = (char) fgetc(file);\n\n        }\n\n        if ((int)c == EOF) {\n\n            /* Error or end of file */\n\n            return (-1);\n\n        } else if (c == EOL) {\n\n            /* End of line */\n\n            str[i] = NUL;\n\n        } else {\n\n            str[i] = c;\n\n        }\n\n\n\n    } while (str[i] != NUL);\n\n\n\n\n\n    return (i);\n\n\n\n}\n\n\n", "#ifndef __GET_LINE__\n\n#define __GET_LINE__\n\n\n\n/* INCLUDE FILES */\n\n/*****************/\n\n#include <stdio.h>\n\n\n\n#define NUL '\\0'\n\n#define EOL '\\n'\n\n\n\n/* Reads at most len chars from FILE (stdin if FILE=NULL) */\n\n/*  or until EOL (return) is entered. */\n\n/* The out string is always NUL terminated */\n\n/* Returns the strlen of str if OK */\n\n/* It returns -1 if EOF or error */\n\nextern int get_line (FILE *file, char *str, const int len);\n\n\n\n/* Reads at most len chars from FILE (stdin if FILE=NULL) */\n\n/*  or until EOL (return) is entered. */\n\n/* The out string is always NUL terminated */\n\n/* Returns the strlen of str */\n\n/* Reads characters up to a New_Line (that is appended) */\n\n/*  or up to the end of file. */\n\n/*  So, either the returned string ends with a New_Line and */\n\n/*   another get can be performed, */\n\n/*  Or the string does not end with New_Line (or is empty) and */\n\n/*   the end of file has been reached or an error has occured. */\n\nextern unsigned int get_text (FILE *file, char *str,\n\n                              const unsigned int len);\n\n\n\n#endif /* _GET_LINE */\n\n\n", "#include <sys/types.h>\n\n#include <sys/stat.h>\n\n#include <stdio.h>\n\n#include <stdlib.h>\n\n#include <string.h>\n\n\n\n#include \"vt100.h\"\n\n\n\nvoid clrscr (void) {\n\n  char chaine[5];\n\n\n\n  strcpy(chaine,\" [2J\");\n\n  chaine[0]=27;\n\n  printf(\"%s\",chaine);\n\n  gotoxy (0, 0);\n\n}\n\n\n\nvoid gotoxy (int x, int y) {\n\n  char chaine2[15];\n\n\n\n  strcpy(chaine2,\" [  ;  H\");\n\n  chaine2[0]=27;\n\n  chaine2[2]='0'+x/10;\n\n  chaine2[3]='0'+x%10;\n\n  chaine2[5]='0'+y/10;\n\n  chaine2[6]='0'+y%10;\n\n  printf(\"%s\",chaine2);\n\n}\n\n\n\nvoid open_keybd (void) {\n\n  system(\"stty -echo raw\");\n\n}\n\n\n\nvoid close_keybd (void) {\n\n  system(\"stty echo -raw\");\n\n}\n\n\n\n#define cprintf printf\n\n\n\nvoid highvideo (void) {\n\n  char chaine[9];\n\n\n\n  strcpy(chaine ,\" [1m\");\n\n  chaine[0]=27;\n\n  printf(\"%s\",chaine);\n\n}\n\n\n\nvoid lowvideo (void) {\n\n  char chaine[9];\n\n\n\n  strcpy(chaine ,\" [0m\");\n\n  chaine[0]=27;\n\n  printf(\"%s\",chaine);\n\n}\n\n\n\nlong long filelength (int fd) {\n\n  struct stat buf;\n\n\n\n  fstat(fd, &buf);\n\n  return ((long long) buf.st_size);\n\n}\n\n\n\n\n\n\n\nstatic char escape_sequence (void) {\n\n  int car;\n\n\n\n  car = getchar();\n\n\n\n  switch (car) {\n\n    case 0x5b:\n\n      /* Esc [ */\n\n      car = getchar();\n\n      switch (car) {\n\n        case 'A':    /* Arrow up    */\n\n          return 1;  /* Arrow up    */\n\n        case 'C':    /* Arrow right */\n\n          return 2;  /* Arrow right */\n\n        case 'B':    /* Arrow down  */\n\n          return 3;  /* Arrow down  */\n\n        case 'D':    /* Arrow left  */\n\n          return 4;  /* Arrow left  */\n\n        default :\n\n          return 0;\n\n    }\n\n    case 'A':        /* Esc A       */\n\n    case 'a':        /* Esc a       */\n\n      return 20;     /* Begin file  */\n\n    case 'Z':        /* Esc Z       */\n\n    case 'z':        /* Esc z       */\n\n      return 19;     /* End file    */\n\n    case 'H':        /* Esc H       */\n\n    case 'h':        /* Esc h       */\n\n      return 10;     /* Home        */\n\n    case 'E':        /* Esc E       */\n\n    case 'e':        /* Esc e       */\n\n      return 11;     /* End         */\n\n    case 'F':        /* Esc F       */\n\n    case 'f':        /* Esc f       */\n\n      return 15;     /* Find        */\n\n    case 'P':        /* Esc P       */\n\n    case 'p':        /* Esc p       */\n\n      return 16;     /* Goto page   */\n\n    case 'S':        /* Esc S       */\n\n    case 's':        /* Esc s       */\n\n      return 17;     /* Write       */\n\n    case 'U':        /* Esc U       */\n\n    case 'u':        /* Esc u       */\n\n      return 23;     /* Write       */\n\n    case 'X':        /* Esc X       */\n\n    case 'x':        /* Esc x       */\n\n      return 18;     /* Exit        */\n\n    case 'C':        /* Esc C       */\n\n    case 'c':        /* Esc c       */\n\n      return 21;     /* Exit        */\n\n    case 'Q':        /* Esc C       */\n\n    case 'q':        /* Esc c       */\n\n      return 22;     /* Exit        */\n\n    case 0x1B:       /* Escape      */\n\n      return 0x1B;   /* New escape  */\n\n    default :\n\n      return 0;\n\n   }\n\n}\n\n\n\nchar read_char (void) {\n\n  int car;\n\n\n\n  for (;;) {\n\n    car = getchar();\n\n    if ( (car > 0x1F) && (car < 0x7F) ) return car;\n\n    switch (car) {\n\n      case 0x7F:     /* Backspace  */\n\n      case 0x08:     /* Backspace  */\n\n        return 8;    /* Backspace  */\n\n      case 0x10:     /* Ctrl P     */\n\n        return 5;    /* Pg up      */\n\n      case 0x0E:     /* Ctrl N     */\n\n        return 6;    /* Pg down    */\n\n      case 0x09:     /* Tab        */\n\n        return 9;    /* Tab        */\n\n      case 0x0D:     /* Return     */\n\n        return 13;   /* Return     */\n\n      case 0x1B:     /* Esc        */\n\n        while (1) {\n\n          car = escape_sequence();\n\n          if (car == 0x00) break;\n\n          else if (car != 0x1B) return car;\n\n        }\n\n    }\n\n  }\n\n}\n\n\n\nvoid beep (unsigned char nb_beeps,\n\n           unsigned int frequency __attribute__ ((unused))) {\n\n  int i;\n\n\n\n  for (i = 1; i <= nb_beeps; i++) {\n\n    putchar ((int) 0x07);\n\n\n\n  }\n\n}\n\n\n", "void clrscr (void);\n\n\n\nvoid gotoxy (int x, int y);\n\n\n\nvoid open_keybd (void);\n\n\n\nvoid close_keybd (void);\n\n\n\n#define cprintf printf\n\n\n\nvoid highvideo (void);\n\nvoid lowvideo (void);\n\n\n\nlong long filelength (int fd);\n\n\n\nchar read_char (void);\n\n\n\nvoid beep (unsigned char nb_beeps, unsigned int frequency);\n\n\n", "#include <stdio.h>\n\n#include <string.h>\n\n#include <stdlib.h>\n\n\n\n#define ERROR {printf (\"ERROR. Usage %s [ -l | -U ] [ <msg> ]\\n\", argv[0]);\\\n\n               exit (1); }\n\n\n\nint main (int argc, char *argv[]) {\n\nint i, j;\n\nchar rep[256];\n\nchar *msg;\n\nint to_up, to_lo;\n\n\n\n    to_up = 0;\n\n    to_lo = 0;\n\n    msg = NULL;\n\n    if (argc == 1) {\n\n      ;\n\n    } else if (argc == 2) {\n\n      if (strcmp(argv[1], \"-l\") == 0) {\n\n        to_lo = 1;\n\n      } else if (strcmp(argv[1], \"-U\") == 0) {\n\n        to_up = 1;\n\n      } else {\n\n        msg = argv[1];\n\n      }\n\n    } else if (argc == 3) {\n\n      msg = argv[2];\n\n      if (strcmp(argv[1], \"-l\") == 0) {\n\n        to_lo = 1;\n\n      } else if (strcmp(argv[1], \"-U\") == 0) {\n\n        to_up = 1;\n\n      } else {\n\n        ERROR;\n\n      }\n\n    } else {\n\n      ERROR;\n\n    }\n\n\n\n    if (msg != NULL) {\n\n      printf (\"%s\", msg);\n\n    }\n\n\n\n    i = 0;\n\n    for (;;) {\n\n        rep[i] = (char) getchar();\n\n        if (rep[i] == '\\n') break;\n\n        i++;\n\n    }\n\n\n\n\n\n    if (i == 0) {\n\n      i = 1;\n\n      rep[0] = '-';\n\n    }\n\n    rep[i] = '\\0';\n\n\n\n    for (j = 0; j < i; j++) {\n\n        if (to_lo) {\n\n            if ( (rep[j] >= 'A') && (rep[j] <= 'Z') ) {\n\n                rep[j] = rep[j] - 'A' + 'a';\n\n            }\n\n        } else if (to_up) {\n\n            if ( (rep[j] >= 'a') && (rep[j] <= 'z') ) {\n\n                rep[j] = rep[j] - 'a' + 'A';\n\n            }\n\n        }\n\n    }\n\n\n\n    printf (\"%s\\n\", rep);\n\n    exit(0);\n\n}\n\n\n", "#include <stdio.h>\n\n#include <stdlib.h>\n\n#include <unistd.h>\n\n#include <string.h>\n\n\n\n#include \"get_line.h\"\n\n\n\n/* Remove all <....> from a file (argv[1]). Save in <file>-ascii */\n\n/* Or read stdin and write on stdout */\n\n/* Skip all leading spaces */\n\n/* Replace each sequence if 5 spaces within line by 1 space */\n\n\n\n#define BUFFER_SIZE 1024\n\n\n\nstatic void error (const char *prog, const char *msg)\n\n                  __attribute__((noreturn));\n\nstatic void error (const char *prog, const char *msg) {\n\n  fprintf (stderr, \"ERROR: %s.\\n\", msg);\n\n  fprintf (stderr, \"Usage: %s [ <html_file> ]\\n\", prog);\n\n  exit(1);\n\n}\n\n\n\nconst char sstart[] = \"Vos Documents au format PDF:\";\n\nconst char sstop[] = \"&nbsp;\";\n\n\n\n\n\nint main (int argc, char *argv[]) {\n\n\n\n   FILE *fin, *fout;\n\n   char out_file_name[1024];\n\n   char buffer[BUFFER_SIZE];\n\n   int len;\n\n   int i, j;\n\n   int skip, sskip;\n\n   int nb_space;\n\n   int leading;\n\n   int nb_empty;\n\n\n\n   if (argc > 2) {\n\n     error (argv[0], \"invalid arguments\"); \n\n   }\n\n\n\n   if (argc == 1) {\n\n     fin = stdin;\n\n     fout = stdout;\n\n   } else {\n\n     fin = fopen (argv[1], \"r\");\n\n     if (fin == (FILE*) NULL) {\n\n       error (argv[0], \"can't open input file\");\n\n     }\n\n     strcpy (out_file_name, argv[1]);\n\n     strcat (out_file_name, \"-ascii\");\n\n     fout = fopen (out_file_name, \"w\");\n\n     if (fout == (FILE*) NULL) {\n\n       fclose (fin);\n\n       error (argv[0], \"can't create output file\");\n\n     }\n\n  }\n\n\n\n  skip = 0;\n\n  sskip = 0;\n\n  nb_empty = 0;\n\n  for (;;) {\n\n\n\n    nb_space = 0;\n\n    leading = 1;\n\n    len = get_line (fin, buffer, BUFFER_SIZE);\n\n    if (len == -1) {\n\n      break;\n\n    }\n\n    j = 0;\n\n    for (i = 0; i <= len; i++) {\n\n      if (buffer[i] == '<') {\n\n        skip = 1;\n\n      } else if (buffer[i] == '>') {\n\n        skip = 0;\n\n      } else {\n\n\n\n        if (!skip) {\n\n          /* We're out of < .. > */\n\n          /* Skip all leading spaces */\n\n          if (buffer[i] == ' ') {\n\n            if (! leading) {\n\n              /* Within line, 5 spaces become 1 space */\n\n              nb_space ++;\n\n              if (nb_space == 5) {\n\n                j -= 4;\n\n                nb_space = 0;\n\n              } \n\n            }\n\n          } else {\n\n            /* One significant character: within line, no more space */\n\n            leading = 0;\n\n            nb_space = 0;\n\n          }\n\n          if (!leading) {\n\n            if (buffer[i] == (char)0xE9) {\n\n              buffer[j] = 'e';\n\n              j++;\n\n            } else if (buffer[i] < '\\0') {\n\n              /* Skip */\n\n              ;\n\n            } else {\n\n              buffer[j] = buffer[i];\n\n              j++;\n\n            }\n\n          }\n\n        }\n\n\n\n      }\n\n    }\n\n    /* Now check super start and super stop */\n\n    if ( (sskip == 0) && (strncmp(buffer, sstart, strlen(sstart)) == 0) ) {\n\n      sskip = 1;\n\n    }\n\n    if ( (sskip == 1) && (strncmp(buffer, sstop, strlen(sstop)) == 0) ) {\n\n      sskip = 2;\n\n    }\n\n    if (sskip == 1) {\n\n      /* Only one empty line */\n\n      if (strlen(buffer) == 0) {\n\n        nb_empty ++;\n\n      } else {\n\n        nb_empty = 0;\n\n      }\n\n      if (nb_empty <= 1) {\n\n        fprintf (fout, \"%s\\n\", buffer);\n\n      }\n\n    }\n\n  }\n\n\n\n     \n\n  if (argc != 1) {\n\n   fclose (fin);\n\n   fclose (fout);\n\n  }\n\n  exit(0);\n\n}\n\n\n", "#include \"module1.h\"\n\n#include \"module2.h\"\n\n\n\nint main (void) {\n\n  func1();\n\n  func2();\n\n  return 0;\n\n}\n\n\n", "#include <stdio.h>\n\n#include \"module2.h\"\n\n\n\nextern void __init_21(void);\n\nextern void __init_22(void);\n\nextern void _init(void);\n\n\n\nextern void __init_21(void) {\n\n  printf (\"Init 21\\n\");\n\n}\n\n\n\nextern void __init_22(void) {\n\n  printf (\"Init 22\\n\");\n\n}\n\n\n\nextern void _init(void) {\n\n  printf (\"Init 2\\n\");\n\n}\n\n\n\nextern void func2(void) {\n\n  printf (\"Func 2\\n\");\n\n}\n\n\n", "\n\nextern void func2(void);\n", "\n\nextern void func1(void);\n", "#include <stdio.h>\n\n#include \"module1.h\"\n\n\n\nextern void __init_11(void);\n\nextern void __init_12(void);\n\nextern void _init(void);\n\n\n\nextern void __init_11(void) {\n\n  printf (\"Init 11\\n\");\n\n}\n\n\n\nextern void __init_12(void) {\n\n  printf (\"Init 12\\n\");\n\n}\n\n\n\nextern void _init(void) {\n\n  printf (\"Init 1\\n\");\n\n}\n\n\n\nextern void func1(void) {\n\n  printf (\"Func 1\\n\");\n\n}\n\n\n", "#include <sys/types.h>\n\n#include <sys/ipc.h>\n\n#include <sys/sem.h>\n\n#include <stdio.h>\n\n#include <stdlib.h>\n\n#include <string.h>\n\n#include <ctype.h>\n\n#include <time.h>\n\n#include <pwd.h>\n\n#include <grp.h>\n\n\n\n\n\nunion semun {\n\n  int val;\n\n  struct semid_ds *buf;\n\n  short *array;\n\n};\n\n\n\nstatic void usage(void) __attribute__ ((noreturn));\n\nstatic void usage(void) {\n\n  fprintf (stderr, \"Usage : semctl -k key [ semnum ]    or    semctl -i id [ semnum ]\\n\");\n\n  fprintf (stderr, \"   semnum is a number or b or s\\n\");\n\n  exit (2);\n\n}\n\n\n\n/* Print access rights on semaphore */\n\nstatic void print_rights (int rights, int mask_read, int mask_alter) {\n\n  if ( (rights & (mask_read | mask_alter) ) == 0 ) {\n\n    printf (\"--\");\n\n  } else {\n\n    if ( (rights & mask_read) == mask_read ) {\n\n      printf (\"r\");\n\n    } else {\n\n      printf (\" \");\n\n    }\n\n    if ( (rights & mask_alter) == mask_alter ) {\n\n      printf (\"a\");\n\n    } else {\n\n      printf (\" \");\n\n    }\n\n  }\n\n}\n\n\n\nint main (int argc, char *argv[]) {\n\n  int i;\n\n  unsigned int u;\n\n  int semid;\n\n  int semnum, nsemnum, fsemnum;\n\n  int blocked, say;\n\n  int some_wait;\n\n  union semun arg;\n\n  int val, pid, ncnt, zcnt, res, rights;\n\n  char key[3];\n\n  /* String of the date printed : year month day hours:min:sec */\n\n  char printed_date [133];\n\n  char *date;\n\n  struct passwd * pw;\n\n  struct group *  gr;\n\n\n\n  arg.buf = (struct semid_ds*) malloc (sizeof(struct semid_ds));\n\n\n\n\n\n  if ( (argc != 3) && (argc != 4) ) usage();\n\n  if (strlen(argv[1]) >= sizeof(key) ) usage();\n\n  strcpy(key, argv[1]);\n\n  for (i = 0; (unsigned)i < strlen(key); i++) {\n\n    key[i] = toupper(key[i]);\n\n  }\n\n\n\n\n\n  if ( (strcmp (key, \"-K\") != 0) &&\n\n       (strcmp (key, \"-I\") != 0) ) usage();\n\n\n\n  i = 0;\n\n  i = atoi(argv[2]);\n\n  if ( (i == 0) && (strcmp (argv[2], \"0\") != 0 ) ) {\n\n    if (strcmp (key, \"-I\") == 0) {\n\n      fprintf (stderr, \"Bad semid\\n\");\n\n      usage();\n\n    }\n\n    if ( (argv[2][0] == '0') && (argv[2][1] == 'x') ) {\n\n      if (sscanf (argv[2], \"%x\", &u) <= 0) {\n\n        fprintf (stderr, \"Bad semkey\\n\");\n\n        usage();\n\n      }\n\n      i = (int)u;\n\n    } else {\n\n      fprintf (stderr, \"Bad semkey\\n\");\n\n      usage();\n\n    }\n\n  }\n\n\n\n  if (strcmp (key, \"-K\") == 0) {\n\n    if (i == 0) {\n\n      fprintf (stderr, \"Bad semkey\\n\");\n\n      usage();\n\n    }\n\n    semid = semget ( (key_t)i, 1, 0);\n\n    if (semid == -1) {\n\n      perror (\"semget\");\n\n      fprintf (stderr, \"Cannot find sem with key %d\\n\", i);\n\n      usage();\n\n    }\n\n  } else {\n\n    semid = i;\n\n  }\n\n\n\n  if (argc == 3) {\n\n    nsemnum = -1;\n\n  } else if ( (strcmp (argv[3], \"b\") == 0)\n\n           || (strcmp (argv[3], \"B\") == 0) ) {\n\n    nsemnum = -2;\n\n  } else if ( (strcmp (argv[3], \"s\") == 0)\n\n           || (strcmp (argv[3], \"S\") == 0) ) {\n\n    nsemnum = -3;\n\n  } else if ( strcmp (argv[3], \"0\") == 0) {\n\n    nsemnum = 0;\n\n  } else {\n\n    nsemnum = atoi (argv[3]);\n\n    if (nsemnum == 0){\n\n      printf (\"Bad semnum\\n\");\n\n      usage();\n\n    }\n\n  }\n\n\n\n  res = semctl (semid, 0, IPC_STAT, arg);\n\n  if (res == -1) {\n\n    perror (\"semctl, stat\");\n\n    fprintf (stderr, \"Cannot access to sem id %d\\n\", semid);\n\n    exit(2);\n\n  }\n\n\n\n  rights =  (int) (arg.buf->sem_perm).mode;\n\n  if (nsemnum == -1) {\n\n    fsemnum = 0;\n\n    nsemnum = arg.buf->sem_nsems - 1;\n\n    blocked = 0;\n\n    say = 1;\n\n    printf (\"All on \");\n\n  } else if (nsemnum == -2) {\n\n    fsemnum = 0;\n\n    nsemnum = arg.buf->sem_nsems - 1;\n\n    blocked = 1;\n\n    say = 1;\n\n    printf (\"Blocked on \");\n\n  } else if (nsemnum == -3) {\n\n    fsemnum = 0;\n\n    nsemnum = arg.buf->sem_nsems - 1;\n\n    blocked = 1;\n\n    say = 0;\n\n  } else {\n\n    fsemnum = nsemnum;\n\n    blocked = 0;\n\n    say = 1;\n\n    printf (\"No %d of \", nsemnum);\n\n  }\n\n\n\n  if (say) {\n\n  printf (\"Semaphore \");\n\n    if (strcmp (key, \"-K\") == 0) {\n\n      printf (\"Key %d id %d, \", i, semid);\n\n    } else {\n\n      printf (\"Id %d, \", semid);\n\n    }\n\n\n\n    printf (\"num in 0 .. %ld\\n\", arg.buf->sem_nsems - 1);\n\n\n\n    pw = getpwuid((arg.buf->sem_perm).cuid);\n\n    gr = getgrgid((arg.buf->sem_perm).cgid);\n\n    printf (\"Created by %s group %s\\n\", pw->pw_name, gr->gr_name);\n\n    pw = getpwuid((arg.buf->sem_perm).uid);\n\n    gr = getgrgid((arg.buf->sem_perm).gid);\n\n    printf (\"Owned   by %s group %s\\n\", pw->pw_name, gr->gr_name);\n\n\n\n    printf (\"Access rights User : \");\n\n    print_rights (rights, 0x100, 0x80);\n\n    printf (\"   Group : \");\n\n    print_rights (rights, 0x20, 0x10);\n\n    printf (\"   Others : \");\n\n    print_rights (rights, 0x4, 0x2);\n\n    printf (\"\\n\");\n\n\n\n\n\n    printf (\"+---------------------------------------------------------------------------------------+\\n\");\n\n    printf (\"| Num | Val | LastPid |       LastDateUpdate |       LastDateChange | Nproc>0 | Nproc=0 |\\n\");\n\n    printf (\"|-----+-----+---------+----------------------+----------------------+---------+---------|\\n\");\n\n  }\n\n\n\n  some_wait = 0;\n\n  for (semnum = fsemnum; semnum <= nsemnum; semnum++) {\n\n\n\n    val = semctl (semid, semnum, GETVAL, arg);\n\n    if (val == -1) {\n\n      perror (\"semctl, getval\");\n\n      fprintf (stderr, \"Cannot access to sem id %d\\n\", semid);\n\n      exit (2);\n\n    }\n\n    pid = semctl (semid, semnum, GETPID, arg);\n\n    if (pid == -1) {\n\n      perror (\"semctl, getpid\");\n\n      fprintf (stderr, \"Cannot access to sem id %d\\n\", semid);\n\n      exit (2);\n\n    }\n\n    ncnt = semctl (semid, semnum, GETNCNT, arg);\n\n    if (ncnt == -1) {\n\n      perror (\"semctl, getncnt\");\n\n      fprintf (stderr, \"Cannot access to sem id %d\\n\", semid);\n\n      exit (2);\n\n    }\n\n    zcnt = semctl (semid, semnum, GETZCNT, arg);\n\n    if (zcnt == -1) {\n\n      perror (\"semctl, zcnt\");\n\n      fprintf (stderr, \"Cannot access to sem id %d\\n\", semid);\n\n      exit (2);\n\n    }\n\n\n\n    some_wait = some_wait || ((ncnt + zcnt) != 0);\n\n    if (  ( (!blocked) || ((ncnt + zcnt) != 0)) && say) {\n\n\n\n      printf (\"| %3d | \", semnum);\n\n      printf (\"%3d | \", val);\n\n      printf (\"%7d | \", pid);\n\n\n\n      date = ctime (&(arg.buf->sem_otime));\n\n      (void) strncpy (&(printed_date[0]), &(date[20]), 4);\n\n      printed_date[4] = ' ';\n\n      (void) strncpy (&(printed_date[5]), &(date[4]), 15);\n\n      printed_date[20] = '\\0';\n\n      printf (\"%s | \", printed_date);\n\n\n\n      date = ctime (&(arg.buf->sem_ctime));\n\n      (void) strncpy (&(printed_date[0]), &(date[20]), 4);\n\n      printed_date[4] = ' ';\n\n      (void) strncpy (&(printed_date[5]), &(date[4]), 15);\n\n      printed_date[20] = '\\0';\n\n      printf (\"%s | \", printed_date);\n\n\n\n      printf (\"%7d | \", ncnt);\n\n      printf (\"%7d |\\n\", zcnt);\n\n    }\n\n\n\n  }\n\n  if (say) printf (\"+---------------------------------------------------------------------------------------+\\n\");\n\n\n\n  if (some_wait) {\n\n    exit(1);\n\n  } else {\n\n    exit(0);\n\n  }\n\n}\n\n\n", "#include <stdio.h>\n\n#include <errno.h>\n\n#include <unistd.h>\n\n#include <stdlib.h>\n\n\n\n#include \"sem_util.h\"\n\n#include \"timeval.h\"\n\n\n\n#define KEY 0x11111\n\n\n\nint main (void) {\n\n\n\n  int id;\n\n  int wait;\n\n  timeout_t timeout;\n\n\n\n  printf (\"My pid is %d\\n\", getpid());\n\n\n\n  id = get_sem_id (KEY);\n\n\n\n  if (id != ERR) {\n\n    printf (\"Sem %d got, id %d\\n\", KEY, id);\n\n    wait = 0;\n\n  } else {\n\n    fflush(stderr);\n\n    if (create_sem_key (KEY, &id) == OK) {\n\n      printf (\"Sem %d created, id %d\\n\", KEY, id);\n\n    } else {\n\n      printf (\"sem %d creation failure. Errno %d\\n\", KEY, errno);\n\n      exit (1);\n\n    }\n\n    wait = 1;\n\n  }\n\n\n\n  if (decr_sem_id(id, FALSE) != OK) {\n\n    printf (\"Sem %d id %d decrementation failure. Errno %d\\n\", KEY, id, errno);\n\n  }\n\n\n\n  if (wait) {\n\n    for (;;) {\n\n      timeout.tv_sec = 10;\n\n      timeout.tv_usec = 0;\n\n      delay (&timeout);\n\n    }\n\n  }\n\n  exit(0);\n\n}\n\n\n", "#include <stdlib.h>\n\n#include <stdio.h>\n\n#include <string.h>\n\n#include <libgen.h>\n\n#include <sys/param.h>\n\n\n\n#include \"socket.h\"\n\n\n\nstatic void print_ip (soc_host *host, char *name) {\n\n  int i;\n\n\n\n  for (i = 0; i <= 3; i++) {\n\n    printf (\"%02X\", host->bytes[i]);\n\n  }\n\n  printf (\" <==> \");\n\n  for (i = 0; i <= 3; i++) {\n\n    printf (\"%d\", host->bytes[i]);\n\n    if (i != 3) {\n\n      printf (\".\");\n\n    }\n\n  }\n\n  printf (\" <==> \");\n\n  if (name[0] == '\\0') {\n\n    printf (\"?\");\n\n  } else {\n\n    printf (\"%s\", name);\n\n  }\n\n  printf (\"\\n\");\n\n}\n\n\n\nstatic byte b2h (char c) {\n\n  if ( (c >= '0') && (c <= '9') ) {\n\n    return c - '0';\n\n  } else if ( (c >= 'a') && (c <= 'f') ) {\n\n    return 10 + c - 'a';\n\n  } else if ( (c >= 'A') && (c <= 'F') ) {\n\n    return 10 + c - 'A';\n\n  } else {\n\n    return 0;\n\n  }\n\n}\n\n\n\nchar host_name[MAXHOSTNAMELEN];\n\n\n\nstatic void do_one (char *host_name) {\n\n  int i;\n\n  int res;\n\n  char c;\n\n  soc_host host;\n\n\n\n  /* Try with host name or ip notation */\n\n  if ( (res = soc_host_of (host_name, &host) ) == SOC_OK) {\n\n    if (soc_host_name_of (&host, host_name, sizeof(host_name)) != SOC_OK) {\n\n      /* Host not found */\n\n      host_name[0] = '\\0';\n\n    }\n\n    print_ip (&host, host_name);\n\n  } else  if (strlen (host_name) == 8) {\n\n    /* Try with 8 hexa digits */\n\n    res = 0;\n\n    for (i = 0; i < 8; i++) {\n\n      c = host_name[i];\n\n      if ( ( (c >= '0') && (c <= '9') )\n\n        || ( (c >= 'a') && (c <= 'f') )\n\n        || ( (c >= 'A') && (c <= 'F') ) ) {\n\n        ;\n\n      } else {\n\n        res = 1;\n\n      }\n\n    }\n\n    if (res == 0) {\n\n      /* Looks like a host id */\n\n      for (i = 0; i < 8; i++, i++) {\n\n        host.bytes[i/2] = (b2h(host_name[i]) * 16) + b2h(host_name[i+1]);\n\n      }\n\n      if (soc_host_name_of (&host, host_name, sizeof(host_name)) != SOC_OK) {\n\n        /* Host not found */\n\n        host_name[0] = '\\0';\n\n      }\n\n      print_ip (&host, host_name);\n\n    }  else {\n\n      fprintf (stderr, \"Invalid argument %s\\n\", host_name);\n\n    }\n\n  }\n\n}\n\n\n\nint main (int argc, char *argv[]) {\n\n\n\n  int i;\n\n  int res;\n\n\n\n  if (argc == 1) {\n\n    /* No arg => local host */\n\n    if ( (res = soc_get_local_host_name (host_name, sizeof(host_name)) ) == SOC_OK) {\n\n      do_one (host_name);\n\n    } else {\n\n      fprintf (stderr, \"soc_get_local_host_name -> %d\\n\", res);\n\n      exit (1);\n\n    }\n\n  } else if (strcmp (argv[1], \"-h\") == 0) {\n\n    printf (\"Usage: %s [ { <host_name> | <host_ip> | <host_id> } ]\\n\",\n\n            basename(argv[0]));\n\n    exit (2);\n\n  } else {\n\n    /* Dump each argument */\n\n    for (i = 1; i < argc; i++) {\n\n      do_one (argv[i]);\n\n    }\n\n  }\n\n  exit (0);\n\n}\n\n\n", "#include <fcntl.h>\n\n#include <sys/stat.h>\n\n#include <sys/types.h>\n\n#include <stdio.h>\n\n#include <stdlib.h>\n\n#include <string.h>\n\n#include <sys/param.h>\n\n#include <unistd.h>\n\n#include <errno.h>\n\n\n\n/* Read stdin (a pipe) flow and outputs it in a circular file (argv[1]) */\n\n/*  of a given size (arv[2]) */\n\n\n\n#include \"circul.h\"\n\n\n\n#define INTERNAL_BUFFER_SIZE  1024\n\nchar buffer[INTERNAL_BUFFER_SIZE];\n\n\n\n\n\nint main (int argc, char *argv[]) {\n\n\n\n  unsigned int size;\n\n  int nb_read;\n\n  struct cir_file *circul_fd = NULL;\n\n\n\n  if (argc < 2) {\n\n    fprintf (stderr, \"Syntax error. Syntax %s <circular_file_name>\"\n\n                     \" <circular_file_size>\\n\", argv[0]);\n\n    exit (1);\n\n  }\n\n\n\n  size = strtol (argv[2], NULL, 10);\n\n  if ( (size == 0) || (errno != 0) ) {\n\n    fprintf (stderr, \"Invalid size %s\\n\", argv[2]);\n\n    exit (1);\n\n  }\n\n  \n\n  /* Open output circular file */\n\n  circul_fd = cir_open(argv[1], \"w+\", size);\n\n  if (circul_fd == NULL) {\n\n    fprintf(stderr, \"Cannot open the circular file %s\\n\", argv[1]);\n\n    exit (1);\n\n  }\n\n\n\n  /* Read stdin and write circ */\n\n  for (;;) {\n\n    nb_read = read (0, buffer, sizeof(buffer));\n\n    if (nb_read > 0) {\n\n      if (cir_write (circul_fd, buffer, nb_read) == -1 ) {\n\n        fprintf(stderr, \"Failed to write in the circular file\\n\");\n\n        (void) cir_close (circul_fd);\n\n        exit (1);\n\n      }\n\n    } else if (nb_read < 0) {\n\n      perror (\"read\");\n\n      exit (1);\n\n    } else {\n\n      /* End of input */\n\n      break;\n\n    }\n\n  }\n\n\n\n  /* Close */\n\n  if (cir_close (circul_fd) == -1) {\n\n    fprintf(stderr, \"Failed to close the circular file\\n\");\n\n    exit (1);\n\n  }\n\n\n\n  /* Done */\n\n  exit (0);\n\n\n\n}\n\n\n\n\n", "#ifndef __CIRCUL_H\n\n#define __CIRCUL_H\n\n\n\n#include <stdio.h>\n\n\n\n/* The circulat file descriptor */\n\nstruct cir_file;\n\n\n\n/* The character marker of the circular limit end/start */\n\nextern char CIR_EOF;\n\n\n\n/* This routine attemps to open a \\a size byte circular file \\a\n\n * filename. The \\a mode parameter is the same as in \\c fopen(3).\n\n * \\return a pointer to an allocated \\c cir_file structure or NULL if an error\n\n * occured.\n\n * \\warning This routine performs dynamic memory allocation : don't forget to\n\n * call \\c cir_close when finished.\n\n */\n\nextern struct cir_file* cir_open(const char* filename, const char* mode,\n\n                                 unsigned int size);\n\n\n\n/* This routine closes the circular file \\a fd and free the \\c cir_file\n\n * structure.\n\n * \\return 0 or -1 if an error occured.\n\n */\n\nextern int cir_close(struct cir_file* fd);\n\n\n\n/* This routine attempts to write to the circular file \\a fd, much like\n\n * the write(2) system call.\n\n * \\return the number of written bytes or -1 if an error occured.\n\n */\n\nextern int cir_write(struct cir_file* fd, char* buffer, unsigned int size);\n\n\n\n/* This routine attempts to read from the circular file \\a fd, much like\n\n * the read(2) system call.\n\n * \\return the number of read bytes or -1 if an error occured.\n\n */\n\nextern int cir_read(struct cir_file* fd, char* buffer, unsigned int size);\n\n\n\n/* This routine attempts to read a string from the circular file \\a fd,\n\n * much like the gets(3) standard C library call.\n\n * \\return the length of the read string or -1 if an error occured.\n\n */\n\nextern int cir_gets(struct cir_file* fd, char* buffer, unsigned int size);\n\n\n\n#endif\n\n\n", "#include <fcntl.h>\n\n#include <sys/stat.h>\n\n#include <sys/types.h>\n\n#include <stdio.h>\n\n#include <stdlib.h>\n\n#include <string.h>\n\n#include <sys/param.h>\n\n#include <unistd.h>\n\n#include <errno.h>\n\n\n\n/* Uncircular and concat several circular files into stdout */\n\n\n\n#include \"circul.h\"\n\n\n\n#define INTERNAL_BUFFER_SIZE  512\n\nchar buffer[INTERNAL_BUFFER_SIZE];\n\n\n\nstatic int uncircular_one (char *input_file_name) {\n\n\n\nsize_t char_read;\n\nstruct cir_file *circul_fd = NULL;\n\n\n\n  /* Generate linear file */\n\n  circul_fd = cir_open(input_file_name, \"r\", 0);\n\n  if (circul_fd == NULL) {\n\n    fprintf(stderr, \"Cannot open the circular file %s\\n\", input_file_name);\n\n    return (1);\n\n  }\n\n\n\n  do {\n\n    char_read = 0;\n\n    char_read = cir_read(circul_fd, buffer, INTERNAL_BUFFER_SIZE);\n\n    if ((int) char_read == -1) {\n\n      fprintf(stderr, \"Cannot read on circular file %s\\n\", input_file_name);\n\n      return (1);\n\n    }\n\n\n\n    if (fwrite(buffer, 1, char_read, stdout) != char_read) {\n\n      fprintf(stderr, \"Cannot write (%ld bytes) on stdout\\n\", char_read);\n\n      return (1);\n\n    }\n\n  } while ( (char_read != 0) && ((int) char_read != -1));\n\n\n\n  cir_close (circul_fd);\n\n  circul_fd = NULL;\n\n  return (0);\n\n}\n\n\n\nint main (int argc, char *argv[]) {\n\nint result;\n\nint i;\n\n\n\n\n\n  if (argc < 2) {\n\n    fprintf (stderr, \"Syntax error. Syntax %s { <circular_file_name> }\\n\",\n\n             argv[0]);\n\n    exit (1);\n\n  }\n\n\n\n  /* Process each argument */\n\n  result = 0;\n\n  for (i = 1; i < argc; i++) {\n\n      result += uncircular_one(argv[i]);\n\n  }\n\n\n\n  if (fwrite(\"\\n\", 1, 1, stdout) != 1) {\n\n    fprintf(stderr, \"Cannot write last \\\\n on stdout\\n\");\n\n    exit (1);\n\n  }\n\n\n\n  exit (result != 0);\n\n}\n\n\n\n\n", "/* Includes\n\n ******************************************************************************/\n\n#include <stdio.h>\n\n#include <stdlib.h>\n\n#include <string.h>\n\n#include <errno.h>\n\n#include <ctype.h>\n\n\n\n#include \"circul.h\"\n\n\n\nchar CIR_EOF = 0X1; /* ^A */\n\n\n\ntypedef enum { READ, WRITE, WRITE_APPEND } TYPE_FILE_CIRCULAR;\n\ntypedef enum { IS_FOUND, IS_NOT_FOUND }  MARK_FOUND;\n\ntypedef MARK_FOUND    END_FOUND;\n\n\n\nstruct cir_file\n\n{\n\n    FILE          *ptf;       /* File descriptor of circular file */\n\n    unsigned int  size_max;   /* size (octet) of this file   */\n\n    TYPE_FILE_CIRCULAR mode;  /* open mode */\n\n    MARK_FOUND    mark;       /* CIR_EOF already search */\n\n    END_FOUND     end;        /* CIR_EOF already found */\n\n};\n\n\n\n\n\n/* Routines\n\n ******************************************************************************/\n\nstatic int lookup_marker (struct cir_file * fd);\n\nstatic int write_mfb (struct cir_file * fd);\n\nstatic int local_fwrite (char *buff ,int size ,unsigned int lg ,FILE *fd );\n\n\n\n/******************************************************************************/\n\nint cir_close (struct cir_file *fd)\n\n{\n\n    int cr = 0;\n\n\n\n    if (!fd) return -1;\n\n\n\n    fd->mark= IS_NOT_FOUND;\n\n    fd->end = IS_NOT_FOUND;\n\n    cr = fclose (fd->ptf);\n\n\n\n    free(fd);\n\n    return (cr == EOF ? -1 : 0);\n\n}\n\n\n\n/******************************************************************************/\n\nint cir_gets (struct cir_file *fd, char *buffer,  unsigned int lg)\n\n{\n\n    int lu = 0;\n\n    char c = EOF;\n\n    union {\n\n        char *ptc;\n\n        void *ptv;\n\n    } X;\n\n\n\n    if (fd == (struct cir_file *) NULL)  return -1;\n\n\n\n    if (fd->mode != READ) return -1;\n\n\n\n    if (lg == (unsigned int) 0) return 0;\n\n\n\n    /* The end was already reached during the previous read */\n\n    if (fd->end == IS_FOUND) return 0;\n\n\n\n    if (fd->mark == IS_NOT_FOUND) {\n\n        /* The marker has not been found */\n\n        lu = lookup_marker (fd);\n\n        if (lu == 0) return -1;\n\n    }\n\n\n\n    X.ptc = buffer;\n\n\n\n    /* Reads characters from fd into buffer, until either a newline character\n\n     * is read, byte_count - 1 characters have been read, or CIR_EOF\n\n     * is seen.\n\n     * Finishes by appending a null character and returning buffer.\n\n     * If CIR_EOF is seen before any characters have been written,\n\n     * the function returns -1 without appending the null character.\n\n     * If there is a file error, always return -1.\n\n     */\n\n\n\n    while (--lg > 0 && (c = getc(fd->ptf)) != CIR_EOF) {\n\n        if (c == EOF) {\n\n            if ( fseek (fd->ptf, 0, SEEK_SET)== -1 ) return -1;\n\n            lg++;\n\n        }\n\n        else if ((*(X.ptc)++ = c) == '\\n') {\n\n            break;\n\n        }\n\n    }\n\n\n\n    *(X.ptc) = '\\0';\n\n\n\n    if (c == CIR_EOF) {\n\n        fd->end = IS_FOUND;\n\n        return 0;\n\n     }\n\n\n\n    return strlen(buffer);\n\n}\n\n\n\n/******************************************************************************/\n\nstruct cir_file* cir_open(const char *path, const char *mode, unsigned int lg)\n\n{\n\n    struct cir_file* cir_fp;\n\n    TYPE_FILE_CIRCULAR m;\n\n    FILE*     fp;\n\n    char     file_mode[3];\n\n\n\n    if (!mode) return NULL;\n\n\n\n    switch (tolower(mode[0])) {\n\n        case 'r': strcpy(file_mode, \"r\");  m = READ;  break;\n\n        case 'w': strcpy(file_mode, \"w+\"); m = WRITE; break;\n\n        default: return NULL;\n\n    }\n\n\n\n    if ( (fp = fopen(path, file_mode)) == NULL) return NULL;\n\n\n\n    cir_fp = calloc(1, sizeof(struct cir_file));\n\n    cir_fp->ptf  = fp;\n\n    cir_fp->mode = m;\n\n    cir_fp->mark = IS_NOT_FOUND;\n\n    cir_fp->end  = IS_NOT_FOUND;\n\n    cir_fp->size_max   = lg;\n\n\n\n    return cir_fp;\n\n}\n\n\n\n/******************************************************************************/\n\nstatic int lookup_marker (struct cir_file *fd)\n\n{\n\n    union {\n\n        char *ptc;\n\n        void *ptv;\n\n    } X;\n\n    char buf[1];\n\n    register int i;\n\n\n\n    X.ptc=buf;\n\n    fd->mark = IS_FOUND;\n\n    fd->end = IS_NOT_FOUND;\n\n\n\n    i = ftell (fd->ptf);\n\n\n\n    do {\n\n        do {\n\n            i = fread (X.ptv, 1, 1, fd->ptf);\n\n        } while ( (i== -1) && ( errno==EINTR));\n\n    } while ((i != 0) && (buf[0] != (char) CIR_EOF));\n\n    return (i);\n\n}\n\n\n\n/******************************************************************************/\n\nint cir_read (struct cir_file *fd, char* buffer, unsigned int size)\n\n{\n\n    int lu = 0, i = 0;\n\n    union {\n\n        char *ptc;\n\n        void *ptv;\n\n    } X;\n\n\n\n\n\n    if (fd == NULL)  return -1;\n\n    if (fd->mode != READ) return -1;\n\n    if (size == 0)  return 0;\n\n\n\n    /* The end was already reached during the previous read */\n\n    if (fd->end == IS_FOUND) return 0;\n\n\n\n    if (fd->mark == IS_NOT_FOUND) {\n\n        /* The marker has not been found */\n\n        if ( (lu = lookup_marker(fd)) == 0) return -1;\n\n    }\n\n\n\n    X.ptc=buffer;\n\n\n\n    do {\n\n        lu = fread (X.ptv, 1, size, fd->ptf);\n\n    } while ( (lu==-1)&&(errno==EINTR));\n\n\n\n    if (lu == 0) {\n\n        if ( fseek (fd->ptf, 0, SEEK_SET)== -1 ) return -1;\n\n        do {\n\n            lu = fread (X.ptv, 1, size, fd->ptf);\n\n        } while ( (lu==-1)&&(errno==EINTR));\n\n    }\n\n\n\n    for (i = 0; i < lu; i++) {\n\n        if (X.ptc[i] == (char) CIR_EOF) {\n\n            fd->end = IS_FOUND;\n\n            return i;\n\n        }\n\n    }\n\n\n\n    return lu;\n\n}\n\n\n\n/*\n\n   ERROR MANAGEMENT\n\n   if return = 0 no error\n\n   if return > 0 impossible\n\n   if return < 0 then val give the error\n\n\n\n   possible error -\n\n   1 : the file is open in read mode\n\n   2 : error on write in the circular file\n\n   3 : error on moving in the circular file\n\n   4 : error on write in the circular file\n\n   5 : error on moving in the circular file\n\n   6 : error on moving in the circular file\n\n */\n\n\n\n/******************************************************************************/\n\nint cir_write (struct cir_file *fd, char *buffer, unsigned int lg)\n\n{\n\n    long position;\n\n    int cr = 0;\n\n    union {\n\n        char *ptc;\n\n        void *ptv;\n\n    } X;\n\n\n\n    if (fd == (struct cir_file *) NULL) {\n\n        return -1;\n\n    }\n\n\n\n    if (fd->mode != WRITE)  {\n\n        return -1;\n\n    }\n\n\n\n    if (lg == (unsigned int) 0) {\n\n        return (write_mfb (fd));\n\n    }\n\n\n\n    X.ptc = buffer;\n\n    position = ftell (fd->ptf);\n\n\n\n    if (position + lg + 1 > fd->size_max) {\n\n        register unsigned int rest_file = fd->size_max - position;\n\n        register unsigned int rest_buffer = lg - rest_file;\n\n\n\n        if (fseek (fd->ptf, 0, SEEK_SET) == -1) {\n\n            return -1;\n\n        }\n\n        if (write_mfb (fd) == -1) {\n\n            return -1;\n\n        }\n\n        if (fseek (fd->ptf, position, SEEK_SET) == -1) {\n\n            return -1;\n\n        }\n\n\n\n        cr = local_fwrite (X.ptc, 1, rest_file, fd->ptf);\n\n\n\n        if ((unsigned int)cr != rest_file) {\n\n            return -1;\n\n        }\n\n\n\n        if (fseek (fd->ptf, 0, SEEK_SET) == -1) {\n\n            return -1;\n\n        }\n\n\n\n        return (cir_write (fd, X.ptc + rest_file, rest_buffer));\n\n\n\n    } else {\n\n        /* position + lg+1 <= fd->size_max */\n\n        if (fseek (fd->ptf, position + lg, SEEK_SET) == -1) {\n\n            return -1;\n\n        }\n\n\n\n        if (write_mfb (fd) == -1) {\n\n            return -1;\n\n        }\n\n\n\n        if (fseek (fd->ptf, position, SEEK_SET) == -1) {\n\n            return -1;\n\n        }\n\n\n\n        cr = local_fwrite (X.ptc, 1, lg, fd->ptf);\n\n\n\n        if ((unsigned int)cr != lg) {\n\n            return -1;\n\n        }\n\n    }\n\n    return (write_mfb (fd));\n\n}\n\n\n\n/******************************************************************************/\n\nstatic int write_mfb (struct cir_file *fd)\n\n{\n\n    union {\n\n        char *ptc;\n\n        void *ptv;\n\n    } X;\n\n    int cr;\n\n\n\n    X.ptc = &CIR_EOF;\n\n\n\n    if (ftell (fd->ptf) + 1 > (long)fd->size_max) {\n\n        if (fseek (fd->ptf, 0, SEEK_SET) == -1) {\n\n            return -1;\n\n        }\n\n    }\n\n\n\n    do {\n\n        cr=fwrite (X.ptv, 1, 1, fd->ptf);\n\n    } while ( (cr== -1) &&(errno==EINTR));\n\n\n\n    if ( cr !=  1 ) {\n\n        return -1;\n\n    }\n\n\n\n    if (fseek (fd->ptf, -1, SEEK_CUR) == -1) {\n\n        return -1;\n\n    }\n\n    return 0;\n\n}\n\n\n\n/******************************************************************************/\n\nstatic int local_fwrite (char *buff ,int size ,unsigned int lg ,FILE *fd )\n\n{\n\n    union {\n\n        char *ptc;\n\n        void *ptv;\n\n    } X;\n\n    register int lg_to_write = lg ;\n\n    register int lg_written  = 0 ;\n\n    register int cr    = 0 ;\n\n\n\n    X.ptc = buff;\n\n\n\n    do {\n\n\n\n        X.ptc = X.ptc + lg_written;\n\n\n\n        do {\n\n            cr = fwrite (X.ptv, (size_t)size, (size_t)lg_to_write, fd);\n\n        } while ( (cr== -1) &&(errno==EINTR));\n\n        if ( cr == -1 ) return (-1);\n\n        lg_to_write -= cr ;\n\n        lg_written  += cr ;\n\n\n\n    } while ( lg_to_write != 0 ) ;\n\n\n\n    return (lg_written);\n\n}\n\n\n", "#include <stdio.h>\n\n#include <stdlib.h>\n\n#include <string.h>\n\n#include <sys/param.h>\n\n#include <sys/types.h>\n\n#include <sys/time.h>\n\n\n\n/* Tail -f a circular file (argv[1]), outputs on stdout */\n\n/*  option -i <period_ms> changes the polling period (default 1000 ms) */\n\n\n\n#include \"circul.h\"\n\n\n\n#define DEFAULT_DELAY_MS 1000\n\n\n\n#define BUFFER_SIZE 512\n\n\n\nint main (int argc, char *argv[]) {\n\n\n\nchar c;\n\nFILE * circul_file;\n\nint delay_ms;\n\nchar * circular_file_name;\n\nstruct timeval delay;\n\nlong last_pos;\n\nchar buffer [BUFFER_SIZE];\n\nint len;\n\nlong nb_block;\n\nint offset;\n\n\n\n    circular_file_name = NULL;\n\n    delay_ms = DEFAULT_DELAY_MS;\n\n    if (argc == 2) {\n\n        delay_ms = DEFAULT_DELAY_MS;\n\n        circular_file_name = argv[1];\n\n    } else {\n\n        if ( (argc == 4) && (strcmp(argv[1], \"-i\") == 0) ) {\n\n            delay_ms = atoi (argv[2]);\n\n            if (delay_ms > 0) {\n\n                circular_file_name = argv[3];\n\n            }\n\n        }\n\n    }\n\n\n\n    if (circular_file_name == NULL) {\n\n        fprintf (stderr, \"Syntax error. Syntax %s \"\n\n                         \"[ -i <delay_ms> ] <circular_file_name>\\n\", argv[0]);\n\n        exit (1);\n\n    }\n\n\n\n    /* Open linear file */\n\n    circul_file = fopen(circular_file_name, \"r\");\n\n    if (circul_file == (FILE*) NULL) {\n\n        perror (\"fopen\");\n\n        fprintf(stderr, \"Cannot open the circular file %s\\n\",\n\n                circular_file_name);\n\n        exit (1);\n\n    }\n\n\n\n    /* Locate mark */\n\n    /* Look first end of file */\n\n    (void) fseek(circul_file, -1, SEEK_END);\n\n    c = getc(circul_file);\n\n\n\n    if (c !=  CIR_EOF) {\n\n        /* Look for the mark from beginning */\n\n        (void) fseek(circul_file, 0, SEEK_SET);\n\n        c = '\\0';\n\n        nb_block = 1;\n\n        do {\n\n            len = fread (buffer, 1, BUFFER_SIZE, circul_file);\n\n            if (len == 0) {\n\n                /* Mark has moved back at the beginning during our search */\n\n                /* Give up the search and let's go to standard behaviour */\n\n                nb_block = 1;\n\n                offset = 0;\n\n                c = CIR_EOF;\n\n            } else {\n\n                for (offset = 0; offset < len; offset++) {\n\n                    if (buffer[offset] == CIR_EOF) {\n\n                        c = CIR_EOF;\n\n                        break;\n\n                    }\n\n                }\n\n                nb_block ++;\n\n            }\n\n        } while (c != CIR_EOF);\n\n        (void) fseek(circul_file, offset - len, SEEK_CUR);\n\n    } else {\n\n        /* Mark is at end of file */\n\n        fseek (circul_file, -1, SEEK_CUR);\n\n        nb_block = -1;\n\n    }\n\n\n\n    /* Mark is found */\n\n    /* Go back one block to have something to display */\n\n    if (nb_block == 1) {\n\n        (void) fseek(circul_file, 0, SEEK_SET);\n\n    } else {\n\n        (void) fseek(circul_file, -BUFFER_SIZE, SEEK_CUR);\n\n    }\n\n\n\n    for (;;) {\n\n        c = getc(circul_file);\n\n\n\n        if ( (c != CIR_EOF) && (c != EOF) ) {\n\n            /* Normal behaviour */\n\n            (void) putchar (c);\n\n        } else {\n\n            if (c == EOF) {\n\n                /* End of file. Look for mark from beginning of file */\n\n                last_pos = 0;\n\n                fclose (circul_file);\n\n            } else {\n\n                /* Mark found. Current end of file */\n\n                /* Close file, wait a bit, then look for mark from */\n\n                /*  same location */\n\n                last_pos = ftell (circul_file) - 1;\n\n                fclose (circul_file);\n\n                (void) fflush (stdout);\n\n                delay.tv_sec = delay_ms / 1000;\n\n                delay.tv_usec = (delay_ms % 1000) * 1000;\n\n                (void) select (0, (fd_set *) NULL, (fd_set *) NULL,\n\n                                  (fd_set *) NULL, &delay);\n\n            }\n\n            circul_file = fopen(circular_file_name, \"r\");\n\n            if (circul_file == (FILE*) NULL) {\n\n                perror (\"fopen\");\n\n                fprintf(stderr, \"Cannot re-open the circular file %s\\n\",\n\n                        circular_file_name);\n\n                break;\n\n            }\n\n            (void) fseek(circul_file, last_pos, SEEK_SET);\n\n        }\n\n    }\n\n    exit(1);\n\n}\n\n\n", "/*\n\n * Copyright (c) 2000-2008 Marc Alexander Lehmann <schmorp@schmorp.de>\n\n * \n\n * Redistribution and use in source and binary forms, with or without modifica-\n\n * tion, are permitted provided that the following conditions are met:\n\n * \n\n *   1.  Redistributions of source code must retain the above copyright notice,\n\n *       this list of conditions and the following disclaimer.\n\n * \n\n *   2.  Redistributions in binary form must reproduce the above copyright\n\n *       notice, this list of conditions and the following disclaimer in the\n\n *       documentation and/or other materials provided with the distribution.\n\n * \n\n * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR IMPLIED\n\n * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MER-\n\n * CHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  IN NO\n\n * EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPE-\n\n * CIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,\n\n * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;\n\n * OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,\n\n * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTH-\n\n * ERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED\n\n * OF THE POSSIBILITY OF SUCH DAMAGE.\n\n *\n\n * Alternatively, the contents of this file may be used under the terms of\n\n * the GNU General Public License (\"GPL\") version 2 or any later version,\n\n * in which case the provisions of the GPL are applicable instead of\n\n * the above. If you wish to allow the use of your version of this file\n\n * only under the terms of the GPL and not to allow others to use your\n\n * version of this file under the BSD license, indicate your decision\n\n * by deleting the provisions above and replace them with the notice\n\n * and other provisions required by the GPL. If you do not delete the\n\n * provisions above, a recipient may use your version of this file under\n\n * either the BSD or the GPL.\n\n */\n\n\n\n#ifndef LZF_H\n\n#define LZF_H\n\n\n\n/***********************************************************************\n\n**\n\n**\tlzf -- an extremely fast/free compression/decompression-method\n\n**\thttp://liblzf.plan9.de/\n\n**\n\n**\tThis algorithm is believed to be patent-free.\n\n**\n\n***********************************************************************/\n\n\n\n#define LZF_VERSION 0x0105 /* 1.5, API version */\n\n\n\n/*\n\n * Compress in_len bytes stored at the memory block starting at\n\n * in_data and write the result to out_data, up to a maximum length\n\n * of out_len bytes.\n\n *\n\n * If the output buffer is not large enough or any error occurs return 0,\n\n * otherwise return the number of bytes used, which might be considerably\n\n * more than in_len (but less than 104% of the original size), so it\n\n * makes sense to always use out_len == in_len - 1), to ensure _some_\n\n * compression, and store the data uncompressed otherwise (with a flag, of\n\n * course.\n\n *\n\n * lzf_compress might use different algorithms on different systems and\n\n * even different runs, thus might result in different compressed strings\n\n * depending on the phase of the moon or similar factors. However, all\n\n * these strings are architecture-independent and will result in the\n\n * original data when decompressed using lzf_decompress.\n\n *\n\n * The buffers must not be overlapping.\n\n *\n\n * If the option LZF_STATE_ARG is enabled, an extra argument must be\n\n * supplied which is not reflected in this header file. Refer to lzfP.h\n\n * and lzf_c.c.\n\n *\n\n */\n\nunsigned int \n\nlzf_compress (const void *const in_data,  unsigned int in_len,\n\n              void             *out_data, unsigned int out_len);\n\n\n\n/*\n\n * Decompress data compressed with some version of the lzf_compress\n\n * function and stored at location in_data and length in_len. The result\n\n * will be stored at out_data up to a maximum of out_len characters.\n\n *\n\n * If the output buffer is not large enough to hold the decompressed\n\n * data, a 0 is returned and errno is set to E2BIG. Otherwise the number\n\n * of decompressed bytes (i.e. the original length of the data) is\n\n * returned.\n\n *\n\n * If an error in the compressed data is detected, a zero is returned and\n\n * errno is set to EINVAL.\n\n *\n\n * This function is very fast, about as fast as a copying loop.\n\n */\n\nunsigned int \n\nlzf_decompress (const void *const in_data,  unsigned int in_len,\n\n                void             *out_data, unsigned int out_len);\n\n\n\n#endif\n\n\n", "/*\n\n * Copyright (c) 2000-2010 Marc Alexander Lehmann <schmorp@schmorp.de>\n\n * \n\n * Redistribution and use in source and binary forms, with or without modifica-\n\n * tion, are permitted provided that the following conditions are met:\n\n * \n\n *   1.  Redistributions of source code must retain the above copyright notice,\n\n *       this list of conditions and the following disclaimer.\n\n * \n\n *   2.  Redistributions in binary form must reproduce the above copyright\n\n *       notice, this list of conditions and the following disclaimer in the\n\n *       documentation and/or other materials provided with the distribution.\n\n * \n\n * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR IMPLIED\n\n * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MER-\n\n * CHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  IN NO\n\n * EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPE-\n\n * CIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,\n\n * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;\n\n * OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,\n\n * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTH-\n\n * ERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED\n\n * OF THE POSSIBILITY OF SUCH DAMAGE.\n\n *\n\n * Alternatively, the contents of this file may be used under the terms of\n\n * the GNU General Public License (\"GPL\") version 2 or any later version,\n\n * in which case the provisions of the GPL are applicable instead of\n\n * the above. If you wish to allow the use of your version of this file\n\n * only under the terms of the GPL and not to allow others to use your\n\n * version of this file under the BSD license, indicate your decision\n\n * by deleting the provisions above and replace them with the notice\n\n * and other provisions required by the GPL. If you do not delete the\n\n * provisions above, a recipient may use your version of this file under\n\n * either the BSD or the GPL.\n\n */\n\n\n\n#include \"lzfP.h\"\n\n\n\n#if AVOID_ERRNO\n\n# define SET_ERRNO(n)\n\n#else\n\n# include <errno.h>\n\n# define SET_ERRNO(n) errno = (n)\n\n#endif\n\n\n\n#if USE_REP_MOVSB /* small win on amd, big loss on intel */\n\n#if (__i386 || __amd64) && __GNUC__ >= 3\n\n# define lzf_movsb(dst, src, len)                \\\n\n   asm (\"rep movsb\"                              \\\n\n        : \"=D\" (dst), \"=S\" (src), \"=c\" (len)     \\\n\n        :  \"0\" (dst),  \"1\" (src),  \"2\" (len));\n\n#endif\n\n#endif\n\n\n\nunsigned int \n\nlzf_decompress (const void *const in_data,  unsigned int in_len,\n\n                void             *out_data, unsigned int out_len)\n\n{\n\n  u8 const *ip = (const u8 *)in_data;\n\n  u8       *op = (u8 *)out_data;\n\n  u8 const *const in_end  = ip + in_len;\n\n  u8       *const out_end = op + out_len;\n\n\n\n  do\n\n    {\n\n      unsigned int ctrl = *ip++;\n\n\n\n      if (ctrl < (1 << 5)) /* literal run */\n\n        {\n\n          ctrl++;\n\n\n\n          if (op + ctrl > out_end)\n\n            {\n\n              SET_ERRNO (E2BIG);\n\n              return 0;\n\n            }\n\n\n\n#if CHECK_INPUT\n\n          if (ip + ctrl > in_end)\n\n            {\n\n              SET_ERRNO (EINVAL);\n\n              return 0;\n\n            }\n\n#endif\n\n\n\n#ifdef lzf_movsb\n\n          lzf_movsb (op, ip, ctrl);\n\n#else\n\n          switch (ctrl)\n\n            {\n\n              case 32: *op++ = *ip++; case 31: *op++ = *ip++; case 30: *op++ = *ip++; case 29: *op++ = *ip++;\n\n              case 28: *op++ = *ip++; case 27: *op++ = *ip++; case 26: *op++ = *ip++; case 25: *op++ = *ip++;\n\n              case 24: *op++ = *ip++; case 23: *op++ = *ip++; case 22: *op++ = *ip++; case 21: *op++ = *ip++;\n\n              case 20: *op++ = *ip++; case 19: *op++ = *ip++; case 18: *op++ = *ip++; case 17: *op++ = *ip++;\n\n              case 16: *op++ = *ip++; case 15: *op++ = *ip++; case 14: *op++ = *ip++; case 13: *op++ = *ip++;\n\n              case 12: *op++ = *ip++; case 11: *op++ = *ip++; case 10: *op++ = *ip++; case  9: *op++ = *ip++;\n\n              case  8: *op++ = *ip++; case  7: *op++ = *ip++; case  6: *op++ = *ip++; case  5: *op++ = *ip++;\n\n              case  4: *op++ = *ip++; case  3: *op++ = *ip++; case  2: *op++ = *ip++; case  1: *op++ = *ip++;\n\n            }\n\n#endif\n\n        }\n\n      else /* back reference */\n\n        {\n\n          unsigned int len = ctrl >> 5;\n\n\n\n          u8 *ref = op - ((ctrl & 0x1f) << 8) - 1;\n\n\n\n#if CHECK_INPUT\n\n          if (ip >= in_end)\n\n            {\n\n              SET_ERRNO (EINVAL);\n\n              return 0;\n\n            }\n\n#endif\n\n          if (len == 7)\n\n            {\n\n              len += *ip++;\n\n#if CHECK_INPUT\n\n              if (ip >= in_end)\n\n                {\n\n                  SET_ERRNO (EINVAL);\n\n                  return 0;\n\n                }\n\n#endif\n\n            }\n\n\n\n          ref -= *ip++;\n\n\n\n          if (op + len + 2 > out_end)\n\n            {\n\n              SET_ERRNO (E2BIG);\n\n              return 0;\n\n            }\n\n\n\n          if (ref < (u8 *)out_data)\n\n            {\n\n              SET_ERRNO (EINVAL);\n\n              return 0;\n\n            }\n\n\n\n#ifdef lzf_movsb\n\n          len += 2;\n\n          lzf_movsb (op, ref, len);\n\n#else\n\n          switch (len)\n\n            {\n\n              default:\n\n                len += 2;\n\n\n\n                if (op >= ref + len)\n\n                  {\n\n                    /* disjunct areas */\n\n                    memcpy (op, ref, len);\n\n                    op += len;\n\n                  }\n\n                else\n\n                  {\n\n                    /* overlapping, use octte by octte copying */\n\n                    do\n\n                      *op++ = *ref++;\n\n                    while (--len);\n\n                  }\n\n\n\n                break;\n\n\n\n              case 9: *op++ = *ref++;\n\n              case 8: *op++ = *ref++;\n\n              case 7: *op++ = *ref++;\n\n              case 6: *op++ = *ref++;\n\n              case 5: *op++ = *ref++;\n\n              case 4: *op++ = *ref++;\n\n              case 3: *op++ = *ref++;\n\n              case 2: *op++ = *ref++;\n\n              case 1: *op++ = *ref++;\n\n              case 0: *op++ = *ref++; /* two octets more */\n\n                      *op++ = *ref++;\n\n            }\n\n#endif\n\n        }\n\n    }\n\n  while (ip < in_end);\n\n\n\n  return op - (u8 *)out_data;\n\n}\n\n\n", "/*\n\n * Copyright (c) 2000-2010 Marc Alexander Lehmann <schmorp@schmorp.de>\n\n * \n\n * Redistribution and use in source and binary forms, with or without modifica-\n\n * tion, are permitted provided that the following conditions are met:\n\n * \n\n *   1.  Redistributions of source code must retain the above copyright notice,\n\n *       this list of conditions and the following disclaimer.\n\n * \n\n *   2.  Redistributions in binary form must reproduce the above copyright\n\n *       notice, this list of conditions and the following disclaimer in the\n\n *       documentation and/or other materials provided with the distribution.\n\n * \n\n * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR IMPLIED\n\n * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MER-\n\n * CHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  IN NO\n\n * EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPE-\n\n * CIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,\n\n * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;\n\n * OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,\n\n * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTH-\n\n * ERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED\n\n * OF THE POSSIBILITY OF SUCH DAMAGE.\n\n *\n\n * Alternatively, the contents of this file may be used under the terms of\n\n * the GNU General Public License (\"GPL\") version 2 or any later version,\n\n * in which case the provisions of the GPL are applicable instead of\n\n * the above. If you wish to allow the use of your version of this file\n\n * only under the terms of the GPL and not to allow others to use your\n\n * version of this file under the BSD license, indicate your decision\n\n * by deleting the provisions above and replace them with the notice\n\n * and other provisions required by the GPL. If you do not delete the\n\n * provisions above, a recipient may use your version of this file under\n\n * either the BSD or the GPL.\n\n */\n\n#ifdef TRACE\n\n#  include <stdio.h>\n\n#  define LOG(...) fprintf (stderr, __VA_ARGS__)\n\n#else\n\n#  define LOG\n\n#endif\n\n\n\n#include \"lzfP.h\"\n\n\n\n#define HSIZE (1 << (HLOG))\n\n\n\n/*\n\n * don't play with this unless you benchmark!\n\n * the data format is not dependent on the hash function.\n\n * the hash function might seem strange, just believe me,\n\n * it works ;)\n\n */\n\n#ifndef FRST\n\n# define FRST(p) (((p[0]) << 8) | p[1])\n\n# define NEXT(v,p) (((v) << 8) | p[2])\n\n# if ULTRA_FAST\n\n#  define IDX(h) ((( h             >> (3*8 - HLOG)) - h  ) & (HSIZE - 1))\n\n# elif VERY_FAST\n\n#  define IDX(h) ((( h             >> (3*8 - HLOG)) - h*5) & (HSIZE - 1))\n\n# else\n\n#  define IDX(h) ((((h ^ (h << 5)) >> (3*8 - HLOG)) - h*5) & (HSIZE - 1))\n\n# endif\n\n#endif\n\n/*\n\n * IDX works because it is very similar to a multiplicative hash, e.g.\n\n * ((h * 57321 >> (3*8 - HLOG)) & (HSIZE - 1))\n\n * the latter is also quite fast on newer CPUs, and compresses similarly.\n\n *\n\n * the next one is also quite good, albeit slow ;)\n\n * (int)(cos(h & 0xffffff) * 1e6)\n\n */\n\n\n\n#if 0\n\n/* original lzv-like hash function, much worse and thus slower */\n\n# define FRST(p) (p[0] << 5) ^ p[1]\n\n# define NEXT(v,p) ((v) << 5) ^ p[2]\n\n# define IDX(h) ((h) & (HSIZE - 1))\n\n#endif\n\n\n\n#define        MAX_LIT        (1 <<  5)\n\n#define        MAX_OFF        (1 << 13)\n\n#define        MAX_REF        ((1 << 8) + (1 << 3))\n\n\n\n#if __GNUC__ >= 3\n\n# define expect(expr,value)         __builtin_expect ((expr),(value))\n\n# define inline                     inline\n\n#else\n\n# define expect(expr,value)         (expr)\n\n# define inline                     static\n\n#endif\n\n\n\n#define expect_false(expr) expect ((expr) != 0, 0)\n\n#define expect_true(expr)  expect ((expr) != 0, 1)\n\n\n\n/*\n\n * compressed format\n\n *\n\n * 000LLLLL <L+1>    ; literal, L+1=1..33 octets\n\n * LLLooooo oooooooo ; backref L+1=1..7 octets, o+1=1..4096 offset\n\n * 111ooooo LLLLLLLL oooooooo ; backref L+8 octets, o+1=1..4096 offset\n\n *\n\n */\n\n\n\nunsigned int\n\nlzf_compress (const void *const in_data, unsigned int in_len,\n\n\t      void *out_data, unsigned int out_len\n\n#if LZF_STATE_ARG\n\n              , LZF_STATE htab\n\n#endif\n\n              )\n\n{\n\n#if !LZF_STATE_ARG\n\n  LZF_STATE htab;\n\n#endif\n\n  const u8 *ip = (const u8 *)in_data;\n\n        u8 *op = (u8 *)out_data;\n\n  const u8 *in_end  = ip + in_len;\n\n        u8 *out_end = op + out_len;\n\n  const u8 *ref;\n\n\n\n  /* off requires a type wide enough to hold a general pointer difference.\n\n   * ISO C doesn't have that (size_t might not be enough and ptrdiff_t only\n\n   * works for differences within a single object). We also assume that no\n\n   * no bit pattern traps. Since the only platform that is both non-POSIX\n\n   * and fails to support both assumptions is windows 64 bit, we make a\n\n   * special workaround for it.\n\n   */\n\n#if defined (WIN32) && defined (_M_X64)\n\n  unsigned _int64 off; /* workaround for missing POSIX compliance */\n\n#else\n\n  unsigned long off;\n\n#endif\n\n  unsigned int hval;\n\n  int lit;\n\n\n\n  if (!in_len || !out_len)\n\n    return 0;\n\n\n\n#if INIT_HTAB\n\n  memset (htab, 0, sizeof (htab));\n\n#endif\n\n\n\n  lit = 0; op++; /* start run */\n\n\n\n  hval = FRST (ip);\n\n  while (ip < in_end - 2)\n\n    {\n\n      LZF_HSLOT *hslot;\n\n\n\n      hval = NEXT (hval, ip);\n\n        LOG (\"Index %02X future %08X hash %X\\n\",\n\n             (int) (ip - (u8*)in_data), hval, IDX(hval));\n\n      hslot = htab + IDX (hval);\n\n      ref = *hslot + LZF_HSLOT_BIAS; *hslot = ip - LZF_HSLOT_BIAS;\n\n\n\n      LOG (\"Off read %02X\\n\", (int)(ref-(u8*)in_data));\n\n      if ( (ref >= (u8*)in_data) && (ref < in_end) ) {\n\n        LOG (\"Bytes at ref %02X %02X %02X\\n\", (int)ref[0], (int)ref[1],\n\n                                              (int)ref[2]);\n\n        LOG (\"Ip-Ref %02X\\n\", ip-ref);\n\n      }\n\n      LOG (\"Bytes here   %02X %02X %02X\\n\", (int)ip[0], (int)ip[1], (int)ip[2]);\n\n\n\n      if (1\n\n#if INIT_HTAB\n\n          && ref < ip /* the next test will actually take care of this, but this is faster */\n\n#endif\n\n          && (off = ip - ref - 1) < MAX_OFF\n\n          && ref > (u8 *)in_data\n\n          && ref[2] == ip[2]\n\n#if STRICT_ALIGN\n\n          && ((ref[1] << 8) | ref[0]) == ((ip[1] << 8) | ip[0])\n\n#else\n\n          && *(u16 *)ref == *(u16 *)ip\n\n#endif\n\n        )\n\n        {\n\n          /* match found at *ref++ */\n\n          unsigned int len = 2;\n\n          unsigned int maxlen = in_end - ip - len;\n\n          maxlen = maxlen > MAX_REF ? MAX_REF : maxlen;\n\n          LOG (\"Match\\n\");\n\n\n\n          if (expect_false (op + 3 + 1 >= out_end)) /* first a faster conservative test */\n\n            if (op - !lit + 3 + 1 >= out_end) /* second the exact but rare test */\n\n              return 0;\n\n\n\n          op [- lit - 1] = lit - 1; /* stop run */\n\n          op -= !lit; /* undo run if length is zero */\n\n\n\n          for (;;)\n\n            {\n\n              if (expect_true (maxlen > 16))\n\n                {\n\n                  len++; if (ref [len] != ip [len]) break;\n\n                  len++; if (ref [len] != ip [len]) break;\n\n                  len++; if (ref [len] != ip [len]) break;\n\n                  len++; if (ref [len] != ip [len]) break;\n\n\n\n                  len++; if (ref [len] != ip [len]) break;\n\n                  len++; if (ref [len] != ip [len]) break;\n\n                  len++; if (ref [len] != ip [len]) break;\n\n                  len++; if (ref [len] != ip [len]) break;\n\n\n\n                  len++; if (ref [len] != ip [len]) break;\n\n                  len++; if (ref [len] != ip [len]) break;\n\n                  len++; if (ref [len] != ip [len]) break;\n\n                  len++; if (ref [len] != ip [len]) break;\n\n\n\n                  len++; if (ref [len] != ip [len]) break;\n\n                  len++; if (ref [len] != ip [len]) break;\n\n                  len++; if (ref [len] != ip [len]) break;\n\n                  len++; if (ref [len] != ip [len]) break;\n\n                }\n\n\n\n              do\n\n                len++;\n\n              while (len < maxlen && ref[len] == ip[len]);\n\n\n\n              break;\n\n            }\n\n\n\n          len -= 2; /* len is now #octets - 1 */\n\n          ip++;\n\n\n\n          if (len < 7)\n\n            {\n\n              *op++ = (off >> 8) + (len << 5);\n\n            }\n\n          else\n\n            {\n\n              *op++ = (off >> 8) + (  7 << 5);\n\n              *op++ = len - 7;\n\n            }\n\n\n\n          *op++ = off;\n\n\n\n          lit = 0; op++; /* start run */\n\n\n\n          ip += len + 1;\n\n\n\n          if (expect_false (ip >= in_end - 2))\n\n            break;\n\n\n\n#if ULTRA_FAST || VERY_FAST\n\n          --ip;\n\n# if VERY_FAST && !ULTRA_FAST\n\n          --ip;\n\n# endif\n\n          hval = FRST (ip);\n\n\n\n          hval = NEXT (hval, ip);\n\n          htab[IDX (hval)] = ip - LZF_HSLOT_BIAS;\n\n          ip++;\n\n\n\n# if VERY_FAST && !ULTRA_FAST\n\n          hval = NEXT (hval, ip);\n\n          htab[IDX (hval)] = ip - LZF_HSLOT_BIAS;\n\n          ip++;\n\n# endif\n\n#else\n\n          ip -= len + 1;\n\n\n\n          do\n\n            {\n\n              hval = NEXT (hval, ip);\n\n              htab[IDX (hval)] = ip - LZF_HSLOT_BIAS;\n\n              ip++;\n\n            }\n\n          while (len--);\n\n#endif\n\n        }\n\n      else\n\n        {\n\n          LOG (\"No match\\n\");\n\n          /* one more literal byte we must copy */\n\n          if (expect_false (op >= out_end))\n\n            return 0;\n\n\n\n          lit++; *op++ = *ip++;\n\n\n\n          if (expect_false (lit == MAX_LIT))\n\n            {\n\n              op [- lit - 1] = lit - 1; /* stop run */\n\n              lit = 0; op++; /* start run */\n\n            }\n\n        }\n\n    }\n\n\n\n  if (op + 3 > out_end) /* at most 3 bytes can be missing here */\n\n    return 0;\n\n\n\n  while (ip < in_end)\n\n    {\n\n      lit++; *op++ = *ip++;\n\n\n\n      if (expect_false (lit == MAX_LIT))\n\n        {\n\n          op [- lit - 1] = lit - 1; /* stop run */\n\n          lit = 0; op++; /* start run */\n\n        }\n\n    }\n\n\n\n  op [- lit - 1] = lit - 1; /* end run */\n\n  op -= !lit; /* undo run if length is zero */\n\n\n\n  return op - (u8 *)out_data;\n\n}\n\n\n", "#ifndef CRC32_H\n\n#define CRC32_H\n\n\n\n/* crc32 0xdebb20e3 table and supplementary functions.  */\n\n\n\nstatic const u32 crc_32_tab[] =\n\n{\n\n    0x00000000UL, 0x77073096UL, 0xee0e612cUL, 0x990951baUL, 0x076dc419UL,\n\n    0x706af48fUL, 0xe963a535UL, 0x9e6495a3UL, 0x0edb8832UL, 0x79dcb8a4UL,\n\n    0xe0d5e91eUL, 0x97d2d988UL, 0x09b64c2bUL, 0x7eb17cbdUL, 0xe7b82d07UL,\n\n    0x90bf1d91UL, 0x1db71064UL, 0x6ab020f2UL, 0xf3b97148UL, 0x84be41deUL,\n\n    0x1adad47dUL, 0x6ddde4ebUL, 0xf4d4b551UL, 0x83d385c7UL, 0x136c9856UL,\n\n    0x646ba8c0UL, 0xfd62f97aUL, 0x8a65c9ecUL, 0x14015c4fUL, 0x63066cd9UL,\n\n    0xfa0f3d63UL, 0x8d080df5UL, 0x3b6e20c8UL, 0x4c69105eUL, 0xd56041e4UL,\n\n    0xa2677172UL, 0x3c03e4d1UL, 0x4b04d447UL, 0xd20d85fdUL, 0xa50ab56bUL,\n\n    0x35b5a8faUL, 0x42b2986cUL, 0xdbbbc9d6UL, 0xacbcf940UL, 0x32d86ce3UL,\n\n    0x45df5c75UL, 0xdcd60dcfUL, 0xabd13d59UL, 0x26d930acUL, 0x51de003aUL,\n\n    0xc8d75180UL, 0xbfd06116UL, 0x21b4f4b5UL, 0x56b3c423UL, 0xcfba9599UL,\n\n    0xb8bda50fUL, 0x2802b89eUL, 0x5f058808UL, 0xc60cd9b2UL, 0xb10be924UL,\n\n    0x2f6f7c87UL, 0x58684c11UL, 0xc1611dabUL, 0xb6662d3dUL, 0x76dc4190UL,\n\n    0x01db7106UL, 0x98d220bcUL, 0xefd5102aUL, 0x71b18589UL, 0x06b6b51fUL,\n\n    0x9fbfe4a5UL, 0xe8b8d433UL, 0x7807c9a2UL, 0x0f00f934UL, 0x9609a88eUL,\n\n    0xe10e9818UL, 0x7f6a0dbbUL, 0x086d3d2dUL, 0x91646c97UL, 0xe6635c01UL,\n\n    0x6b6b51f4UL, 0x1c6c6162UL, 0x856530d8UL, 0xf262004eUL, 0x6c0695edUL,\n\n    0x1b01a57bUL, 0x8208f4c1UL, 0xf50fc457UL, 0x65b0d9c6UL, 0x12b7e950UL,\n\n    0x8bbeb8eaUL, 0xfcb9887cUL, 0x62dd1ddfUL, 0x15da2d49UL, 0x8cd37cf3UL,\n\n    0xfbd44c65UL, 0x4db26158UL, 0x3ab551ceUL, 0xa3bc0074UL, 0xd4bb30e2UL,\n\n    0x4adfa541UL, 0x3dd895d7UL, 0xa4d1c46dUL, 0xd3d6f4fbUL, 0x4369e96aUL,\n\n    0x346ed9fcUL, 0xad678846UL, 0xda60b8d0UL, 0x44042d73UL, 0x33031de5UL,\n\n    0xaa0a4c5fUL, 0xdd0d7cc9UL, 0x5005713cUL, 0x270241aaUL, 0xbe0b1010UL,\n\n    0xc90c2086UL, 0x5768b525UL, 0x206f85b3UL, 0xb966d409UL, 0xce61e49fUL,\n\n    0x5edef90eUL, 0x29d9c998UL, 0xb0d09822UL, 0xc7d7a8b4UL, 0x59b33d17UL,\n\n    0x2eb40d81UL, 0xb7bd5c3bUL, 0xc0ba6cadUL, 0xedb88320UL, 0x9abfb3b6UL,\n\n    0x03b6e20cUL, 0x74b1d29aUL, 0xead54739UL, 0x9dd277afUL, 0x04db2615UL,\n\n    0x73dc1683UL, 0xe3630b12UL, 0x94643b84UL, 0x0d6d6a3eUL, 0x7a6a5aa8UL,\n\n    0xe40ecf0bUL, 0x9309ff9dUL, 0x0a00ae27UL, 0x7d079eb1UL, 0xf00f9344UL,\n\n    0x8708a3d2UL, 0x1e01f268UL, 0x6906c2feUL, 0xf762575dUL, 0x806567cbUL,\n\n    0x196c3671UL, 0x6e6b06e7UL, 0xfed41b76UL, 0x89d32be0UL, 0x10da7a5aUL,\n\n    0x67dd4accUL, 0xf9b9df6fUL, 0x8ebeeff9UL, 0x17b7be43UL, 0x60b08ed5UL,\n\n    0xd6d6a3e8UL, 0xa1d1937eUL, 0x38d8c2c4UL, 0x4fdff252UL, 0xd1bb67f1UL,\n\n    0xa6bc5767UL, 0x3fb506ddUL, 0x48b2364bUL, 0xd80d2bdaUL, 0xaf0a1b4cUL,\n\n    0x36034af6UL, 0x41047a60UL, 0xdf60efc3UL, 0xa867df55UL, 0x316e8eefUL,\n\n    0x4669be79UL, 0xcb61b38cUL, 0xbc66831aUL, 0x256fd2a0UL, 0x5268e236UL,\n\n    0xcc0c7795UL, 0xbb0b4703UL, 0x220216b9UL, 0x5505262fUL, 0xc5ba3bbeUL,\n\n    0xb2bd0b28UL, 0x2bb45a92UL, 0x5cb36a04UL, 0xc2d7ffa7UL, 0xb5d0cf31UL,\n\n    0x2cd99e8bUL, 0x5bdeae1dUL, 0x9b64c2b0UL, 0xec63f226UL, 0x756aa39cUL,\n\n    0x026d930aUL, 0x9c0906a9UL, 0xeb0e363fUL, 0x72076785UL, 0x05005713UL,\n\n    0x95bf4a82UL, 0xe2b87a14UL, 0x7bb12baeUL, 0x0cb61b38UL, 0x92d28e9bUL,\n\n    0xe5d5be0dUL, 0x7cdcefb7UL, 0x0bdbdf21UL, 0x86d3d2d4UL, 0xf1d4e242UL,\n\n    0x68ddb3f8UL, 0x1fda836eUL, 0x81be16cdUL, 0xf6b9265bUL, 0x6fb077e1UL,\n\n    0x18b74777UL, 0x88085ae6UL, 0xff0f6a70UL, 0x66063bcaUL, 0x11010b5cUL,\n\n    0x8f659effUL, 0xf862ae69UL, 0x616bffd3UL, 0x166ccf45UL, 0xa00ae278UL,\n\n    0xd70dd2eeUL, 0x4e048354UL, 0x3903b3c2UL, 0xa7672661UL, 0xd06016f7UL,\n\n    0x4969474dUL, 0x3e6e77dbUL, 0xaed16a4aUL, 0xd9d65adcUL, 0x40df0b66UL,\n\n    0x37d83bf0UL, 0xa9bcae53UL, 0xdebb9ec5UL, 0x47b2cf7fUL, 0x30b5ffe9UL,\n\n    0xbdbdf21cUL, 0xcabac28aUL, 0x53b39330UL, 0x24b4a3a6UL, 0xbad03605UL,\n\n    0xcdd70693UL, 0x54de5729UL, 0x23d967bfUL, 0xb3667a2eUL, 0xc4614ab8UL,\n\n    0x5d681b02UL, 0x2a6f2b94UL, 0xb40bbe37UL, 0xc30c8ea1UL, 0x5a05df1bUL,\n\n    0x2d02ef8dL\n\n};\n\n\n\n#define crc32(crc,byte) (crc_32_tab[(u8)(crc) ^ (u8)(byte)] ^ ((crc) >> 8))\n\n\n\n#endif\n\n\n", "/*\n\n * Copyright (c) 2000-2007 Marc Alexander Lehmann <schmorp@schmorp.de>\n\n * \n\n * Redistribution and use in source and binary forms, with or without modifica-\n\n * tion, are permitted provided that the following conditions are met:\n\n * \n\n *   1.  Redistributions of source code must retain the above copyright notice,\n\n *       this list of conditions and the following disclaimer.\n\n * \n\n *   2.  Redistributions in binary form must reproduce the above copyright\n\n *       notice, this list of conditions and the following disclaimer in the\n\n *       documentation and/or other materials provided with the distribution.\n\n * \n\n * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR IMPLIED\n\n * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MER-\n\n * CHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  IN NO\n\n * EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPE-\n\n * CIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,\n\n * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;\n\n * OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,\n\n * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTH-\n\n * ERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED\n\n * OF THE POSSIBILITY OF SUCH DAMAGE.\n\n *\n\n * Alternatively, the contents of this file may be used under the terms of\n\n * the GNU General Public License (\"GPL\") version 2 or any later version,\n\n * in which case the provisions of the GPL are applicable instead of\n\n * the above. If you wish to allow the use of your version of this file\n\n * only under the terms of the GPL and not to allow others to use your\n\n * version of this file under the BSD license, indicate your decision\n\n * by deleting the provisions above and replace them with the notice\n\n * and other provisions required by the GPL. If you do not delete the\n\n * provisions above, a recipient may use your version of this file under\n\n * either the BSD or the GPL.\n\n */\n\n\n\n#ifndef LZFP_h\n\n#define LZFP_h\n\n\n\n#define STANDALONE 1 /* at the moment, this is ok. */\n\n\n\n#ifndef STANDALONE\n\n# include \"lzf.h\"\n\n#endif\n\n\n\n/*\n\n * Size of hashtable is (1 << HLOG) * sizeof (char *)\n\n * decompression is independent of the hash table size\n\n * the difference between 15 and 14 is very small\n\n * for small blocks (and 14 is usually a bit faster).\n\n * For a low-memory/faster configuration, use HLOG == 13;\n\n * For best compression, use 15 or 16 (or more, up to 22).\n\n */\n\n#ifndef HLOG\n\n# define HLOG 16\n\n#endif\n\n\n\n/*\n\n * Sacrifice very little compression quality in favour of compression speed.\n\n * This gives almost the same compression as the default code, and is\n\n * (very roughly) 15% faster. This is the preferred mode of operation.\n\n */\n\n#ifndef VERY_FAST\n\n# define VERY_FAST 1\n\n#endif\n\n\n\n/*\n\n * Sacrifice some more compression quality in favour of compression speed.\n\n * (roughly 1-2% worse compression for large blocks and\n\n * 9-10% for small, redundant, blocks and >>20% better speed in both cases)\n\n * In short: when in need for speed, enable this for binary data,\n\n * possibly disable this for text data.\n\n */\n\n#ifndef ULTRA_FAST\n\n# define ULTRA_FAST 0\n\n#endif\n\n\n\n/*\n\n * Unconditionally aligning does not cost very much, so do it if unsure\n\n */\n\n#ifndef STRICT_ALIGN\n\n# define STRICT_ALIGN !(defined(__i386) || defined (__amd64))\n\n#endif\n\n\n\n/*\n\n * You may choose to pre-set the hash table (might be faster on some\n\n * modern cpus and large (>>64k) blocks, and also makes compression\n\n * deterministic/repeatable when the configuration otherwise is the same).\n\n */\n\n#ifndef INIT_HTAB\n\n# define INIT_HTAB 0\n\n#endif\n\n\n\n/*\n\n * Avoid assigning values to errno variable? for some embedding purposes\n\n * (linux kernel for example), this is necessary. NOTE: this breaks\n\n * the documentation in lzf.h. Avoiding errno has no speed impact.\n\n */\n\n#ifndef AVOID_ERRNO\n\n# define AVOID_ERRNO 0\n\n#endif\n\n\n\n/*\n\n * Whether to pass the LZF_STATE variable as argument, or allocate it\n\n * on the stack. For small-stack environments, define this to 1.\n\n * NOTE: this breaks the prototype in lzf.h.\n\n */\n\n#ifndef LZF_STATE_ARG\n\n# define LZF_STATE_ARG 0\n\n#endif\n\n\n\n/*\n\n * Whether to add extra checks for input validity in lzf_decompress\n\n * and return EINVAL if the input stream has been corrupted. This\n\n * only shields against overflowing the input buffer and will not\n\n * detect most corrupted streams.\n\n * This check is not normally noticeable on modern hardware\n\n * (<1% slowdown), but might slow down older cpus considerably.\n\n */\n\n#ifndef CHECK_INPUT\n\n# define CHECK_INPUT 1\n\n#endif\n\n\n\n/*\n\n * Whether to store pointers or offsets inside the hash table. On\n\n * 64 bit architetcures, pointers take up twice as much space,\n\n * and might also be slower. Default is to autodetect.\n\n */\n\n/*#define LZF_USER_OFFSETS autodetect */\n\n\n\n/*****************************************************************************/\n\n/* nothing should be changed below */\n\n\n\n#ifdef __cplusplus\n\n# include <cstring>\n\n# include <climits>\n\nusing namespace std;\n\n#else\n\n# include <string.h>\n\n# include <limits.h>\n\n#endif\n\n\n\n#ifndef LZF_USE_OFFSETS\n\n# if defined (WIN32)\n\n#  define LZF_USE_OFFSETS defined(_M_X64)\n\n# else\n\n#  if __cplusplus > 199711L\n\n#   include <cstdint>\n\n#  else\n\n#   include <stdint.h>\n\n#  endif\n\n#  define LZF_USE_OFFSETS (UINTPTR_MAX > 0xffffffffU)\n\n# endif\n\n#endif\n\n\n\ntypedef unsigned char u8;\n\n\n\n#if LZF_USE_OFFSETS\n\n# define LZF_HSLOT_BIAS ((const u8 *)in_data)\n\n  typedef unsigned int LZF_HSLOT;\n\n#else\n\n# define LZF_HSLOT_BIAS 0\n\n  typedef const u8 *LZF_HSLOT;\n\n#endif\n\n\n\ntypedef LZF_HSLOT LZF_STATE[1 << (HLOG)];\n\n\n\n#if !STRICT_ALIGN\n\n/* for unaligned accesses we need a 16 bit datatype. */\n\n# if USHRT_MAX == 65535\n\n    typedef unsigned short u16;\n\n# elif UINT_MAX == 65535\n\n    typedef unsigned int u16;\n\n# else\n\n#  undef STRICT_ALIGN\n\n#  define STRICT_ALIGN 1\n\n# endif\n\n#endif\n\n\n\n#if ULTRA_FAST\n\n# undef VERY_FAST\n\n#endif\n\n\n\n#endif\n\n\n", "/*\n\n * Copyright (c) 2006      Stefan Traby <stefan@hello-penguin.com>\n\n * \n\n * Redistribution and use in source and binary forms, with or without modifica-\n\n * tion, are permitted provided that the following conditions are met:\n\n * \n\n *   1.  Redistributions of source code must retain the above copyright notice,\n\n *       this list of conditions and the following disclaimer.\n\n * \n\n *   2.  Redistributions in binary form must reproduce the above copyright\n\n *       notice, this list of conditions and the following disclaimer in the\n\n *       documentation and/or other materials provided with the distribution.\n\n * \n\n * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR IMPLIED\n\n * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MER-\n\n * CHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  IN NO\n\n * EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPE-\n\n * CIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,\n\n * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;\n\n * OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,\n\n * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTH-\n\n * ERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED\n\n * OF THE POSSIBILITY OF SUCH DAMAGE.\n\n *\n\n * Alternatively, the contents of this file may be used under the terms of\n\n * the GNU General Public License (\"GPL\") version 2 or any later version,\n\n * in which case the provisions of the GPL are applicable instead of\n\n * the above. If you wish to allow the use of your version of this file\n\n * only under the terms of the GPL and not to allow others to use your\n\n * version of this file under the BSD license, indicate your decision\n\n * by deleting the provisions above and replace them with the notice\n\n * and other provisions required by the GPL. If you do not delete the\n\n * provisions above, a recipient may use your version of this file under\n\n * either the BSD or the GPL.\n\n */\n\n\n\n#include \"config.h\"\n\n#include <stdio.h>\n\n#include <string.h>\n\n#include <stdlib.h>\n\n#include <unistd.h>\n\n#include <sys/types.h>\n\n#include <sys/stat.h>\n\n#include <fcntl.h>\n\n#include <errno.h>\n\n#include <limits.h>\n\n#include \"lzf.h\"\n\n\n\n#ifdef HAVE_GETOPT_H\n\n# include <getopt.h>\n\n#endif\n\n\n\n#define BLOCKSIZE (1024 * 64 - 1)\n\n#define MAX_BLOCKSIZE BLOCKSIZE\n\n\n\ntypedef unsigned char u8;\n\n\n\nstatic off_t nr_read, nr_written;\n\n\n\nstatic const char *imagename;\n\nstatic enum { compress, uncompress, lzcat } mode = compress;\n\nstatic int verbose = 0;\n\nstatic int force = 0;\n\nstatic int raw = 0;\n\nstatic long blocksize = BLOCKSIZE;\n\n\n\n#ifdef HAVE_GETOPT_LONG\n\n\n\n  struct option longopts[] = {\n\n    {\"compress\", 0, 0, 'c'},\n\n    {\"decompress\", 0, 0, 'd'},\n\n    {\"uncompress\", 0, 0, 'd'},\n\n    {\"force\", 0, 0, 'f'},\n\n    {\"help\", 0, 0, 'h'},\n\n    {\"verbose\", 0, 0, 'v'},\n\n    {\"blocksize\", 1, 0, 'b'},\n\n    {\"raw\", 1, 0, 'r'},\n\n    {0, 0, 0, 0}\n\n  };\n\n\n\n  static const char *opt =\n\n    \"-c --compress    compress\\n\"\n\n    \"-d --decompress  decompress\\n\"\n\n    \"-f --force       force overwrite of output file\\n\"\n\n    \"-h --help        give this help\\n\"\n\n    \"-v --verbose     verbose mode\\n\"\n\n    \"-b # --blocksize # set blocksize\\n\"\n\n    \"-r --raw         raw mode\\n\"\n\n    \"\\n\";\n\n\n\n#else\n\n\n\n  static const char *opt =\n\n    \"-c   compress\\n\"\n\n    \"-d   decompress\\n\"\n\n    \"-f   force overwrite of output file\\n\"\n\n    \"-h   give this help\\n\"\n\n    \"-v   verbose mode\\n\"\n\n    \"-b # set blocksize\\n\"\n\n    \"-r   raw mode\\n\"\n\n    \"\\n\";\n\n\n\n#endif\n\n\n\nstatic void\n\nusage (int rc)\n\n{\n\n  fprintf (stderr, \"\\n\"\n\n           \"lzf, a very lightweight compression/decompression utility written by Stefan Traby.\\n\"\n\n           \"uses liblzf written by Marc Lehmann <schmorp@schmorp.de> You can find more info at\\n\"\n\n           \"http://liblzf.plan9.de/\\n\"\n\n           \"\\n\"\n\n           \"usage: lzf [-dufhvbr] [file ...]\\n\"\n\n           \"       unlzf [file ...]\\n\"\n\n           \"       lzcat [file ...]\\n\"\n\n           \"\\n%s\",\n\n           opt);\n\n\n\n  exit (rc);\n\n}\n\n\n\nstatic inline ssize_t\n\nrread (int fd, void *buf, size_t len)\n\n{\n\n  ssize_t rc = 0, offset = 0;\n\n  char *p = buf;\n\n\n\n  while (len && (rc = read (fd, &p[offset], len)) > 0)\n\n    {\n\n      offset += rc;\n\n      len -= rc;\n\n    }\n\n\n\n  nr_read += offset;\n\n\n\n  if (rc < 0)\n\n    return rc;\n\n\n\n  return offset;\n\n}\n\n\n\n/* returns 0 if all written else -1 */\n\nstatic inline ssize_t\n\nwwrite (int fd, void *buf, size_t len)\n\n{\n\n  ssize_t rc;\n\n  char *b = buf;\n\n  size_t l = len;\n\n\n\n  while (l)\n\n    {\n\n      rc = write (fd, b, l);\n\n      if (rc < 0)\n\n        {\n\n          fprintf (stderr, \"%s: write error: \", imagename);\n\n          perror (\"\");\n\n          return -1;\n\n        }\n\n\n\n      l -= rc;\n\n      b += rc;\n\n    }\n\n\n\n  nr_written += len;\n\n  return 0;\n\n}\n\n\n\n/*\n\n * Anatomy: an lzf file consists of any number of blocks in the following format:\n\n *\n\n * \\x00   EOF (optional)\n\n * \"ZV\\0\" 2-byte-usize <uncompressed data>\n\n * \"ZV\\1\" 2-byte-csize 2-byte-usize <compressed data>\n\n * \"ZV\\2\" 4-byte-crc32-0xdebb20e3 (NYI)\n\n */\n\n\n\n\n\n#define TYPE0_HDR_SIZE 5\n\n#define TYPE1_HDR_SIZE 7\n\n#define MAX_HDR_SIZE 7\n\n#define MIN_HDR_SIZE 5\n\n\n\nstatic int\n\ncompress_fd (int from, int to)\n\n{\n\n  ssize_t us, cs, len;\n\n  u8 buf1[MAX_BLOCKSIZE + MAX_HDR_SIZE + 16];\n\n  u8 buf2[MAX_BLOCKSIZE + MAX_HDR_SIZE + 16];\n\n  u8 *header;\n\n\n\n  nr_read = nr_written = 0;\n\n  while ((us = rread (from, &buf1[MAX_HDR_SIZE], blocksize)) > 0)\n\n    {\n\n      cs = lzf_compress (&buf1[MAX_HDR_SIZE], us, &buf2[MAX_HDR_SIZE], us > 4 ? us - 4 : us);\n\n      if (cs)\n\n        {\n\n          header = &buf2[MAX_HDR_SIZE - TYPE1_HDR_SIZE];\n\n          header[0] = 'Z';\n\n          header[1] = 'V';\n\n          header[2] = 1;\n\n          header[3] = cs >> 8;\n\n          header[4] = cs & 0xff;\n\n          header[5] = us >> 8;\n\n          header[6] = us & 0xff;\n\n          len = cs + TYPE1_HDR_SIZE;\n\n        }\n\n      else\n\n        {                       // write uncompressed\n\n          header = &buf1[MAX_HDR_SIZE - TYPE0_HDR_SIZE];\n\n          header[0] = 'Z';\n\n          header[1] = 'V';\n\n          header[2] = 0;\n\n          header[3] = us >> 8;\n\n          header[4] = us & 0xff;\n\n          len = us + TYPE0_HDR_SIZE;\n\n        }\n\n      if (raw)\n\n        {\n\n          header = &buf2[MAX_HDR_SIZE]; \n\n          len = cs;\n\n        }\n\n      if (wwrite (to, header, len) == -1)\n\n        return -1;\n\n    }\n\n\n\n  return 0;\n\n}\n\n\n\nstatic int\n\nuncompress_fd (int from, int to)\n\n{\n\n  u8 header[MAX_HDR_SIZE];\n\n  u8 buf1[MAX_BLOCKSIZE + MAX_HDR_SIZE + 16];\n\n  u8 buf2[MAX_BLOCKSIZE + MAX_HDR_SIZE + 16];\n\n  u8 *p;\n\n  int l, rd;\n\n  ssize_t rc, cs, us, bytes, over = 0;\n\n\n\n  nr_read = nr_written = 0;\n\n  while (1)\n\n    {\n\n\n\n      if (raw) \n\n        {\n\n          rc = rread (from, buf1, sizeof(buf1));\n\n          if (rc < 0)\n\n            {\n\n              fprintf (stderr, \"%s: read error: \", imagename);\n\n              perror (\"\");\n\n              return -1;\n\n            }\n\n          l = 0;\n\n          bytes = rc;\n\n        }\n\n      else\n\n        {\n\n          rc = rread (from, header + over, MAX_HDR_SIZE - over);\n\n          if (rc < 0)\n\n            {\n\n              fprintf (stderr, \"%s: read error: \", imagename);\n\n              perror (\"\");\n\n              return -1;\n\n            }\n\n\n\n          rc += over;\n\n          over = 0;\n\n          if (!rc || header[0] == 0)\n\n            return 0;\n\n\n\n          if (rc < MIN_HDR_SIZE || header[0] != 'Z' || header[1] != 'V')\n\n            {\n\n              fprintf (stderr, \"%s: invalid data stream - magic not found or short header\\n\", imagename);\n\n              return -1;\n\n            }\n\n\n\n          switch (header[2])\n\n            {\n\n              case 0:\n\n                cs = -1;\n\n                us = (header[3] << 8) | header[4];\n\n                p = &header[TYPE0_HDR_SIZE];\n\n                break;\n\n              case 1:\n\n                if (rc < TYPE1_HDR_SIZE)\n\n                  {\n\n                    goto short_read;\n\n                  }\n\n                cs = (header[3] << 8) | header[4];\n\n                us = (header[5] << 8) | header[6];\n\n                p = &header[TYPE1_HDR_SIZE];\n\n                break;\n\n              default:\n\n                fprintf (stderr, \"%s: unknown blocktype\\n\", imagename);\n\n                return -1;\n\n            }\n\n\n\n          bytes = cs == -1 ? us : cs;\n\n          l = &header[rc] - p;\n\n\n\n          if (l > 0)\n\n            memcpy (buf1, p, l);\n\n\n\n          if (l > bytes)\n\n            {\n\n              over = l - bytes;\n\n              memmove (header, &p[bytes], over);\n\n            }\n\n        }\n\n\n\n      p = &buf1[l];\n\n      rd = bytes - l;\n\n      if (rd > 0)\n\n        if ((rc = rread (from, p, rd)) != rd)\n\n          goto short_read;\n\n\n\n      if (cs == -1)\n\n        {\n\n          if (wwrite (to, buf1, us))\n\n            return -1;\n\n        }\n\n      else\n\n        {\n\n          if (lzf_decompress (buf1, cs, buf2, us) != us)\n\n            {\n\n              fprintf (stderr, \"%s: decompress: invalid stream - data corrupted\\n\", imagename);\n\n              return -1;\n\n            }\n\n\n\n          if (wwrite (to, buf2, us))\n\n            return -1;\n\n        }\n\n    }\n\n\n\n  return 0;\n\n\n\nshort_read:\n\n  fprintf (stderr, \"%s: short data\\n\", imagename);\n\n  return -1;\n\n}\n\n\n\nstatic int\n\nopen_out (const char *name)\n\n{\n\n  int fd;\n\n  int m = O_EXCL;\n\n\n\n  if (force)\n\n    m = 0;\n\n\n\n  fd = open (name, O_CREAT | O_WRONLY | O_TRUNC | m, 600);\n\n#if defined(__MINGW32__)\n\n  _setmode(fd, _O_BINARY);\n\n#endif\n\n  return fd;\n\n}\n\n\n\nstatic int\n\ncompose_name (const char *fname, char *oname)\n\n{\n\n  char *p;\n\n\n\n  if (mode == compress)\n\n    {\n\n      if (strlen (fname) > PATH_MAX - 4)\n\n        {\n\n          fprintf (stderr, \"%s: %s.lzf: name too long\", imagename, fname);\n\n          return -1;\n\n        }\n\n\n\n      strcpy (oname, fname);\n\n      strcat (oname, \".lzf\");\n\n    }\n\n  else\n\n    {\n\n      if (strlen (fname) > PATH_MAX)\n\n        {\n\n          fprintf (stderr, \"%s: %s: name too long\\n\", imagename, fname);\n\n          return -1;\n\n        }\n\n\n\n      strcpy (oname, fname);\n\n      p = &oname[strlen (oname)] - 4;\n\n      if (p < oname || strcmp (p, \".lzf\"))\n\n        {\n\n          fprintf (stderr, \"%s: %s: unknown suffix\\n\", imagename, fname);\n\n          return -1;\n\n        }\n\n\n\n      *p = 0;\n\n    }\n\n\n\n  return 0;\n\n}\n\n\n\nstatic int\n\nrun_file (const char *fname)\n\n{\n\n  int fd, fd2;\n\n  int rc;\n\n  struct stat mystat;\n\n  char oname[PATH_MAX + 1];\n\n\n\n  if (mode != lzcat)\n\n    if (compose_name (fname, oname))\n\n      return -1;\n\n\n\n#if !defined(__MINGW32__)\n\n  rc = lstat (fname, &mystat);\n\n#else\n\n  rc = stat (fname, &mystat);\n\n#endif\n\n  fd = open (fname, O_RDONLY);\n\n#if defined(__MINGW32__)\n\n  _setmode(fd, _O_BINARY);\n\n#endif\n\n  if (rc || fd == -1)\n\n    {\n\n      fprintf (stderr, \"%s: %s: \", imagename, fname);\n\n      perror (\"\");\n\n      return -1;\n\n    }\n\n\n\n  if (!S_ISREG (mystat.st_mode))\n\n    {\n\n      fprintf (stderr, \"%s: %s: not a regular file.\\n\", imagename, fname);\n\n      close (fd);\n\n      return -1;\n\n    }\n\n\n\n  if (mode == lzcat)\n\n    {\n\n      rc = uncompress_fd (fd, 1);\n\n      close (fd);\n\n      return rc;\n\n    }\n\n\n\n  fd2 = open_out (oname);\n\n  if (fd2 == -1)\n\n    {\n\n      fprintf (stderr, \"%s: %s: \", imagename, oname);\n\n      perror (\"\");\n\n      close (fd);\n\n      return -1;\n\n    }\n\n\n\n  if (mode == compress)\n\n    {\n\n      rc = compress_fd (fd, fd2);\n\n      if (!rc && verbose)\n\n        fprintf (stderr, \"%s:  %5.1f%% -- replaced with %s\\n\",\n\n                 fname, nr_read == 0 ? 0 : 100.0 - nr_written / ((double) nr_read / 100.0), oname);\n\n    }\n\n  else\n\n    {\n\n      rc = uncompress_fd (fd, fd2);\n\n      if (!rc && verbose)\n\n        fprintf (stderr, \"%s:  %5.1f%% -- replaced with %s\\n\",\n\n                 fname, nr_written == 0 ? 0 : 100.0 - nr_read / ((double) nr_written / 100.0), oname);\n\n    }\n\n\n\n#if !defined(__MINGW32__)\n\n  fchmod (fd2, mystat.st_mode);\n\n#else\n\n  chmod (oname, mystat.st_mode);\n\n#endif\n\n  close (fd);\n\n  close (fd2);\n\n\n\n  if (!rc)\n\n    unlink (fname);\n\n\n\n  return rc;\n\n}\n\n\n\nint\n\nmain (int argc, char *argv[])\n\n{\n\n  char *p = argv[0];\n\n  int optc;\n\n  int rc = 0;\n\n\n\n  errno = 0;\n\n  p = getenv (\"LZF_BLOCKSIZE\");\n\n  if (p)\n\n    {\n\n      blocksize = strtoul (p, 0, 0);\n\n      if (errno || !blocksize || blocksize > MAX_BLOCKSIZE)\n\n        blocksize = BLOCKSIZE;\n\n    }\n\n\n\n  p = strrchr (argv[0], '/');\n\n  imagename = p ? ++p : argv[0];\n\n\n\n  if (!strncmp (imagename, \"un\", 2) || !strncmp (imagename, \"de\", 2))\n\n    mode = uncompress;\n\n\n\n  if (strstr (imagename, \"cat\"))\n\n    mode = lzcat;\n\n\n\n#ifdef HAVE_GETOPT_LONG\n\n  while ((optc = getopt_long (argc, argv, \"cdfhvb:r\", longopts, 0)) != -1)\n\n#else\n\n  while ((optc = getopt (argc, argv, \"cdfhvb:r\")) != -1)\n\n#endif\n\n    {\n\n      switch (optc)\n\n        {\n\n          case 'c':\n\n            mode = compress;\n\n            break;\n\n          case 'd':\n\n            mode = uncompress;\n\n            break;\n\n          case 'f':\n\n            force = 1;\n\n            break;\n\n          case 'h':\n\n            usage (0);\n\n            break;\n\n          case 'v':\n\n            verbose = 1;\n\n            break;\n\n          case 'b':\n\n            errno = 0;\n\n            blocksize = strtoul (optarg, 0, 0);\n\n            if (errno || !blocksize || blocksize > MAX_BLOCKSIZE)\n\n              blocksize = BLOCKSIZE;\n\n            break;\n\n          case 'r':\n\n            raw = 1;\n\n            break;\n\n          default:\n\n            usage (1);\n\n            break;\n\n        }\n\n    }\n\n\n\n  if (optind == argc)\n\n    {                           // stdin stdout\n\n      if (!force)\n\n        {\n\n          if ((mode == uncompress || mode == lzcat) && isatty (0))\n\n            {\n\n              fprintf (stderr, \"%s: compressed data not read from a terminal. Use -f to force decompression.\\n\", imagename);\n\n              exit (1);\n\n            }\n\n          if (mode == compress && isatty (1))\n\n            {\n\n              fprintf (stderr, \"%s: compressed data not written to a terminal. Use -f to force compression.\\n\", imagename);\n\n              exit (1);\n\n            }\n\n        }\n\n\n\n      if (mode == compress)\n\n        rc = compress_fd (0, 1);\n\n      else\n\n        rc = uncompress_fd (0, 1);\n\n\n\n      exit (rc ? 1 : 0);\n\n    }\n\n\n\n  while (optind < argc)\n\n    rc |= run_file (argv[optind++]);\n\n\n\n  exit (rc ? 1 : 0);\n\n}\n\n\n", "#include <stdio.h>\n\n#include <stdlib.h>\n\n\n\nint main (int argc, char *argv[]) {\n\n\n\n  int i;\n\n  char *p;\n\n\n\n\n\n  for (i = 1; i < argc; i++) {\n\n    p = getenv (argv[i]);\n\n    if (p == NULL) {\n\n      printf (\"%s is not set\\n\", argv[i]);\n\n    } else {\n\n      printf  (\"%s is set to %s\\n\", argv[i], p);\n\n    }\n\n  }\n\n\n\n  exit (0);\n\n}\n\n\n", "#include \"stdio.h\"\n\n#include \"stdlib.h\"\n\n#include <sys/types.h>\n\n#include <sys/time.h>\n\n#include <unistd.h>\n\n#include <errno.h>\n\n#include <string.h>\n\n#include \"malloc.h\"\n\n\n\nstatic unsigned long allocated;\n\n\n\nstatic void *my_malloc(size_t size) {\n\n\n\n  allocated = allocated + size;\n\n  return malloc(size);\n\n}\n\n\n\n\n\nstatic size_t put_stats (int put_stats) {\n\n  struct mallinfo info;\n\n  pid_t pid;\n\n  FILE *file;\n\n  char buffer[1024];\n\n  char vmtext[1024];\n\n  const char *crit = \"VmSize:\";\n\n  long int vmsize, mfree;\n\n\n\n  /* Get virtual size from /proc/pid/stat line \"VmSize:\" */\n\n  pid = getpid();\n\n  sprintf(buffer, \"/proc/%d/status\", (int)pid);\n\n  file = fopen(buffer, \"r\");\n\n  if (file == NULL) {\n\n    perror(\"fopen\");\n\n    exit(1);\n\n  }\n\n  for (;;) {\n\n    if (fscanf(file, \"%s%s\", buffer, vmtext) <= 0) {\n\n      perror(\"scanf\");\n\n      exit(1);\n\n    }\n\n    if (strncmp (buffer, crit, strlen(crit) + 1) == 0) break;\n\n  }\n\n  fclose (file);\n\n  vmsize = strtol (vmtext, NULL, 10);\n\n\n\n  /* Mallinfo */\n\n  info = mallinfo();\n\n#ifdef DEBUG\n\n  printf(\"Mallinfo\\n\");\n\n  printf(\"Arena %d\\n\", info.arena);\n\n  printf(\"Free chunks %d\\n\", info.ordblks);\n\n  printf(\"Fastbin blocks %d\\n\", info.smblks);\n\n  printf(\"Mmapped regions %d\\n\", info.hblks);\n\n  printf(\"Space in mmapped regions %d\\n\", info.hblkhd);\n\n  printf(\"Max allocated space %d\\n\", info.usmblks);\n\n  printf(\"Space available in freed fastbin blocks %d\\n\", info.fsmblks);\n\n  printf(\"Total allocated space %d\\n\", info.uordblks);\n\n  printf(\"Total free space %d\\n\", info.fordblks);\n\n  printf(\"Top-most, releasable space %d\\n\", info.keepcost);\n\n#endif\n\n\n\n  /* Malloc_stats */\n\n  if (put_stats) {\n\n    malloc_stats();\n\n  }\n\n\n\n  mfree = (long)info.fordblks;\n\n  return (size_t)vmsize * 1024 - mfree;\n\n}\n\n\n\n#define MAX_MALLOC (10 * 1024 * 1024)\n\n#define MAX_LEAK (10 * 1024)\n\n#define NB_SLOTS 100\n\nvoid *slots[NB_SLOTS];\n\nstatic void alloc (int leak) {\n\n  int i;\n\n  size_t sizer;\n\n  char *p;\n\n\n\n  sizer = random();\n\n  /* A hundredth of allocs leak */\n\n   if (leak && (random() < RAND_MAX / 100)) {\n\n    /* Leak by less than 10KB, store amount */\n\n    sizer = (size_t) ((float)sizer / (float)RAND_MAX * (float)MAX_LEAK);\n\n    p = my_malloc(sizer);\n\n  } else {\n\n    /* Malloc less than 3MB, free first */\n\n    sizer = (size_t) ((float)sizer / (float)RAND_MAX * (float)MAX_MALLOC);\n\n    i = (int) ((float)sizer / (float)RAND_MAX * (float)NB_SLOTS);\n\n    if (i >= NB_SLOTS) i = NB_SLOTS - 1;\n\n    if (slots[i] != NULL) free(slots[i]);\n\n    p = malloc(sizer);\n\n    slots[i] = p;\n\n  }\n\n  if (p == NULL) {\n\n    perror(\"malloc\");\n\n    exit(1);\n\n  }\n\n\n\n}\n\n\n\n\n\nint main (int argc, char *argv[]) {\n\n\n\n  int leak;\n\n  int j, i;\n\n  struct timeval tv;\n\n  size_t size1, size2;\n\n  long delta;\n\n  char *p;\n\n\n\n\n\n  /* Init random */\n\n  printf (\"My pid is %d\\n\", getpid());\n\n  leak = ((argc == 2) && (strcmp (argv[1], \"leak\") == 0));\n\n  if (leak) printf (\"Leaking...\\n\");\n\n  sleep (5);\n\n  gettimeofday (&tv, NULL);\n\n  srandom (tv.tv_usec);\n\n\n\n  /* Init slots */\n\n  for (i = 0; i < NB_SLOTS; i++) slots[i] = NULL;\n\n\n\n  /* 128M allocated and freed to set brk/mmap thresholdt,\n\n   * then 1GB allocated, \n\n   * then one alloc to tare\n\n   */\n\n  printf (\"Start\\n\");\n\n  size1 = put_stats(0);\n\n  printf (\"\\n\");\n\n  p = malloc(128 * 1024 * 1024);\n\n  free(p);\n\n  (void) malloc (1024 * 1024 * 1024);\n\n  alloc(leak);\n\n  allocated = 0L;\n\n\n\n  /* Initial (reference) state */\n\n  printf (\"Initial\\n\");\n\n  size1 = put_stats(1);\n\n  printf (\"\\n\");\n\n\n\n  for (j = 0; j < 100; j++) {\n\n    /* Loop on malloc and leaks */\n\n    for (i = 0; i < 5000; i++) {\n\n      alloc(leak);\n\n    }\n\n    size2 = put_stats(0);\n\n    if (i == 0) size1 = size2;\n\n    sleep(2);\n\n  }\n\n\n\n  /* Final */\n\n  /* Garbage-collect mallocs that are not leaks */\n\n  printf(\"Final\\n\");\n\n  for (i = 0; i < NB_SLOTS; i++) {\n\n    if (slots[i] != NULL) free(slots[i]);\n\n  }\n\n  size2 = put_stats(1);\n\n\n\n  /* End to end stats */\n\n  delta = (long)size2-(long)size1;\n\n  printf(\"Delta size %ld\\n\", delta);\n\n  printf(\"Allocated %lu\\n\", allocated);\n\n  printf(\"Error %ld\\n\", delta-(long)allocated);\n\n\n\n  sleep(5);\n\n  exit(0);\n\n} \n\n\n", "#include <stdio.h>\n\n#include <stdlib.h>\n\n#include <X11/Xlib.h>\n\n\n\nchar *prog_name;\n\n\n\nstatic void usage (void) {\n\n  printf (\"Usage : %s <display> { <font> }\\n\", prog_name);\n\n}\n\n\n\nstatic int result;\n\nstatic void error (const char *msg, int fatal) {\n\n  fprintf (stderr, \"ERROR: %s.\\n\", msg);\n\n  result = 1;\n\n  if (fatal) {\n\n    usage();\n\n    exit (result);\n\n  }\n\n}\n\n\n\nint main (int argc, char *argv[]) {\n\n  /* Error message */\n\n  char msg [1024];\n\n  /* X11 display */\n\n  Display *disp;\n\n  /* Index of font argument */\n\n  int i;\n\n  /* Font stuff */\n\n  XFontSet font_set;\n\n  int missing_count;\n\n  char **font_names;\n\n  XFontStruct **fonts, *font;\n\n  int res;\n\n\n\n  /* Check syntax: 2 or more arguments: <diplay> and <font>... */\n\n  prog_name = argv[0];\n\n  if (argc < 3) {\n\n    error (\"Invalid argument\", True);\n\n  }\n\n\n\n  /* Open display */\n\n  disp = XOpenDisplay (argv[1]);\n\n  if (disp == NULL) {\n\n    sprintf (msg, \"Can't open display %s\", argv[1]);\n\n    error (msg, True);\n\n  }\n\n\n\n  /* Loop on all font names */\n\n  result = 0;\n\n  for (i = 2; i < argc; i++) {\n\n\n\n    /* Create font set */\n\n    font_set = XCreateFontSet (disp, argv[i], &font_names, &missing_count, NULL);\n\n    if (font_set == NULL) {\n\n      sprintf (msg, \"Can't create font set of %s\", argv[i]);\n\n      error (msg, False);\n\n      continue;\n\n    }\n\n    if (missing_count != 0)  {\n\n      int j;\n\n      for (j = 0; j < missing_count; j++) {\n\n         printf (\"Missing font %s for %s.\\n\", font_names[j], argv[i]);\n\n      }\n\n    }\n\n\n\n    /* Load font characteristics */\n\n    res = XFontsOfFontSet (font_set, &fonts, &font_names);\n\n    if (res == -1) {\n\n      sprintf (msg, \"Cannot get fonts from set for %s\", argv[i]);\n\n      error (msg, False);\n\n      XFreeFontSet (disp, font_set);\n\n      continue;\n\n    }\n\n\n\n    /* Load font */\n\n    font = XLoadQueryFont (disp, argv[i]);\n\n    if (font == NULL) {\n\n      sprintf  (msg, \"Cannot query font %s\", argv[i]);\n\n      error (msg, False);\n\n      XFreeFontSet (disp, font_set);\n\n    }\n\n\n\n    printf (\"Font %s is %dx%d-%d\\n\", argv[i],\n\n        (int)font->max_bounds.width,\n\n        (int)(font->ascent + font->descent),\n\n        (int)font->ascent);\n\n\n\n    /* Done for this font */\n\n    XFreeFontSet (disp, font_set);\n\n    XFreeFont (disp, font);\n\n  }\n\n\n\n  /* Done */\n\n  (void) XCloseDisplay (disp);\n\n  exit (result);\n\n\n\n}\n\n\n", "#include <stdio.h>\n\n#include <stdlib.h>\n\n#include \"adjtime_call.h\"\n\n\n\nint main(void) {\n\n  int i, j;\n\n  struct timeval t1, t2;\n\n  float printed_delta;\n\n\n\n  for (i = 0; i < 10; i++) {\n\n    t1.tv_sec = i;\n\n    t1.tv_usec = 0;\n\n    for (j = 0; j < 100; j++)\n\n      if (adjtime_call(&t1, &t2) == -1)\n\n        exit(0);\n\n    printed_delta = t2.tv_sec + (float) t2.tv_usec / 1000000.0;\n\n    printf (\"remaining (%3.06f)\\n\", printed_delta);\n\n  }\n\n\n\n\n\n  for (i = -10; i <= 0; i++) {\n\n    t1.tv_sec = i;\n\n    t1.tv_usec = 0;\n\n    for (j = 0; j < 100; j++)\n\n      if (adjtime_call(&t1, &t2) == -1)\n\n        exit(0);\n\n    printed_delta = t2.tv_sec + (float) t2.tv_usec / 1000000.0;\n\n    printf (\"remaining (%3.06f)\\n\", printed_delta);\n\n  }\n\n  exit(0);\n\n}\n\n\n", "#include <sys/time.h>\n\n\n\n\n\n/*\n\nif new_delta is non NULL -> change adjustement\n\nif new_delta is NULL -> do not change adjustement\n\nif old_delta is non NULL -> fill it with current adjustement\n\n\n\nreturns 0 if OK and -1 if error\n\n*/\n\n\n\nextern int adjtime_call (struct timeval *new_delta, struct timeval *old_delta);\n\n\n", "#include <errno.h>\n\n#include <stdio.h>\n\n#include \"adjtime_call.h\"\n\n\n\n\n\nextern int adjtime_call (struct timeval *new_delta, struct timeval *old_delta) {\n\n  struct timeval loc_delta;\n\n\n\n  /* New delta to set or read only */\n\n  if (new_delta != (struct timeval *)NULL) {\n\n    /* New delta to set */\n\n    loc_delta = *new_delta;\n\n    if ( (loc_delta.tv_sec == 0) && (loc_delta.tv_usec == 0) ) {\n\n        /* (0, 0) does not affect! trick */\n\n        loc_delta.tv_usec = 1;\n\n    }\n\n  } else {\n\n    /* To read value without affecting current delta */\n\n    loc_delta.tv_sec = 0;\n\n    loc_delta.tv_usec = 0;\n\n  }\n\n\n\n  if (adjtime (&loc_delta, old_delta) != 0) {\n\n    perror(\"adjtime\");\n\n    return (-1);\n\n  }\n\n\n\n  /* Restore adjustement if read only */\n\n  if (new_delta == (struct timeval *)NULL) {\n\n    if (adjtime (old_delta, (struct timeval*)NULL) != 0) {\n\n      perror(\"adjtime\");\n\n      return (-1);\n\n    }\n\n  }\n\n  return (0);\n\n\n\n}\n\n\n", "#include <stdio.h>\n\n#include <stdlib.h>\n\n\n\n#include \"adjtime_call.h\"\n\n\n\nint main(int argc, char *argv[]) {\n\n\n\n  struct timeval delta, old_delta, *p_delta;\n\n\n\n  float printed_delta;\n\n\n\n  if (argc > 2) {\n\n    fprintf (stderr, \"Syntax error. Usage : adjtime [ <secs> ]\\n\");\n\n    exit (1);\n\n  }\n\n\n\n  if (argc == 2) {\n\n    p_delta = &delta;\n\n    sscanf (argv[1], \"%f\", &printed_delta);\n\n    delta.tv_sec = (time_t)printed_delta;\n\n    delta.tv_usec = (printed_delta - (float) delta.tv_sec) * 1000000;\n\n    printf (\"adjtime (%d.%06d)\\n\", (int)delta.tv_sec, abs((int)delta.tv_usec));\n\n  } else {\n\n    p_delta = (struct timeval*) NULL;\n\n  }\n\n\n\n  if (adjtime_call (p_delta, &old_delta) != 0) {\n\n    exit (1);\n\n  } else {\n\n    printed_delta = old_delta.tv_sec + (float) old_delta.tv_usec / 1000000.0;\n\n    printf (\"remaining (%3.06f)\\n\", printed_delta);\n\n  }\n\n\n\n  exit (0);\n\n\n\n}\n", "#include <time.h>\n\n#include <string.h>\n\n#include <stdio.h>\n\n#include <stdlib.h>\n\n\n\n#include \"socket.h\"\n\n#include \"timeval.h\"\n\n\n\n#define MSG_LEN 30\n\nstatic char msg[MSG_LEN];\n\n\n\n\n\nstatic char week_day[7][4] = {\"DIM\", \"LUN\", \"MAR\", \"MER\", \"JEU\", \"VEN\", \"SAM\"};\n\n\n\nstatic void print_time (timeout_t *p_time) {\n\n  char *date_str;\n\n  char buf[50];\n\n  struct tm *date_struct;\n\n\n\n  date_str = ctime ( (time_t*) &(p_time->tv_sec));\n\n  date_struct = gmtime ( (time_t*) &(p_time->tv_sec));\n\n\n\n\n\n  /* msg[0..2] <- day_name */\n\n  msg[ 0] = week_day[date_struct->tm_wday][0];\n\n  msg[ 1] = week_day[date_struct->tm_wday][1];\n\n  msg[ 2] = week_day[date_struct->tm_wday][2];\n\n\n\n  msg[ 3] = ' ';\n\n\n\n  /* msg[4..5] <- jj */\n\n  sprintf (buf, \"%02d\", date_struct->tm_mday);\n\n  msg[ 4] = buf[0];\n\n  msg[ 5] = buf[1];\n\n  msg[ 6] = '/';\n\n  /* msg[7..8] <- mm */\n\n  sprintf (buf, \"%02d\", date_struct->tm_mon+1);\n\n  msg[ 7] = buf[0];\n\n  msg[ 8] = buf[1];\n\n  msg[ 9] = '/';\n\n  /* msg[10..11] <- yy */\n\n  msg[10] = date_str[22];\n\n  msg[11] = date_str[23];\n\n\n\n  msg[12] = ' ';\n\n  msg[13] = ' ';\n\n\n\n  /* msg[14..21] <- hh:mm:ss */\n\n  strncpy (&(msg[14]), &(date_str[11]), 8);\n\n\n\n  /* msg 22..28 <- .millisecs */\n\n  msg[22] = '.';\n\n  sprintf (&msg[23], \"%06d\", (int)p_time->tv_usec);\n\n\n\n  msg[29] = '\\0';\n\n\n\n  printf (\"%s\\n\", msg);\n\n  fflush (stdout);\n\n\n\n}\n\n\n\nstatic void usage (void) {\n\n  printf (\"Usage : time_spy\\n\");\n\n  printf (\"or      time_spy -C <udp_port>\\n\");\n\n  printf (\"or      time_spy -S <udp_port> <client_node>\\n\");\n\n}\n\n\n\nstatic void single (void) __attribute__ ((noreturn));\n\nstatic void single (void) {\n\n  timeout_t cur_time, exp_time, delta_time;\n\n  int cr;\n\n\n\n  get_time (&cur_time);\n\n\n\n  exp_time.tv_sec = cur_time.tv_sec + 1;\n\n  exp_time.tv_usec = 0;\n\n\n\n\n\n  for (;;) {\n\n\n\n\n\n    delta_time.tv_sec = exp_time.tv_sec;\n\n    delta_time.tv_usec = exp_time.tv_usec;\n\n    get_time (&cur_time);\n\n    print_time (&cur_time);\n\n    if (sub_time (&delta_time, &cur_time) > 0) {\n\n      cr = select (0, NULL, NULL, NULL, &delta_time);\n\n    } else {\n\n      cr = 0;\n\n    }\n\n    if (cr < 0) {\n\n      perror (\"select\");\n\n    }\n\n    exp_time.tv_sec = exp_time.tv_sec + 1;\n\n  }\n\n}\n\n\n\nstatic void client (char *port_def) __attribute__ ((noreturn));\n\nstatic void client (char *port_def) {\n\n  soc_token soc;\n\n  soc_port port_no;\n\n  char message[500];\n\n  soc_length length;\n\n  timeout_t cur_time;\n\n\n\n  if (soc_open(&soc, udp_socket) != SOC_OK) {\n\n    perror (\"opening socket\\n\");\n\n    exit (1);\n\n  }\n\n\n\n  port_no = atoi(port_def);\n\n  if (port_no <= 0) {\n\n    if (soc_link_service(soc, port_def) != SOC_OK) {\n\n      perror (\"linking socket\\n\");\n\n      exit (1);\n\n    }\n\n  } else {\n\n    if (soc_link_port(soc, port_no) != SOC_OK) {\n\n      perror (\"linking socket\\n\");\n\n      exit (1);\n\n    }\n\n  }\n\n\n\n  printf (\"Client ready.\\n\");\n\n\n\n  for (;;) {\n\n    length = sizeof(message);\n\n    if (soc_receive(soc, message, length, TRUE) <= 0) {\n\n      perror (\"receiving from socket\\n\");\n\n    }\n\n    get_time (&cur_time);\n\n    print_time (&cur_time);\n\n  }\n\n\n\n}\n\n\n\nstatic void server (char *port_def, char *server_node)\n\n                    __attribute__ ((noreturn));\n\nstatic void server (char *port_def, char *server_node) {\n\n  soc_token soc;\n\n  soc_port port_no;\n\n  char message[500];\n\n  soc_length length;\n\n  timeout_t cur_time, exp_time, delta_time;\n\n  int cr;\n\n\n\n  if (soc_open(&soc, udp_socket) != SOC_OK) {\n\n    perror (\"opening socket\\n\");\n\n    exit (1);\n\n  }\n\n\n\n  port_no = atoi(port_def);\n\n  if (port_no <= 0) {\n\n    if (soc_set_dest_name_service(soc, server_node, false, port_def) != SOC_OK) {\n\n      perror (\"setting destination socket\\n\");\n\n      exit (1);\n\n    }\n\n  } else {\n\n    if (soc_set_dest_name_port(soc, server_node, false, port_no) != SOC_OK) {\n\n      perror (\"setting destination socket\\n\");\n\n      exit (1);\n\n    }\n\n  }\n\n\n\n  printf (\"Server ready.\\n\");\n\n  strcpy (message, \"Hello.\");\n\n  length = strlen(message) +1;\n\n\n\n\n\n  get_time (&cur_time);\n\n\n\n  exp_time.tv_sec = cur_time.tv_sec + 1;\n\n  exp_time.tv_usec = 0;\n\n\n\n\n\n  for (;;) {\n\n\n\n\n\n    delta_time.tv_sec = exp_time.tv_sec;\n\n    delta_time.tv_usec = exp_time.tv_usec;\n\n    get_time (&cur_time);\n\n    if (sub_time (&delta_time, &cur_time) > 0) {\n\n      cr = select (0, NULL, NULL, NULL, &delta_time);\n\n    } else {\n\n      cr = 0;\n\n    }\n\n    if (cr < 0) {\n\n      perror (\"select\");\n\n    }\n\n    exp_time.tv_sec = exp_time.tv_sec + 1;\n\n\n\n    if (soc_send(soc, message, length) != SOC_OK) {\n\n      perror (\"sending to socket\\n\");\n\n    }\n\n  }\n\n\n\n\n\n}\n\n\n\n\n\nint main (int argc, char *argv[]) {\n\n\n\n  if (argc == 1) {\n\n    single();\n\n  } else if ((argc == 3) && (strcmp(argv[1], \"-C\") == 0) ) {\n\n    client(argv[2]);\n\n  } else if ((argc == 4) && (strcmp(argv[1], \"-S\") == 0) ) {\n\n    server (argv[2], argv[3]);\n\n  } else {\n\n    usage();\n\n  }\n\n  exit(0);\n\n}\n\n\n", "#include \"stdio.h\"\n\n#include \"stdlib.h\"\n\n#include \"string.h\"\n\n\n\n#define usage(n) { fprintf (stderr, \"Usage : fread_float <file_name> <offset_in_bytes> [ <number> ] [ -d ]\\n\"); \\\n\n                   exit (n); }\n\n\n\nint main (int argc, char *argv[]) {\n\n  int number = 1;\n\n  int double_float = 0;\n\n  long int offset;\n\n  int i;\n\n  float f;\n\n  double d;\n\n  int res;\n\n\n\n  FILE *file;\n\n\n\n  if (argc == 4) {\n\n    if (strcmp(argv[3], \"-d\") == 0) {\n\n      double_float = 1;\n\n    } else {\n\n      number = atoi(argv[3]);\n\n    }\n\n  } else if (argc == 5) {\n\n    if (strcmp(argv[4], \"-d\") == 0) {\n\n      double_float = 1;\n\n      number = atoi(argv[3]);\n\n    } else {\n\n      usage(1);\n\n    }\n\n  } else if (argc != 3) {\n\n    usage(1);\n\n  }\n\n  if (number == 0) {\n\n    usage(1);\n\n  }\n\n  offset = atol(argv[2]);\n\n  if (offset == 0) {\n\n    usage(1);\n\n  }\n\n\n\n  printf (\"Reading %d %s at pos %ld in file %s\\n\",\n\n           number, (double_float ? \"double(s)\" : \"float(s)\"), offset, argv[1]);\n\n\n\n  file = fopen (argv[1], \"r\");\n\n  if (file == (FILE*)NULL) {\n\n    perror (\"fopen\");\n\n    fprintf (stderr, \"cannot open file %s\\n\", argv[1]);\n\n    usage(2);\n\n  }\n\n\n\n  if (fseek (file, offset-1, SEEK_SET) == -1) {\n\n    perror (\"fseek\");\n\n    fprintf (stderr, \"cannot move at pos %ld in file %s\\n\", offset, argv[1]);\n\n    usage(2);\n\n  }\n\n\n\n  for (i = 1; i <= number; i++) {\n\n    if (double_float) {\n\n      res = fread (&d, sizeof(double), 1, file);\n\n    } else {\n\n      res = fread (&f, sizeof(float), 1, file);\n\n    }\n\n    if (res != 1) {\n\n      perror (\"fread\");\n\n      fprintf (stderr, \"cannot read %d %s at pos %ld in file %s\\n\",\n\n               number, (double_float ? \"double(s)\" : \"float(s)\"), offset, argv[1]);\n\n      usage(2);\n\n    }\n\n\n\n    if (double_float) {\n\n      printf (\"%g\\n\", d);\n\n    } else {\n\n      printf (\"%f\\n\", f);\n\n    }\n\n  }\n\n\n\n  exit (0);\n\n\n\n}\n", "#include <stdio.h>\n\n#include <string.h>\n\n#include <stdlib.h>\n\n\n\n#define usage(n) { \\\n\n  fprintf (stderr, \"Usage : flint <float> [ -d ]\\n\"); \\\n\n  fprintf (stderr, \"   or : flint <hex> <hex> <hex> <hex> [ <hex> <hex> <hex> <hex> ]\\n\"); \\\n\n  exit (n); \\\n\n}\n\n\n\nint main (int argc, char *argv[]) {\n\n\n\n  double d;\n\n\n\n  double *dp = &d;\n\n  float  *fp = (float*)&d;\n\n  unsigned char *bp = (unsigned char *)&d;\n\n  int n, i;\n\n  unsigned int u;\n\n\n\n\n\n  if (argc == 2) {\n\n    sscanf (argv[1], \"%f\", fp);\n\n    n = 4;\n\n  } else if (argc == 3) {\n\n    if (strcmp(argv[2], \"-d\") != 0) {\n\n      usage(1);\n\n    }\n\n    sscanf (argv[1], \"%lf\", dp);\n\n    n = 8;\n\n  } else if ( (argc == 5) || (argc == 9) ) {\n\n    n = argc - 1;\n\n    for (i = 1; i <= n; i++, bp++) {\n\n      sscanf (argv[i], \"%x\", &u);\n\n      *bp = (unsigned char) u;\n\n    }\n\n\n\n  } else {\n\n    usage(1);\n\n  }\n\n\n\n  if (argc <= 3) {\n\n    for (i = 1; i <= n; i++, bp++) {\n\n      printf (\"%02X \", (int)*bp);\n\n    }\n\n    printf (\"\\n\");\n\n  } else if (argc == 5) {\n\n    printf (\"%f\\n\", *fp);\n\n  } else {\n\n    printf (\"%g\\n\", *dp);\n\n  }\n\n\n\n  exit (0);\n\n\n\n}\n\n\n\n\n\n\n\n\n\n\n", "#include <stdio.h>\n\n\n\nint main(void) {\n\n  FILE *file;\n\n  float f = 21.0;\n\n  double d = 22.0;\n\n\n\n  file = fopen(\"toto\", \"w\");\n\n  fwrite (&f, sizeof(float), 1, file);\n\n  fwrite (&d, sizeof(double), 1, file);\n\n  return 0;\n\n}\n\n\n", "#ifndef SVN_INCLUDES_H\n\n#define SVN_INCLUDES_H\n\n\n\n/* Includes needed to use svn */\n\n#include <sys/types.h>\n\ntypedef __off64_t off64_t;\n\n\n\n#include <assert.h>\n\n#include <stdlib.h>\n\n\n\n#include <apr_general.h>\n\n#include <apr_pools.h>\n\n#include <apr_time.h>\n\n#include <apr_file_io.h>\n\n#include <apr_signal.h>\n\n\n\n#define APR_WANT_STDIO\n\n#define APR_WANT_STRFUNC\n\n#include <apr_want.h>\n\n\n\n#include <svn_cmdline.h>\n\n#include <svn_types.h>\n\n#include <svn_pools.h>\n\n#include <svn_error.h>\n\n#include <svn_error_codes.h>\n\n#include <svn_path.h>\n\n#include <svn_repos.h>\n\n#include <svn_fs.h>\n\n#include <svn_time.h>\n\n#include <svn_utf.h>\n\n#include <svn_subst.h>\n\n#include <svn_opt.h>\n\n#include <svn_props.h>\n\n#include <svn_diff.h>\n\n#include <svn_xml.h>\n\n#include <svn_client.h>\n\n#include <svn_sorts.h>\n\n#include <svn_compat.h>\n\n\n\n#endif\n\n\n", "#ifndef UTILITIES_H\n\n#define UTILITIES_H\n\n\n\n#include \"boolean.h\"\n\n\n\n/**********************************/\n\n/*** Prototypes for utilities.c ***/\n\n/**********************************/\n\n\n\n/* Defines array size to store URL */\n\n#define PATH_MAX_LEN 1024\n\n#define URL_MAX_LEN (10+256+PATH_MAX_LEN)\n\ntypedef char url_t[URL_MAX_LEN+1];\n\n\n\n/* Defines array size to store date of type '2009-07-20T14:30:17\\0' */\n\n#define DATE_LENGTH 19\n\ntypedef char date_t[DATE_LENGTH+1];\n\n\n\n/* Modes depend from user input arguments */\n\ntypedef enum {URL_MODE, CUR_MODE, ALL_MODE} mode_kind;\n\n\n\n/* Enums for defining path and action type */\n\ntypedef enum {INVALID=0, TRUNK, BRANCH, TAG} label_kind;\n\n\n\n/* Error message in case of fatal error */\n\nextern void error_data (const char *msg, const char *data);\n\n\n\n/* In any kind of fatal error */\n\nextern void error (const char *msg);\n\n\n\n/* Put command line help */\n\nextern void put_help (const char *prog);\n\n\n\n/* Debug */\n\nextern void debug1 (int severity, const char *msg);\n\nextern void debug2 (int severity, const char *msg, const char *data);\n\nextern void debug3 (int severity, const char *msg, const char *data,\n\n                                  const char *extra);\n\n\n\n/* Modifying SVN output date to readable format */\n\nextern void svn_date_to_normal (char *date);\n\n\n\n/* Check that the action is not against a file.\n\n   Function checks number of '/' in key path.\n\n   Return kind of label */\n\nextern label_kind compare_path (const char *path);\n\n\n\n/* Skip info after label (keep name) */\n\nextern void get_node_path (char *string);\n\n\n\n/* Check URL: return addr of label (trunk/tags/branches) */\n\nextern char * url_check (const char *url, boolean allow_trunk);\n\n\n\n/* Check if the argument is URL */\n\nextern boolean is_url (const char *url);\n\n\n\n#endif\n\n\n", "  /**********************************/\n\n /***** FUNCTIONS FOR svn_tree *****/\n\n/**********************************/\n\n\n\n#include <string.h>\n\n#include <stdlib.h>\n\n#include <stdio.h>\n\n#include <unistd.h>\n\n\n\n#include \"dynlist.h\"\n\n\n\n#include \"callbacks.h\"\n\n\n\n/* ************************/\n\n/* Callback for prompting */\n\n/* ************************/\n\n\n\n/* Display a prompt and read a one-line response into the provided buffer,\n\n   removing a trailing newline if present. */\n\nstatic svn_error_t * prompt_and_get (\n\n           const char *prompt,\n\n           char *buffer,\n\n           size_t max) {\n\n  int len;\n\n  printf (\"%s: \", prompt);\n\n  if (fgets(buffer, max, stdin) == NULL) {\n\n    return svn_error_create(0, NULL, \"error reading stdin\");\n\n  }\n\n  len = strlen(buffer);\n\n  if (len > 0 && buffer[len-1] == '\\n') {\n\n    buffer[len-1] = 0;\n\n  }\n\n  return SVN_NO_ERROR;\n\n}\n\n\n\nextern svn_error_t * my_simple_prompt_callback (\n\n           svn_auth_cred_simple_t **cred,\n\n           void *baton __attribute__ ((unused)),\n\n           const char *realm,\n\n           const char *username,\n\n           svn_boolean_t may_save __attribute__ ((unused)),\n\n           apr_pool_t *pool) {\n\n  svn_auth_cred_simple_t *ret = apr_pcalloc (pool, sizeof (*ret));\n\n  char answerbuf[100];\n\n\n\n  if (realm) {\n\n    debug2 (2, \"Authentication realm\", realm);\n\n  }\n\n\n\n  if (username) {\n\n    ret->username = apr_pstrdup (pool, username);\n\n  } else {\n\n    SVN_ERR (prompt_and_get (\"Username\", answerbuf, sizeof(answerbuf)));\n\n    ret->username = apr_pstrdup (pool, answerbuf);\n\n  }\n\n\n\n  SVN_ERR (prompt_and_get (\"Password\", answerbuf, sizeof(answerbuf)));\n\n  ret->password = apr_pstrdup (pool, answerbuf);\n\n\n\n  *cred = ret;\n\n  return SVN_NO_ERROR;\n\n}\n\n\n\nextern svn_error_t * my_username_prompt_callback (\n\n           svn_auth_cred_username_t **cred,\n\n           void *baton __attribute__ ((unused)),\n\n           const char *realm,\n\n           svn_boolean_t may_save __attribute__ ((unused)),\n\n           apr_pool_t *pool) {\n\n  svn_auth_cred_username_t *ret = apr_pcalloc (pool, sizeof (*ret));\n\n  char answerbuf[100];\n\n\n\n  if (realm) {\n\n    debug2 (2, \"Authentication realm\", realm);\n\n  }\n\n\n\n  SVN_ERR (prompt_and_get (\"Username\", answerbuf, sizeof(answerbuf)));\n\n  ret->username = apr_pstrdup (pool, answerbuf);\n\n\n\n  *cred = ret;\n\n  return SVN_NO_ERROR;\n\n}\n\n\n\n/* **************************** */\n\n/* Callback to get current URL */\n\n/* ************************** */\n\nextern svn_error_t * client_info_cb (\n\n           void *baton,\n\n           const char *target __attribute__ ((unused)),\n\n           const svn_info_t *info,\n\n           apr_pool_t *pool __attribute__ ((unused))) {\n\n  /* Baton is a urls_type* */\n\n  urls_type * urls = (urls_type*) baton;\n\n\n\n  /* Check and copy repository URL */\n\n  if (strlen (info->repos_root_URL) > sizeof(url_t) ) {\n\n    error_data (\"The repository URL is too long\", info->repos_root_URL);\n\n  }\n\n  strcpy (urls->repository_url, info->repos_root_URL);\n\n\n\n  /* Check and copy current URL */\n\n  if (strlen (info->URL) > sizeof(url_t) ) {\n\n    error_data (\"The current URL is too long\", info->URL);\n\n  }\n\n  strcpy (urls->current_url, info->URL);\n\n  debug2 (1, \"Cb got info reposit\", urls->repository_url);\n\n  debug2 (1, \"Cb got info current\", urls->current_url);\n\n\n\n  /* Done */\n\n  return SVN_NO_ERROR;\n\n}\n\n\n\n/* ***************************************************** */\n\n/* Callback to retrieve creation revision number + date */\n\n/* of node and its destination                         */\n\n/* ************************************************** */\n\nextern svn_error_t * log_entry_cb (\n\n            void * baton,\n\n            svn_log_entry_t *log_entry,\n\n            apr_pool_t *pool) {\n\n\n\n  long int rev = log_entry->revision;\n\n  node_type *node_p = (node_type *) baton;\n\n  apr_hash_t *hash_table = log_entry->changed_paths2;\n\n\n\n  const char *date;\n\n  const char *author;\n\n  const char *message;\n\n  char tmpdate[256];\n\n  source_dest_values source_dest;\n\n\n\n  /* Assigning default values to structure */\n\n  source_dest.action = OTHER;\n\n  source_dest.dst_kind = INVALID;\n\n  source_dest.src_kind = INVALID;\n\n\n\n  /* Svn function to return date */\n\n  svn_compat_log_revprops_out (&author, &date,\n\n                &message, log_entry->revprops);\n\n\n\n  if (hash_table != NULL) {\n\n\n\n    sprintf (tmpdate, \"%ld\", rev);\n\n    debug2 (3, \"Cb getting action for rev\", tmpdate);\n\n\n\n    get_action(hash_table, pool, &source_dest);\n\n    /* If it is first COPY, then it is destination of tag/branch */\n\n    if ((node_p->dst_rev) == 0 ) {\n\n      if ((source_dest.action) == COPY) {\n\n        node_p->dst_rev = rev;\n\n        strcpy(tmpdate, date);\n\n        svn_date_to_normal(tmpdate);\n\n        strcpy((node_p->dst_date), tmpdate);\n\n        strcpy(node_p->dst_path, source_dest.dst_path);\n\n        get_node_path(node_p->dst_path);\n\n        strcpy(node_p->src_path, source_dest.src_path);\n\n        get_node_path(node_p->src_path);\n\n      }\n\n    } else {\n\n      /* If dest is already found, look for next revision that is not MOVE */\n\n      if (source_dest.dst_kind != TAG) {\n\n        if (source_dest.action != MOVE) {\n\n          node_p->src_rev = rev;\n\n          strcpy(tmpdate, date);\n\n          svn_date_to_normal(tmpdate);\n\n          strcpy((node_p->src_date), tmpdate);\n\n          sprintf (tmpdate, \"%s %ld | %s %ld\",\n\n                             node_p->src_path, node_p->src_rev,\n\n                             node_p->dst_path, node_p->dst_rev);\n\n          debug2 (2, \"Cb got node\", tmpdate);\n\n          return svn_error_create (ABORT_ITERATIONS, NULL, NULL);\n\n        }\n\n      }\n\n    }\n\n  }\n\n  return SVN_NO_ERROR;\n\n}\n\n\n\n/* ***************************************************************** */\n\n/************** Function used in previous callback **************** */\n\n/** What is the action? Is it COPY = 1; MOVE = -1 or OTHER = 0 ?? **/\n\n/* ************************************************************** */\n\nextern void get_action (apr_hash_t *hash_table, apr_pool_t *pool,\n\n                                 source_dest_values *source_dest) {\n\n  apr_hash_index_t *index;\n\n  svn_log_changed_path2_t *value;\n\n  char *key;\n\n  url_t copy_path, delete_path;\n\n  apr_ssize_t len;\n\n  int count = 0;\n\n  char tmpbuf[1024];\n\n\n\n  source_dest->src_path[0] = '\\0';\n\n  source_dest->dst_path[0] = '\\0';\n\n\n\n  /* Loop to go through all the hash table values */\n\n  for (index = apr_hash_first(pool, hash_table);\n\n       index != NULL; index = apr_hash_next(index)) {\n\n    apr_hash_this(index,(const void**)&key, &len, (void**)&value);\n\n    /* If its COPY, take destination and source kinds */\n\n    sprintf (tmpbuf, \"%c %s from %s %ld\", value->action, key,\n\n             value->copyfrom_path, value->copyfrom_rev);\n\n    debug2 (4, \"Cb action entry\", tmpbuf);\n\n    if ((value->action == 'A') && (value->copyfrom_rev != -1)) {\n\n\n\n      if ( (compare_path(value->copyfrom_path) != INVALID)\n\n        && (compare_path(key) != INVALID)) {\n\n\n\n        count++;\n\n        source_dest->src_kind = compare_path(value->copyfrom_path);\n\n        strcpy (source_dest->src_path, value->copyfrom_path);\n\n        source_dest->dst_kind = compare_path(key);\n\n        strcpy(source_dest->dst_path, key);\n\n        /* Save this copy to check validity of move */\n\n        strcpy (copy_path, value->copyfrom_path);\n\n      }\n\n    } else if (value->action == 'D') {\n\n      /* It is a deletion */\n\n        if (compare_path(key) != INVALID) {\n\n          /* Save this delete to check validity of move */\n\n          strcpy (delete_path, key);\n\n          count -= 2;\n\n        }\n\n    }\n\n  } /* end for loop */\n\n\n\n  if (count == -1) {\n\n    if (strcmp(delete_path, copy_path) != 0) {\n\n      /* This is not a move! */\n\n      count = 0;\n\n    }\n\n  }\n\n  source_dest->action = count;\n\n  sprintf (tmpbuf, \"%d %s to %s\", source_dest->action,\n\n           source_dest->src_path, source_dest->dst_path);\n\n  debug2 (3, \"Cb action got\", tmpbuf);\n\n}\n\n\n\n/* ***************************************************************** */\n\n/* 2 callbacks to retrieve and store revision numbers from log info */\n\n/* *************************************************************** */\n\n\n\n/* Store full revision list */\n\n/***************************/\n\nextern svn_error_t * log_frevlist_cb(\n\n               void * baton,\n\n               svn_log_entry_t *log_entry,\n\n               apr_pool_t *pool __attribute__ ((unused))) {\n\n\n\n  long int rev = log_entry->revision;\n\n  char revstr[80];\n\n  dlist *revlist_p = (dlist *) baton;\n\n\n\n  sprintf (revstr, \"%ld\", rev);\n\n  debug2 (2, \"Cb got rev\", revstr);\n\n  dlist_insert (revlist_p, &rev, TRUE);\n\n  return SVN_NO_ERROR;\n\n}\n\n/* Store short revision list: Stop at first copy */\n\n/*************************************************/\n\nextern svn_error_t * log_srevlist_cb(\n\n            void * baton,\n\n            svn_log_entry_t *log_entry,\n\n            apr_pool_t *pool) {\n\n\n\n  source_dest_values source_dest;\n\n  apr_hash_t *hash_table = log_entry->changed_paths2;\n\n\n\n  get_action(hash_table, pool, &source_dest);\n\n\n\n  (void) log_frevlist_cb (baton, log_entry, pool);\n\n  if (hash_table != NULL) {\n\n    if ((source_dest.action) == COPY) {\n\n      return svn_error_create (ABORT_ITERATIONS, NULL, NULL);\n\n    }\n\n  }\n\n  return SVN_NO_ERROR;\n\n}\n\n\n\n\n\n/*********************************/\n\n/* Callback to get list of tags */\n\n/*******************************/\n\nextern svn_error_t *\n\n  print_dirent_cb(void *baton,\n\n                  const char *path,\n\n                  const svn_dirent_t *dirent __attribute__ ((unused)),\n\n                  const svn_lock_t *lock __attribute__ ((unused)),\n\n                  const char *abs_path __attribute__ ((unused)),\n\n                  apr_pool_t *pool __attribute__ ((unused))) {\n\n\n\n  dlist *list_p = (dlist *) baton;\n\n\n\n  /* Discard empty entry */\n\n  if (strlen (path) == 0) {\n\n    return SVN_NO_ERROR;\n\n  }\n\n  debug2 (3, \"Cb got dir entry\", path);\n\n  dlist_insert (list_p, path, TRUE);\n\n  return SVN_NO_ERROR;\n\n}\n\n\n", "#ifndef CALLBACKS_H\n\n#define CALLBACKS_H\n\n\n\n/**********************************************/\n\n/****** Function prototypes for svn_tree *****/\n\n/********************************************/\n\n\n\n#include \"svn_includes.h\"\n\n\n\n#include \"utilities.h\"\n\n\n\n/* Max size of path */\n\n#define PATH_LENGTH 256\n\n\n\n/* The specific error to abort iterations */\n\n#define ABORT_ITERATIONS SVN_ERR_CL_NO_EXTERNAL_MERGE_TOOL\n\n\n\n/* Structure to hold node values of source and destination revisions */\n\ntypedef struct {\n\n  url_t src_path;\n\n  url_t dst_path;\n\n  long int src_rev;\n\n  long int dst_rev;\n\n  date_t src_date;\n\n  date_t dst_date;\n\n} node_type;\n\n\n\n/* Structure to hold info with action type + two path values */\n\ntypedef enum {DELETE=-2, MOVE=-1, OTHER=0, COPY=1} action_kind;\n\ntypedef struct {\n\n   action_kind action;\n\n   url_t src_path;\n\n   url_t dst_path;\n\n   label_kind src_kind;\n\n   label_kind dst_kind;\n\n} source_dest_values;\n\n\n\ntypedef struct {\n\n  url_t repository_url;\n\n  url_t current_url;\n\n} urls_type;\n\n\n\ntypedef char tag_path_type[PATH_LENGTH+1];\n\n\n\n/* Callbacks for promt of authentication */\n\nextern svn_error_t * my_simple_prompt_callback(\n\n           svn_auth_cred_simple_t **cred,\n\n           void *baton,\n\n           const char *realm,\n\n           const char *username,\n\n           svn_boolean_t may_save,\n\n           apr_pool_t *pool);\n\nextern svn_error_t * my_username_prompt_callback(\n\n           svn_auth_cred_username_t **cred,\n\n           void *baton,\n\n           const char *realm,\n\n           svn_boolean_t may_save,\n\n           apr_pool_t *pool);\n\n\n\n/* Callback to get current URL */\n\nextern svn_error_t * client_info_cb(\n\n           void *baton,\n\n           const char *target,\n\n           const svn_info_t *info,\n\n           apr_pool_t *pool);\n\n\n\n/* Callback to retrieve creation revision number + date */\n\nextern svn_error_t * log_entry_cb(\n\n            void * baton,\n\n            svn_log_entry_t *log_entry,\n\n            apr_pool_t *pool);\n\n/* Getting the action (COPY = 1; MOVE = -1 or OTHER = 0) in \"log_entry_cb\" */\n\nextern void get_action (apr_hash_t *hash_table, apr_pool_t *pool,\n\n                                 source_dest_values *source_dest);\n\n\n\n/* Store short revision list; -b option */\n\nextern svn_error_t * log_srevlist_cb(\n\n            void * baton,\n\n            svn_log_entry_t *log_entry,\n\n            apr_pool_t *pool);\n\n\n\n/* Store long  revision list */\n\nextern svn_error_t * log_frevlist_cb(\n\n               void * baton,\n\n               svn_log_entry_t *log_entry,\n\n               apr_pool_t *pool);\n\n\n\n/* Get list of tag names */\n\nextern svn_error_t *\n\n  print_dirent_cb(void *baton,\n\n                  const char *path,\n\n                  const svn_dirent_t *dirent,\n\n                  const svn_lock_t *lock,\n\n                  const char *abs_path,\n\n                  apr_pool_t *pool);\n\n\n\n#endif\n\n\n", "/*****************/\n\n/*    SVN_TREE   */\n\n/*****************/\n\n#include <string.h>\n\n#include <stdlib.h>\n\n#include <stdio.h>\n\n#include <unistd.h>\n\n\n\n#include \"boolean.h\"\n\n#include \"dynlist.h\"\n\n\n\n#include \"svn_includes.h\"\n\n\n\n#include \"utilities.h\"\n\n#include \"callbacks.h\"\n\n\n\n\n\nconst char *syntax_err_msg = \"Invalid argument. Use option '-h' for help.\";\n\n\n\n/* Used for sorting the dynlist */\n\nstatic boolean less_than (const void *l, const void *r) {\n\n  /* Casting voids in output_type and comparing the revisions */\n\n  /* out = current position; out = next position */\n\n  const node_type *out  = (const node_type *) l;\n\n  const node_type *out1 = (const node_type *) r;\n\n    if (out->src_rev < out1->src_rev) {\n\n      return TRUE;\n\n    }\n\n    else if (out->src_rev == out1->src_rev) {\n\n      return (out->dst_rev < out1->dst_rev);\n\n    }\n\n    else return FALSE;\n\n}\n\n\n\n/* Check if a rev appears in REV list */\n\nstatic boolean find_rev (long int node_rev, dlist *revlist) {\n\n  long int rev;\n\n  unsigned int low, mid, high, i;\n\n\n\n  /* By convention, an empty revlist means no citreria */\n\n  if (dlist_is_empty (revlist)) {\n\n    return TRUE;\n\n  }\n\n\n\n  /* Dichotomy */\n\n  low = 1;\n\n  high = dlist_length (revlist);\n\n\n\n  dlist_rewind (revlist, TRUE);\n\n  do {\n\n    mid = (low + high) / 2;\n\n    for (i = 1; i < mid; i++) {\n\n      dlist_move (revlist, TRUE);\n\n    }\n\n    dlist_read (revlist, &rev);\n\n    if (node_rev < rev) {\n\n      low = mid + 1;\n\n      dlist_rewind (revlist, TRUE);\n\n    } else if (node_rev > rev) {\n\n      high = mid - 1;\n\n      dlist_rewind (revlist, TRUE);\n\n    }\n\n    if (node_rev == rev) {\n\n      return TRUE;\n\n    }\n\n  } while (low <= high);\n\n  return FALSE;\n\n}\n\n\n\n/* Open the ctx */\n\nstatic void open_ctx (apr_pool_t *ctx_pool,\n\n                      svn_client_ctx_t **ctx,\n\n                      apr_array_header_t *providers) {\n\n  svn_error_t *err;\n\n\n\n  /* Create a client context object. */\n\n  svn_client_create_context(ctx, ctx_pool);\n\n  if (*ctx == NULL) {\n\n    error (\"Cannot create client context\");\n\n  }\n\n\n\n  /* Make sure the ~/.subversion run-time config files exist, and load. */\n\n  err = svn_config_ensure (NULL, ctx_pool);\n\n  if (err != SVN_NO_ERROR) {\n\n    err = svn_config_get_config (&((*ctx)->config), NULL, ctx_pool);\n\n      if (err != SVN_NO_ERROR) {\n\n        error (\"Cannot load run-time config ~/.subversion\");\n\n      }\n\n  }\n\n  /* Register the auth-providers into the context's auth_baton. */\n\n  svn_auth_open (&(*ctx)->auth_baton, providers, ctx_pool);\n\n}\n\n\n\n\n\n/*************/\n\n/*** MAIN ***/\n\n/***********/\n\nint main (int argc, const char *argv[]) {\n\n\n\n  /* Svn variables */\n\n  svn_error_t *err;\n\n  apr_allocator_t *allocator, *ctx_allocator;\n\n  apr_pool_t *pool, *ctx_pool;\n\n  svn_client_ctx_t *ctx;\n\n  svn_auth_provider_object_t *provider;\n\n  apr_array_header_t *providers;\n\n  apr_array_header_t *targets, *range_array;\n\n  const char **target;\n\n  apr_array_header_t *revisions;\n\n  svn_opt_revision_t peg_revision, **p_revision, revision;\n\n  svn_opt_revision_range_t **range, range_struct;\n\n  apr_array_header_t *revprops;\n\n  apr_uint32_t dirent_fields;\n\n  int count;\n\n\n\n\n\n  /* Urls of local sandbox */\n\n  urls_type urls;\n\n\n\n  /* Result of argument parsing */\n\n  mode_kind whatmode;\n\n  url_t whaturl;\n\n  mode_kind wheremode;\n\n  url_t whereurl;\n\n  boolean whereloc;\n\n\n\n  /* URL of the dir of tags (or of the tag) */\n\n  url_t tagurl;\n\n  url_t tmpurl, tmp1url;\n\n\n\n  /* Result node of a SVN copy */\n\n  node_type node;\n\n\n\n  /* List of tags/branches to list, of revisions to check versus,\n\n     and of node infos */\n\n  dlist name_list, rev_list, node_list;\n\n\n\n  /* Revision of current src */\n\n  long int srcrev;\n\n\n\n  /* Addr of start of label type */\n\n  char *startp;\n\n\n\n  /*******************/\n\n  /* INITIALISATIONS */\n\n  /*******************/\n\n\n\n  /* CHECK HELP */\n\n  /**************/\n\n  if ( (argc == 2) && (strcmp(argv[1], \"-h\") == 0\n\n                       || (strcmp(argv[1], \"--help\") == 0) ) ) {\n\n    put_help (argv[0]);\n\n    exit (1);\n\n  }\n\n\n\n  /* CHECK STACK */\n\n  /***************/\n\n  debug1 (1, \"Initializing\");\n\n  /* Check that 'ulimit -s' returns \"unlimited\" or a value >= 4194304 */\n\n  {\n\n    FILE * pip;\n\n    char line[1024];\n\n    long int ssize;\n\n    const long int min_ssize = 4194304;\n\n\n\n    pip = popen (\"ulimit -s\", \"r\");\n\n    fscanf (pip, \"%s\", line);\n\n    fclose (pip);\n\n    if (strcmp(line, \"unlimited\") != 0) {\n\n      ssize = atol (line);\n\n      if (ssize < min_ssize) {\n\n        sprintf (line, \"Stack size must be  at least %ld (ulimit -s)\",\n\n                       min_ssize);\n\n        error (line);\n\n      }\n\n    }\n\n\n\n  }\n\n  debug1 (2, \"Stack OK\");\n\n\n\n  /* INIT SVN */\n\n  /************/\n\n  if (svn_cmdline_init(\"t_svn\", stderr) != EXIT_SUCCESS) {\n\n    error (\"Cannot initialise command line\");\n\n  }\n\n\n\n  /* Create our top-level pool. Use a separate mutexless allocator,\n\n   * given this application is single threaded.\n\n   */\n\n  if (apr_allocator_create(&allocator)) {\n\n    error (\"Cannot create allocator\");\n\n  }\n\n  apr_allocator_max_free_set(allocator, SVN_ALLOCATOR_RECOMMENDED_MAX_FREE);\n\n  pool = svn_pool_create_ex(NULL, allocator);\n\n  if (pool == NULL) {\n\n    error (\"Cannot create pool\");\n\n  }\n\n  apr_allocator_owner_set(allocator, pool);\n\n\n\n  /* Create specific allocator and pool for context */\n\n  if (apr_allocator_create(&ctx_allocator)) {\n\n    error (\"Cannot create context allocator\");\n\n  }\n\n  apr_allocator_max_free_set(ctx_allocator, SVN_ALLOCATOR_RECOMMENDED_MAX_FREE);\n\n  ctx_pool = svn_pool_create_ex(NULL, ctx_allocator);\n\n  if (ctx_pool == NULL) {\n\n    error (\"Cannot create context pool\");\n\n  }\n\n  apr_allocator_owner_set(ctx_allocator, ctx_pool);\n\n\n\n  /* Initialize the FS library. */\n\n  err = svn_fs_initialize(pool);\n\n  if (err != SVN_NO_ERROR) {\n\n    error (\"Cannot initialize fs library\");\n\n  }\n\n\n\n  /* Make ctx capable of authenticating users */\n\n  providers = apr_array_make (pool, 4, sizeof (svn_auth_provider_object_t *));\n\n\n\n  svn_auth_get_simple_prompt_provider (&provider,\n\n       my_simple_prompt_callback, NULL, 2, pool);\n\n  APR_ARRAY_PUSH (providers, svn_auth_provider_object_t *) = provider;\n\n\n\n  svn_auth_get_username_prompt_provider (&provider,\n\n        my_username_prompt_callback, NULL, 2, pool);\n\n  APR_ARRAY_PUSH (providers, svn_auth_provider_object_t *) = provider;\n\n\n\n  /* Init client context */\n\n  open_ctx (ctx_pool, &ctx, providers);\n\n\n\n  debug1 (2, \"Svn init OK\");\n\n\n\n  /* GET CURRENT URL */\n\n  /**********i********/\n\n  /* Just for sanity check or when \"CUR\" argument */\n\n  {\n\n    url_t path;\n\n    (void)getcwd(path, sizeof(path));\n\n    err = svn_client_info3(path,\n\n                           NULL,\n\n                           NULL,\n\n                           svn_depth_empty,\n\n                           FALSE, FALSE,\n\n                           NULL,\n\n                           &client_info_cb,\n\n                           &urls,\n\n                           ctx,\n\n                           pool);\n\n    if (err != SVN_NO_ERROR) {\n\n      error_data (\"Cannot get client info: \", err->message);\n\n    }\n\n  }\n\n\n\n  /* CHECK ARGUMENTS */\n\n  /******************/\n\n\n\n  /* Usage: svn_tree   <url> | CUR | ALLTAGS [ -of | -on    <url> | CUR ] */\n\n  /* So either 1 arg or 3 */\n\n  if ( (argc != 2) && (argc != 4) ) {\n\n    error(syntax_err_msg);\n\n  }\n\n\n\n  /* First arg: what mode */\n\n  if (strcmp(argv[1], \"CUR\") == 0) {\n\n    whatmode = CUR_MODE;\n\n  } else if (strcmp(argv[1], \"ALLTAGS\") == 0) {\n\n    whatmode = ALL_MODE;\n\n  } else {\n\n    /* URL: Must be valid tag or branch */\n\n    whatmode = URL_MODE;\n\n    strcpy (whaturl, argv[1]);\n\n    if (!is_url(whaturl)) {\n\n      error(syntax_err_msg);\n\n    }\n\n  }\n\n\n\n  if (argc == 2) {\n\n    wheremode = ALL_MODE;\n\n  } else {\n\n    /* Where is global or local */\n\n    if (strcmp(argv[2], \"-of\") == 0) {\n\n      whereloc = FALSE;\n\n    } else if (strcmp(argv[2], \"-on\") == 0) {\n\n      whereloc = TRUE;\n\n    } else {\n\n      error(syntax_err_msg);\n\n    }\n\n\n\n    if (strcmp(argv[3], \"CUR\") == 0) {\n\n      wheremode = CUR_MODE;\n\n    } else {\n\n      /* URL: Must be valid tag or branch or trunk */\n\n      wheremode = URL_MODE;\n\n      strcpy (whereurl, argv[3]);\n\n      if (!is_url(whereurl)) {\n\n        error(syntax_err_msg);\n\n      }\n\n    }\n\n  }\n\n  debug1 (2, \"Arguments parsed OK\");\n\n\n\n  /* INIT GENERAL SVN DATA */\n\n  /*************************/\n\n  /* Init first array with URL */\n\n  targets = apr_array_make(pool, 1, sizeof (char*));\n\n  target = apr_array_push(targets);\n\n  /* Will need to set *target */\n\n\n\n  /* Init revisions : unspecified */\n\n  revisions = apr_array_make(pool, 1, sizeof(svn_opt_revision_t));\n\n  p_revision = apr_array_push(revisions);\n\n  revision.kind = svn_opt_revision_unspecified;\n\n  *p_revision = &(revision);\n\n\n\n  /* Init range : base to head */\n\n  range_array = apr_array_make(pool, 1, sizeof( svn_opt_revision_range_t));\n\n  range = apr_array_push(range_array);\n\n  range_struct.start.kind = svn_opt_revision_base;\n\n  range_struct.end.kind = svn_opt_revision_head;\n\n  range_struct.start.kind = svn_opt_revision_unspecified;\n\n  range_struct.end.kind = svn_opt_revision_unspecified;\n\n  *range = &(range_struct);\n\n\n\n  /* Peg revision */\n\n  peg_revision.kind = svn_opt_revision_unspecified;\n\n  revprops = apr_array_make(pool, 1, sizeof(svn_opt_revision_t));\n\n\n\n\n\n  /* INIT GLOBAl DATA */\n\n  /********************/\n\n  dlist_init (&name_list, sizeof(tag_path_type)); /* Tags' URLs */\n\n  dlist_init (&rev_list, sizeof(long int));       /* Revison numbers of where */\n\n  dlist_init (&node_list, sizeof(node_type));     /* Nodes infos (result) */\n\n  debug1 (2, \"Data init OK\");\n\n\n\n  /*******************************************/\n\n  /* LIST TAGS AND GET THEIR NODE, LIST REVS */\n\n  /*******************************************/\n\n  debug1 (1, \"Starting\");\n\n\n\n  /* MAKE LIST OF URLS */\n\n  /*********************/\n\n  if (whatmode == ALL_MODE) {\n\n    /* All tags */\n\n    strcpy (tagurl, urls.repository_url);\n\n    strcat (tagurl, \"/tags\");\n\n    dirent_fields = SVN_DIRENT_ALL;\n\n    debug2 (2, \"Listing tags\", tagurl);\n\n    err  = svn_client_list2(tagurl,\n\n                            &peg_revision,\n\n                            &peg_revision,\n\n                            svn_depth_immediates,\n\n                            dirent_fields,\n\n                            FALSE,\n\n                            print_dirent_cb,\n\n                            &name_list,\n\n                            ctx,\n\n                            pool);\n\n    if (err != SVN_NO_ERROR) {\n\n      error_data (\"Cannot list tags: \", err->message);\n\n      exit(1);\n\n    }\n\n    if (dlist_is_empty (&name_list)) {\n\n      /* No tag at all */\n\n      debug1 (1, \"No tag found\");\n\n      exit (0);\n\n    }\n\n    /* Replace each entry (tag name) by full path */\n\n    dlist_rewind (&name_list, TRUE);\n\n    strcat (tagurl, \"/\");\n\n    for (;;) {\n\n      strcpy (tmpurl, tagurl);\n\n      dlist_read (&name_list, tmp1url);\n\n      strcat(tmpurl, tmp1url);\n\n      dlist_replace (&name_list, tmpurl);\n\n      debug2 (2, \"Found tag\", tmpurl);\n\n      if (dlist_get_pos (&name_list, FALSE) == 1) break;\n\n      dlist_move (&name_list, TRUE);\n\n    }\n\n  } else {\n\n    /* One tag (current or specified) */\n\n    if (whatmode == URL_MODE) {\n\n      strcpy (tagurl, whaturl);\n\n    } else {\n\n      strcpy (tagurl, urls.current_url);\n\n    }\n\n    {\n\n      /* Check URL and strip tail */\n\n      startp = url_check (tagurl, FALSE);\n\n      if (startp == NULL) {\n\n        error(\"Wrong URL. Does not point to branches or tags\");\n\n      }\n\n      get_node_path (startp);\n\n      debug2 (2, \"Added URL\", tmpurl);\n\n      dlist_insert (&name_list, tagurl, TRUE);\n\n    }\n\n  }\n\n\n\n  /* GET INFO ON EACH URL */\n\n  /************************/\n\n  debug1 (2, \"Getting nodes\");\n\n  dlist_rewind (&name_list, TRUE);\n\n  count = 0;\n\n  for (;;) {\n\n\n\n    /* Get node info on current tag */\n\n    dlist_read (&name_list, tagurl);\n\n    *target = tagurl;\n\n    node.dst_rev = 0;\n\n    node.src_rev = 0;\n\n    debug2 (2, \"Getting node of\", tagurl);\n\n    err = svn_client_log5(targets,\n\n                          &peg_revision,\n\n                          range_array,\n\n                          0,\n\n                          TRUE,\n\n                          FALSE,\n\n                          FALSE,\n\n                          NULL,\n\n                          log_entry_cb,\n\n                          &node,\n\n                          ctx,\n\n                          ctx_pool);\n\n    if (err != SVN_NO_ERROR) {\n\n      if (err->apr_err != ABORT_ITERATIONS) {\n\n        error_data (\"Cannot log history:\", err->message);\n\n        exit (1);\n\n      } else {\n\n        /* The dest node is the target of last copy, not the final name\n\n           of the tag. So restore the final tag name */\n\n        startp = url_check (tagurl, TRUE);\n\n        strcpy (node.dst_path, startp);\n\n        get_node_path (node.dst_path);\n\n        dlist_insert(&node_list, &node, TRUE);\n\n        dlist_move (&node_list, TRUE);\n\n      }\n\n    } else {\n\n      /* Cannot find node of this tag, skip it */\n\n      debug2 (1, \"Cannot find node\", tagurl);\n\n    }\n\n    if (dlist_get_pos (&name_list, FALSE) == 1) break;\n\n    dlist_move (&name_list, TRUE);\n\n    /* Each 1000 iteration clear pool and re-create client context */\n\n    /* Necessary to avoid too many open sockets :-( */\n\n    count++;\n\n    if (count == 1000) {\n\n      count = 0;\n\n      apr_pool_clear (ctx_pool);\n\n      open_ctx (ctx_pool, &ctx, providers);\n\n    }\n\n  }\n\n  if (dlist_is_empty (&node_list)) {\n\n    /* No mode node */\n\n    debug1 (1, \"No node found\");\n\n    exit (0);\n\n  }\n\n  dlist_rewind (&rev_list, TRUE);\n\n  dlist_rewind (&node_list, TRUE);\n\n\n\n  /* LIST  REVS (WHERE) */\n\n  /**********************/\n\n  if (wheremode != ALL_MODE) {\n\n    if (wheremode == URL_MODE) {\n\n      strcpy (tagurl, whereurl);\n\n    } else {\n\n      strcpy (tagurl, urls.current_url);\n\n    }\n\n    {\n\n      /* Check URL and strip tail */\n\n      startp = url_check (tagurl, TRUE);\n\n      if (startp == NULL) {\n\n        error(\"Wrong URL. Does not point to branches, tags or trunk\");\n\n      }\n\n      get_node_path (startp);\n\n    }\n\n    debug1 (2, \"Listing revs\");\n\n    *target = tagurl;\n\n    err = svn_client_log5(targets,\n\n                          &peg_revision,\n\n                          range_array,\n\n                          0,\n\n                          TRUE,\n\n                          FALSE,\n\n                          FALSE,\n\n                          NULL,\n\n                         ((whereloc) ? log_srevlist_cb : log_frevlist_cb),\n\n                          &rev_list,\n\n                          ctx,\n\n                          pool);\n\n    if ((err != SVN_NO_ERROR) && (err->apr_err != ABORT_ITERATIONS)){\n\n      error_data (\"Cannot get rev numbers: \", err->message);\n\n    }\n\n    dlist_rewind (&rev_list, TRUE);\n\n  }\n\n\n\n  /*********************************/\n\n  /* PUT NODES THAT APPEAR IN REVS */\n\n  /*********************************/\n\n\n\n  debug1 (2, \"Putting nodes\");\n\n  dlist_sort (&node_list, less_than);\n\n  /* FOR EACH NODE */\n\n  /*****************/\n\n  srcrev = -1;\n\n  for (;;) {\n\n    dlist_read (&node_list, &node);\n\n    if (find_rev (node.src_rev, &rev_list) ) {\n\n      if (node.src_rev != srcrev) {\n\n        /* A new source => a new line */\n\n        if (srcrev != -1) {\n\n          printf(\"\\n\");\n\n        }\n\n        printf(\"%ld %s %s\", node.src_rev, node.src_path, node.src_date);\n\n        srcrev = node.src_rev;\n\n      }\n\n      /* This dest */\n\n      printf(\" | %ld %s %s\", node.dst_rev, node.dst_path, node.dst_date);\n\n    } else {\n\n      sprintf (tmpurl, \"%ld %s\", node.src_rev, node.dst_path);\n\n      debug2 (2, \"Discarding node\", tmpurl);\n\n    }\n\n    if (dlist_get_pos (&node_list, FALSE) == 1) break;\n\n    dlist_move (&node_list, TRUE);\n\n  }\n\n  if (srcrev != -1) {\n\n    /* At least one rev was put */\n\n    printf(\"\\n\");\n\n  }\n\n\n\n  /***********/\n\n  /* CLEANUP */\n\n  /***********/\n\n  /* Clear all dyn lists and free memory */\n\n  dlist_delete_all (&name_list);\n\n  dlist_delete_all (&rev_list);\n\n  dlist_delete_all (&node_list);\n\n\n\n  /* Clear memory\n\n  apr_array_clear (targets);\n\n  apr_array_clear (revisions);\n\n  apr_array_clear (range_array);\n\n  apr_array_clear (revprops);\n\n  */\n\n\n\n  /* Done */\n\n  exit (0);\n\n}\n\n\n", "  /****************************************/\n\n /*** Utility functions for \"svn_tree\" ***/\n\n/****************************************/\n\n\n\n#include <string.h>\n\n#include <stdlib.h>\n\n#include <stdio.h>\n\n#include <unistd.h>\n\n#include <libgen.h>\n\n#include <errno.h>\n\n\n\n#include \"utilities.h\"\n\n\n\n/* Level set by getenv */\n\nstatic const char *DEBUG_NAME=\"SVN_TREE_DEBUG\";\n\nstatic int debug_level = -1;\n\n\n\n/* In any kind of fatal error */\n\nextern void error_data (const char *msg, const char *data)\n\n  __attribute__ ((noreturn));\n\nextern void error_data (const char *msg, const char *data) {\n\n  fprintf (stderr, \"ERROR: %s %s\\n\", msg, data);\n\n  exit (1);\n\n}\n\n\n\n/* In any kind of fatal error */\n\nextern void error (const char *msg)\n\n  __attribute__ ((noreturn));\n\nextern void error (const char *msg) {\n\n  fprintf (stderr, \"ERROR: %s\\n\", msg);\n\n  exit (1);\n\n}\n\n\n\n/* Put command line help */\n\nextern void put_help (const char *prog) {\n\n  url_t local_prog;\n\n  strcpy (local_prog, prog);\n\n  fprintf(stderr,\"%s <what> [ <where> ]\\n\", basename (local_prog));\n\n  fprintf(stderr, \" <what>  ::= <url> | CUR | ALLTAGS\\n\");\n\n  fprintf(stderr, \" <where> ::= -of | -on  <onwhat>\\n\");\n\n  fprintf(stderr, \" <onwhat> ::= <url> | CUR\\n\\n\");\n\n  fprintf(stderr, \"Print info (source and dest) of the provided <url>\\n\");\n\n  fprintf(stderr, \"  or of current sandbox or of all tags.\\n\");\n\n  fprintf(stderr, \"  <url> or CUR must be a label (branch or tag)\\n\");\n\n  fprintf(stderr, \"Option <where> prints info only if label is on tree\\n\");\n\n  fprintf(stderr, \"  (either provided <url> or current sandbox),\\n\");\n\n  fprintf(stderr, \"  including (-of) or excluding (-on) its ancestors.\\n\");\n\n}\n\n\n\n/***********************************/\n\n/* Functions to deal with strings */\n\n/*********************************/\n\n\n\n/* Check whether string begins with URL start symbols \"://\" */\n\nextern boolean  is_url(const char *url) {\n\n  const char *url_start = \"://\";\n\n  char *p;\n\n\n\n  p = strstr(url, url_start);\n\n  if ( (p == NULL) || (p == url) ) {\n\n    /* Invalid or empty scheme */\n\n    return FALSE;\n\n  }\n\n  if (*(p + 3) == '\\0') {\n\n    /* Empty URL after scheme */\n\n    return FALSE;\n\n  }\n\n  if ( (*(p + 3) == '/')\n\n    && (*(p + 4) == '\\0') ) {\n\n    /* Empty URL after scheme */\n\n    return FALSE;\n\n  }\n\n  return TRUE;\n\n}\n\n\n\nstatic const char *branch = \"/branches/\";\n\nstatic const char *tag = \"/tags/\";\n\nstatic const char *trunk = \"/trunk\";\n\n\n\n/* Check program input argument URL */\n\nextern char *url_check (const char *url, boolean allow_trunk) {\n\n  char *p, *ps[3];\n\n  int i;\n\n\n\n  if (strlen(url) > URL_MAX_LEN) {\n\n    debug2 (1, \"url_check with too long url\", url);\n\n    error(\"URL is too long\");\n\n  }\n\n  /* Try to locate any label, store smallest non null */\n\n  ps[0] = strstr(url, branch);\n\n  ps[1] = strstr(url, tag);\n\n  ps[2] = strstr(url, trunk);\n\n  p = NULL;\n\n  for (i = 0; i <= 2; i++) {\n\n    if ( (p == NULL) || (p < ps[i]) ) {\n\n      p = ps[i];\n\n    }\n\n  }\n\n  if (p == NULL) {\n\n    return p;\n\n  }\n\n\n\n  if ( !allow_trunk && (strstr(p, trunk) == p) ) {\n\n    /* This URL is on trunk, which is not allowed */\n\n    return NULL;\n\n  }\n\n\n\n  return p;\n\n}\n\n\n\n/* Get short label (trunk, branches/name or tags/name) */\n\nextern void get_node_path (char *string) {\n\n  int nb;\n\n  int count= 0;\n\n  int i;\n\n  label_kind lab;\n\n\n\n  /* Nb of / to pass before cutting */\n\n  lab = compare_path (string);\n\n  switch (lab) {\n\n    case TRUNK:\n\n      nb = 2;\n\n    break;\n\n    case TAG:\n\n    case BRANCH:\n\n      nb = 3;\n\n    break;\n\n    default:\n\n      return;\n\n  }\n\n\n\n  /* Cut at nb '/'s */\n\n  for (i = 0; i < (int) strlen (string); i++) {\n\n    if (string[i] == '/') {\n\n      count++;\n\n      if (count == nb) {\n\n        string[i] = '\\0';\n\n      }\n\n    }\n\n  }\n\n}\n\n\n\n/* Check that the action is not against a file.\n\n   Function checks number of '/' in key path. */\n\nextern label_kind compare_path (const char *path) {\n\n  int count = 0;\n\n  int i;\n\n  char *p;\n\n\n\n  /* Scanning string for end char. If '/' appears  more than twice,\n\n     then this is a copy against a file -> INVALID */\n\n  for (i = 0; path[i] != '\\0'; i++) {\n\n    if (path[i] == '/') {\n\n      count++;\n\n    }\n\n  }\n\n  if (count > 2) {\n\n    return INVALID;\n\n  }\n\n  p = url_check (path, TRUE);\n\n  if (p == NULL) {\n\n    return INVALID;\n\n  }\n\n\n\n  if (strstr(path, branch) == p) {\n\n    return BRANCH;\n\n  }\n\n  if (strstr(path, tag) == p) {\n\n    return TAG;\n\n  }\n\n  if (strstr(path, trunk) == p) {\n\n    /* Only \"/trunk\" accepted */\n\n    if (count > 1) {\n\n      return INVALID;\n\n    }\n\n    return TRUNK;\n\n  }\n\n  return INVALID;\n\n}\n\n\n\n/* Modifying SVN output date to readable format */\n\nextern void svn_date_to_normal (char *date) {\n\n  int i = 0;\n\n  for (i = 0; date[i] != '\\0'; i++) {\n\n     if (date[i] == '.') {\n\n         date[i] = '\\0';\n\n     }\n\n  }\n\n}\n\n\n\n/* Output debug info */\n\nstatic boolean putit (int severity) {\n\n  char *p;\n\n  if (debug_level == -1) {\n\n    /* Done at first call */\n\n    p = getenv (DEBUG_NAME);\n\n    if (p == NULL) {\n\n      /* ENV var not set */\n\n      debug_level = 0;\n\n    } else {\n\n      /* Convert to int */\n\n      errno = 0;\n\n      debug_level = (int) strtol (p, NULL, 0);\n\n      if (errno != 0) {\n\n        /* Env var is not int => set to 1 */\n\n        debug_level = 1;\n\n      }\n\n    }\n\n  }\n\n  return (severity <= debug_level);\n\n}\n\n\n\nextern void debug1 (int severity, const char *msg) {\n\n  if (! putit (severity) ) return;\n\n  fprintf (stderr, \"-> %s\\n\", msg);\n\n}\n\n\n\nextern void debug2 (int severity, const char *msg, const char *data) {\n\n  if (! putit (severity) ) return;\n\n  fprintf (stderr, \"-> %s, %s\\n\", msg, data);\n\n}\n\n\n\nextern void debug3 (int severity, const char *msg, const char *data,\n\n                                  const char *extra) {\n\n  if (! putit (severity) ) return;\n\n  fprintf (stderr, \"-> %s, %s, %s\\n\", msg, data, extra);\n\n}\n\n\n", "#include \"boolean.h\"\n\n\n\n/* Results of calls */\n\n#define OK 0\n\n#define ERR -1\n\n\n\n#define t_result int\n\n\n\n/* Creates a semaphore associated with the given key */\n\n/* The out value sem_id is set, if p_sem_id != NULL for furhter use */\n\nt_result create_sem_key (int sem_key, int *p_sem_id);\n\n\n\n/* Id of the semaphore associated with the key, or ERR */\n\n/* The sem must have been created */\n\nint get_sem_id (int sem_key);\n\n\n\n/* The calls with id are faster the the calls with the key */\n\nt_result delete_sem_id (int sem_id);\n\nt_result delete_sem_key (int sem_key);\n\n\n\n/* decrements the semaphore (try to get (blocking) ) */\n\nt_result decr_sem_id (int sem_id, boolean undo);\n\nt_result decr_sem_key (int sem_key, boolean undo);\n\n\n\n/* increments (release) the semaphore */\n\nt_result incr_sem_id (int sem_id, boolean undo);\n\nt_result incr_sem_key (int sem_key, boolean undo);\n\n\n", "#include <stdio.h>\n\n#include <sys/types.h>\n\n#include <sys/ipc.h>\n\n#include <sys/sem.h>\n\n#include <errno.h>\n\n\n\n#include \"sem_util.h\"\n\n\n\n\n\nunion semun {\n\n  int               val;    /* value for SETVAL */\n\n  struct semid_ds   *buf;   /* buffer for IPC_STAT & IPC_SET */\n\n  u_short           *array; /* array for GETALL & SETALL */\n\n#ifdef linux\n\n  struct seminfo *__buf;    /* buffer for IPC_INFO */\n\n#endif\n\n};\n\n\n\nint get_sem_id (int sem_key) {\n\n  int sem_id;\n\n\n\n  sem_id = semget ( (key_t)sem_key, 1, 0666);\n\n  if (sem_id == -1) {\n\n    perror (\"get_sem_id.semget\");\n\n    return (ERR);\n\n  }\n\n\n\n  return (sem_id);\n\n}\n\n\n\nt_result create_sem_key (int sem_key, int *p_sem_id) {\n\n  int sem_id;\n\n  union semun arg1;\n\n\n\n  /* creation of the semaphore associated with the key key_sem */\n\n  sem_id = semget ( (key_t)sem_key, 1, IPC_CREAT | 0666);\n\n  if (sem_id  == -1) {\n\n    perror (\"create_sem_key.semget\");\n\n    return (ERR);\n\n  }\n\n\n\n  /* Out value sem_id */\n\n  if (p_sem_id != NULL) *p_sem_id = sem_id;\n\n\n\n  /* initialisation of the semaphore number 0 associated */\n\n  /* with the id number semid */\n\n  arg1.val = 1;\n\n  if (semctl (sem_id, 0 , SETVAL , arg1) == -1 ) {\n\n    perror (\"create_sem_key.semctl\");\n\n    return (ERR);\n\n  }\n\n\n\n  return (OK);\n\n}\n\n\n\n\n\nt_result delete_sem_id (int sem_id) {\n\n  /* deletion of the semaphore number 0 associated */\n\n  /* with the id number semid */\n\n  if (semctl (sem_id, 0 , IPC_RMID , 1) == -1 ) {\n\n    perror (\"delete_sem_id.semctl\");\n\n    return (ERR);\n\n  }\n\n\n\n  return (OK);\n\n}\n\n\n\n\n\nt_result delete_sem_key (int sem_key) {\n\n  int sem_id;\n\n  /* research of the id number associated with the key: key_sem */\n\n  sem_id = get_sem_id (sem_key);\n\n  if (sem_id  == ERR) return (ERR);\n\n\n\n  return (delete_sem_id(sem_id));\n\n}\n\n\n\n\n\nstatic t_result incr_decr_sem_id (int sem_id, boolean incr, boolean undo) {\n\n  struct sembuf sops;\n\n  int res;\n\n\n\n  sops.sem_num = (short) 0;  /* semaphore number 0 */\n\n  sops.sem_op  = (short) (incr ? 1 : -1); /* semaphore operation */\n\n  /* operation flags : process lock until the semaphore is zero */\n\n  sops.sem_flg = (undo ? SEM_UNDO : 0);\n\n\n\n  do {\n\n    errno = 0;\n\n    res = semop (sem_id, (struct sembuf *)(&sops), 1);\n\n    if ( (res == -1) && (errno != EINTR) ) {\n\n      perror (\"decr_sem_id.semctl\");\n\n      return (ERR);\n\n    }\n\n  } while (res == -1);\n\n\n\n  return (OK);\n\n}\n\n\n\nt_result decr_sem_id (int sem_id, boolean undo) {\n\n\n\n  return incr_decr_sem_id (sem_id, FALSE, undo);\n\n}\n\n\n\n\n\nt_result decr_sem_key (int sem_key,  boolean undo) {\n\n  int sem_id;\n\n\n\n  sem_id = get_sem_id (sem_key);\n\n  if (sem_id  == ERR) return (ERR);\n\n\n\n  return decr_sem_id (sem_id, undo);\n\n}\n\n\n\n\n\n\n\nt_result incr_sem_id (int sem_id,  boolean undo) {\n\n    return incr_decr_sem_id (sem_id, TRUE, undo);\n\n}\n\n\n\nt_result incr_sem_key (int sem_key,  boolean undo) {\n\n  int sem_id;\n\n\n\n  sem_id = get_sem_id (sem_key);\n\n  if (sem_id  == -1) return (ERR);\n\n\n\n  return incr_sem_id(sem_id, undo);\n\n}\n", "#include <stdlib.h>\n\n#include <stdio.h>\n\n#include <errno.h>\n\n#include <unistd.h>\n\n#include <string.h>\n\n\n\n#include \"boolean.h\"\n\n\n\n#define SUFFIX \".tmp\"\n\n\n\n#define write_char(c) {if (putc((int)c, fo) == EOF) { \\\n\n                         perror (\"putc\"); \\\n\n                         fprintf (stderr, \"Error writting on %s\\n\", file_name); \\\n\n                         break; \\\n\n                        } \\\n\n                      }\n\n\n\nstatic void convert (char *file_name) {\n\n  char *dos_file_name;\n\n  FILE *fi, *fo;\n\n  char c;\n\n\n\n  dos_file_name = malloc(strlen(file_name) + sizeof(SUFFIX));\n\n  if (dos_file_name == (char*) NULL) {\n\n    perror (\"malloc\");\n\n    fprintf (stderr, \"Error allocating file name %s%s\\n\", file_name, SUFFIX);\n\n    return;\n\n  }\n\n  strcpy (dos_file_name, file_name);\n\n  strcat (dos_file_name, \".tmp\");\n\n\n\n  if ( (fi = fopen (file_name, \"rb\")) == (FILE*)NULL) {\n\n    perror (\"fopen\");\n\n    fprintf (stderr, \"Error openning %s for reading\\n\", file_name);\n\n    free (dos_file_name);\n\n    return;\n\n  }\n\n\n\n  if ( (fo = fopen (dos_file_name, \"wb\")) == (FILE*)NULL) {\n\n    perror (\"fopen\");\n\n    fprintf (stderr, \"Error openning %s for writting\\n\", dos_file_name);\n\n    (void) fclose(fi);\n\n    free (dos_file_name);\n\n    return;\n\n  }\n\n\n\n  /* 0A --> 0D 0A */\n\n  /* EOF --> 1A Close */\n\n  for (;;) {\n\n    c = getc(fi);\n\n    if (c == (char) 0x0A) {\n\n      write_char(0X0D);\n\n      write_char(c);\n\n    } else if (c == (char) EOF) {\n\n      write_char(0x1A);\n\n      break;\n\n    } else {\n\n      write_char(c);\n\n    }\n\n  }\n\n\n\n  if (fclose(fi) != 0) {\n\n    perror (\"fclose\");\n\n    fprintf (stderr, \"Error closing %s after processing\\n\", file_name);\n\n    free (dos_file_name);\n\n  }\n\n\n\n  if (fclose(fo) != 0) {\n\n    perror (\"fclose\");\n\n    fprintf (stderr, \"Error closing %s after processing\\n\", dos_file_name);\n\n    free (dos_file_name);\n\n  }\n\n\n\n  if (unlink (file_name) == -1) {\n\n    perror (\"unlink\");\n\n    fprintf (stderr, \"Error removing %s after processing\\n\",\n\n                     file_name);\n\n    free (dos_file_name);\n\n    return;\n\n  }\n\n  if (rename (dos_file_name, file_name) == -1) {\n\n    perror (\"rename\");\n\n    fprintf (stderr, \"Error renaming %s to %s after processing\\n\",\n\n                      dos_file_name, file_name);\n\n    free (dos_file_name);\n\n    return;\n\n  }\n\n\n\n  free (dos_file_name);\n\n}\n\n\n\nint main (int argc, char *argv[]) {\n\n\n\n\n\n  int cur_arg;\n\n\n\n  for (cur_arg=2; cur_arg <= argc; cur_arg++) {\n\n    printf (\"Converting unix to dos : %s\\n\", argv[cur_arg-1]);\n\n    convert(argv[cur_arg-1]);\n\n  }\n\n  printf (\"Done.\\n\");\n\n  exit (0);\n\n}\n\n\n", "#include <stdlib.h>\n\n#include <stdio.h>\n\n#include <errno.h>\n\n#include <string.h>\n\n#include <unistd.h>\n\n\n\n#include \"boolean.h\"\n\n\n\n#define SUFFIX \".tmp\"\n\n\n\n#define write_char(c) {if (putc((int)c, fo) == EOF) { \\\n\n                         perror (\"putc\"); \\\n\n                         fprintf (stderr, \"Error writting on %s\\n\", file_name); \\\n\n                         break; \\\n\n                        } \\\n\n                      }\n\n\n\nstatic void convert (char *file_name) {\n\n  char *unix_file_name;\n\n  FILE *fi, *fo;\n\n  char c, c1;\n\n\n\n  unix_file_name = malloc(strlen(file_name) + sizeof(SUFFIX));\n\n  if (unix_file_name == (char*) NULL) {\n\n    perror (\"malloc\");\n\n    fprintf (stderr, \"Error allocating file name %s%s\\n\", file_name, SUFFIX);\n\n    return;\n\n  }\n\n  strcpy (unix_file_name, file_name);\n\n  strcat (unix_file_name, \".tmp\");\n\n\n\n\n\n  if ( (fi = fopen (file_name, \"rb\")) == (FILE*)NULL) {\n\n    perror (\"fopen\");\n\n    fprintf (stderr, \"Error openning %s for reading\\n\", file_name);\n\n    free (unix_file_name);\n\n    return;\n\n  }\n\n\n\n  if ( (fo = fopen (unix_file_name, \"wb\")) == (FILE*)NULL) {\n\n    perror (\"fopen\");\n\n    fprintf (stderr, \"Error openning %s for writting\\n\", unix_file_name);\n\n    (void) fclose(fi);\n\n    free (unix_file_name);\n\n    return;\n\n  }\n\n\n\n  /* 0D 0A --> 0A */\n\n  /* 1A    --> Close */\n\n  for (;;) {\n\n    c = getc(fi);\n\n    if (c == (char) 0x0D) {\n\n      c1 = getc(fi);\n\n      if (c1 != (char) 0x0A) {\n\n        write_char(c);\n\n      }\n\n      write_char(c1);\n\n    } else if ( (c == (char) 0x1A) || ((int)c == EOF) ) {\n\n      break;\n\n    } else {\n\n      write_char(c);\n\n    }\n\n  }\n\n\n\n  if (fclose(fi) != 0) {\n\n    perror (\"fclose\");\n\n    fprintf (stderr, \"Error closing %s after processing\\n\", file_name);\n\n  }\n\n\n\n  if (fclose(fo) != 0) {\n\n    perror (\"fclose\");\n\n    fprintf (stderr, \"Error closing %s after processing\\n\", unix_file_name);\n\n  }\n\n\n\n  if (unlink (file_name) == -1) {\n\n    perror (\"unlink\");\n\n    fprintf (stderr, \"Error removing %s after processing\\n\",\n\n                     file_name);\n\n    free (unix_file_name);\n\n    return;\n\n  }\n\n  if (rename (unix_file_name, file_name) == -1) {\n\n    perror (\"rename\");\n\n    fprintf (stderr, \"Error renaming %s to %s after processing\\n\",\n\n                      unix_file_name, file_name);\n\n    free (unix_file_name);\n\n    exit (1);\n\n  }\n\n  free (unix_file_name);\n\n\n\n}\n\n\n\nint main (int argc, char *argv[]) {\n\n\n\n\n\n  int cur_arg;\n\n\n\n  for (cur_arg=2; cur_arg <= argc; cur_arg++) {\n\n    printf (\"Converting dos to unix : %s\\n\", argv[cur_arg-1]);\n\n    convert(argv[cur_arg-1]);\n\n  }\n\n  printf (\"Done.\\n\");\n\n  exit (0);\n\n}\n\n\n", "#include <stdio.h>\n\n#include <stdlib.h>\n\n#include \"timeval.h\"\n\n\n\n\n\nint main(void) {\n\ntimeout_t orig, new;\n\n\n\n  get_time (&new);\n\n\n\n  do {\n\n    get_time (&orig);\n\n  } while (comp_time (&orig, &new) == 0);\n\n\n\n  do {\n\n    get_time (&new);\n\n  } while (comp_time (&orig, &new) == 0);\n\n\n\n  (void) sub_time (&new, &orig);\n\n\n\n  printf (\"Tick : %ld sec . %06ld usec \\n\", new.tv_sec, new.tv_usec);\n\n  exit(0);\n\n}\n\n\n", "#include <stdio.h>\n\n#include <stdlib.h>\n\n#include <unistd.h>\n\n\n\n#define LP_NAME \"/dev/lp0\"\n\n\n\nint main (void) {\n\n  const char form_feed = (char) 0x0C;\n\n  FILE * lp;\n\n  \n\n  lp = fopen (LP_NAME, \"a\");\n\n  if (lp == (FILE*)NULL) {\n\n    perror (\"fopen\");\n\n    fprintf (stderr, \"Cannot open stream %s\\n\", LP_NAME);\n\n    exit (1);\n\n  }\n\n\n\n  (void) fputc ((int)form_feed, lp);\n\n  (void) fclose (lp);\n\n  exit (0);\n\n}\n\n\n", "#include <ctype.h>\n\n#include <stdlib.h>\n\n#include <stdio.h>\n\n#include <string.h>\n\n\n\n#include \"boolean.h\"\n\n#include \"timeval.h\"\n\n\n\nextern char *basename (const char *filename);\n\n\n\nint main(int argc, char *argv[]) {\n\n\n\n  timeout_t timeout;\n\n  int i, j;\n\n\n\n  timeout.tv_sec = 0;\n\n  timeout.tv_usec = 0;\n\n\n\n  if (argc == 1) {\n\n    exit (0);\n\n  } else if (argc > 3) {\n\n    fprintf (stderr, \"Syntax Error. Usage : %s  [secs [msecs]]\\n\", basename(argv[0]));\n\n    exit (1);\n\n  } else {\n\n    for (i = 1; i < argc; i++) {\n\n      for (j = 0; (unsigned int)j < strlen(argv[i]); j++) {\n\n        if (! isdigit((int)argv[i][j])) {\n\n          fprintf (stderr, \"Syntax Error. Usage : %s  [secs [msecs]]\\n\", basename(argv[0]));\n\n          exit (1);\n\n        }\n\n      }\n\n    }\n\n  }\n\n\n\n\n\n  timeout.tv_sec = atoi(argv[1]);\n\n\n\n  if (argc == 3) timeout.tv_usec = atoi(argv[2]) * 1000;\n\n\n\n  delay(&timeout);\n\n\n\n  exit (0);\n\n\n\n}\n", "void init_tty (const char *arg, int ctsrts, int echo, int crlf);\n\n\n\nvoid restore_tty (void);\n\n\n\nvoid send_tty (char c);\n\n\n\nvoid read_tty (char *c);\n\n\n\nint get_tty_fd(void);\n\n\n\nvoid init_kbd (int kfd);\n\n\n\nvoid restore_kbd (int kfd);\n\n\n", "#include <sys/types.h>\n\n#include <sys/ioctl.h>\n\n#include <sys/termios.h>\n\n#include <sys/file.h>\n\n#include <stdio.h>\n\n#include <stdlib.h>\n\n#include <fcntl.h>\n\n#include <errno.h>\n\n#include <unistd.h>\n\n#include <string.h>\n\n\n\n#include \"tty.h\"\n\n\n\n#define TTY_DEV \"/dev/\"\n\n\n\n#define EXIT { \\\n\n  printf (\"TTY specification ERROR\\n\"); \\\n\n  printf (\"<tty_name>:<datab>:<parity>:<stopb>:<bauds>\\n\"); \\\n\n  printf (\" example : tty00:8:N:1:9600\\n\"); \\\n\n  exit (1); \\\n\n}\n\n\n\nstatic struct termios kbd_mode;\t\n\nstatic int fd = -1;\n\nstatic char tty_spec[50];\n\nstatic int start;\n\nstatic unsigned int last;\n\n\n\nstatic void parse (const char *arg) {\n\n  unsigned int i;\n\n  last = strlen(arg);\n\n  if (last > sizeof(tty_spec)-1) {\n\n    EXIT;\n\n  }\n\n  strcpy (tty_spec, arg);\n\n  for (i = 0; i < last; i++) {\n\n    if (tty_spec[i] == ':') {\n\n      tty_spec[i] = '\\0';\n\n    }\n\n  }\n\n  start = 0;\n\n}\n\n\n\nstatic void next (void) {\n\n  do {\n\n    start++;\n\n  } while (tty_spec[start]!='\\0' );\n\n\n\n  if ((unsigned)start == last) {\n\n    start = -1;\n\n  } else {\n\n    start ++;\n\n  }\n\n\n\n}\n\n\n\nvoid init_tty (const char *arg, int ctsrts, int echo, int crlf) {\n\n\n\n  char tty_name[50];\n\n  struct termios mode;\n\n\n\n  tcflag_t c_flags;\n\n  speed_t speed;\n\n  long flags;\n\n\n\n  parse (arg);\n\n\n\n  strcpy (tty_name, TTY_DEV);\n\n  strcat (tty_name, &tty_spec[start]);\n\n\n\n  /* Parse tty spec and set c_flags and speeds */\n\n  c_flags = 0;\n\n  next (); if (start == -1) EXIT;\n\n\n\n  if      (strcmp(&tty_spec[start], \"7\") == 0) c_flags |= CS7;\n\n  else if (strcmp(&tty_spec[start], \"8\") == 0) c_flags |= CS8;\n\n  else    EXIT;\n\n\n\n  next (); if (start == -1) EXIT;\n\n  if      (strcmp(&tty_spec[start], \"N\") == 0) ;\n\n  else if (strcmp(&tty_spec[start], \"O\") == 0) c_flags |= (PARENB | PARODD);\n\n  else if (strcmp(&tty_spec[start], \"E\") == 0) c_flags |= PARENB;\n\n  else    EXIT;\n\n\n\n  next (); if (start == -1) EXIT;\n\n  if      (strcmp(&tty_spec[start], \"1\") == 0);\n\n  else if (strcmp(&tty_spec[start], \"2\") == 0) c_flags = CSTOPB;\n\n  else    EXIT;\n\n\n\n  next (); if (start == -1) EXIT;\n\n  if      (strcmp(&tty_spec[start],    \"300\") == 0) speed = B300;\n\n  else if (strcmp(&tty_spec[start],    \"600\") == 0) speed = B600;\n\n  else if (strcmp(&tty_spec[start],   \"1200\") == 0) speed = B1200;\n\n  else if (strcmp(&tty_spec[start],   \"1800\") == 0) speed = B1800;\n\n  else if (strcmp(&tty_spec[start],   \"2400\") == 0) speed = B2400;\n\n  else if (strcmp(&tty_spec[start],   \"4800\") == 0) speed = B4800;\n\n  else if (strcmp(&tty_spec[start],   \"9600\") == 0) speed = B9600;\n\n  else if (strcmp(&tty_spec[start],  \"19200\") == 0) speed = B19200;\n\n  else if (strcmp(&tty_spec[start],  \"38400\") == 0) speed = B38400;\n\n  else if (strcmp(&tty_spec[start], \"115200\") == 0) speed = B115200;\n\n  else if (strcmp(&tty_spec[start], \"230400\") == 0) speed = B230400;\n\n  else    EXIT;\n\n\n\n  next (); if (start != -1) EXIT;\n\n\n\n  fd = open (tty_name, O_RDWR | O_NONBLOCK | O_NOCTTY);\n\n  if (fd < 0) {\n\n    perror (\"Error open tty\");\n\n    fprintf (stderr, \">%s<\\n\", tty_name);\n\n    exit(1);\n\n  }\n\n\n\n  if (flock (fd, LOCK_EX | LOCK_NB) != 0) {\n\n    perror (\"Error flock tty\");\n\n    fprintf (stderr, \"Device %s is locked.\\n\", tty_name);\n\n    close (fd);\n\n    exit(1);\n\n  }\n\n\n\n  flags = fcntl (fd, F_GETFL);\n\n  if (flags == -1) {\n\n    perror (\"Error fcntl getfl tty\");\n\n    fprintf (stderr, \">%s<\\n\", tty_name);\n\n    exit(1);\n\n  }\n\n  flags = O_RDWR;\n\n  if (fcntl (fd, F_SETFL, flags) != 0) {\n\n    perror (\"Error fcntl setfl tty\");\n\n    fprintf (stderr, \">%s<\\n\", tty_name);\n\n    exit(1);\n\n  }\n\n\n\n\n\n  if (tcgetattr (fd, &mode) < 0) {\n\n    perror (\"Error tcgetattr tty\");\n\n    restore_tty ();\n\n    exit (1);\n\n  }\n\n\n\n  /* Set Serial line charactistics */\n\n  mode.c_cflag = c_flags;\n\n  if (cfsetispeed (&mode, speed) < 0) {\n\n    perror (\"Error cfsetispeed\");\n\n    fprintf (stderr, \">%s<\\n\", tty_name);\n\n    exit(1);\n\n  }\n\n  if (cfsetospeed (&mode, speed) < 0) {\n\n    perror (\"Error cfsetospeed\");\n\n    fprintf (stderr, \">%s<\\n\", tty_name);\n\n    exit(1);\n\n  }\n\n\n\n  if (crlf) {\n\n    mode.c_oflag = OCRNL;\n\n    mode.c_iflag = ICRNL;\n\n  } else {\n\n    mode.c_oflag = 0;\n\n    mode.c_iflag = 0;\n\n  }\n\n  mode.c_iflag |= IGNBRK;\n\n  if (echo) {\n\n    mode.c_lflag = ECHO;\n\n  } else {\n\n    mode.c_lflag = 0;\n\n  }\n\n   mode.c_cflag |= CLOCAL | CREAD;\n\n  if (ctsrts) {\n\n    mode.c_cflag |= CRTSCTS;\n\n  } else {\n\n    mode.c_cflag &= ~CRTSCTS;\n\n    mode.c_iflag |= IXOFF | IXON;\n\n  }\n\n  mode.c_cc[VMIN] = 1;\n\n  mode.c_cc[VTIME] = 5;\n\n\n\n  if (tcsetattr (fd, TCSANOW, &mode) < 0) {\n\n    perror (\"Error tcsetattr tty\");\n\n    restore_tty ();\n\n    exit (1);\n\n  }\n\n#ifdef DEBUG\n\nfprintf (stderr, \"TTY %s initialised.\\n\", tty_name);\n\n#endif\n\n\n\n}\n\n\n\nvoid restore_tty (void) {\n\n  if (fd == -1) return;\n\n  (void) flock (fd, LOCK_UN);\n\n  (void) close (fd);\n\n}\n\n\n\nvoid send_tty (char c) {\n\n\n\n  int cr;\n\n\n\n  for (;;) {\n\n    cr = (write (fd, &c, 1) >= 0);\n\n    if (cr) return;\n\n    if (errno != EINTR) {\n\n      perror (\"write tty\");\n\n      return;\n\n    }\n\n  }\n\n}\n\n\n\nvoid read_tty (char *c) {\n\n  int res;\n\n\n\n  do {\n\n    res = read (fd, c, 1);\n\n    if ( (res == -1)  && (errno != EINTR) )  {\n\n      perror (\"read tty\");\n\n    }\n\n  } while (res != 1);\n\n}\n\n\n\nint get_tty_fd(void) {\n\n  return (fd);\n\n}\n\n\n\n\n\nvoid init_kbd (int kfd) {\n\n  struct termios mode;\n\n\n\n  if (tcgetattr (kfd, &mode) < 0) {\n\n    perror (\"Error tcgetattr kbd\");\n\n    restore_tty ();\n\n    exit (1);\n\n  }\n\n  memcpy (&kbd_mode, &mode, sizeof(struct termios));\n\n  mode.c_iflag = 0;\n\n  mode.c_oflag = 0;\n\n  mode.c_lflag = 0;\n\n  mode.c_cflag = (CLOCAL);\n\n  mode.c_cc[VMIN] = 1;\n\n  mode.c_cc[VTIME] = 0;\n\n\n\n  if (tcsetattr (kfd, TCSANOW, &mode) < 0) {\n\n    perror (\"Error tcsetattr kbd\");\n\n    restore_tty ();\n\n    exit (1);\n\n  }\n\n\n\n#ifdef DEBUG\n\nfprintf (stderr, \"KBD initialised.\\n\");\n\n#endif\n\n\n\n}\n\n\n\nvoid restore_kbd (int kfd) {\n\n\n\n  if (tcsetattr (kfd, TCSANOW, &kbd_mode) < 0) {\n\n    perror (\"Error tcsetattr kbd\");\n\n    restore_tty ();\n\n    exit (1);\n\n  }\n\n}\n\n\n", "#include <sys/time.h>\n\n#include <sys/types.h>\n\n#include <unistd.h>\n\n#include <stdio.h>\n\n#include <stdlib.h>\n\n#include <string.h>\n\n#include <errno.h>\n\n\n\n#include \"tty.h\"\n\n\n\nint main (int argc, char *argv[]) {\n\n\n\n  int kfd, tfd;\n\n  int nfd;\n\n  fd_set fixed_mask, select_mask;\n\n  int cr;\n\n  char c;\n\n  int i;\n\n  int echo;\n\n  int mapda;\n\n  int ctsrts;\n\n\n\n  if (argc < 2) {\n\n    fprintf (stderr, \"Usage %s <tty_spec> [ echo ] [ crlf ] [ noctsrts ]\\n\",\n\n                     argv[0]);\n\n    init_tty(\"\", 0, 0, 0);\n\n    exit (1);\n\n  }\n\n\n\n  echo = 0;\n\n  mapda = 0;\n\n  ctsrts = 1;\n\n  for (i = 2; i < argc; i++) {\n\n    if (strcmp(argv[i], \"echo\") == 0) {\n\n      echo = 1;\n\n    } else if (strcmp(argv[i], \"crlf\") == 0) {\n\n      mapda = 1;\n\n    } else if (strcmp(argv[i], \"noctsrts\") == 0) {\n\n      ctsrts = 0;\n\n    } else {\n\n      fprintf (stderr, \"Usage %s <tty_spec> [ echo ] [ crlf ] [ noctsrts ]\\n\",\n\n               argv[0]);\n\n      init_tty(\"\", 0, 0, 0);\n\n      exit (1);\n\n    }\n\n  }\n\n\n\n  init_tty(argv[1], ctsrts, echo, mapda);\n\n  tfd = get_tty_fd();\n\n  printf (\"Ready. Exit with Ctrl X.\\n\");\n\n\n\n  kfd = fileno(stdin);\n\n  init_kbd(kfd);\n\n\n\n  nfd = tfd;\n\n  if (nfd < kfd) nfd = kfd;\n\n  FD_ZERO (&fixed_mask);\n\n  FD_SET (tfd, &fixed_mask);\n\n  FD_SET (kfd, &fixed_mask);\n\n\n\n  for (;;) {\n\n    memcpy (&select_mask, &fixed_mask, sizeof(fd_set));\n\n    cr = select (nfd+1, &select_mask, (fd_set*)NULL, (fd_set*)NULL,\n\n         (struct timeval*)NULL);\n\n    if (cr == -1) {\n\n      if (errno != EINTR) {\n\n        perror (\"select\");\n\n      }\n\n    } else if (cr == 0) {\n\n      fprintf (stderr, \"select returned 0\\n\");\n\n    } else {\n\n      if (FD_ISSET(kfd, &select_mask) ) {\n\n#ifdef DEBUG\n\nfprintf (stderr, \"kbd event selected\\n\");\n\n#endif\n\n        errno = 0;\n\n        cr = read (kfd, &c, 1);\n\n        if (cr != 1) {\n\n          perror (\"read kbd\");\n\n        }\n\n#ifdef DEBUG\n\nfprintf (stderr, \"kbd char read: %c 0x%x\\n\", c, (int)c);\n\n#endif\n\n\n\n        if (c == 0x18) {\n\n          /* Exit */\n\n          restore_kbd (kfd);\n\n          restore_tty ();\n\n          (void) putchar ((int)'\\n');\n\n          exit (0);\n\n        }\n\n\n\n        send_tty (c);\n\n#ifdef DEBUG\n\nfprintf (stderr, \"sent to tty.\\n\");\n\n#endif\n\n      } else if (FD_ISSET(tfd, &select_mask) ) {\n\n#ifdef DEBUG\n\nfprintf (stderr, \"tty event selected\\n\");\n\n#endif\n\n        read_tty (&c);\n\n#ifdef DEBUG\n\nfprintf (stderr, \"tty char read: %c %x\\n\", c, (int)c);\n\n#endif\n\n        (void) putchar ((int)c);\n\n#ifdef DEBUG\n\nfprintf (stderr, \"sent to display.\\n\");\n\n#endif\n\n        (void) fflush (stdout);\n\n      } else {\n\n        fprintf (stderr, \"select returned but fd not set\\n\");\n\n      }\n\n    }\n\n \n\n  }\n\n\n\n}\n\n\n", "/* limits.h */\n\n/* Produced by enquire version 5.0, CWI, Amsterdam */\n\n\n\n   /* Number of bits in a storage unit */\n\n#define CHAR_BIT 8\n\n   /* Maximum char */\n\n#define CHAR_MAX 127\n\n   /* Minimum char */\n\n#define CHAR_MIN (-128)\n\n   /* Maximum signed char */\n\n#define SCHAR_MAX 127\n\n   /* Minimum signed char */\n\n#define SCHAR_MIN (-128)\n\n   /* Maximum unsigned char (minimum is always 0) */\n\n#define UCHAR_MAX 255\n\n   /* Maximum short */\n\n#define SHRT_MAX 32767\n\n   /* Minimum short */\n\n#define SHRT_MIN (-32768)\n\n   /* Maximum int */\n\n#define INT_MAX 2147483647\n\n   /* Minimum int */\n\n#define INT_MIN (-2147483647-1)\n\n   /* Maximum long */\n\n#define LONG_MAX 2147483647L\n\n   /* Minimum long */\n\n#define LONG_MIN (-2147483647L-1L)\n\n   /* Maximum unsigned short (minimum is always 0) */\n\n#define USHRT_MAX 65535\n\n   /* Maximum unsigned int (minimum is always 0) */\n\n#define UINT_MAX 4294967295U\n\n   /* Maximum unsigned long (minimum is always 0) */\n\n#define ULONG_MAX 4294967295UL\n", "/* float.h */\n\n/* Produced by enquire version 5.0, CWI, Amsterdam */\n\n\n\n   /* Radix of exponent representation */\n\n#define FLT_RADIX 2\n\n   /* Number of base-FLT_RADIX digits in the significand of a float */\n\n#define FLT_MANT_DIG 24\n\n   /* Number of decimal digits of precision in a float */\n\n#define FLT_DIG 6\n\n   /* Addition rounds to 0: zero, 1: nearest, 2: +inf, 3: -inf, -1: unknown */\n\n#define FLT_ROUNDS 1\n\n   /* Difference between 1.0 and the minimum float greater than 1.0 */\n\n#define FLT_EPSILON 1.19209290e-07F\n\n   /* Minimum int x such that FLT_RADIX**(x-1) is a normalised float */\n\n#define FLT_MIN_EXP (-125)\n\n   /* Minimum normalised float */\n\n#define FLT_MIN 1.17549435e-38F\n\n   /* Minimum int x such that 10**x is a normalised float */\n\n#define FLT_MIN_10_EXP (-37)\n\n   /* Maximum int x such that FLT_RADIX**(x-1) is a representable float */\n\n#define FLT_MAX_EXP 128\n\n   /* Maximum float */\n\n#define FLT_MAX 3.40282347e+38F\n\n   /* Maximum int x such that 10**x is a representable float */\n\n#define FLT_MAX_10_EXP 38\n\n\n\n   /* Number of base-FLT_RADIX digits in the significand of a double */\n\n#define DBL_MANT_DIG 53\n\n   /* Number of decimal digits of precision in a double */\n\n#define DBL_DIG 15\n\n   /* Difference between 1.0 and the minimum double greater than 1.0 */\n\n#define DBL_EPSILON 2.2204460492503131e-16\n\n   /* Minimum int x such that FLT_RADIX**(x-1) is a normalised double */\n\n#define DBL_MIN_EXP (-1021)\n\n   /* Minimum normalised double */\n\n#define DBL_MIN 2.2250738585072014e-308\n\n   /* Minimum int x such that 10**x is a normalised double */\n\n#define DBL_MIN_10_EXP (-307)\n\n   /* Maximum int x such that FLT_RADIX**(x-1) is a representable double */\n\n#define DBL_MAX_EXP 1024\n\n   /* Maximum double */\n\n#define DBL_MAX 1.7976931348623157e+308\n\n   /* Maximum int x such that 10**x is a representable double */\n\n#define DBL_MAX_10_EXP 308\n\n\n\n   /* Number of base-FLT_RADIX digits in the significand of a long double */\n\n#define LDBL_MANT_DIG 64\n\n   /* Number of decimal digits of precision in a long double */\n\n#define LDBL_DIG 18\n\n   /* Difference between 1.0 and the minimum long double greater than 1.0 */\n\n#define LDBL_EPSILON 1.08420217248550443401e-19L\n\n   /* Minimum int x such that FLT_RADIX**(x-1) is a normalised long double */\n\n#define LDBL_MIN_EXP (-16381)\n\n   /* Minimum normalised long double */\n\n#define LDBL_MIN 3.36210314311209350626e-4932L\n\n   /* Minimum int x such that 10**x is a normalised long double */\n\n#define LDBL_MIN_10_EXP (-4931)\n\n   /* Maximum int x such that FLT_RADIX**(x-1) is a representable long double */\n\n#define LDBL_MAX_EXP 16384\n\n   /* Maximum long double */\n\n#define LDBL_MAX 1.18973149535723176502e+4932L\n\n   /* Maximum int x such that 10**x is a representable long double */\n\n#define LDBL_MAX_10_EXP 4932\n\n\n\n/* *** Something fishy here!\n\n    Exponent size + significand size doesn't match with the size of a long double! */\n\n\n\n\n", "#ifndef PROGRAM\n\n#define PROGRAM enquire.c\n\n#define VERSION \"5.0\"\n\n#define PURPOSE Everything you wanted to know about your machine and C compiler\n\n#define BUT\tdidnt know who to ask\n\n#define FOR\tAny OS, any C compiler\n\n#define AUTHOR\tSteven Pemberton, CWI, Amsterdam; \"Steven.Pemberton@cwi.nl\"\n\n#define COPYRIGHT(c) 1993 Steven Pemberton, CWI. All rights reserved.\n\n#define NOTE\tImprovements gratefully received. Please mention the version.\n\n#define COMPILE\tOn Unix compile with: \"sh enquire.c\"; see below for details\n\n#endif\n\n\n\n#ifdef NOTDEFINED /* This is how you compile it; see below for details */\n\n\tcase $0 in\n\n\t*.c) ;;\n\n\tsh) echo 'Use \"sh enquire.c\", not \"sh < enquire.c\"' >&2; exit 1;;\n\n\t*) echo 'Filename must end in \".c\"' >&2; exit 1;;\n\n\tesac\n\n\tif test -r test.c\n\n\tthen echo Would overwrite test.c - try it somewhere safer >&2; exit 1\n\n\tfi\n\n\tCFLAGS=\n\n\techo Testing for needed CFLAGS ...\n\n\techo \"main(){char c; c=0;}\" > test.c\n\n\tif ${CC=cc} ${1+\"$@\"} -o enquire test.c $LIBS\n\n\tthen :\n\n\telse\n\n\t    echo '*** \"'$CC ${1+\"$@\"} -o enquire test.c $LIBS'\" failed'\n\n\t    echo '*** Giving up'\n\n\t    /bin/rm -f test.c\n\n\t    exit 1\n\n\tfi\n\n\techo \"main(){signed char c; c=0;}\" > test.c\n\n\tif $CC ${1+\"$@\"} -o enquire test.c $LIBS 2>/dev/null\n\n\tthen echo \"   Signed char ok\"\n\n\telse\n\n\t\tCFLAGS=-DNO_SC\n\n\t\techo \"   Signed char not accepted; using $CFLAGS\"\n\n\tfi\n\n\techo \"main(){unsigned char c; c=0;}\" > test.c\n\n\tif $CC ${1+\"$@\"} -o enquire test.c $LIBS 2>/dev/null\n\n\tthen echo \"   Unsigned char ok\"\n\n\telse\n\n\t\tCFLAGS=\"$CFLAGS -DNO_UC\"\n\n\t\techo \"   Unsigned char not accepted; using $CFLAGS\"\n\n\tfi\n\n\techo \"main(){unsigned short s;unsigned long l;s=0;l=0;}\" > test.c\n\n\tif $CC ${1+\"$@\"} -o enquire test.c $LIBS 2>/dev/null\n\n\tthen echo \"   Unsigned short and long ok\"\n\n\telse\n\n\t\tCFLAGS=\"$CFLAGS -DNO_UI\"\n\n\t\techo \"   Unsigned short or long not accepted; using $CFLAGS\"\n\n\tfi\n\n\techo \"void foo(){} main(){foo();}\" > test.c\n\n\tif $CC ${1+\"$@\"} -o enquire test.c $LIBS 2>/dev/null\n\n\tthen echo \"   Void ok\"\n\n\telse\n\n\t\tCFLAGS=\"$CFLAGS -DNO_VOID\"\n\n\t\techo \"   Void not accepted; using $CFLAGS\"\n\n\tfi\n\n\t/bin/rm -f test.c a.out\n\n\n\n\techo Compiling $0 ...\n\n\tcase $# in\n\n\t0) : check bug in interpreting \"$@\" in some shells, if no parameters\n\n\t   case `echo 1 \"$@\" 2` in\n\n\t   \"1  2\") echo '   *** There is a bug in your shell expanding \"$@\"!'\n\n\t\t   echo '   *** Taking remedial action' ;;\n\n\t   \"1 2\") ;;\n\n\t   esac\n\n\tesac\n\n\techo \"   $CC\" $CFLAGS \"$@\" $0 -o enquire $LIBS\n\n\t$CC $CFLAGS ${1+\"$@\"} $0 -o enquire $LIBS ||\n\n\t\t{ echo '***' Try setting some CFLAGS; exit 1; }\n\n\techo \"Producing enquire.out limits.h and float.h ...\"\n\n\techo \"   enquire > enquire.out\"\n\n\t./enquire > enquire.out || echo '   *** Some problems: see enquire.out'\n\n\techo \"   enquire -l > limits.h\"\n\n\t./enquire -l > limits.h || echo '   *** Some problems: see limits.h'\n\n\techo \"   enquire -f > float.h\"\n\n\t./enquire -f > float.h  || echo '   *** Some problems: see float.h'\n\n\techo \"Verifying the contents of limits.h and float.h ...\"\n\n\techo \"   $CC\" -DVERIFY $CFLAGS \"$@\" $0 -o verify $LIBS\n\n\t$CC -DVERIFY $CFLAGS ${@+\"$@\"} $0 -o verify $LIBS ||\n\n\t\t{ echo '***' Failed; exit 1; }\n\n\techo \"   verify -fl > verify.out\"\n\n\t./verify -fl > verify.out ||\n\n\t\techo '   *** Some problems: see verify.out'\n\n\techo Done\n\n\texit 0\n\n#endif\n\n\n\n/*\n\n PURPOSE\n\n    This is a program that determines many properties of the C\n\n    compiler and machine that it is run on, such as minimum and\n\n    maximum [un]signed char/int/long, many properties of float/ [long]\n\n    double, and so on.\n\n\n\n    As an option it produces the ANSI C float.h and limits.h files.\n\n\n\n    As a further option, it even checks that the compiler reads the\n\n    header files correctly.\n\n\n\n    It is a good test-case for compilers, since it exercises them with\n\n    many limiting values, such as the minimum and maximum floating-point\n\n    numbers.\n\n\n\n    Enquire is a part of the CWI Portability Kit, a suite of programs\n\n    and tools designed to make the task of porting easier.\n\n    More details from Steven.Pemberton@cwi.nl.\n\n\n\n COMPILING AND RUNNING ON UNIX MACHINES\n\n    With luck and a following wind, on Unix systems just the following\n\n    will work:\n\n\tsh enquire.c    (or whatever filename you chose).\n\n    Any parameters are passed to the C compiler, so if the compilation\n\n    fails for any reason curable as explained below, you can do the following:\n\n\tsh enquire.c -DBAD_CPP\n\n\n\n    If you do get compilation errors, check the line in question.\n\n    Very often there is a comment attached saying which define to set.\n\n\n\n    You can use a different C compiler than the default cc by setting CC:\n\n\tCC=gcc sh enquire.c -ansi\n\n    You can load extra libraries by setting LIBS:\n\n\tCC=gcc LIBS=-lflong sh enquire.c -ansi\n\n\n\n    Add -DID=\\\"name\\\" if you want the machine/flags identified in the output.\n\n\n\n    Compiling may give messages about unreachable code. These you can ignore.\n\n\n\n    Some compilers offer various flags for different floating point\n\n    modes; it's worth trying all possible combinations of these.\n\n\n\n    Don't say I haven't tried to make life easy for you...\n\n\n\n COMPILING AND RUNNING ON NON-UNIX SYSTEMS\n\n    On non-Unix systems, you must say (the equivalent of):\n\n\tcc enquire.c -o enquire\n\n\tenquire > enquire.out\n\n\tenquire -l > limits.h\n\n\tenquire -f > float.h\n\n\tcc -DVERIFY enquire.c -o verify #this includes limits.h and float.h\n\n\tverify -fl > verify.out\n\n\n\n    If your compiler doesn't support:\t\tadd flag:\n\n\tsigned char (eg pcc)\t\t\t-DNO_SC\n\n\tunsigned char\t\t\t\t-DNO_UC\n\n\tunsigned short and long\t\t\t-DNO_UI\n\n\tvoid\t\t\t\t\t-DNO_VOID\n\n\tsignal(), or setjmp/longjmp()\t\t-DNO_SIG\n\n\n\n    Try to compile first with no flags, and see if you get any errors\n\n    - you might be surprised. (Most non-ANSI compilers need -DNO_SC,\n\n    though.)  Some compilers need a -f flag for floating point.\n\n\n\n    Don't use any optimisation flags: the program may not work if you\n\n    do.  Though \"while (a+1.0-a-1.0 == 0.0)\" may look like \"while(1)\"\n\n    to an optimiser, to a floating-point unit there's a world of difference.\n\n\n\n    Compiling may give messages about unreachable code. These you can ignore.\n\n\n\n    Some compilers offer various flags for different floating point\n\n    modes; it's worth trying all possible combinations of these.\n\n\n\n FAULTY COMPILERS\n\n    Because of bugs and/or inadequacies, some compilers need the following\n\n    defines:\n\n\n\n    -  If your C preprocessor doesn't have the predefined __FILE__\n\n       macro, and you don't want to call this file enquire.c but, say,\n\n       tell.c, add the flag -DFILENAME=\\\"tell.c\\\" .\n\n\n\n    -  Some compilers won't accept the line \"#include FILENAME\".  Add\n\n       flag -DBAD_CPP. In that case, this file *must* be called\n\n       enquire.c.\n\n\n\n    -  Some compilers can't cope with \"#ifdef __FILE__\". Use\n\n       -DFILENAME= or -DBAD_CPP as above.\n\n\n\n    -  Some naughty compilers define __STDC__, but don't really\n\n       support it.  Some define it as 0, in which case we ignore it.\n\n       But if your compiler defines it, and isn't really ANSI C, add\n\n       flag -DBAD_STDC. (To those compiler writers: for shame).\n\n\n\n    -  Some naughty compilers define __STDC__, but don't have the\n\n       stddef.h include file. Add flag -DBAD_STDDEF. (Gcc needs this\n\n       on some machines, due to clashes between stddef.h and other\n\n       include files.)\n\n\n\n    -  Some systems crash when you try to malloc all store. To save\n\n       users of such defective systems too much grief, they may\n\n       compile with -DBAD_MALLOC, which ignores that bit of the code.\n\n\n\n    Summary of naughty-compiler flags:\n\n    If your compiler doesn't support:\t\t add flag:\n\n\t__FILE__ (and you changed the filename) -DFILENAME=\\\"name.c\\\"\n\n\t#ifdef __FILE__\t\t\t \t-DBAD_CPP or -DFILENAME=...\n\n\t#include FILENAME\t\t\t-DBAD_CPP\n\n\t__STDC__ (properly)\t\t\t-DBAD_STDC\n\n\tstddef.h\t\t\t\t-DBAD_STDDEF\n\n\tmalloc(LOTS) == NULL\t\t\t-DBAD_MALLOC\n\n\n\n    While it is not our policy to support defective compilers, pity has been\n\n    taken on people with compilers that can't produce object files bigger than\n\n    32k (especially since it was an easy addition). Compile the program\n\n    into separate parts like this:\n\n\tcc -c -DSEP -DPASS0 -o p0.o <other flags> enquire.c\n\n\tcc -c -DSEP -DPASS1 -o p1.o <other flags> enquire.c\n\n\tcc -c -DSEP -DPASS2 -o p2.o <other flags> enquire.c\n\n\tcc -c -DSEP -DPASS3 -o p3.o <other flags> enquire.c\n\n\tcc -o enquire p0.o p1.o p2.o p3.o\n\n\n\n SYSTEM DEPENDENCIES\n\n    You may possibly need to add some calls to signal() for other sorts of\n\n    exception on your machine than SIGFPE, SIGOVER, SIGBUS, and SIGSEGV.\n\n    See lines beginning #ifdef SIGxxx (and communicate the differences to me!).\n\n\n\n OUTPUT\n\n    Running without argument gives the information as English text. If run\n\n    with argument -l (e.g. enquire -l), output is a series of #define's for\n\n    the ANSI standard limits.h include file, excluding MB_MAX_CHAR. If run\n\n    with argument -f, output is a series of #define's for the ANSI standard\n\n    float.h include file (according to ANSI C Draft of Dec 7, 1988).\n\n    Flag -v gives verbose output: output includes the English text above\n\n    as C comments. The program exit(0)'s if everything went ok, otherwise\n\n    it exits with a positive number, telling how many problems there were.\n\n\n\n VERIFYING THE COMPILER\n\n    If, having produced the float.h and limits.h header files, you want to\n\n    verify that the compiler reads them back correctly (there are a lot of\n\n    boundary cases, of course, like minimum and maximum numbers), you can\n\n    recompile enquire.c with -DVERIFY set (plus the other flags that you used\n\n    when compiling the version that produced the header files). This then\n\n    recompiles the program so that it #includes \"limits.h\" and \"float.h\",\n\n    and checks that the constants it finds there are the same as the\n\n    constants it produces. Run the resulting program with enquire -fl.\n\n    Very few compilers have passed without error.\n\n    NB: You *must* recompile with the same compiler and flags, otherwise\n\n    you may get odd results.\n\n\n\n    You can also use this option if your compiler already has both files,\n\n    and you want to confirm that this program produces the right results.\n\n\n\n TROUBLESHOOTING.\n\n    This program is now quite trustworthy, and suspicious and wrong output\n\n    may well be caused by bugs in the compiler, not in the program (however\n\n    of course, this is not guaranteed, and no responsibility can be\n\n    accepted, etc.)\n\n\n\n    The program only works if overflows are ignored by the C system or\n\n    are catchable with signal().\n\n\n\n    If the program fails to run to completion (often with the error message\n\n    \"Unexpected signal at point x\"), this often turns out to be a bug in the\n\n    C compiler's run-time system. Check what was about to be printed, and\n\n    try to narrow the problem down.\n\n\n\n    Another possible problem is that you have compiled the program to produce\n\n    loss-of-precision arithmetic traps. The program cannot cope with these,\n\n    and you should re-compile without them. (They should never be the default).\n\n\n\n    Make sure you compiled with optimisation turned off.\n\n\n\n    Output preceded by *** WARNING: identifies behaviour of the C system\n\n    deemed incorrect by the program. Likely problems are that printf or\n\n    scanf don't cope properly with certain boundary numbers: this program\n\n    goes to a lot of trouble to calculate its values, and these values\n\n    are mostly boundary numbers. Experience has shown that often printf\n\n    cannot cope with these values, and so in an attempt to increase\n\n    confidence in the output, for each float and double that is printed,\n\n    the printed value is checked by using sscanf to read it back.\n\n\t Care is taken that numbers are printed with enough digits to uniquely\n\n    identify them, and therefore that they can be read back identically.\n\n    If the number read back is different, then there is probably a bug in\n\n    printf or sscanf, and the program prints the warning message.\n\n    If the two numbers in the warning look identical, then printf is more\n\n    than likely rounding the last digit(s) incorrectly. To put you at ease\n\n    that the two really are different, the bit patterns of the two numbers\n\n    are also printed. The difference is very likely in the last bit.\n\n\t Many scanf's read the minimum double back as 0.0, and similarly cause\n\n    overflow when reading the maximum double. This program quite ruthlessly\n\n    declares all these behaviours faulty. The point is that if you get\n\n    one of these warnings, the output may be wrong, so you should check\n\n    the result carefully if you intend to use the results. Of course, printf\n\n    and sscanf may both be wrong, and cancel each other out, so you should\n\n    check the output carefully anyway.\n\n\n\n    The warning that \"a cast didn't work\" refers to cases like this:\n\n\n\n\tfloat f;\n\n\t#define C 1.234567890123456789\n\n\tf= C;\n\n\tif (f != (float) C) printf (\"Wrong!\");\n\n\n\n    A faulty compiler will widen f to double and ignore the cast to float,\n\n    and because there is more accuracy in a double than a float, fail to\n\n    recognise that they are the same. In the actual case in point, f and C\n\n    are passed as parameters to a function that discovers they are not equal,\n\n    so it's just possible that the error was in the parameter passing,\n\n    not in the cast (see function Verify()).\n\n    For ANSI C, which has float constants, the error message is \"constant has\n\n    wrong precision\".\n\n\n\n REPORTING PROBLEMS\n\n    If the program doesn't work for you for any reason that can't be\n\n    narrowed down to a problem in the C compiler, or it has to be\n\n    changed in order to get it to compile, or it produces suspicious\n\n    output (like a very low maximum float, for instance), please mail\n\n    the problem and an example of the incorrect output to\n\n    Steven.Pemberton@cwi.nl or ..!sun4nl!cwi.nl!steven, so that\n\n    improvements can be worked into future versions; cwi.nl is the\n\n    European backbone, and is connected to uunet and other fine hosts.\n\n    Try to give as much information as possible;\n\n\t\tDON'T FORGET TO MENTION THE VERSION NUMBER!\n\n\n\n    The program tries to catch and diagnose bugs in the compiler/run-time\n\n    system. I would be especially pleased to have reports of failures so\n\n    that I can improve this service.\n\n\n\n    I apologise unreservedly for the contorted use of the preprocessor...\n\n    but it was fun!\n\n\n\n NEW VERSIONS\n\n    Worried that you may not have the latest version? Ftp to\n\n    ftp.cwi.nl, and look in directory pub/steven/enquire\n\n    for file enquireXX.c; XX is the version number.  Or look at\n\n    http://www.cwi.nl/~steven/enquire.html\n\n\n\n HOW DOES ENQUIRE WORK?\n\n    There is an article that explains a lot of the workings: The\n\n    Ergonomics of Portability; available from the above addresses as file\n\n    enquire.ps.\n\n\n\n THE SMALL PRINT\n\n    This is not a public domain program; nor is any other program that\n\n    carries a copyright notice. It is however freely copyable under the\n\n    following conditions:\n\n\n\n       You may copy and distribute verbatim copies of this source file.\n\n       You may modify this source file, and copy and distribute such\n\n       modified versions, provided that you leave the copyright notice\n\n       at the top of the file and also cause the modified file to carry\n\n       prominent notices stating that you changed the files and the\n\n       date of any change; and cause the whole of any work that you\n\n       distribute or publish, that in whole or in part contains or is a\n\n       derivative of this program or any part thereof, to be licensed\n\n       at no charge to all third parties on terms identical to those\n\n       here.\n\n\n\n    While every effort has been taken to make this program as reliable as\n\n    possible, no responsibility can be taken for the correctness of the\n\n    output, nor suitability for any particular use.\n\n\n\n    If you do have a fix to any problem, please send it to me, so that\n\n    other people can have the benefits.\n\n\n\n    This program is an offshoot of a project funded by public funds.\n\n    If you use this program for research or commercial use (i.e. more\n\n    than just for the fun of knowing about your compiler) mailing a short\n\n    note of acknowledgement may help keep enquire.c supported.\n\n\n\n ACKNOWLEDGEMENTS\n\n    Many people have given time and ideas to making this program what it is.\n\n    To all of them thanks, and apologies for not mentioning them by name.\n\n\n\n HISTORY\n\n    Originally started as a program to generate configuration constants\n\n    for a large piece of software we were writing, which later took on\n\n    a life of its own...\n\n    1.0 Length 6658!; end 1984?\n\n\tUnix only. Only printed a dozen maximum int/double values.\n\n    2.0 Length 10535; Spring 1985\n\n\tPrints values as #defines (about 20 of them)\n\n\tMore extensive floating point, using Cody and Waite\n\n\tHandles signals better\n\n\tPrograms around optimisations\n\n\tHandles Cybers\n\n    3.0\tLength 12648; Aug 1987; prints about 42 values\n\n\tAdded PASS stuff, so treats float as well as double\n\n    4.0 Length 33891; Feb 1989; prints around 85 values\n\n\tFirst GNU version (for gcc, where they called it hard-params.c)\n\n\tGenerates float.h and limits.h files\n\n\tHandles long double\n\n\tGenerates warnings for dubious output\n\n    4.1 Length 47738; April 1989\n\n\tAdded VERIFY and TEST\n\n    4.2 Length 63442; Feb 1990\n\n\tAdded SEP\n\n\tFixed eps/epsneg\n\n\tAdded check for pseudo-unsigned chars\n\n\tAdded description for each #define output\n\n\tAdded check for absence of defines during verify\n\n\tAdded prototypes\n\n\tAdded BAD_STDC and BAD_CPP\n\n\tFixed alignments output\n\n    4.3\tLength 75000; Oct 1990; around 114 lines of output\n\n\tFunction xmalloc defined, Richard Stallman, June 89.\n\n\tAlignments computed from member offsets rather than structure sizes,\n\n\t    Richard Stallman, Oct 89\n\n\tPrint whether char* and int* pointers have the same format;\n\n\t    also char * and function *\n\n\tUpdate to Draft C version Dec 7, 1988\n\n\t    - types of constants produced in limits.h\n\n\t\t(whether to put a U after unsigned shorts and chars and\n\n\t\t whether to output -1024 as (-1023-1))\n\n\t    - values of SCHAR_MIN/MAX\n\n\t    - values of *_EPSILON (not the smallest but the effective smallest)\n\n\tAdded FILENAME, since ANSI C doesn't allow #define __FILE__\n\n\tRenamed from config.c to enquire.c\n\n\tAdded size_t and ptrdiff_t enquiries\n\n\tAdded promotion enquiries\n\n\tAdded type checks of #defines\n\n\tAdded BAD_STDDEF\n\n\tChanged endian to allow for cases where not all bits are used\n\n\tSanity check for max integrals\n\n\tFixed definition of setjmp for -DNO_SIG\n\n\tMoved #define ... 0.0L inside #ifdef STDC, in case some cpp's tokenize\n\n\tAdded BAD_MALLOC\n\n    5.0 Length 87993; February 1993; around 120 lines of output\n\n\t\t\t\t (depends on what you count)\n\n\tAdded the 'sh enquire.c' horror/delight: thanks David Mankins@think\n\n\tAdded checks for long names: thanks Steve Simon@leeds-poly\n\n\tAdded FPE signal checks: thanks Leonid A. Broukhis@s514.ipmce.su\n\n\tAdded check for dereferencing NULL\n\n\tAdded TESTI\n\n\tAdded LIBS, fixed showtype: thanks Rainer Orth@TechFak.Uni-Bielefeld.DE\n\n\tAdded a free(): thanks nickc@perihelion.co.uk\n\n\tAdded signal catching to the malloc part\n\n\tRenamed naughty-compiler defines to BAD_*\n\n\tRenamed and altered Verify() to better check faulty compilers\n\n\tShut some compilers up from giving incorrect warnings.\n\n\tFixed sign_of(): thanks Hugh Redelmeier@redvax\n\n\tFixed USHRT_MAX for sizeof(short)=sizeof(int) but INT_MAX > SHRT_MAX\n\n\tFixed NO_UI\n\n\tFixed -DSEP: thanks Mike Black@seismo\n\n\tFixed the case where stdio.h includes limits.h: thanks rms@gnu\n\n\tFixed exponent(): thanks Christophe BINOT\n\n\t\t<chb%hpvpta.france.hp.com@hplb.hpl.hp.com>\n\n*/\n\n\n\n/* Set FILENAME to the name of this file */\n\n#ifndef FILENAME\n\n#ifdef BAD_CPP\n\n#define FILENAME \"enquire.c\"\n\n#else\n\n#ifdef __FILE__ /* It's a compiler bug if this fails. Define BAD_CPP */\n\n#define FILENAME __FILE__\n\n#else\n\n#define FILENAME \"enquire.c\"\n\n#endif /* __FILE__ */\n\n#endif /* BAD_CPP */\n\n#endif /* FILENAME */\n\n\n\n/* This file is read three times (it #includes itself), to generate\n\n   otherwise identical code for each of short+float, int+double,\n\n   long+long double. If PASS isn't defined, then this is the first pass.\n\n   Code bracketed by 'PASS0' is for stuff independent of all three,\n\n   but is read during the first pass.\n\n*/\n\n#ifndef PASS\n\n#ifdef SEP /* so we're only interested if this is pass 1 or not */\n\n#ifdef PASS1\n\n#define PASS 1\n\n#else\n\n#define PASS 0\n\n#endif\n\n#else /* no SEP, so this is the first pass */\n\n#define PASS 1\n\n#define PASS0 1\n\n#define PASS1 1\n\n#endif /* SEP */\n\n\n\n/* Void just marks the functions that don't return a result */\n\n#ifdef NO_VOID\n\n#define Void int\n\n#else\n\n#define Void void\n\n#endif\n\n\n\n/* Set STDC to whether this is *really* an ANSI C compiler.\n\n   Some bad compilers define __STDC__, when they don't support it.\n\n   Compile with -DBAD_STDC to get round this.\n\n*/\n\n#ifndef BAD_STDC\n\n#ifdef __STDC__\n\n#if __STDC__ /* If __STDC__ is 0, assume it isn't supported */\n\n#define STDC\n\n#endif\n\n#endif\n\n#endif\n\n\n\n/* Stuff different for ANSI C, and old C:\n\n   ARGS and NOARGS are used for function prototypes.\n\n   Volatile is used to reduce the chance of optimisation,\n\n\tand to prevent variables being put in registers (when setjmp/longjmp\n\n\twouldn't work as we want)\n\n   Long_double is the longest floating point type available.\n\n   stdc is used in tests like \"if (stdc)\", which is less ugly than #ifdef.\n\n   U is output after unsigned constants.\n\n */\n\n#ifdef STDC\n\n\n\n#define ARGS(x) x\n\n#define NOARGS (void)\n\n#define Volatile volatile\n\n#define Long_double long double\n\n#define stdc 1\n\n#define U \"U\"\n\n\n\n#else /* Old style C */\n\n\n\n#define ARGS(x) ()\n\n#define NOARGS ()\n\n#define Volatile static\n\n#define Long_double double\n\n#define stdc 0\n\n#define U \"\"\n\n\n\n#endif /* STDC */\n\n\n\n/* include files */\n\n#include <stdio.h>\n\n\n\n#ifdef STDC\n\n#ifndef BAD_STDDEF\n\n#include <stddef.h> /* for size_t: if this fails, define BAD_STDDEF */\n\n#endif\n\n#endif\n\n\n\n#ifdef NO_SIG\n\n#define jmp_buf int\n\n#else\n\n#include <signal.h> /* if this fails, define NO_SIG */\n\n#include <setjmp.h> /* if this fails, define NO_SIG */\n\n#endif\n\n\n\n/* Kludge around the possiblity that <stdio.h> includes <limits.h> */\n\n#ifdef CHAR_BIT\n\n#undef CHAR_BIT\n\n#undef CHAR_MAX\n\n#undef CHAR_MIN\n\n#undef SCHAR_MAX\n\n#undef SCHAR_MIN\n\n#undef UCHAR_MAX\n\n#undef UCHAR_MIN\n\n#endif\n\n\n\n#ifdef VERIFY\n\n#include \"limits.h\"\n\n#include \"float.h\"\n\n#endif\n\n\n\n/* The largest unsigned type */\n\n#ifdef NO_UI\n\n#define ulong unsigned int\n\n#else\n\n#define ulong unsigned long\n\n#endif\n\n\n\n/* Some shorthands */\n\n#define Vprintf if (V) printf\n\n#define Unexpected(place) if (setjmp(lab)!=0) croak(place)\n\n#define fabs(x) (((x)<0.0)?(-x):(x))\n\n\n\n#endif /* PASS */\n\n\n\n/* A description of the ANSI constants */\n\n#define D_CHAR_BIT \"Number of bits in a storage unit\"\n\n#define D_CHAR_MAX \"Maximum char\"\n\n#define D_CHAR_MIN \"Minimum char\"\n\n#define D_SCHAR_MAX \"Maximum signed char\"\n\n#define D_SCHAR_MIN \"Minimum signed char\"\n\n#define D_UCHAR_MAX \"Maximum unsigned char (minimum is always 0)\"\n\n\n\n#define D_INT_MAX \"Maximum %s\"\n\n#define D_INT_MIN \"Minimum %s\"\n\n#define D_UINT_MAX \"Maximum unsigned %s (minimum is always 0)\"\n\n\n\n#define D_FLT_ROUNDS \"Addition rounds to 0: zero, 1: nearest, 2: +inf, 3: -inf, -1: unknown\"\n\n#define D_FLT_RADIX \"Radix of exponent representation\"\n\n#define D_MANT_DIG \"Number of base-FLT_RADIX digits in the significand of a %s\"\n\n#define D_DIG \"Number of decimal digits of precision in a %s\"\n\n#define D_MIN_EXP \"Minimum int x such that FLT_RADIX**(x-1) is a normalised %s\"\n\n#define D_MIN_10_EXP \"Minimum int x such that 10**x is a normalised %s\"\n\n#define D_MAX_EXP \"Maximum int x such that FLT_RADIX**(x-1) is a representable %s\"\n\n#define D_MAX_10_EXP \"Maximum int x such that 10**x is a representable %s\"\n\n#define D_MAX \"Maximum %s\"\n\n#define D_EPSILON \"Difference between 1.0 and the minimum %s greater than 1.0\"\n\n#define D_MIN \"Minimum normalised %s\"\n\n\n\n#ifdef PASS0\n\n\n\n/* Prototypes for what's to come: */\n\n\n\nint false NOARGS;\n\n\n\n#ifdef BAD_STDDEF\n\nchar *malloc (); /* Old style prototype, since we don't know what size_t is */\n\n#else\n\nchar *malloc ARGS((size_t size));\n\n#endif\n\nVoid free ARGS((char *p)); /* Syntax error here? Try -DNO_VOID */\n\n\n\nVoid exit ARGS((int status));\n\n\n\nchar *f_rep ARGS((int precision, Long_double val));\n\n\n\nint maximum_int NOARGS;\n\nint cprop NOARGS;\n\nint basic NOARGS;\n\nVoid sprop NOARGS;\n\nVoid iprop NOARGS;\n\nVoid lprop NOARGS;\n\nVoid usprop NOARGS;\n\nVoid uiprop NOARGS;\n\nVoid ulprop NOARGS;\n\nint fprop ARGS((int byte_size));\n\nint dprop ARGS((int byte_size));\n\nint ldprop ARGS((int byte_size));\n\nVoid efprop ARGS((int fprec, int dprec, int lprec));\n\nVoid edprop ARGS((int fprec, int dprec, int lprec));\n\nVoid eldprop ARGS((int fprec, int dprec, int lprec));\n\n\n\nint setmode ARGS((char *s));\n\nVoid farewell ARGS((int bugs));\n\nVoid describe ARGS((char *description, char *extra));\n\nVoid missing ARGS((char *s));\n\nVoid fmissing ARGS((char *s));\n\nVoid check_defines NOARGS;\n\nVoid bitpattern ARGS((char *p, unsigned int size));\n\nint ceil_log ARGS((int base, Long_double x));\n\nVoid croak ARGS((int place));\n\nVoid trap1 ARGS((int sig));\n\nVoid eek_a_bug ARGS((char *problem));\n\nVoid endian ARGS((int byte_size));\n\nint exponent ARGS((Long_double x, Long_double *fract, int *exp));\n\nint floor_log ARGS((int base, Long_double x));\n\nVoid f_define ARGS((char *desc, char *extra, char *sort, char *name,\n\n\t\t\t int prec, Long_double val, char *mark));\n\nVoid i_define ARGS((char *desc, char *extra, char *sort, char *name,\n\n\t\t\t long val, long lim, long req, char *mark));\n\nVoid u_define ARGS((char *desc, char *extra, char *sort, char *name,\n\n\t\t\t ulong val, ulong req, char *mark));\n\n\n\n#ifdef NO_SIG  /* There's no signal(), or setjmp/longjmp() */\n\n\n\n\t/* Dummy routines instead */\n\n\ttypedef int jmp_buf;\n\n\n\n\tint setjmp ARGS((jmp_buf lab));\n\n\n\n\tjmp_buf lab, mlab;\n\n\tint setjmp(lab) jmp_buf lab; { return(0); }\n\n\tVoid signal(i, p) int i, (*p)(); {}\n\n\n\n#else\n\n\tjmp_buf lab, mlab;\n\n\tVoid overflow(sig) int sig; { /* what to do on over/underflow */\n\n\t\tsignal(sig, overflow);\n\n\t\tlongjmp(lab, 1);\n\n\t}\n\n\n\n\tVoid address(sig) int sig; { /* what to do on an address error */\n\n\t\tsignal(sig, address);\n\n\t\tlongjmp(mlab, 1);\n\n\t}\n\n\n\n#endif /*NO_SIG*/\n\n\n\nint V= 0,\t/* verbose */\n\n    L= 0,\t/* produce limits.h */\n\n    F= 0,\t/* produce float.h  */\n\n    bugs=0;\t/* The number of (possible) bugs in the output */\n\n\n\nchar co[4], oc[4]; /* Comment starter and ender symbols */\n\n\n\nint bits_per_byte; /* the number of bits per unit returned by sizeof() */\n\nint flt_rounds;    /* The calculated value of FLT_ROUNDS */\n\nint flt_radix;     /* The calculated value of FLT_RADIX */\n\nVolatile int trapped; /* For testing FPE traps */\n\n\n\n#ifdef TEST\n\n/* Set the fp modes on a SUN with 68881 chip, to check that different\n\n   rounding modes etc. get properly detected.\n\n   Compile with -f68881 for cc, -m68881 for gcc, and with additional flag\n\n   -DTEST. Run with additional parameter +hex-number, to set the 68881 mode\n\n   register to hex-number\n\n*/\n\n\n\n/* Bits 0x30 = rounding mode */\n\n#define ROUND_BITS\t0x30\n\n#define TO_NEAREST\t0x00\n\n#define TO_ZERO\t\t0x10\n\n#define TO_MINUS_INF\t0x20\n\n#define TO_PLUS_INF\t0x30 /* The SUN FP user's guide seems to be wrong here */\n\n\n\n/* Bits 0xc0 = extended rounding */\n\n#define EXT_BITS\t0xc0\n\n#define ROUND_EXTENDED\t0x00\n\n#define ROUND_SINGLE\t0x40\n\n#define ROUND_DOUBLE\t0x80\n\n\n\n/* Enabled traps */\n\n#define EXE_INEX1  0x100\n\n#define EXE_INEX2  0x200\n\n#define EXE_DZ\t   0x400\n\n#define EXE_UNFL   0x800\n\n#define EXE_OVFL  0x1000\n\n#define EXE_OPERR 0x2000\n\n#define EXE_SNAN  0x4000\n\n#define EXE_BSUN  0x8000\n\n\n\n/* Only used for testing, on a Sun with 68881 chip */\n\n/* Print the FP mode */\n\nprintmode(new) unsigned new; {\n\n\tfpmode_(&new);\n\n\tprintf(\"New fp mode:\\n\");\n\n\tprintf(\"  Round toward \");\n\n\tswitch (new & ROUND_BITS) {\n\n\t      case TO_NEAREST:   printf(\"nearest\"); break;\n\n\t      case TO_ZERO:      printf(\"zero\"); break;\n\n\t      case TO_MINUS_INF: printf(\"minus infinity\"); break;\n\n\t      case TO_PLUS_INF:  printf(\"plus infinity\"); break;\n\n\t      default: printf(\"???\"); break;\n\n\t}\n\n\n\n\tprintf(\"\\n  Extended rounding precision: \");\n\n\n\n\tswitch (new & EXT_BITS) {\n\n\t      case ROUND_EXTENDED: printf(\"extended\"); break;\n\n\t      case ROUND_SINGLE:   printf(\"single\"); break;\n\n\t      case ROUND_DOUBLE:   printf(\"double\"); break;\n\n\t      default: printf(\"???\"); break;\n\n\t}\n\n\n\n\tprintf(\"\\n  Enabled exceptions:\");\n\n\tif (new & (unsigned) EXE_INEX1) printf(\" inex1\");\n\n\tif (new & (unsigned) EXE_INEX2) printf(\" inex2\");\n\n\tif (new & (unsigned) EXE_DZ)    printf(\" divz\");\n\n\tif (new & (unsigned) EXE_UNFL)  printf(\" unfl\");\n\n\tif (new & (unsigned) EXE_OVFL)  printf(\" ovfl\");\n\n\tif (new & (unsigned) EXE_OPERR) printf(\" operr\");\n\n\tif (new & (unsigned) EXE_SNAN)  printf(\" snan\");\n\n\tif (new & (unsigned) EXE_BSUN)  printf(\" bsun\");\n\n\tprintf(\"\\n\");\n\n}\n\n\n\n/* Only used for testing, on a Sun with 68881 chip */\n\n/* Set the FP mode */\n\nint setmode(s) char *s; {\n\n\tunsigned mode=0, dig;\n\n\tchar c;\n\n\n\n\twhile (*s) {\n\n\t\tc= *s++;\n\n\t\tif  (c>='0' && c<='9') dig= c-'0';\n\n\t\telse if (c>='a' && c<='f') dig= c-'a'+10;\n\n\t\telse if (c>='A' && c<='F') dig= c-'A'+10;\n\n\t\telse return 1;\n\n\t\tmode= mode<<4 | dig;\n\n\t}\n\n\tprintmode(mode);\n\n\treturn 0;\n\n}\n\n#define SETMODE\n\n#endif\n\n\n\n#ifdef TESTI /* Test mode using SunOs IEEE routines */\n\n\n\n#include <sys/ieeefp.h>\n\n\n\nint setmode(s) char *s; {\n\n\tchar *dummy, c, *cmd, *val;\n\n\twhile (*s) {\n\n\t\tswitch (c= *s++) {\n\n\t\t      case '=': cmd= \"direction\"; val= \"nearest\"; break;\n\n\t\t      case '0': cmd= \"direction\"; val= \"tozero\"; break;\n\n\t\t      case '+': cmd= \"direction\"; val= \"positive\"; break;\n\n\t\t      case '-': cmd= \"direction\"; val= \"negative\"; break;\n\n\t\t      case '1': cmd= \"precision\"; val= \"single\"; break;\n\n\t\t      case '2': cmd= \"precision\"; val= \"double\"; break;\n\n\t\t      case '3': cmd= \"precision\"; val= \"extended\"; break;\n\n\t\t      case '~': cmd= \"exception\"; val= \"inexact\"; break;\n\n\t\t      case '/': cmd= \"exception\"; val= \"division\"; break;\n\n\t\t      case '>': cmd= \"exception\"; val= \"overflow\"; break;\n\n\t\t      case '<': cmd= \"exception\"; val= \"underflow\"; break;\n\n\t\t      default:\n\n\t\t\tprintf(\"Bad setmode character: %c\\n\", c);\n\n\t\t\treturn 1;\n\n\t\t\tbreak;\n\n\t\t}\n\n\t\tprintf(\"Set %s %s\", cmd, val);\n\n\t\tif (ieee_flags(\"set\", cmd, val, &dummy)) {\n\n\t\t\tprintf(\": failed\\n\");\n\n\t\t\treturn 1;\n\n\t\t}\n\n\t\tprintf(\"\\n\");\n\n\t}\n\n\treturn 0;\n\n}\n\n#define SETMODE\n\n#endif\n\n\n\n#ifndef SETMODE\n\n/* ARGSUSED */\n\nint setmode(s) char *s; {\n\n\tfprintf(stderr, \"Can't set mode: not compiled with TEST\\n\");\n\n\treturn(1);\n\n}\n\n#endif\n\n\n\nint memeq(p1, size1, p2, size2) char *p1, *p2; int size1, size2; {\n\n\t/* See if two blocks of store are identical */\n\n\tint i;\n\n\tif (size1 != size2) return 0;\n\n\tfor (i=1; i<=size1; i++) {\n\n\t\tif (*p1++ != *p2++) return 0;\n\n\t}\n\n\treturn 1;\n\n}\n\n\n\nVoid farewell(bugs) int bugs; {\n\n\tif (bugs == 0) exit(0);\n\n\tprintf(\"\\n%sFor hints on dealing with the \", co);\n\n\tif (bugs == 1) printf(\"problem\");\n\n\telse printf(\"%d problems\", bugs);\n\n\tprintf(\" above\\n   see the section 'TROUBLESHOOTING' in the file \");\n\n\tprintf(\"%s%s\\n\", FILENAME, oc);\n\n\texit(bugs);\n\n}\n\n\n\n/* The program has received a signal where it wasn't expecting one */\n\nVoid croak(place) int place; {\n\n\tprintf(\"*** Unexpected signal at point %d\\n\", place);\n\n\tfarewell(bugs+1); /* An exit isn't essential here, but avoids loops */\n\n}\n\n\n\n/* This is here in case alloca.c is used, which calls this. */\n\nchar *xmalloc(size) unsigned size; {\n\n\tchar *value = malloc(size);\n\n\tif (value == 0) {\n\n\t\tfprintf(stderr, \"Virtual memory exceeded\\n\");\n\n\t\texit(bugs+1);\n\n\t}\n\n\treturn value;\n\n}\n\n\n\nint maxint;\n\n\n\nint maximum_int() {\n\n\t/* Find the maximum integer */\n\n\tVolatile int newi, int_max, two=2;\n\n\n\n\t/* Calculate maxint ***********************************/\n\n\t/* Calculate 2**n-1 until overflow - then use the previous value  */\n\n\n\n\tnewi=1; int_max=0;\n\n\n\n\tif (setjmp(lab)==0) { /* Yields int_max */\n\n\t\twhile(newi>int_max) {\n\n\t\t\tint_max=newi;\n\n\t\t\tnewi=newi*two+1;\n\n\t\t}\n\n\t}\n\n\tUnexpected(0);\n\n\treturn int_max;\n\n}\n\n\n\n/* How long are my identifiers? I could go further here, but some compilers\n\n   have line length limits that I don't want to break.\n\n*/\n\n\n\nint zzzzzzzzz1zzzzzzzzz2zzzzzzzzz3zzzzzzzzz4zzzzzzzzz5zzzzzzzzz6zzzz=64;\n\n\n\nint name_len() {\n\n   int zzzzzzzzz1zzzzzzzzz2zzzzzzzzz3zz=32;\n\n   { int zzzzzzzzz1zzzzzz=16;\n\n     { int zzzzzzzz=8;\n\n       { int zzzzzzz=7;\n\n\t { int zzzzzz=6;\n\n\t   return\n\n\t     zzzzzzzzz1zzzzzzzzz2zzzzzzzzz3zzzzzzzzz4zzzzzzzzz5zzzzzzzzz6zzzz;\n\n\t }\n\n       }\n\n     }\n\n   }\n\n}\n\n\n\n#define aaaaaaaaa1aaaaaaaaa2aaaaaaaaa3aaaaaaaaa4aaaaaaaaa5aaaaaaaaa6aaaa 64\n\n#define LENGTH 64\n\n\n\n#ifdef aaaaaaaaa1aaaaaaaaa2aaaaaaaaa3aa\n\n#undef LENGTH\n\n#define LENGTH 32\n\n#endif\n\n\n\n#ifdef aaaaaaaaa1aaaaaa\n\n#undef LENGTH\n\n#define LENGTH 16\n\n#endif\n\n\n\n#ifdef aaaaaaaa\n\n#undef LENGTH\n\n#define LENGTH 8\n\n#endif\n\n\n\n#undef aaaaaaaaa1aaaaaaaaa2aaaaaaaaa3aaaaaaaaa4aaaaaaaaa5aaaaaaaaa6aaaa\n\n\n\nVoid long_names() {\n\n\tint l= name_len();\n\n\tVprintf(\"Compiler names are at least %d chars long\", l);\n\n\tif (l != 64)\n\n\t  Vprintf(\" (but less than %d)\", l*2);\n\n\tVprintf(\"\\n\");\n\n\tVprintf(\"Preprocessor names are at least %d long\", LENGTH);\n\n\tif (LENGTH != 64)\n\n\t  Vprintf(\" (but less than %d)\", LENGTH*2);\n\n\tVprintf(\"\\n\\n\");\n\n}\n\n\n\n/* Used by FPROP to see if FP traps are generated, and if they may return */\n\n\n\nVoid trap2(sig) int sig; {\n\n\tlongjmp(lab, 1);\n\n}\n\n\n\nVoid trap1(sig) int sig; {\n\n\ttrapped= 1; /* A global */\n\n\tsignal(sig, trap2);\n\n}\n\n\n\nVoid setsignals() {\n\n#ifdef SIGFPE\n\n\tsignal(SIGFPE, overflow);\n\n#endif\n\n#ifdef SIGOVER\n\n\tsignal(SIGOVER, overflow);\n\n#endif\n\n#ifdef SIGBUS\n\n\tsignal(SIGBUS, address);\n\n#endif\n\n#ifdef SIGSEGV\n\n\tsignal(SIGSEGV, address);\n\n#endif\n\n\t/* Add more calls as necessary */\n\n}\n\n\n\n#undef LENGTH\n\n\n\nint main(argc, argv) int argc; char *argv[]; {\n\n\tint dprec, fprec, lprec;\n\n\tint i; char *s; int bad;\n\n\n\n\tsetsignals();\n\n\tUnexpected(1);\n\n\n\n\tbad=0;\n\n\tfor (i=1; i < argc; i++) {\n\n\t\ts= argv[i];\n\n\t\tif (*s == '-') {\n\n\t\t\ts++;\n\n\t\t\twhile (*s) {\n\n\t\t\t\tswitch (*(s++)) {\n\n\t\t\t\t      case 'v': V=1; break;\n\n\t\t\t\t      case 'l': L=1; break;\n\n\t\t\t\t      case 'f': F=1; break;\n\n\t\t\t\t      default: bad=1; break;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t} else if (*s == '+') {\n\n\t\t\ts++;\n\n\t\t\tbad= setmode(s);\n\n\t\t} else bad= 1;\n\n\t}\n\n\tif (bad) {\n\n\t\tfprintf(stderr,\n\n\t\t\t\"Usage: %s [-vlf]\\n  v=Verbose l=Limits.h f=Float.h\\n\",\n\n\t\t\targv[0]);\n\n\t\texit(1);\n\n\t}\n\n\tif (L || F) {\n\n\t\tco[0]= '/'; oc[0]= ' ';\n\n\t\tco[1]= '*'; oc[1]= '*';\n\n\t\tco[2]= ' '; oc[2]= '/';\n\n\t\tco[3]= '\\0'; oc[3]= '\\0';\n\n\t} else {\n\n\t\tco[0]= '\\0'; oc[0]= '\\0';\n\n\t\tV=1;\n\n\t}\n\n\n\n\tif (L) printf(\"%slimits.h%s\\n\", co, oc);\n\n\tif (F) printf(\"%sfloat.h%s\\n\", co, oc);\n\n#ifdef ID\n\n\tprintf(\"%sProduced on %s by enquire version %s, CWI, Amsterdam%s\\n\",\n\n\t       co, ID, VERSION, oc);\n\n#else\n\n\tprintf(\"%sProduced by enquire version %s, CWI, Amsterdam%s\\n\",\n\n\t       co, VERSION, oc);\n\n#endif\n\n\n\n#ifdef VERIFY\n\n\tprintf(\"%sVerification phase%s\\n\", co, oc);\n\n#endif\n\n\n\n#ifdef NO_SIG\n\n\tVprintf(\"%sCompiled without signal(): %s%s\\n\",\n\n\t\tco,\n\n\t\t\"there's nothing that can be done if overflow occurs\",\n\n\t\toc);\n\n#endif\n\n#ifdef NO_SC\n\n\tVprintf(\"%sCompiled without signed char%s\\n\", co, oc);\n\n#endif\n\n#ifdef NO_UC\n\n\tVprintf(\"%sCompiled without unsigned char%s\\n\", co, oc);\n\n#endif\n\n#ifdef NO_UI\n\n\tVprintf(\"%sCompiled without unsigned short or long%s\\n\", co, oc);\n\n#endif\n\n#ifdef __STDC__\n\n\tVprintf(\"%sCompiler claims to be ANSI C level %d%s\\n\",\n\n\t\tco, __STDC__, oc);\n\n#else\n\n\tVprintf(\"%sCompiler does not claim to be ANSI C%s\\n\", co, oc);\n\n#endif\n\n\tprintf(\"\\n\");\n\n\n\n\tlong_names();\n\n\tcheck_defines();\n\n\n\n\tmaxint= maximum_int();\n\n\tbits_per_byte= basic();\n\n\tVprintf(\"\\n\");\n\n\tif (F||V) {\n\n\t\tfprec= fprop(bits_per_byte);\n\n\t\tdprec= dprop(bits_per_byte);\n\n\t\tlprec= ldprop(bits_per_byte);\n\n\t\tefprop(fprec, dprec, lprec);\n\n\t\tedprop(fprec, dprec, lprec);\n\n\t\teldprop(fprec, dprec, lprec);\n\n\t}\n\n#ifndef BAD_MALLOC\n\n\tif (V) {\n\n\t\t/* An extra goody: the approximate amount of data-space */\n\n\t\t/* Allocate store until no more available */\n\n\t\t/* Different implementations have a different argument type\n\n\t\t   to malloc. Here we assume that it's the same type as\n\n\t\t   that which sizeof() returns */\n\n\t\tunsigned int size;\n\n\t\tVolatile long total;\n\n\t\tchar kmg, *ptr, *save;\n\n\n\n\t\tsave= NULL;\n\n\t\tsize=maximum_int()/4;\n\n\t\ttotal=0;\n\n\t\twhile (size!=0) {\n\n\t\t\tif (setjmp(mlab) == 0) {\n\n\t\t\t\twhile ((ptr= malloc((false()?sizeof(int):size))) != (char *)NULL) {\n\n\t\t\t\t\tif (save == NULL) save= ptr; /* save the biggest chunk */\n\n\t\t\t\t\ttotal+=(size/2);\n\n\t\t\t\t}\n\n\t\t\t} else {\n\n\t\t\t\teek_a_bug(\"Trying to malloc all store generates a trap\");\n\n\t\t\t}\n\n\t\t\tsize/=2;\n\n\t\t}\n\n\t\tif (setjmp(mlab)!=0) croak(-1);\n\n\n\n\t\tif (save != NULL) free(save);\n\n\n\n\t\ttotal= (total+511)/512; /* Sic */ kmg= 'K';\n\n\t\tif (total > 10000) {\n\n\t\t\ttotal= (total+999)/1000; kmg= 'M';\n\n\t\t}\n\n\t\tif (total > 10000) {\n\n\t\t\ttotal= (total+999)/1000; kmg= 'G';\n\n\t\t}\n\n\t\tif (total > 10000) {\n\n\t\t\ttotal= (total+999)/1000; kmg= 'T';\n\n\t\t}\n\n\t\tVprintf(\"%sMemory mallocatable ~= %ld %cbytes%s\\n\",\n\n\t\t\tco, total, kmg, oc);\n\n\t}\n\n#endif\n\n\tfarewell(bugs);\n\n\treturn bugs; /* To keep compilers and lint happy */\n\n}\n\n\n\nVoid eek_a_bug(problem) char *problem; {\n\n\t/* The program has discovered a problem */\n\n\tprintf(\"\\n%s*** WARNING: %s%s\\n\", co, problem, oc);\n\n\tbugs++;\n\n}\n\n\n\nVoid describe(description, extra) char *description, *extra; {\n\n\t/* Produce the description for a #define */\n\n\tprintf(\"   %s\", co);\n\n\tprintf(description, extra);\n\n\tprintf(\"%s\\n\", oc);\n\n}\n\n\n\nVoid i_define(desc, extra, sort, name, val, lim, req, mark)\n\n     char *desc, *extra, *sort, *name; long val, lim, req; char *mark; {\n\n\t/* Produce a #define for a signed int type */\n\n\tdescribe(desc, extra);\n\n\tif (val >= 0) {\n\n\t\tprintf(\"#define %s%s %ld%s\\n\", sort, name, val, mark);\n\n\t} else if (val + lim < 0) {\n\n\t\t/* We may not produce a constant like -1024 if the max\n\n\t\t   allowable value is 1023. It has then to be output as\n\n\t\t   -1023-1. lim is the max allowable value. */\n\n\t\tprintf(\"#define %s%s (%ld%s%ld%s)\\n\",\n\n\t\t       sort, name, -lim, mark, val+lim, mark);\n\n\t} else {\n\n\t\tprintf(\"#define %s%s (%ld%s)\\n\", sort, name, val, mark);\n\n\t}\n\n\t/* If VERIFY is not set, val and req are just the same value;\n\n\t   if it is set, val is the value as calculated, and req is\n\n\t   the #defined constant\n\n\t*/\n\n\tif (val != req) {\n\n\t\tprintf(\"%s*** Verify failed for above #define!\\n\", co);\n\n\t\tprintf(\"       Compiler has %ld for value%s\\n\\n\", req, oc);\n\n\t\tbugs++;\n\n\t}\n\n\tVprintf(\"\\n\");\n\n}\n\n\n\nVoid u_define(desc, extra, sort, name, val, req, mark)\n\n     char *desc, *extra, *sort, *name; ulong val, req; char *mark; {\n\n\t/* Produce a #define for an unsigned value */\n\n\tdescribe(desc, extra);\n\n\tprintf(\"#define %s%s %lu%s%s\\n\", sort, name, val, U, mark);\n\n\tif (val != req) {\n\n\t\tprintf(\"%s*** Verify failed for above #define!\\n\", co);\n\n\t\tprintf(\"       Compiler has %lu for value%s\\n\\n\", req, oc);\n\n\t\tbugs++;\n\n\t}\n\n\tVprintf(\"\\n\");\n\n}\n\n\n\nVoid f_define(desc, extra, sort, name, precision, val, mark)\n\n     char *desc, *extra, *sort, *name; int precision;\n\n     Long_double val; char *mark; {\n\n\t/* Produce a #define for a float/double/long double */\n\n\tdescribe(desc, extra);\n\n\tif (stdc) {\n\n\t\tprintf(\"#define %s%s %s%s\\n\",\n\n\t\t       sort, name, f_rep(precision, val), mark);\n\n\t} else if (*mark == 'F') {\n\n\t\t/* non-ANSI C has no float constants, so cast the constant */\n\n\t\tprintf(\"#define %s%s ((float)%s)\\n\",\n\n\t\t       sort, name, f_rep(precision, val));\n\n\t} else {\n\n\t\tprintf(\"#define %s%s %s\\n\", sort, name, f_rep(precision, val));\n\n\t}\n\n\tVprintf(\"\\n\");\n\n}\n\n\n\nint floor_log(base, x) int base; Long_double x; {\n\n\t/* return floor(log base(x)) */\n\n\tint r=0;\n\n\twhile (x>=base) { r++; x/=base; }\n\n\treturn r;\n\n}\n\n\n\nint ceil_log(base, x) int base; Long_double x; {\n\n\tint r=0;\n\n\twhile (x>1.0) { r++; x/=base; }\n\n\treturn r;\n\n}\n\n\n\nint exponent(x, fract, exp) Long_double x; Long_double *fract; int *exp; {\n\n\t/* Split x into a fraction and a power of ten;\n\n\t   returns 0 if x is unusable, 1 otherwise.\n\n\t   Only used for error messages about faulty output.\n\n\t*/\n\n\tint r=0, neg=0;\n\n\tLong_double old;\n\n\t*fract=0.0; *exp=0;\n\n\tif (x<0.0) {\n\n\t\tx= -x;\n\n\t\tneg= 1;\n\n\t}\n\n\tif (x==0.0) return 1;\n\n\tif (x>=10.0) {\n\n\t\twhile (x>=10.0) {\n\n\t\t\told=x; r++; x/=10.0;\n\n\t\t\tif (old==x) return 0;\n\n\t\t}\n\n\t} else {\n\n\t\twhile (x<1.0) {\n\n\t\t\told=x; r--; x*=10.0;\n\n\t\t\tif (old==x) return 0;\n\n\t\t}\n\n\t}\n\n\tif (neg) *fract= -x;\n\n\telse *fract= x;\n\n\t*exp=r;\n\n\treturn 1;\n\n}\n\n\n\nchar *f_rep(precision, val) int precision; Long_double val; {\n\n\t/* Return the floating representation of val */\n\n\tstatic char buf[1024];\n\n\tchar *f1;\n\n\tif (sizeof(double) == sizeof(Long_double)) {\n\n\t\t/* Assume they're the same, and use non-stdc format */\n\n\t\t/* This is for stdc compilers using non-stdc libraries */\n\n\t\tf1= \"%.*e\";\n\n\t} else {\n\n\t\t/* It had better support Le then */\n\n\t\tf1= \"%.*Le\";\n\n\t}\n\n\tsprintf(buf, f1, precision, val);\n\n\treturn buf;\n\n}\n\n\n\nVoid bitpattern(p, size) char *p; unsigned int size; {\n\n\t/* Printf the bit-pattern of p */\n\n\tchar c;\n\n\tunsigned int i;\n\n\tint j;\n\n\n\n\tfor (i=1; i<=size; i++) {\n\n\t\tc= *p;\n\n\t\tp++;\n\n\t\tfor (j=bits_per_byte-1; j>=0; j--)\n\n\t\t\tprintf(\"%c\", (c>>j)&1 ? '1' : '0');\n\n\t\tif (i!=size) printf(\" \");\n\n\t}\n\n}\n\n\n\nVoid fill(p, size) char *p; int size; {\n\n\tchar *ab= \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\";\n\n\tint i;\n\n\n\n\tfor (i=0; i<size; i++)\n\n\t\tp[i]= ab[i];\n\n}\n\n\n\n#define Order(x, mode)\\\n\n   printf(\"%s%s \", co, mode); fill((char *)&x, sizeof(x)); \\\n\n   for (i=1; i<=sizeof(x); i++) { c=((x>>(byte_size*(sizeof(x)-i)))&mask);\\\n\n      putchar(c==0 ? '?' : (char)c); }\\\n\n   printf(\"%s\\n\", oc);\n\n\n\nVoid endian(byte_size) int byte_size; {\n\n\t/* Printf the byte-order used on this machine */\n\n\t/*unsigned*/ short s=0;\n\n\t/*unsigned*/ int j=0;\n\n\t/*unsigned*/ long l=0;\n\n\n\n\tunsigned int mask, i, c;\n\n\n\n\tmask=0;\n\n\tfor (i=1; i<=(unsigned)byte_size; i++) mask= (mask<<1)|1;\n\n\n\n\tif (V) {\n\n\t\tprintf(\"%sCHARACTER ORDER%s\\n\", co, oc);\n\n\t\tOrder(s, \"short:\");\n\n\t\tOrder(j, \"int:  \");\n\n\t\tOrder(l, \"long: \");\n\n\t}\n\n}\n\n\n\nVoid missing(s) char *s; {\n\n\tprintf(\"%s*** #define %s missing from limits.h%s\\n\", co, s, oc);\n\n\tbugs++;\n\n}\n\n\n\nVoid fmissing(s) char *s; {\n\n\tprintf(\"%s*** #define %s missing from float.h%s\\n\", co, s, oc);\n\n\tbugs++;\n\n}\n\n\n\n/* To try and fool optimisers */\n\nint false() { return 0; }\n\n\n\n#define Promoted(x) (false()?(x):(-1))\n\n#define is_signed(x) (Promoted(x) < 0)\n\n#define sign_of(x) (is_signed(x)?\"signed\":\"unsigned\")\n\n#define Signed 1\n\n#define Unsigned 0\n\n#define sgn(x) ((is_signed(x))?Signed:Unsigned)\n\n\n\n#define showtype(t, x) Vprintf(\"%s%s %s %s%s\\n\", co, t, sign_of(x), type_of((int)sizeof(x)), oc)\n\n\n\nchar *type_of(x) int x; {\n\n\tif (x == sizeof(char)) {\n\n\t\tif (sizeof(char) == sizeof(int)) return \"char/short/int\";\n\n\t\tif (sizeof(char) == sizeof(short)) return \"char/short\";\n\n\t\treturn \"char\";\n\n\t}\n\n\tif (x == sizeof(short)) {\n\n\t\tif (sizeof(short) == sizeof(int)) return \"short/int\";\n\n\t\treturn \"short\";\n\n\t}\n\n\tif (x == sizeof(int)) {\n\n\t\tif (sizeof(int) == sizeof(long)) return \"int/long\";\n\n\t\treturn \"int\";\n\n\t}\n\n\tif (x == sizeof(long)) return \"long\";\n\n\treturn \"unknown-type\";\n\n}\n\n\n\nchar *ftype_of(x) int x; {\n\n\tif (x == sizeof(float)) {\n\n\t\treturn \"float\";\n\n\t}\n\n\tif (x == sizeof(double)) {\n\n\t\tif (sizeof(double) == sizeof(Long_double))\n\n\t\t  return \"(long)double\";\n\n\t\treturn \"double\";\n\n\t}\n\n\tif (x == sizeof(Long_double)) {\n\n\t\treturn \"long double\";\n\n\t}\n\n\treturn \"unknown-type\";\n\n}\n\n\n\nVoid typerr(name, esign, esize, sign, size)\n\n  char *name; int esign, esize, sign, size;\n\n{\n\n\tVprintf(\"*** %s has wrong type: expected %s %s, found %s %s\\n\",\n\n\t\tname, sign_of(esign), type_of(esize),\n\n\t\tsign_of(sign), type_of(size));\n\n}\n\n\n\nVoid ftyperr(name, esize, size) char *name; int esize, size; {\n\n\tVprintf(\"*** %s has wrong type: expected %s, found %s\\n\",\n\n\t\tname, ftype_of(esize), ftype_of(size));\n\n}\n\n\n\nVoid promotions() {\n\n\tint si; long sl;\n\n\tunsigned int ui;\n\n\tshort ss;\n\n\n\n#ifndef NO_UI\n\n\tunsigned long ul;  /* if this fails, define NO_UI */\n\n\tunsigned short us; /* if this fails, define NO_UI */\n\n\n\n\tul=0; us=0;\n\n#endif\n\n\t/* Shut compiler warnings up: */\n\n\tsi=0; sl=0; ui=0; ss=0;\n\n\n\n\tVprintf(\"\\n%sPROMOTIONS%s\\n\", co, oc);\n\n\n\n\t/* Sanity checks. Possible warnings here; should be no problem */\n\n\tif (is_signed(ui))\n\n\t  eek_a_bug(\"unsigned int promotes to signed!\\n\");\n\n\tif (!is_signed(si))\n\n\t  eek_a_bug(\"signed int promotes to unsigned!\\n\");\n\n\tif (!is_signed(sl))\n\n\t  eek_a_bug(\"signed long promotes to unsigned!\\n\");\n\n\tif (sizeof(Promoted(si)) != sizeof(int))\n\n\t  eek_a_bug(\"int doesn't promote to int!\\n\");\n\n\tif (sizeof(Promoted(sl)) != sizeof(long))\n\n\t  eek_a_bug(\"long doesn't promote to long!\\n\");\n\n\tif (sizeof(Promoted(ss)) != sizeof(int))\n\n\t  eek_a_bug(\"short doesn't promote to int!\\n\");\n\n\tif (sizeof(Promoted(ui)) != sizeof(int))\n\n\t  eek_a_bug(\"unsigned int doesn't promote to int!\\n\");\n\n#ifndef NO_UI\n\n\tif (sizeof(Promoted(ul)) != sizeof(long))\n\n\t  eek_a_bug(\"unsigned long doesn't promote to long!\\n\");\n\n\tif (is_signed(ul))\n\n\t  eek_a_bug(\"unsigned long promotes to signed!\\n\");\n\n#endif\n\n\n\n#ifndef NO_UI\n\n\tshowtype(\"unsigned short promotes to\", Promoted(us));\n\n#endif\n\n\tshowtype(\"long+unsigned gives\", sl+ui);\n\n}\n\n\n\n#define checktype(x, n, s, t) if((sgn(x)!=s)||(sizeof(x)!=sizeof(t))) typerr(n, s, (int)sizeof(t), sgn(x), (int)sizeof(x));\n\n\n\n#define fchecktype(x, n, t) if (sizeof(x) != sizeof(t)) ftyperr(n, (int)sizeof(x), (int)sizeof(t));\n\n\n\nVoid check_defines() {\n\n\t/* ensure that all #defines are present and have the correct type */\n\n#ifdef VERIFY\n\n\tint usign;\n\n\n\n#ifdef NO_UI\n\n\tusign= Signed;\n\n#else\n\n\t/* Implementations promote unsigned short differently */\n\n\tusign= is_signed((unsigned short)0);\n\n#endif\n\n\n\n\tif (L) {\n\n#ifdef CHAR_BIT\n\n\tchecktype(CHAR_BIT, \"CHAR_BIT\", Signed, int);\n\n#else\n\n\tmissing(\"CHAR_BIT\");\n\n#endif\n\n#ifdef CHAR_MAX\n\n\tchecktype(CHAR_MAX, \"CHAR_MAX\", Signed, int);\n\n#else\n\n\tmissing(\"CHAR_MAX\");\n\n#endif\n\n#ifdef CHAR_MIN\n\n\tchecktype(CHAR_MIN, \"CHAR_MIN\", Signed, int);\n\n#else\n\n\tmissing(\"CHAR_MIN\");\n\n#endif\n\n#ifdef SCHAR_MAX\n\n\tchecktype(SCHAR_MAX, \"SCHAR_MAX\", Signed, int);\n\n#else\n\n\tmissing(\"SCHAR_MAX\");\n\n#endif\n\n#ifdef SCHAR_MIN\n\n\tchecktype(SCHAR_MIN, \"SCHAR_MIN\", Signed, int);\n\n#else\n\n\tmissing(\"SCHAR_MIN\");\n\n#endif\n\n#ifdef UCHAR_MAX\n\n\tchecktype(UCHAR_MAX, \"UCHAR_MAX\", Signed, int);\n\n#else\n\n\tmissing(\"UCHAR_MAX\");\n\n#endif\n\n#ifdef SHRT_MAX\n\n\tchecktype(SHRT_MAX, \"SHRT_MAX\", Signed, int);\n\n#else\n\n\tmissing(\"SHRT_MAX\");\n\n#endif\n\n#ifdef SHRT_MIN\n\n\tchecktype(SHRT_MIN, \"SHRT_MIN\", Signed, int);\n\n#else\n\n\tmissing(\"SHRT_MIN\");\n\n#endif\n\n#ifdef INT_MAX\n\n\tchecktype(INT_MAX, \"INT_MAX\", Signed, int);\n\n#else\n\n\tmissing(\"INT_MAX\");\n\n#endif\n\n#ifdef INT_MIN\n\n\tchecktype(INT_MIN, \"INT_MIN\", Signed, int);\n\n#else\n\n\tmissing(\"INT_MIN\");\n\n#endif\n\n#ifdef LONG_MAX\n\n\tchecktype(LONG_MAX, \"LONG_MAX\", Signed, long);\n\n#else\n\n\tmissing(\"LONG_MAX\");\n\n#endif\n\n#ifdef LONG_MIN\n\n\tchecktype(LONG_MIN, \"LONG_MIN\", Signed, long);\n\n#else\n\n\tmissing(\"LONG_MIN\");\n\n#endif\n\n#ifdef USHRT_MAX\n\n\tchecktype(USHRT_MAX, \"USHRT_MAX\", usign, int);\n\n#else\n\n\tmissing(\"USHRT_MAX\");\n\n#endif\n\n#ifdef UINT_MAX\n\n\tchecktype(UINT_MAX, \"UINT_MAX\", Unsigned, int);\n\n#else\n\n\tmissing(\"UINT_MAX\");\n\n#endif\n\n#ifdef ULONG_MAX\n\n\tchecktype(ULONG_MAX, \"ULONG_MAX\", Unsigned, long);\n\n#else\n\n\tmissing(\"ULONG_MAX\");\n\n#endif\n\n\t} /* if (L) */\n\n\n\n\tif (F) {\n\n#ifdef FLT_RADIX\n\n\tchecktype(FLT_RADIX, \"FLT_RADIX\", Signed, int);\n\n#else\n\n\tfmissing(\"FLT_RADIX\");\n\n#endif\n\n#ifdef FLT_MANT_DIG\n\n\tchecktype(FLT_MANT_DIG, \"FLT_MANT_DIG\", Signed, int);\n\n#else\n\n\tfmissing(\"FLT_MANT_DIG\");\n\n#endif\n\n#ifdef FLT_DIG\n\n\tchecktype(FLT_DIG, \"FLT_DIG\", Signed, int);\n\n#else\n\n\tfmissing(\"FLT_DIG\");\n\n#endif\n\n#ifdef FLT_ROUNDS\n\n\tchecktype(FLT_ROUNDS, \"FLT_ROUNDS\", Signed, int);\n\n#else\n\n\tfmissing(\"FLT_ROUNDS\");\n\n#endif\n\n#ifdef FLT_EPSILON\n\n\tfchecktype(FLT_EPSILON, \"FLT_EPSILON\", float);\n\n#else\n\n\tfmissing(\"FLT_EPSILON\");\n\n#endif\n\n#ifdef FLT_MIN_EXP\n\n\tchecktype(FLT_MIN_EXP, \"FLT_MIN_EXP\", Signed, int);\n\n#else\n\n\tfmissing(\"FLT_MIN_EXP\");\n\n#endif\n\n#ifdef FLT_MIN\n\n\tfchecktype(FLT_MIN, \"FLT_MIN\", float);\n\n#else\n\n\tfmissing(\"FLT_MIN\");\n\n#endif\n\n#ifdef FLT_MIN_10_EXP\n\n\tchecktype(FLT_MIN_10_EXP, \"FLT_MIN_10_EXP\", Signed, int);\n\n#else\n\n\tfmissing(\"FLT_MIN_10_EXP\");\n\n#endif\n\n#ifdef FLT_MAX_EXP\n\n\tchecktype(FLT_MAX_EXP, \"FLT_MAX_EXP\", Signed, int);\n\n#else\n\n\tfmissing(\"FLT_MAX_EXP\");\n\n#endif\n\n#ifdef FLT_MAX\n\n\tfchecktype(FLT_MAX, \"FLT_MAX\", float);\n\n#else\n\n\tfmissing(\"FLT_MAX\");\n\n#endif\n\n#ifdef FLT_MAX_10_EXP\n\n\tchecktype(FLT_MAX_10_EXP, \"FLT_MAX_10_EXP\", Signed, int);\n\n#else\n\n\tfmissing(\"FLT_MAX_10_EXP\");\n\n#endif\n\n#ifdef DBL_MANT_DIG\n\n\tchecktype(DBL_MANT_DIG, \"DBL_MANT_DIG\", Signed, int);\n\n#else\n\n\tfmissing(\"DBL_MANT_DIG\");\n\n#endif\n\n#ifdef DBL_DIG\n\n\tchecktype(DBL_DIG, \"DBL_DIG\", Signed, int);\n\n#else\n\n\tfmissing(\"DBL_DIG\");\n\n#endif\n\n#ifdef DBL_EPSILON\n\n\tfchecktype(DBL_EPSILON, \"DBL_EPSILON\", double);\n\n#else\n\n\tfmissing(\"DBL_EPSILON\");\n\n#endif\n\n#ifdef DBL_MIN_EXP\n\n\tchecktype(DBL_MIN_EXP, \"DBL_MIN_EXP\", Signed, int);\n\n#else\n\n\tfmissing(\"DBL_MIN_EXP\");\n\n#endif\n\n#ifdef DBL_MIN\n\n\tfchecktype(DBL_MIN, \"DBL_MIN\", double);\n\n#else\n\n\tfmissing(\"DBL_MIN\");\n\n#endif\n\n#ifdef DBL_MIN_10_EXP\n\n\tchecktype(DBL_MIN_10_EXP, \"DBL_MIN_10_EXP\", Signed, int);\n\n#else\n\n\tfmissing(\"DBL_MIN_10_EXP\");\n\n#endif\n\n#ifdef DBL_MAX_EXP\n\n\tchecktype(DBL_MAX_EXP, \"DBL_MAX_EXP\", Signed, int);\n\n#else\n\n\tfmissing(\"DBL_MAX_EXP\");\n\n#endif\n\n#ifdef DBL_MAX\n\n\tfchecktype(DBL_MAX, \"DBL_MAX\", double);\n\n#else\n\n\tfmissing(\"DBL_MAX\");\n\n#endif\n\n#ifdef DBL_MAX_10_EXP\n\n\tchecktype(DBL_MAX_10_EXP, \"DBL_MAX_10_EXP\", Signed, int);\n\n#else\n\n\tfmissing(\"DBL_MAX_10_EXP\");\n\n#endif\n\n#ifdef STDC\n\n#ifdef LDBL_MANT_DIG\n\n\tchecktype(LDBL_MANT_DIG, \"LDBL_MANT_DIG\", Signed, int);\n\n#else\n\n\tfmissing(\"LDBL_MANT_DIG\");\n\n#endif\n\n#ifdef LDBL_DIG\n\n\tchecktype(LDBL_DIG, \"LDBL_DIG\", Signed, int);\n\n#else\n\n\tfmissing(\"LDBL_DIG\");\n\n#endif\n\n#ifdef LDBL_EPSILON\n\n\tfchecktype(LDBL_EPSILON, \"LDBL_EPSILON\", long double);\n\n#else\n\n\tfmissing(\"LDBL_EPSILON\");\n\n#endif\n\n#ifdef LDBL_MIN_EXP\n\n\tchecktype(LDBL_MIN_EXP, \"LDBL_MIN_EXP\", Signed, int);\n\n#else\n\n\tfmissing(\"LDBL_MIN_EXP\");\n\n#endif\n\n#ifdef LDBL_MIN\n\n\tfchecktype(LDBL_MIN, \"LDBL_MIN\", long double);\n\n#else\n\n\tfmissing(\"LDBL_MIN\");\n\n#endif\n\n#ifdef LDBL_MIN_10_EXP\n\n\tchecktype(LDBL_MIN_10_EXP, \"LDBL_MIN_10_EXP\", Signed, int);\n\n#else\n\n\tfmissing(\"LDBL_MIN_10_EXP\");\n\n#endif\n\n#ifdef LDBL_MAX_EXP\n\n\tchecktype(LDBL_MAX_EXP, \"LDBL_MAX_EXP\", Signed, int);\n\n#else\n\n\tfmissing(\"LDBL_MAX_EXP\");\n\n#endif\n\n#ifdef LDBL_MAX\n\n\tfchecktype(LDBL_MAX, \"LDBL_MAX\", long double);\n\n#else\n\n\tfmissing(\"LDBL_MAX\");\n\n#endif\n\n#ifdef LDBL_MAX_10_EXP\n\n\tchecktype(LDBL_MAX_10_EXP, \"LDBL_MAX_10_EXP\", Signed, int);\n\n#else\n\n\tfmissing(\"LDBL_MAX_10_EXP\");\n\n#endif\n\n#endif /* STDC */\n\n\t} /* if (F) */\n\n#endif /* VERIFY */\n\n}\n\n\n\n#ifdef VERIFY\n\n#ifndef SCHAR_MAX\n\n#define SCHAR_MAX\tchar_max\n\n#endif\n\n#ifndef SCHAR_MIN\n\n#define SCHAR_MIN\tchar_min\n\n#endif\n\n#ifndef UCHAR_MAX\n\n#define UCHAR_MAX\tchar_max\n\n#endif\n\n#endif /* VERIFY */\n\n\n\n#ifndef CHAR_BIT\n\n#define CHAR_BIT\tchar_bit\n\n#endif\n\n#ifndef CHAR_MAX\n\n#define CHAR_MAX\tchar_max\n\n#endif\n\n#ifndef CHAR_MIN\n\n#define CHAR_MIN\tchar_min\n\n#endif\n\n#ifndef SCHAR_MAX\n\n#define SCHAR_MAX\tchar_max\n\n#endif\n\n#ifndef SCHAR_MIN\n\n#define SCHAR_MIN\tchar_min\n\n#endif\n\n#ifndef UCHAR_MAX\n\n#define UCHAR_MAX\tchar_max\n\n#endif\n\n\n\nint cprop() {\n\n\t/* Properties of type char */\n\n\tVolatile char c, char_max, char_min;\n\n\tVolatile int byte_size, c_signed;\n\n\tlong char_bit;\n\n\n\n\tUnexpected(2);\n\n\n\n\t/* Calculate number of bits per character *************************/\n\n\tc=1; byte_size=0;\n\n\tdo { c=c<<1; byte_size++; } while(c!=0);\n\n\tc= (char)(-1);\n\n\tif (((int)c)<0) c_signed=1;\n\n\telse c_signed=0;\n\n\tVprintf(\"%schar = %d bits, %ssigned%s\\n\",\n\n\t\tco, (int)sizeof(c)*byte_size, (c_signed?\"\":\"un\"), oc);\n\n\tchar_bit=(long)(sizeof(c)*byte_size);\n\n\tif (L) i_define(D_CHAR_BIT, \"\", \"CHAR\", \"_BIT\",\n\n\t\t\tchar_bit, 0L, (long) CHAR_BIT, \"\");\n\n\n\n\tc=0; char_max=0;\n\n\tc++;\n\n\tif (setjmp(lab)==0) { /* Yields char_max */\n\n\t\twhile (c>char_max) {\n\n\t\t\tchar_max=c;\n\n\t\t\tc++;\n\n\t\t}\n\n\t} else {\n\n\t\tVprintf(\"%sCharacter overflow generates a trap!%s\\n\", co, oc);\n\n\t}\n\n\tc=0; char_min=0;\n\n\tc--;\n\n\tif (setjmp(lab)==0) { /* Yields char_min */\n\n\t\twhile (c<char_min) {\n\n\t\t\tchar_min=c;\n\n\t\t\tc--;\n\n\t\t}\n\n\t}\n\n\tif (c_signed && char_min == 0) {\n\n\t\tVprintf(\"%sBEWARE! Chars are pseudo-unsigned:%s\\n\", co, oc);\n\n\t\tVprintf(\"%s   %s%s%s\\n\",\n\n\t\t\t\"They contain only nonnegative values, \",\n\n\t\t\t\"but sign extend when used as integers.\", co, oc);\n\n\t}\n\n\tUnexpected(3);\n\n\n\n\tif (L) {\n\n\t\t/* Because of the integer promotions, you must use a U after\n\n\t\t   the MAX_CHARS in the following cases */\n\n\t\tif ((sizeof(char) == sizeof(int)) && !c_signed) {\n\n\t\t\tu_define(D_CHAR_MAX, \"\", \"CHAR\", \"_MAX\",\n\n\t\t\t\t (ulong) char_max,\n\n\t\t\t\t (ulong) CHAR_MAX, \"\");\n\n\t\t} else {\n\n\t\t\ti_define(D_CHAR_MAX, \"\", \"CHAR\", \"_MAX\",\n\n\t\t\t\t (long) char_max, 0L,\n\n\t\t\t\t (long) CHAR_MAX, \"\");\n\n\t\t}\n\n\t\ti_define(D_CHAR_MIN, \"\", \"CHAR\", \"_MIN\",\n\n\t\t\t (long) char_min, (long) maxint,\n\n\t\t\t (long) CHAR_MIN, \"\");\n\n\t\tif (c_signed) {\n\n\t\t\ti_define(D_SCHAR_MAX, \"\", \"SCHAR\", \"_MAX\",\n\n\t\t\t\t (long) char_max, 0L,\n\n\t\t\t\t (long) SCHAR_MAX, \"\");\n\n\t\t\ti_define(D_SCHAR_MIN, \"\", \"SCHAR\", \"_MIN\",\n\n\t\t\t\t (long) char_min, (long) maxint,\n\n\t\t\t\t (long) SCHAR_MIN, \"\");\n\n\t\t} else {\n\n\t\t\tif (sizeof(char) == sizeof(int)) {\n\n\t\t\t\tu_define(D_UCHAR_MAX, \"\", \"UCHAR\", \"_MAX\",\n\n\t\t\t\t\t (ulong) char_max,\n\n\t\t\t\t\t (ulong) UCHAR_MAX, \"\");\n\n\t\t\t} else {\n\n\t\t\t\ti_define(D_UCHAR_MAX, \"\", \"UCHAR\", \"_MAX\",\n\n\t\t\t\t\t (long) char_max, 0L,\n\n\t\t\t\t\t (long) UCHAR_MAX, \"\");\n\n\t\t\t}\n\n\t\t}\n\n\n\n\t\tif (c_signed) {\n\n#ifndef NO_UC\n\n/* Syntax error? Define NO_UC */ Volatile unsigned char c1, char_max;\n\n\t\t\tc1=0; char_max=0;\n\n\t\t\tc1++;\n\n\t\t\tif (setjmp(lab)==0) { /* Yields char_max */\n\n\t\t\t\twhile (c1>char_max) {\n\n\t\t\t\t\tchar_max=c1;\n\n\t\t\t\t\tc1++;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tUnexpected(4);\n\n\t\t\tif (sizeof(char) == sizeof(int)) {\n\n\t\t\t\tu_define(D_UCHAR_MAX, \"\", \"UCHAR\", \"_MAX\",\n\n\t\t\t\t\t (ulong) char_max,\n\n\t\t\t\t\t (ulong) UCHAR_MAX, \"\");\n\n\t\t\t} else {\n\n\t\t\t\ti_define(D_UCHAR_MAX, \"\", \"UCHAR\", \"_MAX\",\n\n\t\t\t\t\t (long) char_max, 0L,\n\n\t\t\t\t\t (long) UCHAR_MAX, \"\");\n\n\t\t\t}\n\n#endif\n\n\t\t} else {\n\n#ifndef NO_SC\n\n/* Syntax error? Define NO_SC */ Volatile signed char c1, char_max, char_min;\n\n\t\t\tc1=0; char_max=0;\n\n\t\t\tc1++;\n\n\t\t\tif (setjmp(lab)==0) { /* Yields char_max */\n\n\t\t\t\twhile (c1>char_max) {\n\n\t\t\t\t\tchar_max=c1;\n\n\t\t\t\t\tc1++;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tc1=0; char_min=0;\n\n\t\t\tc1--;\n\n\t\t\tif (setjmp(lab)==0) { /* Yields char_min */\n\n\t\t\t\twhile (c1<char_min) {\n\n\t\t\t\t\tchar_min=c1;\n\n\t\t\t\t\tc1--;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tUnexpected(5);\n\n\t\t\ti_define(D_SCHAR_MIN, \"\", \"SCHAR\", \"_MIN\",\n\n\t\t\t\t (long) char_min, (long) maxint,\n\n\t\t\t\t (long) SCHAR_MIN, \"\");\n\n\t\t\ti_define(D_SCHAR_MAX, \"\", \"SCHAR\", \"_MAX\",\n\n\t\t\t\t (long) char_max, 0L,\n\n\t\t\t\t (long) SCHAR_MAX, \"\");\n\n#endif /* NO_SC */\n\n\t\t}\n\n\t}\n\n\treturn byte_size;\n\n}\n\n\n\nint basic() {\n\n\t/* The properties of the basic types.\n\n\t   Returns number of bits per sizeof unit */\n\n\tVolatile int byte_size;\n\n\ttypedef int function ();\n\n\tint variable;\n\n\tchar *cp; int *ip; function *fp;\n\n\tint *p, *q;\n\n\n\n\tVprintf(\"%sSIZES%s\\n\", co, oc);\n\n\tbyte_size= cprop();\n\n\n\n\t/* Shorts, ints and longs *****************************************/\n\n\tVprintf(\"%sshort=%d int=%d long=%d float=%d double=%d bits %s\\n\",\n\n\t\tco,\n\n\t\t(int) sizeof(short)*byte_size,\n\n\t\t(int) sizeof(int)*byte_size,\n\n\t\t(int) sizeof(long)*byte_size,\n\n\t\t(int) sizeof(float)*byte_size,\n\n\t\t(int) sizeof(double)*byte_size, oc);\n\n\tif (stdc) {\n\n\t\tVprintf(\"%slong double=%d bits%s\\n\",\n\n\t\t\tco, (int) sizeof(Long_double)*byte_size, oc);\n\n\t}\n\n\tVprintf(\"%schar*=%d bits%s%s\\n\",\n\n\t\tco, (int)sizeof(char *)*byte_size,\n\n\t\tsizeof(char *)>sizeof(int)?\" BEWARE! larger than int!\":\"\",\n\n\t\toc);\n\n\tVprintf(\"%sint* =%d bits%s%s\\n\",\n\n\t\tco, (int)sizeof(int *)*byte_size,\n\n\t\tsizeof(int *)>sizeof(int)?\" BEWARE! larger than int!\":\"\",\n\n\t\toc);\n\n\tVprintf(\"%sfunc*=%d bits%s%s\\n\",\n\n\t\tco, (int)sizeof(function *)*byte_size,\n\n\t\tsizeof(function *)>sizeof(int)?\" BEWARE! larger than int!\":\"\",\n\n\t\toc);\n\n\n\n\tshowtype(\"Type size_t is\", sizeof(0));\n\n#ifdef STDC\n\n\tshowtype(\"Type wchar_t is\", L'x');\n\n#endif\n\n\n\n\t/* Alignment constants ********************************************/\n\n\n\n#define alignment(TYPE) \\\n\n\t((long)((char *)&((struct{char c; TYPE d;}*)0)->d - (char *)0))\n\n\n\n\tVprintf(\"\\n%sALIGNMENTS%s\\n\", co, oc);\n\n\n\n\tVprintf(\"%schar=%ld short=%ld int=%ld long=%ld%s\\n\",\n\n\t\tco,\n\n\t\talignment(char), alignment(short),\n\n\t\talignment(int), alignment(long),\n\n\t\toc);\n\n\n\n\tVprintf(\"%sfloat=%ld double=%ld%s\\n\",\n\n\t\tco,\n\n\t\talignment(float), alignment(double),\n\n\t\toc);\n\n\n\n\tif (stdc) {\n\n\t\tVprintf(\"%slong double=%ld%s\\n\",\n\n\t\t\tco,\n\n\t\t\talignment(Long_double),\n\n\t\t\toc);\n\n\t}\n\n\tVprintf(\"%schar*=%ld int*=%ld func*=%ld%s\\n\",\n\n\t\tco,\n\n\t\talignment(char *), alignment(int *), alignment(function *),\n\n\t\toc);\n\n\n\n\tVprintf(\"\\n\");\n\n\n\n\t/* Ten little endians *********************************************/\n\n\n\n\tendian(byte_size);\n\n\n\n\t/* Pointers *******************************************************/\n\n\n\n\tVprintf(\"\\n%sPROPERTIES OF POINTERS%s\\n\", co, oc);\n\n\tcp= (char *) &variable;\n\n\tip= (int *) &variable;\n\n\tfp= (function *) &variable;\n\n\n\n\tVprintf(\"%sChar and int pointer formats \", co);\n\n\tif (memeq((char *) &cp, sizeof(cp), (char *) &ip, sizeof(ip))) {\n\n\t\tVprintf(\"seem identical%s\\n\", oc);\n\n\t} else {\n\n\t\tVprintf(\"are different%s\\n\", oc);\n\n\t}\n\n\tVprintf(\"%sChar and function pointer formats \", co);\n\n\tif (memeq((char *) &cp, sizeof(cp), (char *) &fp, sizeof(fp))) {\n\n\t\tVprintf(\"seem identical%s\\n\", oc);\n\n\t} else {\n\n\t\tVprintf(\"are different%s\\n\", oc);\n\n\t}\n\n\n\n\tif (V) {\n\n\t\tif (\"abcd\"==\"abcd\")\n\n\t\t\tprintf(\"%sStrings are shared%s\\n\", co, oc);\n\n\t\telse printf(\"%sStrings are not shared%s\\n\", co, oc);\n\n\t}\n\n\n\n\tp=0; q=0;\n\n\tshowtype(\"Type ptrdiff_t is\", p-q);\n\n\n\n\tif (setjmp(mlab) == 0) {\n\n\t\tvariable= *p;\n\n\t\tVprintf(\"%sBEWARE! Dereferencing NULL doesn't cause a trap%s\\n\",\n\n\t\t\tco, oc);\n\n\t} else {\n\n\t\tVprintf(\"%sDereferencing NULL causes a trap%s\\n\", co, oc);\n\n\t}\n\n\tif (setjmp(mlab)!=0) croak(-2);\n\n\n\n\tVprintf(\"\\n%sPROPERTIES OF INTEGRAL TYPES%s\\n\", co, oc);\n\n\n\n\tsprop();\n\n\tiprop();\n\n\tlprop();\n\n\tusprop();\n\n\tuiprop();\n\n\tulprop();\n\n\n\n\tpromotions();\n\n\n\n\tUnexpected(6);\n\n\n\n\treturn byte_size;\n\n}\n\n\n\n#else /* not PASS0 */\n\n\n\n#ifdef SEP\n\n/* The global variables used by several passes */\n\nextern jmp_buf lab;\n\nextern int V, L, F, bugs, bits_per_byte;\n\nextern int maxint, flt_radix, flt_rounds;\n\nextern Volatile int trapped;\n\nextern char co[], oc[];\n\nextern char *f_rep();\n\nextern Void trap1();\n\n#endif /* SEP */\n\n#endif /* ifdef PASS0 */\n\n\n\n/* As I said, I apologise for the contortions below. The functions are\n\n   expanded by the preprocessor twice or three times (for float and double,\n\n   and maybe for long double, and for short, int and long). That way,\n\n   I never make a change to one that I forget to make to the other.\n\n   You can look on it as C's fault for not supporting multi-line macros.\n\n   This whole file is read 3 times by the preprocessor, with PASSn set for\n\n   n=1, 2 or 3, to decide which parts to reprocess.\n\n*/\n\n\n\n/* #undef on an already undefined thing is (wrongly) flagged as an error\n\n   by some compilers, therefore the #ifdef that follows:\n\n*/\n\n#ifdef Number\n\n#undef Number\n\n#undef THING\n\n#undef Thing\n\n#undef thing\n\n#undef FPROP\n\n#undef Fname\n\n#undef Store\n\n#undef Sum\n\n#undef Diff\n\n#undef Mul\n\n#undef Div\n\n#undef ZERO\n\n#undef HALF\n\n#undef ONE\n\n#undef TWO\n\n#undef THREE\n\n#undef FOUR\n\n#undef Self\n\n#undef F_check\n\n#undef Verify\n\n#undef EPROP\n\n#undef MARK\n\n\n\n/* These are the float.h constants */\n\n#undef F_RADIX\n\n#undef F_MANT_DIG\n\n#undef F_DIG\n\n#undef F_ROUNDS\n\n#undef F_EPSILON\n\n#undef F_MIN_EXP\n\n#undef F_MIN\n\n#undef F_MIN_10_EXP\n\n#undef F_MAX_EXP\n\n#undef F_MAX\n\n#undef F_MAX_10_EXP\n\n#endif\n\n\n\n#ifdef Integer\n\n#undef Integer\n\n#undef INT\n\n#undef IPROP\n\n#undef Iname\n\n#undef UPROP\n\n#undef Uname\n\n#undef OK_UI\n\n#undef IMARK\n\n\n\n#undef I_MAX\n\n#undef I_MIN\n\n#undef U_MAX\n\n#endif\n\n\n\n#ifdef PASS1\n\n\n\n/* Define the things we're going to use this pass */\n\n\n\n#define Number\tfloat\n\n#define THING\t\"FLOAT\"\n\n#define Thing\t\"Float\"\n\n#define thing\t\"float\"\n\n#define Fname\t\"FLT\"\n\n#define FPROP\tfprop\n\n#define Store\tfStore\n\n#define Sum\tfSum\n\n#define Diff\tfDiff\n\n#define Mul\tfMul\n\n#define Div\tfDiv\n\n#define ZERO\t0.0\n\n#define HALF\t0.5\n\n#define ONE\t1.0\n\n#define TWO\t2.0\n\n#define THREE\t3.0\n\n#define FOUR\t4.0\n\n#define Self\tfSelf\n\n#define F_check\tfCheck\n\n#define MARK\t\"F\"\n\n#ifdef VERIFY\n\n#define Verify fVerify\n\n#endif\n\n\n\n#define EPROP\tefprop\n\n\n\n#define Integer\tshort\n\n#define INT\t\"short\"\n\n#define IPROP\tsprop\n\n#define Iname\t\"SHRT\"\n\n#ifndef NO_UI\n\n#define OK_UI 1\n\n#endif\n\n#define IMARK\t\"\"\n\n\n\n#define UPROP\tusprop\n\n#define Uname\t\"USHRT\"\n\n\n\n#ifdef VERIFY\n\n#ifdef SHRT_MAX\n\n#define I_MAX\t\tSHRT_MAX\n\n#endif\n\n#ifdef SHRT_MIN\n\n#define I_MIN\t\tSHRT_MIN\n\n#endif\n\n#ifdef USHRT_MAX\n\n#define U_MAX\t\tUSHRT_MAX\n\n#endif\n\n\n\n#ifdef FLT_RADIX\n\n#define F_RADIX\t\tFLT_RADIX\n\n#endif\n\n#ifdef FLT_MANT_DIG\n\n#define F_MANT_DIG\tFLT_MANT_DIG\n\n#endif\n\n#ifdef FLT_DIG\n\n#define F_DIG\t\tFLT_DIG\n\n#endif\n\n#ifdef FLT_ROUNDS\n\n#define F_ROUNDS\tFLT_ROUNDS\n\n#endif\n\n#ifdef FLT_EPSILON\n\n#define F_EPSILON\tFLT_EPSILON\n\n#endif\n\n#ifdef FLT_MIN_EXP\n\n#define F_MIN_EXP\tFLT_MIN_EXP\n\n#endif\n\n#ifdef FLT_MIN\n\n#define F_MIN\t\tFLT_MIN\n\n#endif\n\n#ifdef FLT_MIN_10_EXP\n\n#define F_MIN_10_EXP\tFLT_MIN_10_EXP\n\n#endif\n\n#ifdef FLT_MAX_EXP\n\n#define F_MAX_EXP\tFLT_MAX_EXP\n\n#endif\n\n#ifdef FLT_MAX\n\n#define F_MAX\t\tFLT_MAX\n\n#endif\n\n#ifdef FLT_MAX_10_EXP\n\n#define F_MAX_10_EXP\tFLT_MAX_10_EXP\n\n#endif\n\n#endif /* VERIFY */\n\n\n\n#endif /* PASS1 */\n\n\n\n#ifdef PASS2\n\n\n\n#define Number\tdouble\n\n#define THING\t\"DOUBLE\"\n\n#define Thing\t\"Double\"\n\n#define thing\t\"double\"\n\n#define Fname\t\"DBL\"\n\n#define FPROP\tdprop\n\n#define Store\tdStore\n\n#define Sum\tdSum\n\n#define Diff\tdDiff\n\n#define Mul\tdMul\n\n#define Div\tdDiv\n\n#define ZERO\t0.0\n\n#define HALF\t0.5\n\n#define ONE\t1.0\n\n#define TWO\t2.0\n\n#define THREE\t3.0\n\n#define FOUR\t4.0\n\n#define Self\tdSelf\n\n#define F_check\tdCheck\n\n#define MARK\t\"\"\n\n#ifdef VERIFY\n\n#define Verify dVerify\n\n#endif\n\n\n\n#define EPROP\tedprop\n\n\n\n#define Integer\tint\n\n#define INT\t\"int\"\n\n#define IPROP\tiprop\n\n#define Iname\t\"INT\"\n\n#define OK_UI\t1 /* Unsigned int is always possible */\n\n#define IMARK\t\"\"\n\n\n\n#define UPROP\tuiprop\n\n#define Uname\t\"UINT\"\n\n\n\n#ifdef VERIFY\n\n#ifdef INT_MAX\n\n#define I_MAX\t\tINT_MAX\n\n#endif\n\n#ifdef INT_MIN\n\n#define I_MIN\t\tINT_MIN\n\n#endif\n\n#ifdef UINT_MAX\n\n#define U_MAX\t\tUINT_MAX\n\n#endif\n\n\n\n#ifdef DBL_MANT_DIG\n\n#define F_MANT_DIG\tDBL_MANT_DIG\n\n#endif\n\n#ifdef DBL_DIG\n\n#define F_DIG\t\tDBL_DIG\n\n#endif\n\n#ifdef DBL_EPSILON\n\n#define F_EPSILON\tDBL_EPSILON\n\n#endif\n\n#ifdef DBL_MIN_EXP\n\n#define F_MIN_EXP\tDBL_MIN_EXP\n\n#endif\n\n#ifdef DBL_MIN\n\n#define F_MIN\t\tDBL_MIN\n\n#endif\n\n#ifdef DBL_MIN_10_EXP\n\n#define F_MIN_10_EXP\tDBL_MIN_10_EXP\n\n#endif\n\n#ifdef DBL_MAX_EXP\n\n#define F_MAX_EXP\tDBL_MAX_EXP\n\n#endif\n\n#ifdef DBL_MAX\n\n#define F_MAX\t\tDBL_MAX\n\n#endif\n\n#ifdef DBL_MAX_10_EXP\n\n#define F_MAX_10_EXP\tDBL_MAX_10_EXP\n\n#endif\n\n#endif /* VERIFY */\n\n\n\n#endif /* PASS2 */\n\n\n\n#ifdef PASS3\n\n\n\n#ifdef STDC\n\n#define Number\tlong double\n\n\n\n#define ZERO\t0.0L\n\n#define HALF\t0.5L\n\n#define ONE\t1.0L\n\n#define TWO\t2.0L\n\n#define THREE\t3.0L\n\n#define FOUR\t4.0L\n\n#endif\n\n\n\n#define THING\t\"LONG DOUBLE\"\n\n#define Thing\t\"Long double\"\n\n#define thing\t\"long double\"\n\n#define Fname\t\"LDBL\"\n\n#define FPROP\tldprop\n\n#define Store\tldStore\n\n#define Sum\tldSum\n\n#define Diff\tldDiff\n\n#define Mul\tldMul\n\n#define Div\tldDiv\n\n#define Self\tldSelf\n\n#define F_check\tldCheck\n\n#define MARK\t\"L\"\n\n#ifdef VERIFY\n\n#define Verify ldVerify\n\n#endif\n\n\n\n#define EPROP\teldprop\n\n\n\n#define Integer\tlong\n\n#define INT\t\"long\"\n\n#define IPROP\tlprop\n\n#define Iname\t\"LONG\"\n\n#ifndef NO_UI\n\n#define OK_UI\t1\n\n#endif\n\n#define IMARK\t\"L\"\n\n\n\n#define UPROP\tulprop\n\n#define Uname\t\"ULONG\"\n\n\n\n#ifdef VERIFY\n\n#ifdef LONG_MAX\n\n#define I_MAX\tLONG_MAX\n\n#endif\n\n#ifdef LONG_MIN\n\n#define I_MIN\tLONG_MIN\n\n#endif\n\n#ifdef ULONG_MAX\n\n#define U_MAX\tULONG_MAX\n\n#endif\n\n\n\n#ifdef LDBL_MANT_DIG\n\n#define F_MANT_DIG\tLDBL_MANT_DIG\n\n#endif\n\n#ifdef LDBL_DIG\n\n#define F_DIG\t\tLDBL_DIG\n\n#endif\n\n#ifdef LDBL_EPSILON\n\n#define F_EPSILON\tLDBL_EPSILON\n\n#endif\n\n#ifdef LDBL_MIN_EXP\n\n#define F_MIN_EXP\tLDBL_MIN_EXP\n\n#endif\n\n#ifdef LDBL_MIN\n\n#define F_MIN\t\tLDBL_MIN\n\n#endif\n\n#ifdef LDBL_MIN_10_EXP\n\n#define F_MIN_10_EXP\tLDBL_MIN_10_EXP\n\n#endif\n\n#ifdef LDBL_MAX_EXP\n\n#define F_MAX_EXP\tLDBL_MAX_EXP\n\n#endif\n\n#ifdef LDBL_MAX\n\n#define F_MAX\t\tLDBL_MAX\n\n#endif\n\n#ifdef LDBL_MAX_10_EXP\n\n#define F_MAX_10_EXP\tLDBL_MAX_10_EXP\n\n#endif\n\n#endif /* VERIFY */\n\n\n\n#endif /* PASS3 */\n\n\n\n/* The rest of the file gets read all three times;\n\n   the differences are encoded in the things #defined above.\n\n*/\n\n\n\n#ifndef I_MAX\n\n#define I_MAX\tint_max\n\n#endif\n\n#ifndef I_MIN\n\n#define I_MIN\tint_min\n\n#endif\n\n#ifndef U_MAX\n\n#define U_MAX\tu_max\n\n#endif\n\n\n\n#ifndef F_RADIX\n\n#define F_RADIX\t\tf_radix\n\n#endif\n\n#ifndef F_MANT_DIG\n\n#define F_MANT_DIG\tf_mant_dig\n\n#endif\n\n#ifndef F_DIG\n\n#define F_DIG\t\tf_dig\n\n#endif\n\n#ifndef F_ROUNDS\n\n#define F_ROUNDS\tf_rounds\n\n#endif\n\n#ifndef F_EPSILON\n\n#define F_EPSILON\tf_epsilon\n\n#endif\n\n#ifndef F_MIN_EXP\n\n#define F_MIN_EXP\tf_min_exp\n\n#endif\n\n#ifndef F_MIN\n\n#define F_MIN\t\tf_min\n\n#endif\n\n#ifndef F_MIN_10_EXP\n\n#define F_MIN_10_EXP\tf_min_10_exp\n\n#endif\n\n#ifndef F_MAX_EXP\n\n#define F_MAX_EXP\tf_max_exp\n\n#endif\n\n#ifndef F_MAX\n\n#define F_MAX\t\tf_max\n\n#endif\n\n#ifndef F_MAX_10_EXP\n\n#define F_MAX_10_EXP\tf_max_10_exp\n\n#endif\n\n\n\n#ifndef VERIFY\n\n#define Verify(prec, val, req, same, same1) {;}\n\n#endif\n\n\n\n#ifdef Integer\n\n\n\nVoid IPROP() {\n\n\t/* the properties of short, int, and long */\n\n\tVolatile Integer newi, int_max, maxeri, int_min, minneri;\n\n\tVolatile int ibits, ipower, two=2;\n\n\n\n\t/* Calculate max short/int/long ***********************************/\n\n\t/* Calculate 2**n-1 until overflow - then use the previous value  */\n\n\n\n\tnewi=1; int_max=0;\n\n\n\n\tif (setjmp(lab)==0) { /* Yields int_max */\n\n\t\tfor(ipower=0; newi>int_max; ipower++) {\n\n\t\t\tint_max=newi;\n\n\t\t\tnewi=newi*two+1;\n\n\t\t}\n\n\t\tVprintf(\"%sOverflow of a%s %s does not generate a trap%s\\n\",\n\n\t\t\tco, INT[0]=='i'?\"n\":\"\", INT, oc);\n\n\t} else {\n\n\t\tVprintf(\"%sOverflow of a%s %s generates a trap%s\\n\",\n\n\t\t\tco, INT[0]=='i'?\"n\":\"\", INT, oc);\n\n\t}\n\n\tUnexpected(7);\n\n\n\n\t/* Minimum value: assume either two's or one's complement *********/\n\n\tint_min= -int_max;\n\n\tif (setjmp(lab)==0) { /* Yields int_min */\n\n\t\tif (int_min-1 < int_min) int_min--;\n\n\t}\n\n\tUnexpected(8);\n\n\n\n\t/* Now for those daft Cybers */\n\n\n\n\tmaxeri=0; newi=int_max;\n\n\n\n\tif (setjmp(lab)==0) { /* Yields maxeri */\n\n\t\tfor(ibits=ipower; newi>maxeri; ibits++) {\n\n\t\t\tmaxeri=newi;\n\n\t\t\tnewi=newi+newi+1;\n\n\t\t}\n\n\t}\n\n\tUnexpected(9);\n\n\n\n\tminneri= -maxeri;\n\n\tif (setjmp(lab)==0) { /* Yields minneri */\n\n\t\tif (minneri-1 < minneri) minneri--;\n\n\t}\n\n\tUnexpected(10);\n\n\n\n\tVprintf(\"%sMaximum %s = %ld (= 2**%d-1)%s\\n\",\n\n\t\tco, INT, (long)int_max, ipower, oc);\n\n\tVprintf(\"%sMinimum %s = %ld%s\\n\", co, INT, (long)int_min, oc);\n\n\n\n\tif (L) i_define(D_INT_MAX, INT, Iname, \"_MAX\",\n\n\t\t\t(long) int_max, 0L,\n\n\t\t\t(long) I_MAX, IMARK);\n\n\tif (L) i_define(D_INT_MIN, INT, Iname, \"_MIN\",\n\n\t\t\t(long) int_min, (long) (PASS==1?maxint:int_max),\n\n\t\t\t(long) I_MIN, IMARK);\n\n\n\n\tif(int_max < 0) { /* It has happened (on a Cray) */\n\n\t\teek_a_bug(\"signed integral comparison faulty?\");\n\n\t}\n\n\n\n\tif (maxeri>int_max) {\n\n\t\tVprintf(\"%sThere is a larger %s, %ld (= 2**%d-1), %s %s%s\\n\",\n\n\t\t\tco, INT, (long)maxeri, ibits,\n\n\t\t\t\"but only for addition, not multiplication\",\n\n\t\t\t\"(I smell a Cyber!)\",\n\n\t\t\toc);\n\n\t}\n\n\n\n\tif (minneri<int_min) {\n\n\t\tVprintf(\"%sThere is a smaller %s, %ld, %s %s%s\\n\",\n\n\t\t\tco, INT, (long)minneri,\n\n\t\t\t\"but only for addition, not multiplication\",\n\n\t\t\t\"(I smell a Cyber!)\",\n\n\t\t\toc);\n\n\t}\n\n}\n\n\n\nVoid UPROP () {\n\n\t/* The properties of unsigned short/int/long */\n\n#ifdef OK_UI\n\n\tVolatile unsigned Integer u_max, newi, two;\n\n\tnewi=1; u_max=0; two=2;\n\n\n\n\tif (setjmp(lab)==0) { /* Yields u_max */\n\n\t\twhile(newi>u_max) {\n\n\t\t\tu_max=newi;\n\n\t\t\tnewi=newi*two+1;\n\n\t\t}\n\n\t}\n\n\tUnexpected(11);\n\n\tVprintf(\"%sMaximum unsigned %s = %lu%s\\n\",\n\n\t\tco, INT, (unsigned long) u_max, oc);\n\n\n\n\t/* Oh woe: new standard C defines value preserving promotions:\n\n\t   3.2.1.1: \"If an int can represent all values of the original type,\n\n\t   \t     the value is converted to an int;\n\n\t\t     otherwise it is converted to an unsigned int.\"\n\n\t*/\n\n\tif (L) {\n\n\t\tif (PASS == 1 /* we're dealing with short */\n\n\t\t    && u_max <= maxint /* an int can represent all values */\n\n\t\t    )\n\n\t\t{ /* the value is converted to an int */\n\n\t\t\ti_define(D_UINT_MAX, INT, Uname, \"_MAX\",\n\n\t\t\t\t (long) u_max, 0L,\n\n\t\t\t\t (long) U_MAX, IMARK);\n\n\t\t} else { /* it is converted to an unsigned int */\n\n\t\t\tu_define(D_UINT_MAX, INT, Uname, \"_MAX\",\n\n\t\t\t\t (unsigned long) u_max,\n\n\t\t\t\t (unsigned long) U_MAX, IMARK);\n\n\t\t}\n\n\t}\n\n#endif\n\n}\n\n\n\n#endif /* Integer */\n\n\n\n#ifdef Number\n\n\n\n/* The following routines are intended to defeat any attempt at optimisation\n\n   or use of extended precision, and to defeat faulty narrowing casts.\n\n   The weird prototypes are because of widening incompatibilities.\n\n*/\n\n#ifdef STDC\n\n#define ARGS1(A, a) (A a)\n\n#define ARGS2(A, a, B, b) (A a, B b)\n\n#define ARGS5(A, a, B, b, C, c, D, d, E, e) (A a, B b, C c, D d, E e)\n\n#else\n\n#define ARGS1(A, a) (a) A a;\n\n#define ARGS2(A, a, B, b) (a, b) A a; B b;\n\n#define ARGS5(A, a, B, b, C, c, D, d, E, e) (a,b,c,d,e)A a; B b; C c; D d; E e;\n\n#endif\n\n\n\nVoid Store ARGS2(Number, a, Number *, b) { *b=a; }\n\nNumber Sum ARGS2(Number, a, Number, b) {Number r; Store(a+b, &r); return r; }\n\nNumber Diff ARGS2(Number, a, Number, b){Number r; Store(a-b, &r); return r; }\n\nNumber Mul ARGS2(Number, a, Number, b) {Number r; Store(a*b, &r); return r; }\n\nNumber Div ARGS2(Number, a, Number, b) {Number r; Store(a/b, &r); return r; }\n\nNumber Self ARGS1(Number, a)\t       {Number r; Store(a,   &r); return r; }\n\n\n\nVoid F_check ARGS((int precision, Long_double val1));\n\n\n\nVoid F_check(precision, val1) int precision; Long_double val1; {\n\n\t/* You don't think I'm going to go to all the trouble of writing\n\n\t   a program that works out what all sorts of values are, only to\n\n\t   have printf go and print the wrong values out, do you?\n\n\t   No, you're right, so this function tries to see if printf\n\n\t   has written the right value, by reading it back again.\n\n\t   This introduces a new problem of course: suppose printf writes\n\n\t   the correct value, and scanf reads it back wrong... oh well.\n\n\t   But I'm adamant about this: the precision given is enough\n\n\t   to uniquely identify the printed number, therefore I insist\n\n\t   that sscanf read the number back identically. Harsh yes, but\n\n\t   sometimes you've got to be cruel to be kind.\n\n\t*/\n\n\tLong_double new1, rem;\n\n\tNumber val, new, diff;\n\n\tint e;\n\n\tchar *rep, *f2;\n\n\n\n\tif (sizeof(double) == sizeof(Long_double)) {\n\n\t\t/* Assume they're the same, and use non-stdc format */\n\n\t\t/* This is for stdc compilers using non-stdc libraries */\n\n\t\tf2= \"%le\";   /* Input */\n\n\t} else {\n\n\t\t/* It had better support Le then */\n\n\t\tf2= \"%Le\";\n\n\t}\n\n\tval= (Number) val1;\n\n\trep= f_rep(precision, (Long_double) val);\n\n\tif (setjmp(lab)==0) {\n\n\t\tsscanf(rep, f2, &new1);\n\n\t} else {\n\n\t\teek_a_bug(\"sscanf caused a trap\");\n\n\t\tprintf(\"%s    scanning: %s format: %s%s\\n\\n\", co, rep, f2, oc);\n\n\t\tUnexpected(12);\n\n\t\treturn;\n\n\t}\n\n\n\n\tif (setjmp(lab)==0) { /* See if new is usable */\n\n\t\tnew= new1;\n\n\t\tif (new != 0.0) {\n\n\t\t\tdiff= val/new - 1.0;\n\n\t\t\tif (diff < 0.1) diff= 1.0;\n\n\t\t\t/* That should be enough to generate a trap */\n\n\t\t}\n\n\t} else {\n\n\t\teek_a_bug(\"sscanf returned an unusable number\");\n\n\t\tprintf(\"%s    scanning: %s with format: %s%s\\n\\n\",\n\n\t\t       co, rep, f2, oc);\n\n\t\tUnexpected(13);\n\n\t\treturn;\n\n\t}\n\n\n\n\tUnexpected(14);\n\n\tif (new != val) {\n\n\t\teek_a_bug(\"Possibly bad output from printf above\");\n\n\t\tif (!exponent((Long_double)val, &rem, &e)) {\n\n\t\t\tprintf(\"%s    but value was an unusable number%s\\n\\n\",\n\n\t\t\t       co, oc);\n\n\t\t\treturn;\n\n\t\t}\n\n\t\tprintf(\"%s    expected value around \", co);\n\n\t\tif (sizeof(double) == sizeof(Long_double)) {\n\n\t\t\t/* Assume they're the same, and use non-stdc format */\n\n\t\t\t/* This is for stdc compilers using non-stdc libraries */\n\n\t\t\tprintf(\"%.*Lfe%d, bit pattern:\\n    \", precision, rem, e);\n\n\t\t} else {\n\n\t\t\t/* It had better support Lfe then */\n\n\t\t\tprintf(\"%.*Lfe%d, bit pattern:\\n    \", precision, rem, e);\n\n\t\t}\n\n\t\tbitpattern((char *) &val, (unsigned)sizeof(val));\n\n\t\tprintf (\"%s\\n\", oc);\n\n\t\tprintf(\"%s    sscanf gave           %s, bit pattern:\\n    \",\n\n\t\t       co, f_rep(precision, (Long_double) new));\n\n\t\tbitpattern((char *) &new, (unsigned)sizeof(new));\n\n\t\tprintf (\"%s\\n\", oc);\n\n\t\tif (setjmp(lab) == 0) {\n\n\t\t\tdiff= val-new;\n\n\t\t\tprintf(\"%s    difference= %s%s\\n\\n\",\n\n\t\t\t       co, f_rep(precision, (Long_double) diff), oc);\n\n\t\t} /* else forget it */\n\n\t\tUnexpected(15);\n\n\t}\n\n}\n\n\n\n#ifdef VERIFY\n\nVoid Verify ARGS5(int, prec, Number, val, Number, req, int, same, int, same1) {\n\n\t/* Check that the compiler has read a #define value correctly */\n\n\tUnexpected(16);\n\n\tif (!same) {\n\n\t\tprintf(\"%s*** Verify failed for above #define!\\n\", co);\n\n\t\tif (setjmp(lab) == 0) { /* for the case that req == nan */\n\n\t\t\tprintf(\"       Compiler has %s for value\\n\",\n\n\t\t\t       f_rep(prec, req));\n\n\t\t} else {\n\n\t\t\tprintf(\"       Compiler has %s for value\\n\",\n\n\t\t\t       \"an unusable number\");\n\n\t\t}\n\n\t\tif (setjmp(lab) == 0) {\n\n\t\t\tF_check(prec, (Long_double) req);\n\n\t\t} /*else forget it*/\n\n\t\tif (setjmp(lab) == 0) {\n\n\t\t\tif (req > 0.0 && val > 0.0) {\n\n\t\t\t\tprintf(\"       difference= %s\\n\",\n\n\t\t\t\t       f_rep(prec, val-req));\n\n\t\t\t}\n\n\t\t} /*else forget it*/\n\n\t\tUnexpected(17);\n\n\t\tprintf(\"%s\\n\", oc);\n\n\t\tbugs++;\n\n\t} else if (!same1) {\n\n\t\tif (stdc) eek_a_bug(\"constant has the wrong precision\");\n\n\t\telse eek_a_bug(\"the cast didn't work\");\n\n\t\tprintf(\"\\n\");\n\n\t}\n\n}\n\n#endif /* VERIFY */\n\n\n\nint FPROP(byte_size) int byte_size; {\n\n\t/* Properties of floating types, using algorithms by Cody and Waite\n\n\t   from MA Malcolm, as modified by WM Gentleman and SB Marovich.\n\n\t   Further extended by S Pemberton.\n\n\n\n\t   Returns the number of digits in the fraction.\n\n\t*/\n\n\n\n\tVolatile int\n\n\t\ti, f_radix, iexp, irnd, mrnd, f_rounds, f_mant_dig,\n\n\t\tiz, k, inf, machep, f_max_exp, f_min_exp, mx, negeps,\n\n\t\tmantbits, digs, f_dig, trap,\n\n\t\thidden, normal, f_min_10_exp, f_max_10_exp;\n\n\tVolatile Number\n\n\t\ta, b, base, basein, basem1, f_epsilon, epsneg,\n\n\t\teps, epsp1, etop, ebot,\n\n\t\tf_max, newxmax, f_min, xminner, y, y1, z, z1, z2;\n\n\n\n\tUnexpected(18);\n\n\n\n\tVprintf(\"%sPROPERTIES OF %s%s\\n\", co, THING, oc);\n\n\n\n\t/* Base and size of significand **************************************/\n\n\t/* First repeatedly double until adding 1 has no effect.\t  */\n\n\t/* For instance, if base is 10, with 3 significant digits\t  */\n\n\t/* it will try 1, 2, 4, 8, ... 512, 1024, and stop there,\t  */\n\n\t/* since 1024 is only representable as 1020.\t\t\t  */\n\n\ta=1.0;\n\n\tif (setjmp(lab)==0) { /* inexact trap? */\n\n\t\tdo { a=Sum(a, a); }\n\n\t\twhile (Diff(Diff(Sum(a, ONE), a), ONE) == ZERO);\n\n\t} else {\n\n\t\tfprintf(stderr, \"*** Program got loss-of-precision trap!\\n\");\n\n\t\t/* And supporting those is just TOO much trouble! */\n\n\t\tfarewell(bugs+1);\n\n\t}\n\n\tUnexpected(19);\n\n\t/* Now double until you find a number that can be added to the\t  */\n\n\t/* above number. For 1020 this is 8 or 16, depending whether the  */\n\n\t/* result is rounded or truncated.\t\t\t\t  */\n\n\t/* In either case the result is 1030. 1030-1020= the base, 10.\t  */\n\n\tb=1.0;\n\n\tdo { b=Sum(b, b); } while ((base=Diff(Sum(a, b), a)) == ZERO);\n\n\tf_radix=base;\n\n\tVprintf(\"%sBase = %d%s\\n\", co, f_radix, oc);\n\n\n\n\t/* Sanity check; if base<2, I can't guarantee the rest will work  */\n\n\tif (f_radix < 2) {\n\n\t\teek_a_bug(\"Function return or parameter passing faulty? (This is a guess.)\");\n\n\t\tprintf(\"\\n\");\n\n\t\treturn(0);\n\n\t}\n\n\n\n\tif (PASS == 1) { /* only for FLT */\n\n\t\tflt_radix= f_radix;\n\n\t\tif (F) i_define(D_FLT_RADIX, \"\", \"FLT\", \"_RADIX\",\n\n\t\t\t\t(long) f_radix, 0L, (long) F_RADIX, \"\");\n\n\t} else if (f_radix != flt_radix) {\n\n\t\tprintf(\"\\n%s*** WARNING: %s %s (%d) %s%s\\n\",\n\n\t\t       co, thing, \"arithmetic has a different radix\",\n\n\t\t       f_radix, \"from float\", oc);\n\n\t\tbugs++;\n\n\t}\n\n\n\n\t/* Now the number of digits precision */\n\n\tf_mant_dig=0; b=1.0;\n\n\tdo { f_mant_dig++; b=Mul(b, base); }\n\n\twhile (Diff(Diff(Sum(b, ONE), b), ONE) == ZERO);\n\n\tf_dig=floor_log(10, (Long_double)(b/base)) + (base==10?1:0);\n\n\tVprintf(\"%sSignificant base digits = %d %s %d %s%s\\n\",\n\n\t\tco, f_mant_dig, \"(= at least\", f_dig, \"decimal digits)\", oc);\n\n\tif (F) i_define(D_MANT_DIG, thing, Fname, \"_MANT_DIG\",\n\n\t\t\t(long) f_mant_dig, 0L, (long) F_MANT_DIG, \"\");\n\n\tif (F) i_define(D_DIG, thing, Fname, \"_DIG\",\n\n\t\t\t(long) f_dig, 0L, (long) F_DIG, \"\");\n\n\tdigs= ceil_log(10, (Long_double)b); /* the number of digits to printf */\n\n\n\n\t/* Rounding *******************************************************/\n\n\tbasem1=Diff(base, HALF);\n\n\tif (Diff(Sum(a, basem1), a) != ZERO) {\n\n\t\tif (f_radix == 2) basem1=0.375;\n\n\t\telse basem1=1.0;\n\n\t\tif (Diff(Sum(a, basem1), a) != ZERO) irnd=2; /* away from 0 */\n\n\t\telse irnd=1; /* to nearest */\n\n\t} else irnd=0; /* towards 0 */\n\n\n\n\tbasem1=Diff(base, HALF);\n\n\n\n\tif (Diff(Diff(-a, basem1), -a) != ZERO) {\n\n\t\tif (f_radix == 2) basem1=0.375;\n\n\t\telse basem1=1.0;\n\n\t\tif (Diff(Diff(-a, basem1), -a) != ZERO) mrnd=2; /* away from 0*/\n\n\t\telse mrnd=1; /* to nearest */\n\n\t} else mrnd=0; /* towards 0 */\n\n\n\n\tf_rounds= -1; /* Unknown rounding */\n\n\tif (irnd==0 && mrnd==0) f_rounds=0; /* zero = chops */\n\n\tif (irnd==1 && mrnd==1) f_rounds=1; /* nearest */\n\n\tif (irnd==2 && mrnd==0) f_rounds=2; /* +inf */\n\n\tif (irnd==0 && mrnd==2) f_rounds=3; /* -inf */\n\n\n\n\tif (f_rounds != -1) {\n\n\t\tVprintf(\"%sArithmetic rounds towards \", co);\n\n\t\tswitch (f_rounds) {\n\n\t\t      case 0: Vprintf(\"zero (i.e. it chops)\"); break;\n\n\t\t      case 1: Vprintf(\"nearest\"); break;\n\n\t\t      case 2: Vprintf(\"+infinity\"); break;\n\n\t\t      case 3: Vprintf(\"-infinity\"); break;\n\n\t\t      default: Vprintf(\"???\"); break;\n\n\t\t}\n\n\t\tVprintf(\"%s\\n\", oc);\n\n\t} else { /* Hmm, try to give some help here */\n\n\t\tVprintf(\"%sArithmetic rounds oddly: %s\\n\", co, oc);\n\n\t\tVprintf(\"%s    Negative numbers %s%s\\n\",\n\n\t\t\tco, mrnd==0 ? \"towards zero\" :\n\n\t\t\t    mrnd==1 ? \"to nearest\" :\n\n\t\t\t\t      \"away from zero\",\n\n\t\t\toc);\n\n\t\tVprintf(\"%s    Positive numbers %s%s\\n\",\n\n\t\t\tco, irnd==0 ? \"towards zero\" :\n\n\t\t\t    irnd==1 ? \"to nearest\" :\n\n\t\t\t\t      \"away from zero\",\n\n\t\t\toc);\n\n\t}\n\n\t/* An extra goody */\n\n\tif (f_radix == 2 && f_rounds == 1) {\n\n\t\tif (Diff(Sum(a, ONE), a) != ZERO) {\n\n\t\t\tVprintf(\"%s   Tie breaking rounds up%s\\n\", co, oc);\n\n\t\t} else if (Diff(Sum(a, THREE), a) == FOUR) {\n\n\t\t\tVprintf(\"%s   Tie breaking rounds to even%s\\n\", co, oc);\n\n\t\t} else {\n\n\t\t\tVprintf(\"%s   Tie breaking rounds down%s\\n\", co, oc);\n\n\t\t}\n\n\t}\n\n\tif (PASS == 1) { /* only for FLT */\n\n\t\tflt_rounds= f_rounds;\n\n\t\tif (F)\n\n\t\t  i_define(D_FLT_ROUNDS, \"\", \"FLT\", \"_ROUNDS\",\n\n\t\t\t   (long) f_rounds, 1L, (long) F_ROUNDS, \"\");\n\n\t} else if (f_rounds != flt_rounds) {\n\n\t\tprintf(\"\\n%s*** WARNING: %s %s (%d) %s%s\\n\\n\",\n\n\t\t       co, thing, \"arithmetic rounds differently\",\n\n\t\t       f_rounds, \"from float\", oc);\n\n\t\tbugs++;\n\n\t}\n\n\n\n\t/* Various flavours of epsilon ************************************/\n\n\tnegeps=f_mant_dig+f_mant_dig;\n\n\tbasein=1.0/base;\n\n\ta=1.0;\n\n\tfor(i=1; i<=negeps; i++) a*=basein;\n\n\n\n\tb=a;\n\n\twhile (Diff(Diff(ONE, a), ONE) == ZERO) {\n\n\t\ta*=base;\n\n\t\tnegeps--;\n\n\t}\n\n\tnegeps= -negeps;\n\n\tVprintf(\"%sSmallest x such that 1.0-base**x != 1.0 = %d%s\\n\",\n\n\t\tco, negeps, oc);\n\n\n\n\tetop = ONE;\n\n\tebot = ZERO;\n\n\teps = Sum(ebot, Div(Diff(etop, ebot), TWO));\n\n\t/* find the smallest epsneg (1-epsneg != 1) by binary search.\n\n\t   ebot and etop are the current bounds */\n\n\twhile (eps != ebot && eps != etop) {\n\n\t\tepsp1 = Diff(ONE, eps);\n\n\t\tif (epsp1 < ONE) etop = eps;\n\n\t\telse ebot = eps;\n\n\t\teps = Sum(ebot, Div(Diff(etop, ebot), TWO));\n\n\t}\n\n\teps= etop;\n\n\t/* Sanity check */\n\n\tif (Diff(ONE, etop) >= ONE || Diff(ONE, ebot) != ONE) {\n\n\t\teek_a_bug(\"internal error calculating epsneg\");\n\n\t}\n\n\tVprintf(\"%sSmallest x such that 1.0-x != 1.0 = %s%s\\n\",\n\n\t\tco, f_rep(digs, (Long_double) eps), oc);\n\n\tif (V) F_check(digs, (Long_double) eps);\n\n\n\n\tepsneg=a;\n\n\tif ((f_radix!=2) && irnd) {\n\n\t/*\ta=(a*(1.0+a))/(1.0+1.0); => */\n\n\t\ta=Div(Mul(a, Sum(ONE, a)), Sum(ONE, ONE));\n\n\t/*\tif ((1.0-a)-1.0 != 0.0) epsneg=a; => */\n\n\t\tif (Diff(Diff(ONE, a), ONE) != ZERO) epsneg=a;\n\n\t}\n\n\t/* epsneg is used later */\n\n\tUnexpected(20);\n\n\n\n\tmachep= -f_mant_dig-f_mant_dig;\n\n\ta=b;\n\n\twhile (Diff(Sum(ONE, a), ONE) == ZERO) { a*=base; machep++; }\n\n\tVprintf(\"%sSmallest x such that 1.0+base**x != 1.0 = %d%s\\n\",\n\n\t\tco, machep, oc);\n\n\n\n\tetop = ONE;\n\n\tebot = ZERO;\n\n\teps = Sum(ebot, Div(Diff(etop, ebot), TWO));\n\n\t/* find the smallest eps (1+eps != 1) by binary search.\n\n\t   ebot and etop are the current bounds */\n\n\twhile (eps != ebot && eps != etop) {\n\n\t\tepsp1 = Sum(ONE, eps);\n\n\t\tif (epsp1 > ONE) etop = eps;\n\n\t\telse ebot = eps;\n\n\t\teps = Sum(ebot, Div(Diff(etop, ebot), TWO));\n\n\t}\n\n\t/* Sanity check */\n\n\tif (Sum(ONE, etop) <= ONE || Sum(ONE, ebot) != ONE) {\n\n\t\teek_a_bug(\"internal error calculating eps\");\n\n\t}\n\n\tf_epsilon=etop;\n\n\n\n\tVprintf(\"%sSmallest x such that 1.0+x != 1.0 = %s%s\\n\",\n\n\t\tco, f_rep(digs, (Long_double) f_epsilon), oc);\n\n\n\n\tf_epsilon= Diff(Sum(ONE, f_epsilon), ONE); /* New C standard defn */\n\n\tVprintf(\"%s(Above number + 1.0) - 1.0 = %s%s\\n\",\n\n\t\tco, f_rep(digs, (Long_double) (f_epsilon)), oc);\n\n\n\n\t/* Possible loss of precision warnings here from non-stdc compilers */\n\n\tif (F) f_define(D_EPSILON, thing,\n\n\t\t\tFname, \"_EPSILON\", digs, (Long_double) f_epsilon, MARK);\n\n\tif (V || F) F_check(digs, (Long_double) f_epsilon);\n\n\tUnexpected(21);\n\n\tif (F) Verify(digs, f_epsilon, F_EPSILON,\n\n\t\t      f_epsilon == Self(F_EPSILON),\n\n\t\t      (Long_double) f_epsilon == (Long_double) F_EPSILON);\n\n\tUnexpected(22);\n\n\n\n\t/* Extra chop info *************************************************/\n\n\tif (f_rounds == 0) {\n\n\t\tif (Diff(Mul(Sum(ONE,f_epsilon),ONE),ONE) !=  ZERO) {\n\n\t\t\tVprintf(\"%sAlthough arithmetic chops, it uses guard digits%s\\n\", co, oc);\n\n\t\t}\n\n\t}\n\n\n\n\t/* Size of and minimum normalised exponent ************************/\n\n\ty=0; i=0; k=1; z=basein; z1=(1.0+f_epsilon)/base;\n\n\n\n\t/* Coarse search for the largest power of two */\n\n\tif (setjmp(lab)==0) { /* for underflow trap */ /* Yields i, k, y, y1 */\n\n\t\tdo {\n\n\t\t\ty=z; y1=z1;\n\n\t\t\tz=Mul(y,y); z1=Mul(z1, y);\n\n\t\t\ta=Mul(z,ONE);\n\n\t\t\tz2=Div(z1,y);\n\n\t\t\tif (z2 != y1) break;\n\n\t\t\tif ((Sum(a,a) == ZERO) || (fabs(z) >= y)) break;\n\n\t\t\ti++;\n\n\t\t\tk+=k;\n\n\t\t} while(1);\n\n\t} else {\n\n\t\tVprintf(\"%s%s underflow generates a trap%s\\n\", co, Thing, oc);\n\n\t}\n\n\tUnexpected(23);\n\n\n\n\tif (f_radix != 10) {\n\n\t\tiexp=i+1; /* for the sign */\n\n\t\tmx=k+k;\n\n\t} else {\n\n\t\tiexp=2;\n\n\t\tiz=f_radix;\n\n\t\twhile (k >= iz) { iz*=f_radix; iexp++; }\n\n\t\tmx=iz+iz-1;\n\n\t}\n\n\n\n\t/* Fine tune starting with y and y1 */\n\n\tif (setjmp(lab)==0) { /* for underflow trap */ /* Yields k, f_min */\n\n\t\tdo {\n\n\t\t\tf_min=y; z1=y1;\n\n\t\t\ty=Div(y,base); y1=Div(y1,base);\n\n\t\t\ta=Mul(y,ONE);\n\n\t\t\tz2=Mul(y1,base);\n\n\t\t\tif (z2 != z1) break;\n\n\t\t\tif ((Sum(a,a) == ZERO) || (fabs(y) >= f_min)) break;\n\n\t\t\tk++;\n\n\t\t} while (1);\n\n\t}\n\n\tUnexpected(24);\n\n\n\n\tf_min_exp=(-k)+1;\n\n\n\n\tif ((mx <= k+k-3) && (f_radix != 10)) { mx+=mx; iexp+=1; }\n\n\tVprintf(\"%sNumber of bits used for exponent = %d%s\\n\", co, iexp, oc);\n\n\tVprintf(\"%sMinimum normalised exponent = %d%s\\n\", co, f_min_exp-1, oc);\n\n\tif (F)\n\n\t  i_define(D_MIN_EXP, thing, Fname, \"_MIN_EXP\",\n\n\t\t   (long) f_min_exp, (long) maxint, (long) F_MIN_EXP, \"\");\n\n\n\n\tif (setjmp(lab)==0) {\n\n\t\tVprintf(\"%sMinimum normalised positive number = %s%s\\n\",\n\n\t\t\tco, f_rep(digs, (Long_double) f_min), oc);\n\n\t} else {\n\n\t\teek_a_bug(\"printf can't print the smallest normalised number\");\n\n\t\tprintf(\"\\n\");\n\n\t}\n\n\tUnexpected(25);\n\n\t/* Possible loss of precision warnings here from non-stdc compilers */\n\n\tif (setjmp(lab) == 0) {\n\n\t\tif (F) f_define(D_MIN, thing,\n\n\t\t\t\tFname, \"_MIN\", digs, (Long_double) f_min, MARK);\n\n\t\tif (V || F) F_check(digs, (Long_double) f_min);\n\n\t} else {\n\n\t\teek_a_bug(\"xxx_MIN caused a trap\");\n\n\t\tprintf(\"\\n\");\n\n\t}\n\n\n\n\tif (setjmp(lab) == 0) {\n\n\t\tif (F) Verify(digs, f_min, F_MIN,\n\n\t\t\t      f_min == Self(F_MIN),\n\n\t\t\t      (Long_double) f_min == (Long_double) F_MIN);\n\n\t} else {\n\n\t\tprintf(\"%s*** Verify failed for above #define!\\n    %s %s\\n\\n\",\n\n\t\t       co, \"Compiler has an unusable number for value\", oc);\n\n\t\tbugs++;\n\n\t}\n\n\tUnexpected(26);\n\n\n\n\ta=1.0; f_min_10_exp=0;\n\n\twhile (a > f_min*10.0) { a/=10.0; f_min_10_exp--; }\n\n\tif (F) i_define(D_MIN_10_EXP, thing, Fname, \"_MIN_10_EXP\",\n\n\t\t\t(long) f_min_10_exp, (long) maxint,\n\n\t\t\t(long) F_MIN_10_EXP, \"\");\n\n\n\n\t/* Minimum exponent ************************************************/\n\n\tif (setjmp(lab)==0) { /* for underflow trap */ /* Yields xminner */\n\n\t\tdo {\n\n\t\t\txminner=y;\n\n\t\t\ty=Div(y,base);\n\n\t\t\ta=Mul(y,ONE);\n\n\t\t\tif ((Sum(a,a) == ZERO) || (fabs(y) >= xminner)) break;\n\n\t\t} while (1);\n\n\t}\n\n\tUnexpected(27);\n\n\n\n\tif (xminner != 0.0 && xminner != f_min) {\n\n\t\tnormal= 0;\n\n\t\tVprintf(\"%sThe smallest numbers are not kept normalised%s\\n\",\n\n\t\t\tco, oc);\n\n\t\tif (setjmp(lab)==0) {\n\n\t\t    Vprintf(\"%sSmallest unnormalised positive number = %s%s\\n\",\n\n\t\t\t    co, f_rep(digs, (Long_double) xminner), oc);\n\n\t\t    if (V) F_check(digs, (Long_double) xminner);\n\n\t\t} else {\n\n\t\t\teek_a_bug(\"printf can't print the smallest unnormalised number.\");\n\n\t\t\tprintf(\"\\n\");\n\n\t\t}\n\n\t\tUnexpected(28);\n\n\t} else {\n\n\t\tnormal= 1;\n\n\t\tVprintf(\"%sThe smallest numbers are normalised%s\\n\", co, oc);\n\n\t}\n\n\n\n\t/* Maximum exponent ************************************************/\n\n\tf_max_exp=2; f_max=1.0; newxmax=base+1.0;\n\n\tinf=0; trap=0;\n\n\twhile (f_max<newxmax) {\n\n\t\tf_max=newxmax;\n\n\t\tif (setjmp(lab) == 0) { /* Yields inf, f_max_exp */\n\n\t\t\tnewxmax=Mul(newxmax, base);\n\n\t\t} else {\n\n\t\t\ttrap=1;\n\n\t\t\tbreak;\n\n\t\t}\n\n\t\tif (Div(newxmax, base) != f_max) {\n\n\t\t\tinf=1; /* ieee infinity */\n\n\t\t\tbreak;\n\n\t\t}\n\n\t\tf_max_exp++;\n\n\t}\n\n\tUnexpected(29);\n\n\tVprintf(\"%sMaximum exponent = %d%s\\n\", co, f_max_exp, oc);\n\n\tif (F) i_define(D_MAX_EXP, thing, Fname, \"_MAX_EXP\",\n\n\t\t\t(long) f_max_exp, 0L, (long) F_MAX_EXP, \"\");\n\n\n\n\t/* Largest number ***************************************************/\n\n\tf_max=Diff(ONE, epsneg);\n\n\tif (Mul(f_max,ONE) != f_max) f_max=Diff(ONE, Mul(base,epsneg));\n\n\tfor (i=1; i<=f_max_exp; i++) f_max=Mul(f_max, base);\n\n\n\n\tif (setjmp(lab)==0) {\n\n\t\tVprintf(\"%sMaximum number = %s%s\\n\",\n\n\t\t\tco, f_rep(digs, (Long_double) f_max), oc);\n\n\t} else {\n\n\t\teek_a_bug(\"printf can't print the largest double.\");\n\n\t\tprintf(\"\\n\");\n\n\t}\n\n\tif (setjmp(lab)==0) {\n\n\t/* Possible loss of precision warnings here from non-stdc compilers */\n\n\t\tif (F) f_define(D_MAX, thing,\n\n\t\t\t\tFname, \"_MAX\", digs, (Long_double) f_max, MARK);\n\n\t\tif (V || F) F_check(digs, (Long_double) f_max);\n\n\t} else {\n\n\t\teek_a_bug(\"xxx_MAX caused a trap\");\n\n\t\tprintf(\"\\n\");\n\n\t}\n\n\tif (setjmp(lab)==0) {\n\n\t\tif (F) Verify(digs, f_max, F_MAX,\n\n\t\t\t      f_max == Self(F_MAX),\n\n\t\t\t      (Long_double) f_max == (Long_double) F_MAX);\n\n\t} else {\n\n\t\tprintf(\"%s*** Verify failed for above #define!\\n    %s %s\\n\\n\",\n\n\t\t       co, \"Compiler has an unusable number for value\", oc);\n\n\t\tbugs++;\n\n\t}\n\n\tUnexpected(30);\n\n\n\n\ta=1.0; f_max_10_exp=0;\n\n\twhile (a < f_max/10.0) { a*=10.0; f_max_10_exp++; }\n\n\tif (F) i_define(D_MAX_10_EXP, thing, Fname, \"_MAX_10_EXP\",\n\n\t\t\t(long) f_max_10_exp, 0L, (long) F_MAX_10_EXP, \"\");\n\n\n\n\t/* Traps and infinities ********************************************/\n\n\tif (trap) {\n\n\t\tVprintf(\"%sOverflow generates a trap%s\\n\", co, oc);\n\n\t} else {\n\n\t\tVprintf(\"%sOverflow doesn't seem to generate a trap%s\\n\",\n\n\t\t\tco, oc);\n\n\t}\n\n\n\n\tif (inf) { Vprintf(\"%sThere is an 'infinite' value%s\\n\", co, oc); }\n\n\n\n#ifdef SIGFPE\n\n\tsignal(SIGFPE, trap1);\n\n#endif\n\n\tif (setjmp(lab) == 0) {\n\n\t\ttrapped= 0; /* A global variable */\n\n\t\tb= 0.0;\n\n\t\ta= (1.0/b)/b;\n\n\t\tif (!trapped) {\n\n\t\t\tVprintf(\"%sDivide by zero doesn't generate a trap%s\\n\",\n\n\t\t\t\tco, oc);\n\n\t\t} else {\n\n\t\t\tVprintf(\"%sDivide by zero generates a trap%s\\n\",\n\n\t\t\t\tco, oc);\n\n\t\t\tVprintf(\"%sFP signal handlers return safely%s\\n\",\n\n\t\t\t\tco, oc);\n\n\t\t}\n\n\t} else {\n\n\t\tVprintf(\"%sDivide by zero generates a trap%s\\n\", co, oc);\n\n\t\tVprintf(\"%sBEWARE! FP signal handlers can NOT return%s\\n\",\n\n\t\t\tco, oc);\n\n\t}\n\n\tsetsignals();\n\n\tUnexpected(31);\n\n\n\n\t/* Hidden bit + sanity check ****************************************/\n\n\tif (f_radix != 10) {\n\n\t\thidden=0;\n\n\t\tmantbits=floor_log(2, (Long_double)f_radix)*f_mant_dig;\n\n\t\tif (mantbits+iexp == (int)sizeof(Number)*byte_size) {\n\n\t\t\thidden=1;\n\n\t\t\tVprintf(\"%sArithmetic uses a hidden bit%s\\n\", co, oc);\n\n\t\t} else if (mantbits+iexp+1 == (int)sizeof(Number)*byte_size) {\n\n\t\t\tVprintf(\"%sArithmetic doesn't use a hidden bit%s\\n\",\n\n\t\t\t\tco, oc);\n\n\t\t} else {\n\n\t\t\tprintf(\"\\n%s%s\\n    %s %s %s!%s\\n\\n\",\n\n\t\t\t       co,\n\n\t\t\t       \"*** Something fishy here!\",\n\n\t\t\t       \"Exponent size + significand size doesn't match\",\n\n\t\t\t       \"with the size of a\", thing,\n\n\t\t\t       oc);\n\n\t\t}\n\n\t\tif (hidden && f_radix == 2 && f_max_exp+f_min_exp==3) {\n\n\t\t\tVprintf(\"%sIt looks like %s length IEEE format%s\\n\",\n\n\t\t\t\tco, f_mant_dig==24 ? \"single\" :\n\n\t\t\t\t    f_mant_dig==53 ? \"double\" :\n\n\t\t\t\t    f_mant_dig >53 ? \"extended\" :\n\n\t\t\t\t\t\t\"some\", oc);\n\n\t\t\tif (f_rounds != 1 || normal) {\n\n\t\t\t\tVprintf(\"%s   though \", co);\n\n\t\t\t\tif (f_rounds != 1) {\n\n\t\t\t\t\tVprintf(\"the rounding is unusual\");\n\n\t\t\t\t\tif (normal) { Vprintf(\" and \"); }\n\n\t\t\t\t}\n\n\t\t\t\tif (normal) {\n\n\t\t\t\t    Vprintf(\"the normalisation is unusual\");\n\n\t\t\t\t}\n\n\t\t\t\tVprintf(\"%s\\n\", oc);\n\n\t\t\t}\n\n\t\t} else {\n\n\t\t\tVprintf(\"%sIt doesn't look like IEEE format%s\\n\",\n\n\t\t\t\tco, oc);\n\n\t\t}\n\n\t}\n\n\tprintf(\"\\n\"); /* regardless of verbosity */\n\n\treturn f_mant_dig;\n\n}\n\n\n\nVoid EPROP(fprec, dprec, lprec) int fprec, dprec, lprec; {\n\n\t/* See if expressions are evaluated in extended precision.\n\n\t   Some compilers optimise even if you don't want it,\n\n\t   and then this function fails to produce the right result.\n\n\t   We try to diagnose this if it happens.\n\n\t*/\n\n\tVolatile int eprec;\n\n\tVolatile double a, b, base, old;\n\n\tVolatile Number d, oldd, dbase, one, zero;\n\n\tVolatile int bad=0;\n\n\n\n\t/* Size of significand **************************************/\n\n\ta=1.0;\n\n\tif (setjmp(lab) == 0) { /* Yields nothing */\n\n\t\tdo { old=a; a=a+a; }\n\n\t\twhile ((((a+1.0)-a)-1.0) == 0.0 && a>old);\n\n\t} else bad=1;\n\n\tif (!bad && a <= old) bad=1;\n\n\n\n\tif (!bad) {\n\n\t\tb=1.0;\n\n\t\tif (setjmp(lab) == 0) { /* Yields nothing */\n\n\t\t\tdo { old=b; b=b+b; }\n\n\t\t\twhile ((base=((a+b)-a)) == 0.0 && b>old);\n\n\t\t\tif (b <= old) bad=1;\n\n\t\t} else bad=1;\n\n\t}\n\n\n\n\tif (!bad) {\n\n\t\teprec=0; d=1.0; dbase=base; one=1.0; zero=0.0;\n\n\t\tif (setjmp(lab) == 0) { /* Yields nothing */\n\n\t\t\tdo { eprec++; oldd=d; d=d*dbase; }\n\n\t\t\twhile ((((d+one)-d)-one) == zero && d>oldd);\n\n\t\t\tif (d <= oldd) bad=1;\n\n\t\t} else bad=1;\n\n\t}\n\n\n\n\tUnexpected(32);\n\n\n\n\tif (bad) {\n\n\t  Vprintf(\"%sCan't determine precision for %s expressions:\\n%s%s\\n\",\n\n\t\t co, thing, \"   check that you compiled without optimisation!\",\n\n\t\t oc);\n\n\t} else if (eprec==dprec) {\n\n\t  Vprintf(\"%s%s expressions are evaluated in double precision%s\\n\",\n\n\t\t  co, Thing, oc);\n\n\t} else if (eprec==fprec) {\n\n\t  Vprintf(\"%s%s expressions are evaluated in float precision%s\\n\",\n\n\t\t  co, Thing, oc);\n\n\t} else if (eprec==lprec) {\n\n\t  Vprintf(\"%s%s expressions are evaluated in long double precision%s\\n\",\n\n\t\t  co, Thing, oc);\n\n\t} else {\n\n\t\tVprintf(\"%s%s expressions are evaluated in a %s %s %d %s%s\\n\",\n\n\t\t\tco, Thing, eprec>dprec ? \"higher\" : \"lower\",\n\n\t\t\t\"precision than double,\\n   using\",\n\n\t\t\teprec, \"base digits\",\n\n\t\t\toc);\n\n\t}\n\n}\n\n\n\n#else /* not Number */\n\n\n\n#ifdef FPROP /* Then create dummy routines for long double */\n\n/* ARGSUSED */\n\nint FPROP(byte_size) int byte_size; { return 0; }\n\n#endif\n\n#ifdef EPROP\n\n/* ARGSUSED */\n\nVoid EPROP(fprec, dprec, lprec) int fprec, dprec, lprec; {}\n\n#endif\n\n\n\n#endif /* ifdef Number */\n\n\n\n/* Increment the pass number */\n\n#undef PASS\n\n\n\n#ifdef PASS2\n\n#undef PASS2\n\n#define PASS 3\n\n#define PASS3 1\n\n#endif\n\n\n\n#ifdef PASS1\n\n#undef PASS1\n\n#define PASS 2\n\n#define PASS2 1\n\n#endif\n\n\n\n#ifdef PASS0\n\n#undef PASS0\n\n#endif\n\n\n\n#ifndef SEP\n\n#ifdef PASS /* then rescan this file */\n\n#ifdef BAD_CPP\n\n#include \"enquire.c\"\n\n#else\n\n#include FILENAME  /* if this line fails to compile, define BAD_CPP */\n\n#endif\n\n#endif /* PASS */\n\n#endif /* SEP */\n", "#include <stdio.h>\n\n#include <errno.h>\n\n#include <string.h>\n\n#include <stdlib.h>\n\n#include <unistd.h>\n\n\n\n#include \"get_line.h\"\n\n\n\nstatic void remove_file(char *name) {\n\n  if (unlink(name) == 0) {\n\n    printf (\">%s< deleted.\\n\", name);\n\n  } else {\n\n    printf (\"Error deleting >%s<. Errno --> %d : %s\\n\", name, errno, strerror(errno));\n\n  }\n\n}\n\n\n\nint main (int argc, char *argv[]) {\n\n\n\nint i;\n\nchar input[500];\n\n\n\n  if (argc == 1) {\n\n\n\n    system (\"ls\");\n\n    for (;;) {\n\n      printf (\"File name : \");\n\n      i = get_line ( (FILE*)NULL, input, sizeof(input));\n\n      if (i < 1) {\n\n        break;\n\n      }\n\n      remove_file(input);\n\n    }\n\n      \n\n  } else {\n\n\n\n    for (i = 1; i < argc; i++) {\n\n      for (;;) {\n\n        printf (\"OK to remove file >%s< ? (Y/N/Q) \", argv[i]);\n\n        (void) get_line ((FILE*)NULL, input, sizeof(input));\n\n        if ( (strcmp(input, \"y\") == 0) || (strcmp(input, \"Y\") == 0) ) {\n\n          remove_file(argv[i]);\n\n          break;\n\n        } else if ( (strcmp(input, \"n\") == 0) || (strcmp(input, \"N\") == 0) ) {\n\n          break;\n\n        } else if ( (strcmp(input, \"q\") == 0) || (strcmp(input, \"Q\") == 0) ) {\n\n          printf (\"Aborted.\\n\");\n\n          exit(0);\n\n        }\n\n      } /* for (;;) */\n\n      printf (\"\\n\");\n\n    } /* for each arg */\n\n\n\n  }\n\n  printf (\"Done.\\n\");\n\n  exit(0);\n\n}\n", "/* Check if target file: $n is up to date comparing to source files:       */\n\n/*  $1, $2 .. $n-1. This is: target file exists and is newer that sources. */\n\n/* exit 0  -->  $n file is ok (newer than all sources)                     */\n\n/* exit 1  -->  $n file is older than some sources or does not exist       */\n\n/* exit 2  -->  Error: cannot read some source files                       */\n\n/* exit 3  -->  Argument or internal error                                 */\n\n\n\n#include <unistd.h>\n\n#include <stdlib.h>\n\n#include <stdio.h>\n\n#include <errno.h>\n\n#include <string.h>\n\n#include <strings.h>\n\n#include <sys/types.h>\n\n#include <sys/stat.h>\n\n\n\n#define EXIT_OK             0\n\n#define EXIT_NOK            1\n\n#define EXIT_SRC_NOT_FOUND  2\n\n#define EXIT_INTERNAL_ERROR 3\n\n\n\n\n\n\n\nstatic char *prog_name (char *prog_path) {\n\n  char *p = strrchr(prog_path, '/');\n\n  if (p == NULL) p = prog_path;\n\n  else p++;\n\n  return (p);\n\n}\n\n\n\n \n\nint main (int argc, char *argv[]) {\n\n\n\n    struct stat bs, br;\n\n    int result;\n\n    int i;\n\n    \n\n\n\n    /* Check arguments */\n\n    if (argc < 3)  {\n\n        fprintf (stderr, \"SYNTAX ERROR. Usage : %s { <source_file> } <result_file>\\n\",\n\n                         prog_name(argv[0]));\n\n        exit (EXIT_INTERNAL_ERROR);\n\n    }\n\n\n\n    /* Check that target file exists and get its modif date */\n\n    result = EXIT_OK;\n\n    if (stat (argv[argc-1], &br) != 0) {\n\n        if (errno == ENOENT) {\n\n            /* Result file not found */\n\n            result = EXIT_NOK;\n\n        } else {\n\n            perror (\"stat\");\n\n            fprintf (stderr, \"Cannot read status of target file %s\\n\", argv[argc-1]);\n\n            exit (EXIT_INTERNAL_ERROR);\n\n        }\n\n    }\n\n\n\n\n\n    /* Check that each source exists and is before result */\n\n    for (i = 1; i <= argc-2; i++) {\n\n        if (strcmp(argv[i], argv[argc-1]) == 0) {\n\n          fprintf (stderr, \"SEMANTIC ERROR: Source file %s is also the result file.\\n\",\n\n                           argv[i]);\n\n          fprintf (stderr, \" Usage : %s { <source_file> } <result_file>\\n\",\n\n                           prog_name(argv[0]));\n\n        }\n\n        if (stat (argv[i], &bs) != 0) {\n\n            perror (\"stat\");\n\n            fprintf (stderr, \"Cannot read status of source file %s\\n\", argv[i]);\n\n            result = EXIT_SRC_NOT_FOUND;\n\n        } else {\n\n            /* time_t (buffer.st_mtime) of last modif is int */\n\n            if ( (result == EXIT_OK) && (br.st_mtime <= bs.st_mtime) ) {\n\n                /* Source files exist so far and this one is after result */\n\n                result = EXIT_NOK;\n\n            }\n\n        }\n\n    }\n\n\n\n    /* Done */\n\n    exit (result);\n\n}\n\n\n", "#define _XOPEN_SOURCE\n\n#include <unistd.h>\n\n#undef _XOPEN_SOURCE\n\n#include <stdlib.h>\n\n#include <stdio.h>\n\n#include <string.h>\n\n#include <libgen.h>\n\n#include <crypt.h>\n\n\n\n\n\n#define Usage() fprintf(stderr, \"Usage: %s <2_digits_key> <password>\\n\", \\\n\n                 basename(argv[0]))\n\n\n\nint main (int argc, char *argv[]) {\n\n\n\n  if (argc != 3) {\n\n    Usage();\n\n    exit(1);\n\n  }\n\n\n\n  if (strlen(argv[1]) != 2) {\n\n    Usage();\n\n    exit(1);\n\n  }\n\n\n\n  printf (\"Salt: %s and Key: %s -> %s\\n\",\n\n          argv[1], argv[2],\n\n          crypt (argv[2], argv[1]));\n\n\n\n  exit(0);\n\n}\n\n\n\n\n", "void init_udp (char *port_name_no);\n\n\n\nvoid send_udp (char *msg, int len);\n", "void init_tty (char *tty_no, int read);\n\n\n\nvoid send_tty (char *msg, int len);\n\n\n\nvoid read_tty (void *buffer, int nbre_octet);\n", "#include <ctype.h>\n\n#include <stdlib.h>\n\n\n\n#include \"socket.h\"\n\n#include \"udp.h\"\n\n\n\nstatic soc_token soc = NULL;\n\n\n\nvoid init_udp (char *port_name_no) {\n\n\n\n  int port_no;\n\n  int cr;\n\n  char lan_name[80];\n\n\n\n  if (soc_get_local_lan_name(lan_name, sizeof(lan_name)) != SOC_OK) {\n\n    perror(\"getting lan name\");\n\n    exit (2);\n\n  }\n\n\n\n  soc = init_soc;\n\n\n\n\n\n  if (soc_open(&soc, udp_socket) != SOC_OK) {\n\n    perror (\"opening socket\");\n\n    exit (2);\n\n  }\n\n\n\n  if (isdigit(port_name_no[0])) {\n\n    port_no = 0;\n\n    port_no = atoi(port_name_no);\n\n    if (port_no == 0) {\n\n      fprintf (stderr, \"Wrong port number >%s<\\n\", port_name_no);\n\n      exit (2);\n\n    } else {\n\n      cr = soc_set_dest_name_port (soc, lan_name, true, (soc_port) port_no);\n\n    }\n\n  } else {\n\n    cr = soc_set_dest_name_service  (soc, lan_name, true, port_name_no);\n\n  }\n\n\n\n  if (cr != SOC_OK) {\n\n    perror (\"setting detination\");\n\n    exit (2);\n\n  }\n\n\n\n  if (soc_get_dest_port(soc, (soc_port*) &port_no) != SOC_OK) {\n\n    perror (\"getting port no\");\n\n    exit (2);\n\n  }\n\n\n\n  printf (\"UDP port no %d initialised.\\n\", port_no);\n\n\n\n}\n\n\n\nvoid send_udp (char *msg, int len) {\n\n\n\n  if (soc_send (soc, (soc_message) msg, (soc_length) len) != SOC_OK)\n\n    perror (\"sending\");\n\n}\n\n\n", "/****************************************************************/\n\n/*                                                              */\n\n/* Syntax : gorgy <period_sec> <channel>                        */\n\n/* <channel>     ::= <udp_port> | <tty>                         */\n\n/* <udp_port>    ::= -u <udp_port_id>                           */\n\n/* <udp_port_id> ::= <port_name> | <port_number>                */\n\n/* <tty>         ::= -s <tty_conf>                              */\n\n/*                                                              */\n\n/* On udp, gorgy is broadcasting the frame on current lan       */\n\n/*  (implied by current host name) for the port specified as    */\n\n/*  argument.                                                   */\n\n/*                                                              */\n\n/* On tty, tty_conf is <tty_no>:<stopb>:<datab>:<parity>:<bauds>*/\n\n/*  gorgy is sending the frame on the tty named                 */\n\n/*  \"/dev/tty<tty_no>\" configuring it as follows:               */\n\n/* - input : no setting                                         */\n\n/* - output : ~OPOST (no post processing)                       */\n\n/* - config : IXANY (Xon on any character)                      */\n\n/*            ~(ECHO | ISIG | ICANON | XCASE)                   */\n\n/*              no echo, no special, no canon                   */\n\n/*            VMIN=1, VTIME=0 (emmit imediatly each character)  */\n\n/* <stopb> can be 1 or 2                                        */\n\n/* <datab> can be 7 or 8                                        */\n\n/* <parity> can be ODD, EVEN or OFF                             */\n\n/* <bauds> can be 300, 600, 1200, 1800, 2400, 4800 or 9600      */\n\n/*                                                              */\n\n/* Different frames can be generated depending on compiling     */\n\n/*  defines.                                                    */\n\n/* STANDARD:                                                    */\n\n/* ---------                                                    */\n\n/* The standard frame has the following format (24 characters)  */\n\n/* <STX>NNN DD/MM/YY  hh:mm:ss<CR>                              */\n\n/* where <STX>    is ASCII 2                                    */\n\n/*       NNN      is the day name in 3 uppercase letters        */\n\n/*                (DIM, LUN, MAR, MER, JEU, VEN, SAM)           */\n\n/*       one space                                              */\n\n/*       JJ/MM/YY is the date at format day/month/year, each on */\n\n/*                  2 digits (0 inserted if necessary)          */\n\n/*       two spaces                                             */\n\n/*       hh/mm/ss is the time at format hour/minute/second, each*/\n\n/*                  on 2 digits (0 inserted if necessary)       */\n\n/*       <CR>     is ASCII 13                                   */\n\n/* PALLAS:                                                      */\n\n/*--------                                                      */\n\n/* The Pallas frame  has the following format (25 characters)   */\n\n/* 'T':YY:MM:DD:NNN:hh:mm:ss<CR><LF>                            */\n\n/* where <LF>     is ASCII 10                                   */\n\n/* PALLAS:                                                      */\n\n/*--------                                                      */\n\n/* The Taaats frame  has the following format (25 characters)   */\n\n/* <STX>NNN DD/MM/YY  hh:mm:ssP<CR>                             */\n\n/* where P        is the precision                              */\n\n/*                  '?' 0.5s < error       or incorrect time    */\n\n/*                  '#' 0.1s < error <= 0.5s                    */\n\n/*                  '*' 10ms < error <= 0.1s                    */\n\n/*                  '.'  1ms < error <= 10ms                    */\n\n/*                  ' '        error <= 1ms                     */\n\n/* DACOTA:                                                      */\n\n/* -------                                                      */\n\n/* The Dacota frame  has the following format (15 characters)   */\n\n/* <SOH>YYMMDDhhmmss<EOT>C                                      */\n\n/* where <SOH>    is ASCII 1                                    */\n\n/*       <EOT>    is ASCII 4                                    */\n\n/*       C        is a checksum, xor of bytes from 2nd byte     */\n\n/*                  to <EOT> included                           */\n\n/*                                                              */\n\n/* The frame is sent each <period_sec> second.                  */\n\n/*                                                              */\n\n/****************************************************************/\n\n\n\n\n\n#include <errno.h>\n\n#include <unistd.h>\n\n#include <string.h>\n\n#include <stdio.h>\n\n#include <stdlib.h>\n\n#include <time.h>\n\n#include <sys/types.h>\n\n\n\n#include \"timeval.h\"\n\n\n\n#include \"tty.h\"\n\n#include \"udp.h\"\n\n#include \"sig_util.h\"\n\n\n\n#define USAGE() {printf (\"Usage : gorgy <period_sec> -s <tty_conf>\\n\"); \\\n\n                 printf (\"or      gorgy <period_sec> -u <udp_port>\\n\"); }\n\n\n\n#define NUL (char) 0x00\n\n#define SOH (char) 0x01\n\n#define STX (char) 0x02\n\n#define EOT (char) 0x04\n\n#define LF  (char) 0x0a\n\n#define CR  (char) 0x0d\n\n\n\n#ifdef TAAATS\n\nstatic char precision;\n\nstatic void sig_handler (int signum) {\n\n  if (signum == 27) {\n\n      precision = ' ';\n\n  } else if (signum == 28) {\n\n      precision = '.';\n\n  } else if (signum == 29) {\n\n      precision = '*';\n\n  } else if (signum == 30) {\n\n      precision = '#';\n\n  } else if (signum == 31) {\n\n      precision = '?';\n\n  }\n\n  printf (\"New precision -> '%c'\\n\", precision);\n\n}\n\n#endif\n\n\n\n\n\n#define MAX_MSG_LEN 132\n\nstatic char msg[MAX_MSG_LEN];\n\nstatic int msg_len = 0;\n\n\n\n\n\n\n\nstatic char week_day[7][4] = {\"DIM\", \"LUN\", \"MAR\", \"MER\", \"JEU\", \"VEN\", \"SAM\"};\n\n\n\nstatic void format_time (timeout_t *p_time) {\n\n  char *date_str;\n\n  struct tm *date_struct;\n\n\n\n  char yyyy[5], mm[3], dd[3], nnn[4], hh[3], mn[2], ss[2];\n\n  char *yy = &yyyy[2];\n\n\n\n  date_str = ctime (&(p_time->tv_sec));\n\n  date_struct = gmtime (&(p_time->tv_sec));\n\n\n\n  strncpy (yyyy, &date_str[20], 4);\n\n  yyyy[4] = NUL;\n\n  sprintf (mm, \"%02d\", date_struct->tm_mon+1);\n\n  mm[2] = NUL;\n\n  sprintf (dd, \"%02d\", date_struct->tm_mday);\n\n  dd[2] = NUL;\n\n  strncpy (nnn, week_day[date_struct->tm_wday], 3);\n\n  nnn[3] = NUL;\n\n  strncpy (hh, &date_str[11], 2);\n\n  hh[2] = NUL;\n\n  strncpy (mn, &date_str[14], 2);\n\n  mn[2] = NUL;\n\n  strncpy (ss, &date_str[17], 2);\n\n  ss[2] = NUL;\n\n\n\n#if defined(STANDARD)\n\n  sprintf (msg, \"%1c%3s %2s/%2s/%2s  %2s:%2s:%2s%1c\", STX, nnn, dd, mm, yy, hh, mn, ss, CR);\n\n  msg_len = 24;\n\n#elif defined(PALLAS)\n\n  sprintf (msg, \"%1c:%2s:%2s:%2s:%3s:%2s:%2s:%2s%1c%1c\", 'T', yy, mm, dd, nnn, hh, mn, ss, CR, LF);\n\n  msg_len = 25;\n\n#elif defined(TAAATS)\n\n  sprintf (msg, \"%1c%3s %2s/%2s/%2s  %2s:%2s:%2s%1c%1c\", STX, nnn, dd, mm, yy, hh, mn, ss, precision, CR);\n\n  msg_len = 25;\n\n#elif defined(DACOTA)\n\n  sprintf (msg, \"%1c%2s%2s%2s%2s%2s%2s%1c%1c\", SOH, yy, mm, dd, hh, mn, ss, EOT, NUL);\n\n  msg_len = 15;\n\n  /* Compute LRC value (xor from 2nd byte to EOT included) */\n\n  {\n\n    int i;\n\n    unsigned char lrc;\n\n\n\n    lrc = 0;\n\n    for (i = 1; i <= 13; i++) {\n\n      lrc ^= (unsigned char) msg[i];\n\n    }\n\n    msg[14] = lrc;\n\n  }\n\n#else\n\ndefine expected: STANDARD PALLAS DACOTA TAAATS\n\n#endif\n\n}\n\n\n\nint main (int argc, char *argv[]) {\n\n\n\n  int period_sec;\n\n  int cr;\n\n  timeout_t cur_time, exp_time, delta_time;\n\n#ifdef TAAATS\n\n  int pid = getpid();\n\n#endif\n\n\n\n  typedef enum {serial, udp} channel_list;\n\n  channel_list channel;\n\n\n\n\n\n  if ( (argc != 4)\n\n    || ( (strcmp(argv[2], \"-u\") != 0) && (strcmp(argv[2], \"-s\") != 0) ) ) {\n\n    USAGE();\n\n    exit(1);\n\n  }\n\n\n\n  period_sec = 0;\n\n  period_sec = atoi (argv[1]);\n\n  if ( (period_sec <= 0) || (period_sec >= 3600) ) {\n\n    USAGE();\n\n    exit(1);\n\n  }\n\n\n\n  printf (\"Period is %d s.\\n\", (int) period_sec);\n\n\n\n  if (strcmp(argv[2], \"-u\") == 0) {\n\n    channel = udp;\n\n    init_udp(argv[3]);\n\n  } else {\n\n    channel = serial;\n\n    init_tty(argv[3], 0);\n\n  }\n\n\n\n#ifdef TAAATS\n\n  (void) set_handler (27, sig_handler, NULL);\n\n  (void) set_handler (28, sig_handler, NULL);\n\n  (void) set_handler (29, sig_handler, NULL);\n\n  (void) set_handler (30, sig_handler, NULL);\n\n  printf (\"kill -28  %5d  -> '.'\\n\", pid);\n\n  printf (\"kill -29  %5d  -> '*'\\n\", pid);\n\n  printf (\"kill -30  %5d  -> '#'\\n\", pid);\n\n  printf (\"kill -31  %5d  -> '?'\\n\", pid);\n\n  precision = '*';\n\n  printf (\"Precision -> '%c'\\n\", precision);\n\n#endif\n\n\n\n  get_time (&cur_time);\n\n\n\n  exp_time.tv_sec = cur_time.tv_sec + 1;\n\n  exp_time. tv_usec = 0;\n\n\n\n\n\n  for (;;) {\n\n    format_time (&exp_time);\n\n\n\n    delta_time.tv_sec = exp_time.tv_sec;\n\n    delta_time.tv_usec = exp_time.tv_usec;\n\n    get_time (&cur_time);\n\n    if (sub_time (&delta_time, &cur_time) > 0) {\n\n      cr = select (0, NULL, NULL, NULL, &delta_time);\n\n    } else {\n\n      cr = 0;\n\n    }\n\n    if (cr == 0) {\n\n      if (channel == udp) {\n\n        send_udp((char*)msg, msg_len);\n\n      } else {\n\n        send_tty ((char*)msg, msg_len);\n\n      }\n\n      exp_time.tv_sec = exp_time.tv_sec + period_sec;\n\n      /* printf (\"Sent.\\n\"); */\n\n    } else if (errno != EINTR) {\n\n      perror (\"select\");\n\n      exp_time.tv_sec = exp_time.tv_sec + period_sec;\n\n    }\n\n  }\n\n}\n\n\n", "#include <stdio.h>\n\n#include <stdlib.h>\n\n#include <fcntl.h>\n\n#include <errno.h>\n\n#include <unistd.h>\n\n#include <string.h>\n\n#include <sys/types.h>\n\n#include <sys/ioctl.h>\n\n#include <sys/termios.h>\n\n\n\n#include \"tty.h\"\n\n#define TTY_DEV \"/dev/tty\"\n\n\n\n#define EXIT { \\\n\n  printf (\"TTY specification ERROR\\n\"); \\\n\n  printf (\"<tty_no>:<stopb>:<datab>:<parity>:<bauds>\\n\"); \\\n\n  printf (\" example : 00:1:7:EVEN:9600\\n\"); \\\n\n  exit (1); \\\n\n}\n\n\n\nint fd;\n\nstatic char tty_spec[50];\n\nstatic int start;\n\nstatic int last;\n\n\n\nstatic void parse (char *arg) {\n\n\n\n  int i;\n\n\n\n  last = (int)strlen(arg);\n\n  if (last > (int)sizeof(tty_spec)-1) {\n\n    EXIT;\n\n  }\n\n  strcpy (tty_spec, arg);\n\n  for (i = 0; i < last; i++) {\n\n    if (tty_spec[i] == ':') {\n\n      tty_spec[i] = '\\0';\n\n    }\n\n  }\n\n  start = 0;\n\n}\n\n\n\nstatic void next (void) {\n\n  do {\n\n    start++;\n\n  } while (tty_spec[start]!='\\0' );\n\n\n\n  if (start == last) {\n\n    start = -1;\n\n  } else {\n\n    start ++;\n\n  }\n\n\n\n}\n\n\n\n\n\n\n\nvoid init_tty (char *arg, int read) {\n\n\n\n  char tty_name[50];\n\n  struct termio mode;\n\n\n\n  unsigned short c_flags;\n\n\n\n  parse (arg);\n\n\n\n  strcpy (tty_name, TTY_DEV);\n\n  strcat (tty_name, &tty_spec[start]);\n\n\n\n  next (); if (start == -1) EXIT;\n\n  if      (strcmp(&tty_spec[start], \"1\") == 0) c_flags = 0;\n\n  else if (strcmp(&tty_spec[start], \"2\") == 0) c_flags = CSTOPB;\n\n  else    EXIT;\n\n\n\n\n\n  next (); if (start == -1) EXIT;\n\n  if      (strcmp(&tty_spec[start], \"7\") == 0) c_flags |= CS7;\n\n  else if (strcmp(&tty_spec[start], \"8\") == 0) c_flags |= CS8;\n\n  else    EXIT;\n\n\n\n  next (); if (start == -1) EXIT;\n\n  if      (strcmp(&tty_spec[start], \"NONE\") == 0) ;\n\n  else if (strcmp(&tty_spec[start],  \"ODD\") == 0) c_flags |= (PARENB | PARODD);\n\n  else if (strcmp(&tty_spec[start], \"EVEN\") == 0) c_flags |= PARENB;\n\n  else    EXIT;\n\n\n\n  next (); if (start == -1) EXIT;\n\n  if      (strcmp(&tty_spec[start],   \"300\") == 0) c_flags |= B300;\n\n  else if (strcmp(&tty_spec[start],   \"600\") == 0) c_flags |= B600;\n\n  else if (strcmp(&tty_spec[start],  \"1200\") == 0) c_flags |= B1200;\n\n  else if (strcmp(&tty_spec[start],  \"1800\") == 0) c_flags |= B1800;\n\n  else if (strcmp(&tty_spec[start],  \"2400\") == 0) c_flags |= B2400;\n\n  else if (strcmp(&tty_spec[start],  \"4800\") == 0) c_flags |= B4800;\n\n  else if (strcmp(&tty_spec[start],  \"9600\") == 0) c_flags |= B9600;\n\n  else if (strcmp(&tty_spec[start], \"19200\") == 0) c_flags |= B19200;\n\n  else if (strcmp(&tty_spec[start], \"38400\") == 0) c_flags |= B38400;\n\n\n\n  next (); if (start != -1) EXIT;\n\n\n\n  if (read) {\n\n    fd = open (tty_name, O_RDONLY);\n\n  } else {\n\n    fd = open (tty_name, O_WRONLY);\n\n  }\n\n  if (fd < 0) {\n\n    perror (\"Error open\");\n\n    fprintf (stderr, \">%s<\\n\", tty_name);\n\n    exit(-1);\n\n  }\n\n\n\n  if (ioctl (fd, TCGETA, (char*) &mode) <0) {\n\n    perror (\"Error ioctl get\");\n\n    exit (-1);\n\n  }\n\n  mode.c_iflag = 0;\n\n  mode.c_oflag = 0;\n\n  mode.c_lflag = 0;\n\n  mode.c_cflag = (CLOCAL | HUPCL | c_flags);\n\n  if (read) {\n\n    mode.c_cflag = (mode.c_cflag | CREAD);\n\n  }\n\n  mode.c_cc[VMIN] = 1;\n\n  mode.c_cc[VTIME] = 0;\n\n\n\n  if (ioctl (fd, TCSETA, (char*) &mode) <0) {\n\n    perror (\"Error ioctl set\");\n\n    exit (-1);\n\n  }\n\n\n\n  printf (\"TTY %s initialised.\\n\", tty_name);\n\n\n\n}\n\n\n\n\n\nvoid send_tty (char *msg, int len) {\n\n\n\nint cr;\n\n\n\n  for (;;) {\n\n    cr = (write (fd, msg, len) >= 0);\n\n    if (cr) return;\n\n    if (errno != EINTR) {\n\n      perror (\"write\");\n\n      return;\n\n    }\n\n  }\n\n}\n\n\n\nvoid read_tty (void *buffer, int nbre_octet) {\n\nint i;\n\nchar *p;\n\nint res;\n\n\n\n  for (i=0, p=(char*)buffer; i<nbre_octet; i++, p++) {\n\n    do {\n\n      res = read (fd, p, 1);\n\n      if ( (res == -1)  && (errno != EINTR) )  {\n\n        perror (\"read\");\n\n      }\n\n    } while (res != 1);\n\n  }\n\n}\n", "#include <stdio.h>\n\n#include <stdlib.h>\n\n\n\n#include \"tty.h\"\n\n\n\n#define BUFFER_SIZE 1000\n\n\n\n\n\n\n\nextern int fd;\n\nstatic  unsigned char buffer[BUFFER_SIZE];\n\nstatic  unsigned int index;\n\n\n\nstatic void store (unsigned char oct) {\n\n  if (index == BUFFER_SIZE - 1) {\n\n    index = 0;\n\n  }\n\n  buffer[index] = oct;\n\n  index ++;\n\n}\n\n\n\nstatic void print (char oct) {\n\n    if (oct < 32) printf (\"'%02X' \", (int)oct);\n\n    else printf (\"%c \", oct);\n\n}\n\n\n\nstatic void flush (void) {\n\n  unsigned int i;\n\n\n\n  for (i = 0; i < index; i++) {\n\n    print (buffer[i]);\n\n  }\n\n  printf (\"\\n\");\n\n  fflush(stdout);\n\n  index = 0;\n\n}\n\n\n\n\n\nint main(int argc, char *argv[]) {\n\n  unsigned char oct;\n\n#if defined(DACOTA)\n\n  unsigned char prev_oct, prev_prev_oct;\n\n#endif\n\n\n\n  int started;\n\n\n\n  if ( argc != 2) {\n\n    printf (\"SYNTAX ERROR. Usage : serial_spy <tty_no>:<stopb>:<datab>:<parity>:<bauds>\\n\");\n\n    exit (1);\n\n  }\n\n\n\n  init_tty(argv[1], 1);\n\n\n\n  started = 0;\n\n#if defined(DACOTA)\n\n  prev_oct = '0';\n\n  prev_prev_oct = '0';\n\n#endif\n\n  index = 0;\n\n\n\n  for(;;) {\n\n    read_tty (&oct, 1);\n\n#if defined(STANDARD) || defined(TAAATS)\n\n    if (oct == 0x02) started = 1;\n\n    if (started) {\n\n      store (oct);\n\n      if (oct == 0x0d) flush();\n\n    }\n\n#elif defined(PALLAS)\n\n    if (oct == 'T') started = 1;\n\n    if (started) {\n\n      store (oct);\n\n      if (oct == 0x0a) flush ();\n\n    }\n\n#elif defined(DACOTA)\n\n    if (oct == 0x01) started = 1;\n\n    if (started) {\n\n      if ( (oct == 0x01) && (prev_prev_oct == 0x04) ) flush ();\n\n      store (oct);\n\n    }\n\n    prev_prev_oct = prev_oct;\n\n    prev_oct = oct;\n\n#else\n\ndefine STANDARD or TAAATS or PALLAS or DACOTA\n\n#endif\n\n  }\n\n}\n\n\n"]